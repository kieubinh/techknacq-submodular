{
  "info": {
    "authors": [
      "Yong-Hun Lee",
      "Mi-Young Kim",
      "Jong-Hyeok Lee"
    ],
    "book": "Second International Joint Conference on Natural Language Processing: Full Papers",
    "id": "acl-I05-1014",
    "title": "Chunking Using Conditional Random Fields in Korean Texts",
    "url": "https://aclweb.org/anthology/I05-1014",
    "year": 2005
  },
  "references": [
    "acl-A00-2022",
    "acl-C92-2117",
    "acl-J90-1004",
    "acl-P01-1028",
    "acl-P02-1036",
    "acl-P85-1018",
    "acl-P89-1018",
    "acl-P96-1027",
    "acl-P99-1061",
    "acl-W02-1503",
    "acl-W02-2030"
  ],
  "sections": [
    {
      "text": [
        "High Efficiency Realization for a Wide-Coverage Unification Grammar*",
        "John Carroll and Stephan Oepen",
        "Abstract.",
        "We give a detailed account of an algorithm for efficient tactical generation from underspecified logical-form semantics, using a wide-coverage grammar and a corpus of real-world target utterances.",
        "Some earlier claims about chart realization are critically reviewed and corrected in the light of a series of practical experiments.",
        "As well as a set of algorithmic refinements, we present two novel techniques: the integration of subsumption-based local ambiguity factoring, and a procedure to selectively unpack the generation forest according to a probability distribution given by a conditional, discriminative model."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "A number of wide-coverage precise bidirectional NL grammars have been developed over the past few years.",
        "One example is the LinGO English Resource Grammar (ERG) [1], couched in the HPSG framework.",
        "Other grammars of similar size and coverage also exist, notable examples using the LFG and the CCG formalisms [2,3].",
        "These grammars are used for generation from logical form input (also termed tactical generation or realization) in circumscribed domains, as part of applications such as spoken dialog systems [4] and machine translation [5].",
        "Grammars like the ERG are lexicalist, in that the majority of information is encoded in lexical entries (or lexical rules) as opposed to being represented in constructions (i.e. rules operating on phrases).",
        "The semantic input to the generator for such grammars, often, is a bag of lexical predicates with semantic relationships captured by appropriate instantiation of variables associated with predicates and their semantic roles.",
        "For these sorts of grammars and 'flat' semantic inputs, lexically-driven approaches to realization - such as Shake-and-Bake [6], bag generation from logical form [7], chart generation [8], and constraint-based generation [9] - are highly suitable.",
        "Alternative approaches based on semantic head-driven generation and more recent variants [10,11] would work less well for lexicalist grammars since these approaches assume a hierarchically structured input logical form.",
        "Similarly to parsing with large scale grammars, realization can be computationally expensive.",
        "In his presentation of chart generation, Kay [8] describes one source of potential inefficiency and proposes an approach for tackling it.",
        "However, Kay does not report on a verification of his approach with an actual grammar.",
        "Carroll et al.",
        "[12]",
        "* Dan Flickinger and Ann Copestake contributed a lot to the work described in this paper.",
        "We also thank Berthold Crysmann, Jan Tore L0nning and Bob Moore for useful discussions.",
        "Funding is from the projects COGENT (UK EPSRC) and LOGON (Norwegian Research Council).",
        "J. Carroll and S. Oepen",
        "Fig.",
        "1.",
        "Simplified MRS for an utterance like the young Polish athlete ran (and variants).",
        "Elements from the bag of EPs are linked through both scopal and 'standard' logical variables.",
        "present a practical evaluation of chart generation efficiency with a large-scale hpsg grammar, and describe a different approach to the problem which becomes necessary when using a wide-coverage grammar.",
        "White [3] identifies further inefficiencies, and describes and evaluates strategies for addressing them, albeit using what appears to be a somewhat task-specific rather than genuine wide-coverage grammar.",
        "In this paper, we revisit this previous work and present new, improved algorithms for efficient chart generation; taken together these result in (i) practical performance that improves over a previous implementation by two orders of magnitude, and (ii) throughput that is near linear in the size of the input semantics.",
        "In Section 2, we give an overview of the grammar and the semantic formalism we use, recap the basic chart generation procedure, and discuss the various sources of potential inefficiency in the basic approach.",
        "We then describe the algorithmic improvements we have made to tackle these problems (Section 3), and conclude with the results of evaluating these improvements (Section 4)."
      ]
    },
    {
      "heading": "2. Background",
      "text": [
        "Minimal Recursion Semantics (mrs) [13] is a popular member of a family of flat, underspecified, event-based (neo-Davidsonian) frameworks for computational semantics that have been in wide use since the mid-1990s.",
        "mrs allows both underspecification of scope relations and generalization over classes of predicates (e.g. two-place temporal relations corresponding to distinct lexical prepositions: English in May vs. on Monday, say), which renders it an attractive input representation for tactical generation.",
        "While an in-depth introduction to mrs is beyond the scope of this paper, Figure1 shows an example semantics that we will use in the following sections.",
        "The truth-conditional core is captured as a flat multi-set (or 'bag') of elementary predications (EPs), combined with generalized quantifiers and designated handle variables to account for scopal relations.",
        "The bag of EPs is complemented by the handle of the top-scoping EP (h1 in our example) and a set of 'handle constraints' recording restrictions on scope relations in terms of dominance relations.",
        "The LinGO ERG [1] is a general-purpose, open-source hpsg implementation with fairly comprehensive lexical and grammatical coverage over a variety of domains and genres.",
        "The grammar has been deployed for diverse NLP tasks, including machine translation of spoken and edited language, email auto response, consumer opinion tracking (from newsgroup data), and some question answering work.",
        "The ERG uses mrs",
        "High Efficiency Realization for a Wide-Coverage Unification Grammar 167",
        "as its meaning representation layer, and the grammar distribution includes treebanked versions of several reference corpora - providing disambiguated and hand-inspected 'gold' standard mrs formulae for each input utterance - of which we chose one of the more complex sets for our empirical investigations of realization performance using the ERG (see Section 4below).",
        "Briefly, the basic chart generation procedure works as follows.",
        "A preprocessing phase indexes lexical entries, lexical rules and grammar rules by the semantics they contain.",
        "In order to find the lexical entries with which to initialize the chart, the input semantics is checked against the indexed lexicon.",
        "When a lexical entry is retrieved, the variable positions in its relations are instantiated in one-to-one correspondence with the variables in the input semantics (a process we term Skolemization, in loose analogy to the more general technique in theorem proving; see Section3.1below).",
        "For instance, for the MRS in Figure1, the lookup process would retrieve one or more instantiated lexical entries for run containing /i3:_run_v(e4, x5).",
        "Lexical and morphological rules are applied to the instantiated lexical entries.",
        "If the lexical rules introduce relations, their application is only allowed if these relations correspond to parts of the input semantics (h3:past(e4), say, in our example).",
        "We treat a number of special cases (lexical items containing more than one relation, grammar rules which introduce relations, and semantically vacuous lexical items) in the same way as Carroll et al.",
        "[12].",
        "After initializing the chart (with inactive edges), active edges are created from inactive ones by instantiating the head daughter of a rule; the resulting edges are then combined with other inactive edges.",
        "Chart generation is very similar to chart parsing, but what an edge covers is defined in terms of semantics, rather than orthography.",
        "Each edge is associated with the set of relations it covers.",
        "Before combining two edges a check is made to ensure that edges do not overlap: i.e. that they do not cover the same relation(s).",
        "The goal is to find all possible inactive edges covering the full input mrs.",
        "The worst-case time complexity of chart generation is exponential (even though chart parsing is polynomial).",
        "The main reason for this is that in theory a grammar could allow any pair of edges to combine (subject to the restriction described above that the edges cover non-overlapping bags of EPs).",
        "For an input semantics containing n EPs, and assuming each EP retrieves a single lexical item, there could in the worst case be O(2n) edges, each covering a different subset of the input semantics.",
        "Although in the general case we cannot improve the complexity, we can make the processing steps involved cheaper, for instance efficiently checking whether two edges are candidates for being combined (see Section 3.1below).",
        "We can also minimize the number of edges covering each subset of EPs by 'packing' locally equivalent edges (Section 3.2).",
        "A particular, identifiable source of complexity is that, as Kay [8] notes, when a word has more than one intersective modifier an indefinite number of its modifiers may be applied.",
        "For instance, when generating from the MRS in Figure1, edges corresponding to the partial realizations athlete, young athlete, Polish athlete,and young Polish athlete will all be constructed.",
        "Even if a grammar constrains modifiers so there is only one valid ordering, or the generator is able to pack equivalent edges covering the same EPs, the number of edges built will still be 2n, because all possible complete and incomplete phrases will be built.",
        "Using the example MRS, ultimately useless edges such as the young athlete ran (omitting Polish) will be created.",
        "Kay proposes an approach to this problem in which edges are checked before they are created to see if they would 'seal off' access to a semantic index (x5 in this case) for which there is still an unincorporated modifier.",
        "Although individual sets of modifiers still result in exponential numbers of edges, the exponentiality is prevented from propagating further.",
        "However, Carroll et al.",
        "[12] argue that this check works only in limited circumstances, since for example in (1) the grammar must allow the index for ran to be available all the wayupthe tree to How, and simultaneously also make available the indexes for newspapers, say,and athlete at appropriate points so these words could be modified2.",
        "(1) How quickly did the newspapers say the athlete ran?",
        "Carroll et al.",
        "describe an alternative technique which adjoins intersective modifiers into edges in a second phase, after all possible edges that do not involve intersective modification have been constructed by chart generation.",
        "This overcomes the multiple index problem described above and reduces the worst-case complexity of intersective modification in the chart generation phase to polynomial, but unfortunately the subsequent phase which attempts to adjoin sets of modifiers into partial realizations is still exponential.",
        "We describe below (Section3.3) a related technique which delays processing of intersective modifiers by inserting them into the generation forest, taking advantage of dynamic programming to reduce the complexity of the second phase.",
        "We also present a different approach which filters out edges based on accessibility of sets of semantic indices (Section 3.4), which covers a wider variety of cases than just intersective modification, and in practice is even more efficient.",
        "Exponential numbers of edges imply exponential numbers of realizations.",
        "For an application task we would usually want only one (the most natural or fluent) realization, or a fixed small number of good realizations that the application could then itself select from.",
        "In Section 3.5 we present an efficient algorithm for selectively unpacking the generation forest to produce the n-best realizations according to a statistical model."
      ]
    },
    {
      "heading": "3. Efficient Wide-Coverage Realization",
      "text": [
        "Once lexical lookup is complete and up until a final, post-generation comparison of results to the input mrs, the core phases of our generator exclusively operate on typed feature structures (which are associated to chart edges).",
        "For efficiency reasons, our algorithm avoids any complex operations on the original logical-form input MRS.",
        "In order to best guide the search from the input semantics, however, we employ two techniques that relate components of the logical form to corresponding substructures in the feature",
        "High Efficiency Realization for a Wide-Coverage Unification Grammar 169",
        "structure (FS) universe: (i) Skolemization of variables and (ii) indexing by EP coverage.",
        "Of these, only the latter we find commonly discussed in the literature, but we expect some equivalent of making variables ground to be present in most implementations.",
        "As part of the process of looking up lexical items and grammar rules introducing semantics in order to initialize the generator chart, all FS correspondences to logical variables from the input MRS are made 'ground' by specializing the relevant substructure with Skolem constants uniquely reflecting the underlying variable, for example adding constraints like [skolem \"x5\"] for all occurrences of x5 from our example MRS. Skolemization, thus, assumes that distinct variables from the input mrs, where supplied, cannot become co-referential during generation.",
        "Enforcing variable identity at the FS level makes sure that composition (by means of FS unification) during rule applications is compatible to the input semantics.",
        "In addition, it enables efficient pre-unification filtering (see 'quick-check' below), and is a prerequisite for our index accessibility test described in Section 3.4below.",
        "In chart parsing, edges are stored into and retrieved from the chart data structure on the basis of their string start and end positions.",
        "This ensures that the parser will only retrieve pairs of chart edges that cover compatible segments of the input string (i.e. that are adjacent with respect to string position).",
        "In chart generation, Kay [8] proposed indexing the chart on the basis of logical variables, where each variable denotes an individual entity in the input semantics, and making the edge coverage compatibility check a filter.",
        "Edge coverage (with respect to the EPs in the input semantics) would be encoded as a bit vector, and for a pair of edges to be combined their corresponding bit vectors would have to be disjoint.",
        "We implement Kay's edge coverage approach, using it not only when combining active and inactive edges, but also for two further tasks in our approach to realization:",
        "• in the second phase of chart generation to determine which intersective modifier(s) can be adjoined into a partially incomplete subtree; and",
        "• as part of the test for whether one edge subsumes another, for local ambiguity factoring (see Section 3.2below)3.",
        "In our testing with the LinGO ERG, many hundreds or thousands of edges may be produced for non-trivial input semantics, but there are only a relatively small number of logical variables.",
        "Indexing edges on these variables involves bookkeeping that turns out not to be worthwhile in practice; logical bit vector operations on edge coverage take negligible time, and these serve to filter out the majority of edge combinations with incompatible indices.",
        "The remainder are filtered out efficiently before unification is attempted by a check on which rules can dominate which others, and the quick-check, as developed for unification-based parsing [14].",
        "For the quick-check, it turns out that the same set of feature paths that most frequently lead to unification failure in parsing also work well in generation.",
        "• doedges e1,...,en cover all input EPs?",
        "NOT(OR(C(e1) ,...,C(en)) = 0."
      ]
    },
    {
      "heading": "3. .2 Local Ambiguity Factoring",
      "text": [
        "In chart parsing with context free grammars, the parse forest (a compact representation of the full set of parses) can only be computed in polynomial time if sub-analyses dominated by the same non-terminal and covering the same segment of the input string are 'packed', or factored into a single unitary representation [15].",
        "Similar benefits accrue for unification grammars without a context free backbone such as the LinGO ERG, if the category equality test is replaced by feature structure subsumption [16]4;also, feature structures representing the derivation history need to be restricted out when applying a rule [17].",
        "The technique can be applied to chart realization if the input span is expressed as coverage of the input semantics.",
        "For example, with the input of Figure1, the two phrases in (2) below would have equivalent feature structures, and we pack the one found second into the one found first, which then acts as the representative edge for all subsequent processing.",
        "(2) young Polish athlete | Polish young athlete",
        "We have found that packing is crucial to efficiency: realization time is improved by more than an order of magnitude for inputs with more than 500 realizations (see Section 4).",
        "Changing packing to operate with respect just to feature structure equality rather than subsumption degrades throughput significantly, resulting in worse overall performance than with packing disabled completely: in other words, equivalence-only packing fails to recoup the cost of the feature structure comparisons involved.",
        "A further technique we use is to postpone the creation of feature structures for active edges until they are actually required for a unification operation, since many end up as dead ends.",
        "Oepen and Carroll [18] do a similar thing in their 'hyper-active' parsing strategy, for the same reason.",
        "As discussed in Section 2.3, Carroll et al.",
        "[12] adjoin intersective modifiers into each partial tree extracted from the forest; their algorithm searches for partitions of modifier phrases to adjoin, and tries all combinations.",
        "This process adds an exponential (in the number of modifiers) factor to the complexity of extracting each partial realization.",
        "This is obviously unsatisfactory, and in practice is slow for larger problems when there are many possible modifiers.",
        "We have devised a better approach which delays processing of intersective modifiers by inserting them into the generation forest at appropriate locations before the forest is unpacked.",
        "By doing this, we take advantage of the dynamic programming-based procedure for unpacking the forest to reduce the complexity of the second phase.",
        "The procedure is even more efficient if realizations are unpacked selectively (section 3.5).",
        "Kay's original proposal for dealing efficiently with modifiers founders because more than one semantic index may need to be accessible at any one time (leading to the",
        "High Efficiency Realization for a Wide-Coverage Unification Grammar 171",
        "alternative solutions of modifier adjunction, and of chunking the input semantics - see Sections 2.3 and3.3).",
        "However, it turns out that Kay's proposal can form the basis of a more generally applicable approach to the problem.",
        "We assume that we have available an operation collect-semantic-vars() that traverses a feature structure and returns the set of semantic indices that it makes available5.",
        "We store in each chart edge two sets: one of semantic variables in the feature structure that are accessible (that is, they are present in the feature structure and could potentially be picked by another edge when it is combined with this one), and a second set of inaccessible semantic variables (ones that were once accessible but no longer are).",
        "Then,",
        "• when an active edge is combined with an inactive edge, the accessible sets and inaccessible sets in the resulting edge are the union of the corresponding sets in the original edges;",
        "• when an inactive edge is created, its accessible set is computed to be the semantic indices available in its feature structure, and the variables that used to be accessible but are no longer in the accessible set are added to its inaccessible set, i.e."
      ]
    },
    {
      "heading": "1. tmp ^ - edge.accessible;",
      "text": []
    },
    {
      "heading": "2. edge.accessible ^ - collect-semantic-vars(edge.fs)",
      "text": [
        "3 edge.inaccessible ^- (tmp \\ edge.accessible) u edge.inaccessible",
        "• immediately after creating an inactive edge, each EP in the input semantics that the edge does not (yet) cover is inspected, and if the EP's index is in the edge's inaccessible set then the edge is discarded (since there is no way in the future that the EP could be integrated with any extension of the edge's semantics).",
        "A nice property of this new technique is that it applies more widely than to just intersective modification: for instance, if the input semantics were to indicate that a phrase should be negated, no edges would be created that extended that phrase without the negation being present.",
        "Section 4shows this technique results in dramatic improvements in realization efficiency.",
        "The selective unpacking procedure outlined in this section allows us to extract a small set of n-best realizations from the generation forest at minimal cost.",
        "The global rank order is determined by a conditional Maximum Entropy (ME) model - essentially an adaptation of recent hpsg parse selection work to the realization ranking task [19].",
        "We use a similar set of features to Toutanova and Manning [20], but our procedure differs from theirs in that it applies the stochastic model before unpacking, in a guided search through the generation forest.",
        "Thus, we avoid enumerating all candidate realizations.",
        "Unlike Malouf and van Noord [21], on the other hand, we avoid an approximative beam search during forest creation and guarantee to produce exactly the n-best realizations (according to the ME model).",
        "Further looking at related parse selection work, our procedure is probably most similar to those of Geman and Johnson [22] and Miyao and",
        "J. Carroll and S. Oepen",
        "Fig.",
        "2.",
        "Sample generator forest and sub-node decompositions: ovals in the forest (on the left) indicate packing of edges under subsumption, i.e. edges \\4\\, [7], [9], and |111 are not in the generator chart proper.",
        "During unpacking, there will be multiple ways of instantiating a chart edge, each obtained from cross-multiplying alternate daughter sequences locally.",
        "The elements of this crossproduct we call decomposition, and they are pivotal points both for stochastic scoring and dynamic programming in selective unpacking.",
        "The table on the right shows all non-leaf decompositions for our example generator forest: given two ways of decomposing \\6\\, there will be three candidate ways of instantiating \\2\\ and six for \\4\\, respectively, for a total of nine full trees.",
        "Tsujii [23], but neither provide a detailed discussion of the dependencies between locality of ME features and the complexity of the readout procedure from a packed forest.",
        "Two key notions in our selective unpacking procedure are the concepts of (i) decomposing an edge locally into candidate ways of instantiating it and of (ii) nested contexts of 'horizontal' search for ranked hypotheses (i.e. uninstantiated edges) about candidate subtrees.",
        "See Figure 2 for examples of edge decomposition, but note that the 'depth' of each local crossproduct needs to correspond to the maximum required context size of ME features; for ease of exposition, our examples assume a context size of no more than depth one (but the algorithm straightforwardly generalizes to larger contexts).",
        "Given one decomposition - i.e. a vector of candidate daughters to a token construction - there can be multiple ways of instantiating each daughter: a parallel index vector {i0 ... in) serves to keep track of 'vertical' search among daughter hypotheses, where each index ij denotes the i-th instantiation (hypothesis) of the daughter at position j.",
        "Hypotheses are associated with ME scores and ordered within each nested context by means of a local agenda (stored in the original representative edge, for convenience).",
        "Given the additive nature of ME scores on complete derivations, it can be guaranteed that larger derivations including an edge e as a sub-constituent on the fringe of their local context of optimization will use the best instantiation of e in their own best instantiation.",
        "The second-best larger instantiation, in turn, will be obtained from moving to the second-best hypothesis for one of the elements in the (right-hand side of the) decomposition.",
        "Therefore, nested local optimizations result in a top-down, exact n-best search through the generation forest, and matching the 'depth' of local decompositions to the maximum required ME feature context effectively prevents exhaustive cross-multiplication of packed nodes.",
        "The main function hypothesize-edge() in Figure 3 controls both the 'horizontal' and 'vertical' search, initializing the set of decompositions and pushing initial hypotheses onto the local agenda when called on an edge for the first time (lines 11-17).",
        "Furthermore, the procedure retrieves the current next-best hypothesis from the agenda (line 18), generates new hypotheses by advancing daughter indices (while skipping over",
        "High Efficiency Realization for a Wide-Coverage Unification Grammar"
      ]
    },
    {
      "heading": "1. procedure selectively-unpack-edge(edge , n) =",
      "text": [
        "4 hypothesis – hypothesize-edge(edge , i); i – i + 1; 5if (new – instantiate-hypothesis(hypothesis)) then"
      ]
    },
    {
      "heading": "7. while (hypothesis and n > 1) 8return results;",
      "text": []
    },
    {
      "heading": "9. procedure hypothesize-edge(edge , i) =",
      "text": []
    },
    {
      "heading": "10. if (edge.hypotheses[i]) return edge.hypotheses[i];",
      "text": []
    },
    {
      "heading": "12. for each (decomposition in decompose-edge(edge)) do",
      "text": []
    },
    {
      "heading": "14. for each (edge in decomposition.rhs) do",
      "text": []
    },
    {
      "heading": "15. daughters – daughters © {hypothesize-edge(edge, 0)>;",
      "text": []
    },
    {
      "heading": "17. new-hypothesis(edge, decomposition, daughters, indices);",
      "text": []
    },
    {
      "heading": "18. if (hypothesis – edge.agenda.pop()) then",
      "text": [
        "19 for each (indices in advance-indices(hypothesis.indices)) do"
      ]
    },
    {
      "heading": "20. if (indices e edge.indices) then continue",
      "text": [
        "22 for each (edge in hypothesis.decomposition.rhs) each (i in indices) do"
      ]
    },
    {
      "heading": "23. daughter – hypothesize-edge(edge, i);",
      "text": []
    },
    {
      "heading": "24. if (not daughter) then",
      "text": [
        "25 daughters – {>; break"
      ]
    },
    {
      "heading": "26. daughters – daughters © {daughter>;",
      "text": [
        "27 if (daughters) then new-hypothesis(edge, decomposition, daughters, indices)"
      ]
    },
    {
      "heading": "28. edge.hypotheses[i] – hypothesis;",
      "text": []
    },
    {
      "heading": "29. return hypothesis;",
      "text": [
        "30 procedure new-hypothesis(edge , decomposition , daughters , indices) = 31 hypothesis – new hypothesis(decomposition, daughters, indices); 32 edge.agenda.insert(score-hypothesis(hypothesis), hypothesis);"
      ]
    },
    {
      "heading": "33. edge.indices – edge.indices n{indices};",
      "text": [
        "Fig.",
        "3.",
        "Selective unpacking procedure, enumerating the n best realizations for a top-level result edge from the generation forest.",
        "An auxiliary function decompose-edge() performs local cross-multiplication as shown in the examples in Figure2.",
        "Another utility function not shown in pseudo-codeisadvance-indices(),another'driver' routinesearchingforalternateinstantiationsofdaughter edges, e.g. advance-indices({0 2 1}) – {{12 1}{0 3 1}{0 2 2}}.",
        "Finally, instantiate-hypothesis() is the function that actually builds result trees, replaying the unifications of constructions from the grammar (as identified by chart edges) with the feature structures of daughter constituents.",
        "configurations seen earlier) and calling itself recursively for each new index (lines 1927), and, finally, arranges for the resulting hypothesis to be cached for later invocations on the same edge and i values (line 28).",
        "Note that we only invoke instantiate-hypothesis() on complete, top-level hypotheses, as the ME features of Toutanova and Manning [20] can actually be evaluated prior to building each full feature structure.",
        "However, the procedure could be adapted to perform instantiation of sub-hypotheses within each local search, should additional features require it.",
        "For better efficiency, our instantiate-hypothesis() routine already uses dynamic programming for intermediate results."
      ]
    },
    {
      "heading": "4. Evaluation and Summary",
      "text": [
        "Below we present an empirical evaluation of each of the refinements discussed in Sections 3.2 through 3.5.",
        "Using the LinGO ERG and its 'hike' treebank - a 330-sentence",
        "Table 1.",
        "Realization efficiency for various instantiations of our algorithm.",
        "The table is broken down by average ambiguity rates, the first two columns showing the number of items per aggregate and average string length.",
        "Subsequent columns show relative cpu time of one-and two-phase realization with or without packing and filtering, shown as a relative multiplier of the baseline performance in the 1p+f+ column.",
        "The rightmost column is for selective unpacking of up to 10 trees from the forest produced by the baseline configuration, again as a factor of the baseline.",
        "(The quality of the selected trees depends on the statistical model and the degree of overgeneration in the grammar, and is a completely separate issue which we do not address in this paper).",
        "collection of instructional text taken from Norwegian tourism brochures - we benchmarked various generator configurations, starting from the 'gold' standard mrs formula recorded for each utterance in the treebank.",
        "At 12.8 words, average sentence length in the original 'hike' corpus is almost exactly what we see as the average length of all paraphrases obtained from the generator (see Table 1); from the available reference treebanks for the ERG, 'hike' appears to be among the more complex data sets.",
        "Table1 summarizes relative generator efficiency for various configurations, where we use the best-performing exhaustive procedure 1p+f+ (one-phase generation with packing and index accessibility filtering) as a baseline.",
        "The configuration 1p-f- (one-phase, no packing or filtering) corresponds to the basic procedure suggested by Kay [8], while 2p-f- (two-phase processing of modifiers without packing and filtering) implements the algorithm presented by Carroll et al.",
        "[12].",
        "Combining packing and filtering clearly outperforms both these earlier configurations, i.e. giving an up to 50 times speed-up for inputs with large numbers of realizations.",
        "Additional columns contrast the various techniques in isolation, thus allowing an assessment of the individual strengths of our proposals.",
        "On low-to medium-ambiguity items, for example, filtering gives rise to a bigger improvement than packing, but packing appears to flatten the curve more.",
        "Both with and without packing, filtering improves significantly over the Carroll et al.",
        "two-phase approach to intersective modifiers (i.e. comparing columns 2p-f- and 2p+f-to 1p-f+ and 1p+f+, respectively), thus confirming the increased generality of our solution to the modification problem.",
        "Finally, the benefits of packing and filtering combine more than merely multiplicatively: compared to 1p-f-, just filtering gives a speed-up of 5.9, and just packing a speed-up of 4.3.",
        "At 25, the product of these factors is well below the overall reduction of 35 that we obtain from the combination of both techniques.",
        "While the rightmost column in Table1 already indicates that 10-best selective unpacking further improves generator performance by close to a factor of two, Figure 4breaks down generation time with respect to forest creation vs. unpacking time.",
        "When plotted against increasing input complexity (in terms of the 'size' of the input mrs), forest creation appears to be a low-order polynomial (or better), whereas exhaustive",
        "Aggregate",
        "items length 1p – f – ",
        "tt <P x",
        "2p – f – ",
        "X",
        "1p – f+ 1p+f – ",
        "X X",
        "2p+f – ",
        "X",
        "1p+f+ n=10",
        "s x",
        "500 < trees",
        "9",
        "23.9",
        "31.76",
        "20.95",
        "11.98",
        "9.49",
        "3.69",
        "31.49 0.33",
        "100 < trees < 500",
        "22",
        "17.4",
        "53.95",
        "36.80",
        "3.80",
        "8.70",
        "4.66",
        "5.61 0.42",
        "50 < trees < 100",
        "21",
        "18.1",
        "51.53",
        "13.12",
        "1.79",
        "8.09",
        "2.81",
        "3.74 0.62",
        "10 < trees < 50",
        "80",
        "14.6",
        "35.50",
        "18.55",
        "1.82",
        "6.38",
        "3.67",
        "1.77 0.89",
        "0 < trees < 10",
        "185",
        "10.5",
        "9.62",
        "6.83",
        "1.19",
        "6.86",
        "3.62",
        "0.58 0.95",
        "Overall",
        "317",
        "12.9",
        "35.03",
        "20.22",
        "5.97",
        "8.21",
        "3.74",
        "2.32 0.58",
        "Coverage",
        "95%",
        "97%",
        "99%",
        "99%",
        "100%",
        "100% 100%",
        "High Efficiency Realization for a Wide-Coverage Unification Grammar o – packed forest creation o – selective unpacking • – exhaustive unpacking",
        "Input Complexity (Number of EPs in MRS)",
        "Fig.",
        "4.",
        "Break-down of generation times (in seconds) according to realization phases and input complexity (approximated in the number of EPs in the original MRS used for generation).",
        "The three curves are, from 'bottom' to 'top', the average time for constructing the packed generation forest, selective unpacking time (using n = 10), and exhaustive unpacking time.",
        "Note that both unpacking times are shown as increments on top of the forest creation time.",
        "unpacking (necessarily) results in an exponential explosion of generation time: with more than 25 EPs, it clearly dominates total processing time.",
        "Selective unpacking, in contrast, appears only mildly sensitive to input complexity and even on complex inputs adds no more than a minor cost to total generation time.",
        "Thus, we obtain an overall observed runtime performance of our wide-coverage generator that is bounded (at least) polynomially.",
        "Practical generation times using the LinGO ERG average below or around one second for outputs of fifteen words in length, i.e. time comparable to human production."
      ]
    }
  ]
}
