{
  "info": {
    "authors": [
      "Giorgio Satta",
      "Enoch Peserico"
    ],
    "book": "Human Language Technology Conference and Empirical Methods in Natural Language Processing",
    "id": "acl-H05-1101",
    "title": "Some Computational Complexity Results for Synchronous Context-Free Grammars",
    "url": "https://aclweb.org/anthology/H05-1101",
    "year": 2005
  },
  "references": [
    "acl-C88-1016",
    "acl-J00-1004",
    "acl-J97-3002",
    "acl-J99-4005",
    "acl-N03-1019",
    "acl-N03-1021",
    "acl-P01-1067",
    "acl-P02-1038",
    "acl-P03-1011",
    "acl-P04-1083",
    "acl-P04-1084",
    "acl-P05-1033",
    "acl-P92-1012",
    "acl-P98-2230",
    "acl-W99-0604"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper investigates some computational problems associated with probabilistic translation models that have recently been adopted in the literature on machine translation.",
        "These models can be viewed as pairs of probabilistic context-free grammars working in a ‘synchronous’ way.",
        "Two hardness results for the class NP are reported, along with an exponential time lower-bound for certain classes of algorithms that are currently used in the literature."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "State of the art architectures for machine translation are all based on mathematical models called translation models.",
        "Generally speaking, a translation model accounts for all the elementary operations that rule the process of translation between the words and the different word orderings of the source and target languages.",
        "Translation models are usually enriched with statistical parameters, to drive the search toward the most likely translation(s).",
        "Specialized algorithms are provided for the automatic estimation of these parameters from corpora of translation pairs.",
        "Besides the task of natural language translation, statistical translation models are also exploited in other applications, such as word alignment, multilingual document retrieval and automatic dictionary construction.",
        "The most successful translation models that are found in the literature exploit finite-state machinery.",
        "Enoch Peserico Dept.",
        "of Information Engineering University of Padua via Gradenigo, 6/A I-35131 Padova Italy enoch@dei.unipd.it The approach started with the so-called IBM models (Brown et al., 1988), implementing a set of elementary operations, such as movement, duplication and translation, that independently act on individual words in the source sentence.",
        "These word-to-word models have been later enriched with the introduction of larger units such as phrases; see for instance (Och et al., 1999; Och and Ney, 2002).",
        "Still, the generative capacity of these models lies within the realm of finite-state machinery (Kumar and Byrne, 2003), so they are unable to handle nested structures and do not provide the expressivity required to process language pairs with very different word orderings.",
        "Recently, more sophisticated translation models have been proposed, borrowing from the theory of compilers and making use of synchronous rewriting.",
        "In synchronous rewriting, two formal grammars are exploited, one describing the source language and the other describing the target language.",
        "Furthermore, the productions of the two grammars are paired and, in the rewriting process, such pairs are always applied synchronously.",
        "Formalisms based on synchronous rewriting have been empowered with the use of statistical parameters, and specialized estimation and translation (decoding) algorithms were newly developed.",
        "Among the several proposals, we mention here the models presented in (Wu, 1997; Wu and Wong, 1998), (Alshawi et al., 2000), (Yamada and Knight, 2001), (Gildea, 2003) and (Melamed, 2003).",
        "In this paper we consider synchronous models based on context-free grammars and probabilistic extensions thereof.",
        "This is the most common choice",
        "in statistical translation models that exceed the generative power of finite-state machinery.",
        "We focus on two associated computational problems that have been defined in the literature.",
        "One is the membership problem, which involves testing whether an input string pair can be generated by the model.",
        "The other is the translation problem (also called the decoding problem) which involves the search for a suitable translation of an input string/structure.",
        "It has been often informally stated in the literature that the use of structured models results in efficient, polynomial time algorithms for the above problems.",
        "We show here that sometimes this is not the case.",
        "The contribution of this paper can be stated as follows:",
        "• we show that the membership problem is NP-hard, unless a constant bound is imposed on the length of the productions (Section 3); • we show an exponential time lower bound for the membership problem, in case chart parsing is adopted (Section 3); • we show that translating an input string into the best parse tree in the target language is NP-hard, even in case productions are bounded in length (Section 4).",
        "Investigation of the computational complexity of translation models has started in (Knight, 1999) for word-to-word models.",
        "This paper can be seen as the continuation of that line of research.",
        "2 Synchronous context-free grammars Several definitions for synchronous context-free grammars have been proposed in the literature; see for instance (Chiang, 2004; Chiang, 2005).",
        "Our definition is based on syntax-directed translation schemata (SDTS; Aho and Ullman, 1972), with the difference that we do not impose the restriction that two paired context-free productions have the same left-hand side.",
        "As it will be discussed in Section 4, this results in an enriched generative capacity when probabilistic extensions are considered.",
        "We assume the reader is familiar with the definition of context-free grammar (CFG) and with the associated notion of derivation.",
        "Let VN and VT be sets of nonterminal and terminal symbols, respectively.",
        "In what follows we need to represent bijections between all the occurrences of nonterminals in two strings over VN U VT.",
        "This can be done by annotating nonterminals with indices from an infinite set.",
        "We define Z(VN) _ JAW I A E VN, t E N} and VI = Z(VN) U VT. We write index(-y), y E VI , to denote the set of all indices (the integers t) that appear in symbols in -y.",
        "Two strings -y, -y' E VI are synchronous if each index in index(-y) occurs only once in -y, each index in index(-y') occurs only once in -y', and index(-y) _ index(-y').",
        "Therefore synchronous strings have the general form",
        "where r >_ 0, uli, u2i E VT, Ak \", A2z-(')) E I(VN), ti 7� tj for i 7 j and 7r is some permutation defined on set 11, ... , r}.",
        "The size of a SCFG G is defined as IGI = E[Al->al, A2->a2]EP IA1a1A2a2I.",
        "Based on an example from (Yamada and Knight, 2001), we provide a sample SCFG fragment translating from English to Japanese, specified by means of the following synchronous productions:",
        "S3: [TO , TOM NN(2), TO , NN (2) TOM] S4: [PRP he, PRP – * kare ha] S5 : [VB1 adores, V131 daisuki desu] S6: [VB listening, VB kiku no] S7: [TO to, TO – * wo] S8: [NN music, NN – * ongaku] Note that in production S2 above, the nonterminals VB and TO generated from nonterminal VB2 in",
        "the English component are inverted in the Japanese component, where some additional lexical material is also added.",
        "In a SCFG, the ‘derives’ relation is defined on synchronous strings in terms of simultaneous rewriting of two nonterminals with the same index.",
        "Some additional notation will help us defining this relation precisely.",
        "A reindexing is a one-to-one function on N. We extend a reindexing f to VI by letting f (A(t)) = AU W) for A(t) E Z(VN) and f (a) = a for a E VT. We also extend f to strings in VI by letting f (E) = E and f (X-y) = f (X) f ('y), for each X E VI and y E VI .",
        "We say that strings -y1, -y2 E VI are independent if index(-y1) n index(-y2) = 0.",
        "Definition 2 Let G = (VN, VT, P, S) be a SCFG and let -y1, -y2 be synchronous strings in VI .",
        "The derives relation 1717 721 ==>'G [617 62] holds whenever there exist an index t in index(-y1), a synchronous production [Al – * al, A2 – * a2] in P and some reindexing f such that (i) f (a1a2) and -y1-y2 are independent; and (ii)YZ = ,�A(t)7��, J.",
        "= ry' f (az)-yj for i = 1, 2.",
        "We also write 171, rye] ==>.G [61, 62] to explicitly indicate that the derives relation holds through some synchronous production s E P. Since 61 and 62 in Definition 2 are synchronous strings, we can define the reflexive and transitive closure of ==>'G, written ==>.G.",
        "This relation is used to represent derivations in G. In case we have ['YlZ-1, 'Y2i-1] ==>-sz [11i, Y2Z] for 1 G i G n,",
        "n > 1, we also write [710, 7201 ==>G [-Yin, 72n], where a = s1s2 • • • sn.",
        "We always assume some canonical form for derivations (as for instance leftmost derivation on the left component).",
        "Similarly to the case of context-free grammars, each derivation in G can be associated with a pair of parse trees, that is, one parse tree for each dimension.",
        "Back to our example, we report a fragment of a derivation of the string pair [he adores listening to music, kare ha ongaku wo kiku no ga daisuki desu]:",
        "kare ha VB2(4) VB1(3)] ==>.G [he adores VB2(4), kare ha VB2(4) daisuki desu] ==>.G [he adores VB(5)TO(6) , kare ha TO(6) VB(5) ga daisuki desu].",
        "The translation generated by a SCFG G is a binary relation over VT defined as T(G) _ {[w1, w21 I [S(1), S(1)] ==�'G [wl, w21, W1, W2 E M_ The set of strings that are translations of a given string wl is defined as: T(G, w1) _ {w2 I [w1, w21 E T(G)}.",
        "A probabilistic SCFG (PSCFG) is a pair (G, PG) where G = (VN, VT, P, S) is a SCFG and PG is a function from P to real numbers in [0, 1] such that, for each A1, A2 E VN, we have:",
        "If for n> 1 and sz E P, 1 G i G n, string Q = s1s2 • sn is a canonical derivation of the form [S(1), S(1)] =�'G [wl, w2], we write PG(U) HZ 1 pG(sz).",
        "If D([w1i w2]) is the set of all canonical derivations in G for pair [w1i w2], we write PG([wl, w2]) _ &EDQ.,,w2]) PG (a)."
      ]
    },
    {
      "heading": "3 The membership problem",
      "text": [
        "We consider here the membership problem for SCFG, defined as follows: for input instance a SCFG G and a pair [w1, w2], decide whether [wl, w21 is in T(G).",
        "This problem has been considered for instance in (Wu, 1997) for his inversion transduction grammars and has applications in the support of several tasks of automatic annotation of parallel corpora, as for instance segmentation, bracketing, phrasal and word alignment.",
        "We show that the membership problem for SCFGs is NP-hard.",
        "The result could be derived from the findings in (Melamed et al., 2004) that synchronous rewriting systems as SCFGs are related to the class of so called linear context-free rewriting systems (LCFRSs) and from the result that the membership problem for",
        "LCFRSs is NP-hard (Satta, 1992; Kaji and others, 1994).",
        "However, we provide here a direct proof, to simplify the presentation.",
        "Theorem 1 The membership problem for SCFGs is NP-hard.",
        "Proof.",
        "We reduce from the three-satisfiability problem (3SAT, Garey and Johnson, 1979).",
        "Let (U, C) be an instance of the 3SAT problem, where U = Jul, ... , up} is a set of variables and C = {c1i ... , cn} is a set of clauses.",
        "Each clause is a set of three literals from Jul, u1, ... , up, up}.",
        "The general idea of the proof is to use a string pair [wlw2 • • • wp, we], where we is a string representation of C and each wi is a string controlling the truth assignment for the variable ui.",
        "We then construct a SCFG G such that each wi can be derived in two possible ways only, using some specialized productions of G, encoding the truth assignment of variable ui.",
        "In this way the derivation of the whole string w1 • • • wp in the left dimension corresponds to a guess of a truth assignment for U.",
        "Accordingly, on the right dimension only those symbols of we will be derived that represent clauses that hold true under the guessed assignment.",
        "We need some additional notation.",
        "Below we treat C as an alphabet of atomic symbols.",
        "We use a function d such that, for every i with 1 < i < , cd(i,1), cd(i,2), ... , cd(i,si) is the sequence of all clauses that include literal ui, in the left to right order in which they appear within ClC2 • • • cn, and Cd(i,ai+1), Cd(i,si+2)i • • • i Cd(i,ti) is the sequence of all clauses that include literal iii, again as they appear within ClC2 • • • Cn from left to right.",
        "Note that we must have �P 1 ti = 3n.",
        "We also use a function e such that, for every 1 < i < p and 1 < j < ti, e(2, j) = j + �k 1 tk (assume Ek=l tk = 0).",
        "Consider the alphabet {ai, bi 1 1 < i < p}.",
        "For every i, 1 < i < p, let wi denote a sequence of exactly ti + 1 alternating symbols ai and bi, i.e., wi E (aibi)+ U (aibi)*ai.",
        "For every 1 < i < p, let x(i,1) = ai bi and let x(i, h) = ai (resp .",
        "bi) if h is even (resp.",
        "odd), 2 < h < ti.",
        "Let also x(i, h) = ai (resp.",
        "bi) if h is odd (resp.",
        "even), 1 < h < ti – 1, and let x(i, ti) = aibi (resp.",
        "biai) if ti is odd (resp.",
        "even).",
        "Therefore we can write wi = x(i,1)x(i, 2) • • • x(i, t1) x(i,1)x(i, 2) ... x(i, t1).",
        "Finally, we need a permutation 7r defined on the set {1, ... , 3n} as follows.",
        "Fix i and j with 1 < i < p and 1 < j < ti, and let h be the number of occurrences of the clause cd(i j) found in the sequence",
        "We can now define the target instance (G, [w, w']) of our reduction.",
        "Let [w, w'] _ [wlw2 ... wp, ClC2 ... cn].",
        "Let also G = (VN, VT, P, S), with VN = {S} U {Ai 1 1 < i < 3n} and VT = C U {ai, bi 1 1 < i < p}.",
        "The productions below define set P:",
        "(i) for every 1 < i < p: (a) for 1 < h < si:",
        "It is easy to see that IG 1, 1 w I and I &I are polynomially related to I U I and I C 1.",
        "From a derivation of [w, w'] E T (G), we can exhibit a truth assignment that satisfies C simply by reading off the derivation of the left string wlw2 • • • wp.",
        "Conversely, starting from a truth assignment that satisfies C we can prove w E L(G) by means of (finite) induction on IUj: this part requires a careful inspection of all items in the definition of G. ■ From Theorem 1 we may conclude that algorithms for the membership problem for SCFGs are very unlikely to run in polynomial time.",
        "In the literature, several algorithms for this problem have been proposed using tabular methods (chart parsing).",
        "In the worst case, all these algorithms run in time 0(IGI • nk(G)), with G an SCFG and n the",
        "length of the input string pair.",
        "We know that, unless P = NP, k(G) cannot be a constant.",
        "We now prove a lower bound on k(G), providing thereby an exponential time lower bound result for our problem under the assumption of the tabular paradigm.",
        "Tabular methods for the membership problem are based on the following representation.",
        "Given a synchronous production",
        "the already recognized constituent pairs Blzi B2,,(z) are gather together in several steps, keeping a record of the spanned substrings of the input.",
        "To provide a concrete example, if we gather all the Biz’s on the left dimension from left to right, the partial analysis we obtain after the first step can be represented as a state (S(1), (ill, ill), (i21, j2l)), meaning that B1l and B2,(l) span substrings wl [ill, ill] and w2[i21, j21], respectively.1 At the second step we have a state (s(2), (iii, j12), (i21, hl), (i22J22)), meaning that BllBl2 together span wl[ill,jl2], B2,,(1) spans w2[i2lJ21] and B2,(2) spans w2 [i22, i221 .",
        "We can see that, for some worst case permutations, the left-to-right strategy demands for increasingly more pairs of indices, so that the exponent in the time complexity linearly grows with r. How much better can we do, if we exploit some strategy other than the left-to-right above?",
        "More precisely, we ask how many unconnected spannings a state may require for some worst case permutation 7r, under the choice of the best possible parsing strategy for 7r itself.",
        "Theorem 2 In the worst case, standard tabular methods for the SCFG membership problem require an amount of time Q(IGI n\"V'), with r the length of the longest production in G and c a constant.",
        "Proof.",
        "For any r > 8 we let q = LV/r/2] >_ LV/8/2] = 2, and define a permutation 7rr on 11, ... , r}.",
        "We view the domain of 7rr as composed of 2q blocks with q adjacent integers each, possibly followed by r – 2q2 additional “padding” integers, and its codomain as composed of q blocks",
        "with 2q adjacent integers each, again possibly followed by r – 2q2 “padding” integers.",
        "Permutation 7rr transposes all blocks by sending the j-th element of the i-th block in the domain into the i-th element of the j-th block in the codomain, while mapping each padding integer identically into itself.",
        "Formally, for all positive integers i < 2q and j < q, 7r, (q • (i – 1) + j) = 2q • (j – 1) + i, and for all integers i with 2q2 < i < r, 7r, (i) = i.",
        "We count below how many spans are instantiated by a state that has gathered p constituent pairs, 1 < p < r, in parsing production (1) under any possible strategy.",
        "When a constituent pair Blzi B2,,,(i) is gathered, we say integer i in the domain of 7rr and integer 7r, (i) in the codomain have been pebbled.",
        "In this way each span (i, j) in a state corresponds to some run i, i + 1.... j of pebbled integers, with either i = 1 or i – 1 unpebbled, and with either j = r or j + 1 unpebbled.",
        "We call each such run a segment, and show that every parsing strategy demands at least q = LV/r/2] segments either in the domain or in the codomain of 7rr.",
        "We say that a block in the domain of 7rr is empty, full, or mixed if, respectively, none, all, or some but not all of its elements have been pebbled.",
        "Assume that, for a given parsing strategy, the last block that becomes mixed does so when we place the i-th pebble, and the first block that becomes full does so when we place the j-th pebble.",
        "Obviously i 7� j: the first pebble placed in a previously empty block can not make it full since every block contains at least 2 elements.",
        "If i < j, after placing the i-th pebble and before placing the j-th pebble every block in the domain of 7rr is mixed.",
        "Each of these 2q blocks then contains at least one pebbled element which is adjacent to an unpebbled one and must therefore be either the first or the last element of a segment.",
        "The domain of 7rr then contains at least 2q/2 = q segments.",
        "If j < i, after placing the j-th pebble and before placing the i-th pebble at least one block in the domain of 7rr (e.g., the h-th block) is full, and at least one (e.g., the k-th) is empty.",
        "Then, in each of the q blocks in the codomain of 7rr, the h-th element is pebbled while the k-this not.",
        "Therefore the h-th elements of any two consecutive blocks in the codomain of 7rr must belong to two distinct segments, since at least one intermediate element is not",
        "pebbled.",
        "The codomain of 7rr then contains at least q segments.",
        "■"
      ]
    },
    {
      "heading": "4 The translation problem",
      "text": [
        "In this section we consider some formulations of the translation problem for PSCFG that have been proposed in the literature.",
        "The most general definition of the translation problem for PSCFG is this: for an input PSCFG Gp = (G, pG) and an input string w, produce a representation of all possible parse trees, along with their probabilities, that are assigned by G to a string in the set T (G, w) under some translation of w. Variant of this definition can be found where the input is a single parse tree for w (Yamada and Knight, 2001), or where the output is a single parse tree, chosen according to some specific criteria (Wu and Wong, 1998).",
        "To formally study these problems, in what follows we focus on single parse trees associated with derivations in GP.",
        "For a derivation Q of the form [S(i), S(i)] ==>G [wi, w21, we write t, ,l and t,,r to denote the left and the right parse trees, respectively, associated with Q.",
        "The probability that t,,r is obtained as a translation of t,,l through Gp is thus pG([tQi, t,,r]) = PG (a).",
        "Let t be some parse tree; we write y(t) to denote the string in the yield of t. For a string w E VT and a parse tree t, we also consider the probability that t is obtained from w through GP, defined as:",
        "We can now precisely define the variants of the translation problem we are interested in.",
        "Given as input a PSCFG Gp = (G, pG) and two strings wi, w2 E VT, output the pair of parse trees",
        "If the synchronous productions in the underlying SCFG G have length bounded by some constant, then the above problem can be solved in polynomial time using extensions of the Viterbi search strategy to parse forests.",
        "This has been shown for instance in (Wu and Wong, 1998; Yamada and Knight, 2001; Melamed, 2004).",
        "A second interesting problem is defined as follows.",
        "Given as input a PSCFG Gp = (G, pG) and a string w E VT, output the parse tree",
        "Even in case we impose some constant bound on the length of the synchronous productions in G, the above problem is NP-hard, as we show in what follows.",
        "We assume the reader is familiar with the definition of probabilistic context-free grammar (PCFG) and with the associated notion of derivation probability (Wetherell, 1980).",
        "We denote a PCFG as a pair (G, pG), with G = (VN, VT, P, S) the underlying context-free grammar and PG the associated function providing the probability distributions for the productions in P, conditioned on their left-hand side.",
        "A probabilistic regular grammar (PRG) is a PCFG with underlying productions of the form A – * aB or A – * E, with A, B nonterminal symbols and a a terminal symbol.",
        "We consider below a decision problem associated with PRG, called the consensus problem, defined as follows: Given as input a PRG (G, pG) and a rational number d E [0, 1], decide whether there exists a string w in the language generated by G such that pG (w) > d. It has been shown in (Casacuberta and de la Higuera, 2000) that, for a PRG G whose productions have all probabilities expressed by rational numbers, the above problem is NP-complete.",
        "(Essentially the same result is also reported in (Lyn-gso and Pedersen, 2002), stated in terms of hidden Markov models.)",
        "We reduce the consensus problem for PRG to a decision version of the problem in (4), called the best translated derivation problem and defined as follows.",
        "Given as input a PCFG GP = (G, pG), a string w E VT and a rational number d E [0, 1], decide whether maxt PG ( [W, t]) > d. Theorem 3 The best translated derivation problem for the class PSCFG is NP-hard.",
        "Proof.",
        "We provide a reduction from the consensus problem for the class PRG with rational production probabilities.",
        "The main idea is described in what follows.",
        "Given the input PRG GP, we construct a target PSCFG Gp' that translates string $ into �, with $ a special symbol.",
        "Given as input the string �, GP' simulates all possible derivations of Gp through its own",
        "derivations.",
        "This is done by encoding the nonterminals appearing in a derivation p of Gp within the left component of some derivation Q of G'P, and by encoding the terminal string generated by p within the right component of Q.",
        "The probability of p is also preserved by Q.",
        "Let Gp = (G, pG), d be an instance of the consensus problem as above, with G = (VN, VT, P, 5).",
        "We specify a PSCFG GP' = (G', pGI) with G' (VN', J$1, P', 5) and VN' = VN U VT. Set P' is constructed as follows: (i) for every (5 – * aA) E P, s : [5 – * AM, 5 a(')] is added to P, with pGI(s) = pG(5 aA); (ii) for every (5 – * E) E P, s : [5 �, 5 – * $] is added to P, with PG, (S) = PG (S E);",
        "(iii) for every a E VT and (A – * bB) E P, s [A , BM, a b(i)] is added to P, with PG' (s) =PG(A bB) (iv) for every a E VT and (A – * E) E P, s : [A – * $, a $] is added to P, with PG' (s) = PG (A – E).",
        "Note that the construction of GP' can be carried out in quadratic time in the size of GP.",
        "It is not difficult to see that there exists a derivation of the form 5 ==�'G a1A1 ==�'G a1a2A2 ... ==�'G a1a2 ... anAn if and only if there exist a derivation in G' associated with unary trees ti and t2, such that string 5A1A2 • • • An is read from the spine of ti and string 5a1a2 • • • an is read from the spine of t2.",
        "Furthermore, the two derivations are composed of ‘corresponding’ productions with the same probabilities.",
        "We conclude that there exists a string w in L(G) with PG (w) > d if and only if there exists a unary tree t with string 5w$ read from the spine such that PG' ([$, t]) > d. ■ We discuss below an interesting consequence of Theorem 3.",
        "The SDTS formalism discussed in Section 1 has been extended to the probabilistic case in (Maryanski and Thomason, 1979), called stochastic SDTS (SSDTS).",
        "As a corollary to the proof of Theorem 3, we obtain that one can define, through some PSCFG Gp and some fixed string w, a probability distribution pG ([w, t]) on parse trees that cannot be obtained through any SSDTS.",
        "Without providing the details of the definition of SSDTS, we give here only an outline of the proof.",
        "We also assume that the reader is familiar with probabilistic finite automata and with their distributional equivalence with PRG.",
        "Consider the PSCFG GP' = (G', pG') defined in the proof of Theorem 3, and assume there exists some SSDTS GP\" = (G\", PG's) such that, for every tree t, we have pG11 ([$, t]) = pGI ([$, t]) .",
        "Since in a derivation of an SDTS the generated trees are always isomorphic, up to some reordering of sibling nodes, we obtain that the productions of G\" must have the form [5 – * a('), 5 a(')], [a – + b(i), a , b(i)] and [a – * $, a – * .",
        "From these productions we can construct a probabilistic deterministic finite automaton generating the same language as the PRG GP, and with the same distribution.",
        "But this is impossible since there are string distributions defined by some PRG that cannot be obtained through probabilistic deterministic finite automata; see for instance (Vidal et al., 2005).",
        "We conclude by remarking that in (Casacuberta and de la Higuera, 2000) it is shown that finding the best output string for a given input string is NP-hard for stochastic SDTS with a single nonterminal in each production’s right-hand side.",
        "Our result in Theorem 3, stated for PSCFG, is stronger, since it investigates individual parse trees rather than strings."
      ]
    },
    {
      "heading": "5 Concluding remarks",
      "text": [
        "The presented results are based on worst case analysis: further experimental evaluation needs to be carried out on multilingual corpora in order to asses the practical impact of these findings."
      ]
    },
    {
      "heading": "Acknowledgment",
      "text": [
        "We are indebted to Dan Melamed and Mark-Jan Nederhof for technical discussion on topics related to this paper.",
        "Dan Melamed also suggested to us the problem investigated by Theorem 2.",
        "The first author is partially supported by MIUR under project PRIN No.",
        "2003091149005."
      ]
    }
  ]
}
