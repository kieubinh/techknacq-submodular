{
  "info": {
    "authors": [
      "Nobuyuki Shimizu"
    ],
    "book": "Conference on Computational Natural Language Learning CoNLL",
    "id": "acl-W06-2936",
    "title": "Maximum Spanning Tree Algorithm for Non-Projective Labeled Dependency Parsing",
    "url": "https://aclweb.org/anthology/W06-2936",
    "year": 2006
  },
  "references": [
    "acl-H05-1066",
    "acl-H05-1091",
    "acl-P04-1015",
    "acl-P05-1013",
    "acl-P05-1067",
    "acl-W02-1001",
    "acl-W04-3201"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Following (McDonald et al., 2005), we present an application of a maximum spanning tree algorithm for a directed graph to non-projective labeled dependency parsing.",
        "Using a variant of the voted perceptron (Collins, 2002; Collins and Roark, 2004; Crammer and Singer, 2003), we discriminatively trained our parser in an on-line fashion.",
        "After just one epoch of training, we were generally able to attain average results in the CoNLL 2006 Shared Task."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Recently, we have seen dependency parsing grow more popular.",
        "It is not rare to see dependency relations used as features, in tasks such as relation extraction (Bunescu and Mooney, 2005) and machine translation (Ding and Palmer, 2005).",
        "Although English dependency relations are mostly projective, in other languages with more flexible word order, such as Czech, non-projective dependencies are more frequent.",
        "There are generally two methods for learning non-projective dependencies.",
        "You could map a non-projective dependency tree to a projective one, learn and predict the tree, then bring it back to the non-projective dependency tree (Nivre and Nilsson, 2005).",
        "Non-projective dependency parsing can also be represented as search for a maximum spanning tree in a directed graph, and this technique has been shown to perform well in Czech (McDonald et al., 2005).",
        "In this paper, we investigate the effectiveness of (McDonald et al., 2005) in the various languages given by the CoNLL 2006 shared task for non-projective labeled dependency parsing.",
        "The paper is structured as follows: in section 2 and 3, we review the decoding and learning aspects of (McDonald et al., 2005), and in section 4, we describe the extension of the algorithm and the features needed for the CoNLL 2006 shared task."
      ]
    },
    {
      "heading": "2 Non-Projective Dependency Parsing",
      "text": []
    },
    {
      "heading": "2.1 Dependency Structure",
      "text": [
        "Let us define x to be a generic sequence of input tokens together with their POS tags and other morphological features, and y to be a generic dependency structure, that is, a set of edges for x.",
        "We use the terminology in (Taskar et al., 2004) for a generic structured output prediction, and define apart.",
        "Apart represents an edge together with its label.",
        "A part is a tuple (DEPREL, i, j) where i is the start point of the edge, j is the end point, and DEPREL is the label of the edge.",
        "The token at i is the head of the token at j.",
        "Table 1 shows our formulation of building a non-projective dependency tree as a prediction problem.",
        "The task is to predict y, the set of parts (column 3, Table 1), given x, the input tokens and their features (column 1 and 2, Table 1).",
        "In this paper we use the common method of factoring the score of the dependency structure as the sum of the scores of all the parts.",
        "A dependency structure is characterized by its features, and for each feature, we have a correspond",
        "ing weight.",
        "The score of a dependency structure is the sum of these weights.",
        "Now, the dependency structures are factored by the parts, so that each feature is some type of a specialization of a part.",
        "Each part in a dependency structure maps to several features.",
        "If we sum up the weights for these features, we have the score for the part, and if we sum up the scores of the parts, we have the score for the dependency structure.",
        "For example, let us say we would like to find the score of the part (OBJ, 2, 4).",
        "This is the edge going to the 4th token ”dog” in Table 1.",
        "Suppose there are two features for this part.",
        "• There is an edge labeled with ”OBJ” that points to the right.",
        "( = DEPREL, dir(i, j) ) • There is an edge labeled with ”OBJ” starting at the token ”saw” which points to the right.",
        "( = DEPREL, dir(i, j), wordz )",
        "If a statement is never true during the training, the weight for it will be 0.",
        "Otherwise there will be a positive weight value.",
        "The score will be the sum of all the weights of the features given by the part.",
        "In the upcoming section, we explain a decoding algorithm for the dependency structures, and later we give a method for learning the weight vector used in the decoding."
      ]
    },
    {
      "heading": "2.2 Maximum Spanning Tree Algorithm",
      "text": [
        "As in (McDonald et al., 2005), the decoding algorithm we used is the Chu-Liu-Edmonds (CLE) algorithm (Chu and Liu, 1965; Edmonds, 1967) for finding the Maximum Spanning Tree in a directed graph.",
        "The following is a nice summary by (McDonald et al., 2005).",
        "Informally, the algorithm has each vertex in the graph greedily select the incoming edge with highest weight.",
        "Note that the edge is coming from the parent to the child.",
        "This means that given a child node word�, we are finding the parent, or the head wordz such that the edge (i, j) has the highest weight among all i, i 7� j.",
        "If a tree results, then this must be the maximum spanning tree.",
        "If not, there must be a cycle.",
        "The procedure identifies a cycle and contracts it into a single vertex and recalculates edge weights going into and out of the cycle.",
        "It can be shown that a maximum spanning tree on the contracted graph is equivalent to a maximum spanning tree in the original graph (Leonidas, 2003).",
        "Hence the algorithm can recursively call itself on the new graph."
      ]
    },
    {
      "heading": "3 Online Learning",
      "text": [
        "Again following (McDonald et al., 2005), we have used the single best MIRA (Crammer and Singer, 2003), which is a variant of the voted perceptron (Collins, 2002; Collins and Roark, 2004) for structured prediction.",
        "In short, the update is executed when the decoder fails to predict the correct parse, and we compare the correct parse yt and the incorrect parse y' suggested by the decoding algorithm.",
        "The weights of the features in y' will be lowered, and the weights of the features in yt will be increased accordingly."
      ]
    },
    {
      "heading": "4 Experiments",
      "text": [
        "Our experiments were conducted on CoNLL-X shared task, with various datasets (Hajiˇc et al., 2004; Simov et al., 2005; Simov and Osenova, 2003; Chen et al., 2003; B¨ohmov´a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; Dˇzeroski et al., 2006; Civit Torruella and Marti An-tonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003) ."
      ]
    },
    {
      "heading": "4.1 Dependency Relation",
      "text": [
        "The CLE algorithm works on a directed graph with unlabeled edges.",
        "Since the CoNLL-X shared task",
        "requires the labeling of edges, as a preprocessing stage, we created a directed complete graph without multi-edges, that is, given two distinct nodes i and j, exactly two edges exist between them, one from i to j, and the other from j to i.",
        "There is no self-pointing edge.",
        "Then we labeled each edge with the highest scoring dependency relation.",
        "This complete graph was given to the CLE algorithm and the edge labels were never altered in the course of finding the maximum spanning tree.",
        "The result is the non-projective dependency tree with labeled edges."
      ]
    },
    {
      "heading": "4.2 Features",
      "text": [
        "The features we used to score each part (edge)",
        "is the position of the parent and j is that of the child.",
        "wordj = the word token at the position j. posj = the coarse part-of-speech at j. dir(i, j) = R if i < j, and L otherwise.",
        "No other features were used beyond the combinations of the CPOS tag and the word token in Table 2.",
        "We have evaluated our parser on Arabic, Danish, Slovene, Spanish, Turkish and Swedish, and used the ”additional features” listed in Table 2 for all languages except for Danish and Swedish.",
        "The reason for this is simply that the model with the additional features did not fit in the 4 GB of memory used in the training.",
        "Although we could do batch learning by running the online algorithm multiple times, we run the online algorithm just once.",
        "The hardware used is an Intel Pentinum D at 3.0 Ghz with 4 GB of memory, and the software was written in C++.",
        "The training time required was Arabic 204 min, Slovene 87 min, Spanish 413 min, Swedish 1192 min, Turkish 410 min, Danish 381 min."
      ]
    },
    {
      "heading": "5 Results",
      "text": [
        "The results are shown in Table 3.",
        "Although our feature set is very simple, the results were around the averages.",
        "We will do error analysis of three notable languages: Arabic, Swedish and Turkish."
      ]
    },
    {
      "heading": "5.1 Arabic",
      "text": [
        "Of 4990 words in the test set, 800 are prepositions.",
        "The prepositions are the most frequently found tokens after nouns in this set.",
        "On the other hand, our head attachment error was 44% for prepositions.",
        "Given the relatively large number of prepositions found in the test set, it is important to get the preposition attachment right to achieve a higher mark in this language.",
        "The obvious solution is to have a feature that connects the head of a preposition to the child of the preposition.",
        "However, such a feature effects the edge based factoring and the decoding algorithm, and we will be forced to modify the MST algorithm in some ways."
      ]
    },
    {
      "heading": "5.2 Swedish",
      "text": [
        "Due to the memory constraint on the computer, we did not use the additional features for Swedish and our feature heavily relied on the CPOS tag.",
        "At the same time, we have noticed that relatively higher performance of our parser compared to the average coincides with the bigger tag set for CPOS for this corpus.",
        "This suggests that we should be using more fine grained POS in other languages."
      ]
    },
    {
      "heading": "5.3 Turkish",
      "text": [
        "The difficulty with parsing Turkish stems from the large unlabeled attachment error rate on the nouns",
        "(39%).",
        "Since the nouns are the most frequently occurring words in the test set (2209 out of 5021 total), this seems to make Turkish the most challenging language for any system in the shared task.",
        "On the average, there are 1.8 or so verbs per sentence, and nouns have a difficult time attaching to the correct verb or postposition.",
        "This, we think, indicates that there are morphological features or word ordering features that we really need in order to disambiguate them."
      ]
    },
    {
      "heading": "6 Future Work",
      "text": [
        "As well as making use of fine-grained POS tags and other morphological features, given the error analysis on Arabic, we would like to add features that are dependent on two or more edges."
      ]
    },
    {
      "heading": "6.1 Bottom-Up Non-Projective Parsing",
      "text": [
        "In order to incorporate features which depend on other edges, we propose Bottom-Up Non-Projective Parsing.",
        "It is often the case that dependency relations can be ordered by how close one relation is to the root of dependency tree.",
        "For example, the dependency relation between a determiner and a noun should be decided before that between a preposition and a noun, and that of a verb and a preposition, and so on.",
        "We can use this information to do bottom-up parsing.",
        "Suppose all words have a POS tag assigned to them, and every edge labeled with a dependency relation is attached to a specific POS tag at the end point.",
        "Also assume that there is an ordering of POS tags such that the edge going to the POS tag needs be decided before other edges.",
        "For example, (1) determiner, (2) noun, (3) preposition, (4) verb would be one such ordering.",
        "We propose the following algorithm: .",
        "Assume we have tokens as nodes in a graph and no edges are present at first.",
        "For example, we have tokens ”I”, ”ate”, ”with”, ”a”, ”spoon”, and no edges between them.",
        ".",
        "Take the POS tag that needs to be decided next.",
        "Find all edges that go to each token labeled with this POS tag, and put them in the graph.",
        "For example, if the POS is noun, put edges from ”ate” to ”I”, from ”ate” to ”spoon”, from ”with” to ”I”, from ”with” to ”spoon”, from ”I” to ”spoon”, and from ”spoon” to ”I”.",
        ".",
        "Run the CLE algorithm on this graph.",
        "This selects the highest incoming edge to each token with the POS tag we are looking at, and remove cycles if any are present.",
        ".",
        "Take the resulting forests and for each edge, bring the information on the child node to the parent node.",
        "For example, if this time POS was noun, and there is an edge to a preposition ”with” from a noun ”spoon”, then ”spoon” is absorbed by ”with”.",
        "Note that since no remaining dependency relation will attach to ”spoon”, we can safely ignore ”spoon” from now on.",
        ".",
        "Go back and repeat until no POS is remaining and we have a dependency tree.",
        "Now in the next round, when deciding the score of the edge from ”ate” to ”with”, we can use the all information at the token ”with”, including ”spoon”."
      ]
    },
    {
      "heading": "7 Conclusion",
      "text": [
        "We have extended non-projective unlabeled dependency parsing (McDonald et al., 2005) to a very simple non-projective labeled dependency and showed that the parser performs reasonably well with small number of features and just one iteration of training.",
        "Based on the analysis of the Arabic parsing results, we have proposed a bottom-up non-projective labeled dependency parsing algorithm that allows us to use features dependent on more than one edge, with very little disadvantage compared to the original algorithm."
      ]
    }
  ]
}
