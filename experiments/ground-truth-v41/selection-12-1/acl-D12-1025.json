{
  "info": {
    "authors": [
      "Qing Dou",
      "Kevin Knight"
    ],
    "book": "EMNLP",
    "id": "acl-D12-1025",
    "title": "Large Scale Decipherment for Out-of-Domain Machine Translation",
    "url": "https://aclweb.org/anthology/D12-1025",
    "year": 2012
  },
  "references": [
    "acl-C08-1125",
    "acl-D08-1085",
    "acl-P02-1040",
    "acl-P03-1021",
    "acl-P06-2065",
    "acl-P07-1094",
    "acl-P07-2045",
    "acl-P08-1088",
    "acl-P09-1088",
    "acl-P11-1002",
    "acl-P11-1025",
    "acl-P11-2071",
    "acl-P95-1050",
    "acl-W02-0902",
    "acl-W08-0309"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We apply slice sampling to Bayesian decipherment and use our new decipherment framework to improve out-of-domain machine translation.",
        "Compared with the state of the art algorithm, our approach is highly scalable and produces better results, which allows us to decipher ciphertext with billions of tokens and hundreds of thousands of word types with high accuracy.",
        "We decipher a large amount of monolingual data to improve out-of-domain translation and achieve significant gains of up to 3.8 BLEU points."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Nowadays, state of the art statistical machine translation (SMT) systems are built using large amounts of bilingual parallel corpora.",
        "Those corpora are used to estimate probabilities of word-to-word translation, word sequences rearrangement, and even syntactic transformation.",
        "Unfortunately, as parallel corpora are expensive and not available for every domain, performance of SMT systems drops significantly when translating out-of-domain texts (Callison-Burch et al2008).",
        "In general, it is easier to obtain in-domain monolingual corpora.",
        "Is it possible to use domain specific monolingual data to improve an MT system trained on parallel texts from a different domain?",
        "Some researchers have attempted to do this by adding a domain specific dictionary (Wu et al2008), or mining unseen words (Daume?",
        "and Jagarlamudi, 2011) using one of several translation lexicon induction techniques (Haghighi et al2008; Koehn and Knight, 2002; Rapp, 1995).",
        "However, a dictionary is not always available, and it is difficult to assign probabilities to a translation lexicon.",
        "(Ravi and Knight, 2011b) have shown that one can use decipherment to learn a full translation model from non-parallel data.",
        "Their approach is able to find translations, and assign probabilities to them.",
        "But their work also has certain limitations.",
        "First of all, the corpus they use to build the translation system has a very small vocabulary.",
        "Secondly, although their algorithm is able to handle word substitution ciphers with limited vocabulary, its deciphering accuracy is low.",
        "The contributions of this work are: ?",
        "We improve previous decipherment work by introducing a more efficient sampling algorithm.",
        "In experiments, our new method improves deciphering accuracy from 82.5% to 88.1% on (Ravi and Knight, 2011b)'s domain specific data set.",
        "Furthermore, we also solve a very large word substitution cipher built from the English Gigaword corpus and achieve 92.2% deciphering accuracy on news text.",
        "?",
        "With the ability to handle a much larger vocabulary, we learn a domain specific translation table from a large amount of monolingual data and use the translation table to improve out-of-domain machine translation.",
        "In experiments, we observe significant gains of up to 3.8 BLEU points.",
        "Unlike previous works, the translation table we build from monolingual data do not only contain unseen words but also words seen in parallel data."
      ]
    },
    {
      "heading": "2 Word Substitution Ciphers",
      "text": [
        "Before we present our new decipherment framework, we quickly review word substitution decipherment.",
        "Recently, there has been an increasing interest in decipherment work (Ravi and Knight, 2011a; Ravi and Knight, 2008).",
        "While letter substitution ciphers can be solved easily, nobody has been able to solve a word substitution cipher with high accuracy.",
        "As shown in Figure 1, a word substitution cipher is generated by replacing each word in a natural language (plaintext) sequence with a cipher token according to a substitution table.",
        "The mapping in the table is deterministic ?",
        "each plaintext word type is only encoded with one unique cipher token.",
        "Solving a word substitution cipher means recovering the original plaintext from the ciphertext without knowing the substitution table.",
        "The only thing we rely on is knowledge about the underlying language.",
        "How can we solve a word substitution cipher?",
        "The approach is similar to those taken by cryptana-lysts who try to recover keys that convert encrypted texts to readable texts.",
        "Suppose we observe a large cipher string f and want to decipher it into English e. We can follow the work in (Ravi and Knight, 2011b) and assume that the cipher string f is generated in the following way: ?",
        "Generate English plaintext sequence e = e1, e2...en with probability P(e).",
        "?",
        "Replace each English plaintext token ei with a cipher token fi with probability P (fi|ei).",
        "Based on the above generative story, we write the probability of the cipher string f as:",
        "We use this equation as an objective function for maximum likelihood training.",
        "In the equation, P (e) is given by an ngram language model, which is trained using a large amount of monolingual texts.",
        "The rest of the task is to manipulate channel probabilities P?",
        "(fi|ei) so that the probability of the observed texts P (f)?",
        "is maximized.",
        "Theoretically, we can directly apply EM, as proposed in (Knight et al2006), or Bayesian decipherment (Ravi and Knight, 2011a) to solve the problem.",
        "However, unlike letter substitution ciphers, word substitution ciphers pose much greater challenges to algorithm scalability.",
        "To solve a word substitution cipher, the EM algorithm has a computational complexity of O(N ?",
        "V 2 ?",
        "R) and the complexity of Bayesian method is O(N ?",
        "V ?",
        "R), where V is the size of plaintext vocabulary, N is the length of ciphertext, and R is the number of iterations.",
        "In the world of word substitution ciphers, both V and N are very large, making these approaches impractical.",
        "(Ravi and Knight, 2011b) propose several modifications to the existing algorithms.",
        "However, the modified algorithms are only an approximation of the original algorithms and produce poor deciphering accuracy, and they are still unable to handle very large scale ciphers.",
        "To address the above problems, we propose the following two new improvements to previous decipherment methods.",
        "?",
        "We apply slice sampling (Neal, 2000) to scale up to ciphers with a very large vocabulary.",
        "?",
        "Instead of deciphering using the original ciphertext, we break the ciphertext into bigrams, collect their counts, and use the bigrams with their counts for decipherment.",
        "The new improvements allow us to solve a word substitution cipher with billions of tokens and hundreds of thousands of word types.",
        "Through better approximation, we achieve a significant increase in deciphering accuracy.",
        "In the following section, we present details of our new approach."
      ]
    },
    {
      "heading": "3 Slice Sampling for Bayesian",
      "text": []
    },
    {
      "heading": "Decipherment",
      "text": [
        "In this section, we first give an introduction to Bayesian decipherment and then describe how to use slice sampling for it."
      ]
    },
    {
      "heading": "3.1 Bayesian Decipherment",
      "text": [
        "Bayesian inference has been widely used in natural language processing (Goldwater and Griffiths, 2007; Blunsom et al2009; Ravi and Knight, 2011b).",
        "It is very attractive for problems like word substitution ciphers for the following reasons.",
        "First, there are no memory bottlenecks as compared to EM, which has an O(N ?",
        "V 2) space complexity.",
        "Second, priors encourage the model to learn a sparse distribution.",
        "The inference is usually performed using Gibbs sampling.",
        "For decipherment, a Gibbs sampler keeps drawing samples from plaintext sequences according to derivation probability P (d):",
        "In Bayesian inference, P (e) is still given by an ngram language model, while the channel probability is modeled by the Chinese Restaurant Process (CRP):",
        "Where prior is the base distribution (we set prior to 1C in all our experiments, where C is the number of word types in ciphertext), and count, also called ?cache?, records events that occurred in the history.",
        "Each sampling operation involves changing a plaintext token ei, which has V possible choices, where V is the plaintext vocabulary size, and the final sample is chosen with probability P (d)?V"
      ]
    },
    {
      "heading": "3.2 Slice Sampling",
      "text": [
        "With Gibbs sampling, one has to evaluate all possible plaintext word types (10k?1M) for each sample decision.",
        "This become intractable when the vocabulary is large and the ciphertext is long.",
        "Slice sampling (Neal, 2000) can solve this problem by automatically adjusting the number of samples to be considered for each sampling operation.",
        "Suppose the derivation probability for current",
        "sample is P (current s).",
        "Then slice sampling draws a sample in two steps: ?",
        "Select a threshold T uniformly from the range {0, P (current s)}.",
        "?",
        "Draw a new sample new s uniformly from a",
        "pool of candidates: {new s|P (new s) > T}.",
        "From the above two steps, we can see that given a threshold T , we only need to consider those samples whose probability is higher than the threshold.",
        "This will lead to a significant reduction on the number of samples to be considered, if probabilities of the most samples are below T .",
        "In practice, the first step is easy to implement, while it is difficult to make the second step efficient.",
        "An obvious way to collect candidate samples is to go over all possible samples and record those with probabilities higher than T .",
        "However, doing this will not save any time.",
        "Fortunately, for Bayesian decipherment, we are able to complete the second step efficiently.",
        "According to Equation 1, the probability of the current sample is given by a language model P (e) and a channel model P (c|e).",
        "The language model is usually an ngram language model.",
        "Suppose our current sample current s contains English tokens X , Y , and Z at position i ?",
        "1, i, and i + 1 respectively.",
        "Let ci be the cipher token at position i.",
        "To obtain a new sample, we just need to change token Y to Y ?.",
        "Since the rest of the sample stays the same, we only need to calculate the probability of any tri-gram 1: P (XY ?Z) and the channel model probability: P (ci|Y ?",
        "), and multiply them together as shown in Equation 4.",
        "In slice sampling, each sampling operation has two steps.",
        "For the first step, we choose a threshold T uniformly between 0 and P (XY Z) ?P (ci|Y ).",
        "For the second step, there are two cases.",
        "First, we notice that two types of Y ?",
        "are more likely to pass the threshold T : (1) Those that have a very high trigram probability , and (2) those that have high channel model probability.",
        "To find candidates that have high trigram probability, we build sorted lists ranked by P (XY ?Z), which can be precomputed off-line.",
        "We only keep the top K English words for each of the sorted list.",
        "When the last item YK in the list satisfies P (XYkZ) ?",
        "prior <",
        "ple Y ?",
        "uniformly from A ?",
        "B until Equation 4 is greater than T .",
        "2 Second, what happens when the last item YK in the list does not satisfy P (XYkZ) ?",
        "prior < T ?",
        "Then we always choose a word Y ?",
        "randomly and accept it as a new sample if Equation 4 is greater than T .",
        "Our algorithm alternates between the two cases.",
        "The actual number of choices the algorithm looks at depends on the K and the total number of possible choices.",
        "In different experiments, we find that when K = 500, the algorithm only looks at 0.06% of all possible choices.",
        "When K = 2000, this further reduces to 0.007%."
      ]
    },
    {
      "heading": "3.3 Deciphering with Bigrams",
      "text": [
        "Since we can decipher with a bigram language model, we posit that a frequency list of ciphertext bigrams may contain enough information for decipherment.",
        "In our letter substitution experiments, we find that breaking ciphertext into bigrams doesn't hurt decipherment accuracy.",
        "Table 1 shows how full English sentences in the original data are broken into bigrams and their counts.",
        "Instead of doing sampling on full sentences, we treat each bigram as a full ?sentence?.",
        "There are 2It is easy to prove that all other candidates that are not in the sorted list and with count(ci, Y ?)",
        "= 0 have a upper bound probability: P (XYkZ) ?",
        "prior.",
        "Therefore, they are ignored when P (XYkZ) ?",
        "prior < T .",
        "man they took our land .",
        "they took our arable land .",
        "two advantages to use bigrams and their counts for decipherment.",
        "First of all, the bigrams and counts are a much more compact representation of the original ciphertext with full sentences.",
        "For instance, after breaking a billion tokens from the English Gigaword corpus, we find only 29m bigrams and 58m tokens, which is only 1/17 of the original text.",
        "In practice, we further discard all bigrams with low frequency, which makes the ciphertext even shorter.",
        "Secondly, using bigrams significantly reduces the number of sorted lists (from |V |2 to 2|V |) mentioned in the previous section.",
        "The number of lists reduces from |V |2 to 2|V |because words in a bigram only have one neighbor.",
        "Therefore, for any word W in a bigram, we need only 2|V |lists (?words to the right of W?",
        "and ?words to the left of W?)",
        "instead of |V |2 lists (?pairs of words that surround W?",
        ")."
      ]
    },
    {
      "heading": "3.4 Iterative Sampling",
      "text": [
        "Although we can directly apply slice sampling on a large number of bigrams, we find that gradually including less frequent bigrams into a sampling process saves deciphering time ?",
        "we call this iterative sampling: ?",
        "Break the ciphertext into bigrams and collect their counts ?",
        "Keep bigrams whose counts are greater than a threshold ?.",
        "Then initialize the first sample randomly and use slice sampling to perform maximum likelihood training.",
        "In the end, extract a translation table T according to the final sample.",
        "?",
        "Lower the threshold ?",
        "to include more bigrams into the sampling process.",
        "Initialize the first sample using the translation table obtained from the previous sampling run (for each ci",
        "pher token f, choose a plaintext token e whose"
      ]
    },
    {
      "heading": "3.5 Parallel Sampling",
      "text": [
        "Inspired by (Newman et al2009), our parallel sampling procedure is described below:",
        "?",
        "Collect bigrams and their counts from ciphertext and split the bigrams into N parts.",
        "?",
        "Run slice sampling on each part for 5 iterations independently.",
        "?",
        "Combine counts from each part to form a new count table and run sampling again on each part using the new table.3"
      ]
    },
    {
      "heading": "4 Decipherment Experiments",
      "text": [
        "In this section, we evaluate our new sampling algorithm in two different experiments.",
        "In the first experiment, we compare our method with (Ravi and Knight, 2011b) on their data set to prove correctness of our approach.",
        "In the second experiment, we scale up to the whole English Gigaword corpus and achieve a much higher deciphering accuracy."
      ]
    },
    {
      "heading": "4.1 Deciphering Transtac Corpus",
      "text": [
        "We split the Transtac corpus the same way it was split in (Ravi and Knight, 2011b).",
        "The data used to create ciphertext consists of 1 million tokens, and 3397 word types.",
        "The data for language model training contains 2.7 million tokens and 25761 word types.",
        "The ciphertext is created by replacing each English word with a cipher word.",
        "We use a bigram language model for decipherment training.",
        "When the training terminates, a translation table with probability P (c|e) is built based on the counts collected from the final sample.",
        "For decoding, we employ a trigram language model using full sentences.",
        "We use Moses (Koehn et al2007)",
        "from (Ravi and Knight, 2011b) to perform the decoding.",
        "We set the distortion limit to 0 and cube the translation probabilities.",
        "Essentially, Moses tries to find an English sequence e that maximizes P (e) ?",
        "P (c|e)3",
        "We evaluate the performance of our algorithm by decipherment accuracy, which measures the percentage of correctly deciphered cipher tokens.",
        "Table 2 compares the deciphering accuracy with the state of the art algorithm.",
        "Results show that our algorithm improves the deciphering accuracy to 88.1%, which amounts to 33% reduction in error rate.",
        "This justifies our claim: doing better approximation using slice sampling improves decipherment accuracy.",
        "Table 3 shows the first 5 decoding results and compares them with the gold plaintext.",
        "From the table we can see that the algorithm recovered the majority of the plaintext correctly."
      ]
    },
    {
      "heading": "4.2 Deciphering Gigaword Corpus",
      "text": [
        "To prove the scalability of our new approach, we apply it to solve a much larger word substitution cipher built from English Gigaword corpus.",
        "The corpus contains news articles from different news agencies",
        "and has a much larger vocabulary compared with the Transtac corpus.",
        "We split the corpus into two parts chronologically.",
        "Each part contains approximately 1.2 billion tokens.",
        "We uses the first part to build a word substitution cipher, which is 10k times longer than the one in the previous experiment, and the second part to build a bigram language model.",
        "5",
        "We first use a single machine and apply iterative sampling to solve a 68 million token cipher.",
        "Then we use the result from the first step to initialize our parallel sampling process, which uses as many as 100 machines.",
        "For evaluation, we calculate deciphering accuracy over the first 1000 sentences (33k tokens).",
        "After 2000 iterations of the parallel sampling process, the deciphering accuracy reaches 92.2%.",
        "Figure 2 shows the learning curve of the algorithm.",
        "It can be seen from the graph that both token and type accuracy increase as more and more data becomes",
        "and more ciphertext becomes available.",
        "5Before building the language model, we replace low frequency word types with an ?UNK?",
        "symbol, leaving 129k unique word types."
      ]
    },
    {
      "heading": "5 Improving Out-of-Domain Machine Translation",
      "text": [
        "Domain specific machine translation (MT) is a challenge for statistical machine translation (SMT) systems trained on parallel corpora.",
        "It is common to see a significant drop in translation quality when translating out-of-domain texts.",
        "Although it is hard to find parallel corpora for any specific domain, it is relatively easy to find domain specific monolingual corpora.",
        "In this section, we show how to use our new decipherment framework to learn a domain specific translation table and use it to improve out-of-domain translations."
      ]
    },
    {
      "heading": "5.1 Baseline SMT System",
      "text": [
        "We build a state of the art phrase-based SMT system using Moses (Koehn et al2007).",
        "The baseline system has 3 models: a translation model, a reordering model, and a language model.",
        "The language model can be trained on monolingual data, and the rest are trained on parallel data.",
        "By default, Moses uses the following 8 features to score a candidate translation: ?",
        "direct and inverse translation probabilities ?",
        "direct and inverse lexical weighting ?",
        "phrase penalty ?",
        "a language model ?",
        "a reordering model ?",
        "word penalty Each of the 8 features has its own weight, which can be tuned on a held-out set using minimum error rate training.",
        "(Och, 2003).",
        "In the following sections, we describe how to use decipherment to learn domain specific translation probabilities, and use the new features to improve the baseline."
      ]
    },
    {
      "heading": "5.2 Learning a New Translation Table with Decipherment",
      "text": [
        "From a decipherment perspective, machine translation is a much more complex task than solving a word substitution cipher and poses three major challenges: ?",
        "Mappings between languages are nondeterministic, as words can have multiple translations",
        "?",
        "Re-ordering of words ?",
        "Insertion and deletion of words",
        "Fortunately, our decipherment model does not assume deterministic mapping and is able to discover multiple translations.",
        "For the reordering problem, we treat Spanish as a simple word substitution for French.",
        "Despite the simplification in the assumption, we still expect to learn a useful word-to-word lexicon via decipherment and use the lexicon to improve our baseline.",
        "Problem formulation: By ignoring word re-orderings, we can formulate MT decipherment problem as word substitution decipherment.",
        "We view source language f as ciphertext and target language e as plaintext.",
        "Our goal is to decipher f into e and estimate translation probabilities based on the decipherment.",
        "Probabilistic decipherment: Similar to solving a word substitution cipher, all we have to do here is to estimate the translation model parameters P?",
        "(f |e) using a large amount of monolingual data in f and e respectively.",
        "According to Equation 5, our objective is to estimate the model parameters so that the probability of source text P(f) is maximized.",
        "argmax",
        "Building a translation table: Once the sampling process completes, we estimate translation probability P (f |e) from the final sample using maximum likelihood estimation.",
        "We also decipher from the reverse direction to estimate P (e|f).",
        "Finally, we build a phrase table by taking translation pairs seen in both decipherments."
      ]
    },
    {
      "heading": "5.3 Combining Phrase Tables",
      "text": [
        "We now have two phrase tables: one learnt from parallel corpus and one learnt from non-parallel monolingual corpus through decipherment.",
        "The phrase table learnt through decipherment only contains word to word translations, and each translation option only has two scores.",
        "Moses has a function to decode with multiple phrase tables, so we just need to add the newly learnt phrase table and specify two more weights for the scores in it.",
        "During decoding, if a source word only appears in the decipherment table,",
        "that table's translation will be used.",
        "If a source word exists in both tables, Moses will create two separate decoding paths and choose the best one after taking other features into account.",
        "If a word is not seen in either of the tables, it is copied literally to the output."
      ]
    },
    {
      "heading": "6 MT Experiments and Results",
      "text": []
    },
    {
      "heading": "6.1 Data",
      "text": [
        "In our MT experiments, we translate French into Spanish and use the following corpora to learn our translation systems: ?",
        "Europarl Corpus (Koehn, 2005): The Europarl parallel corpus is extracted from the proceedings of the European Parliament and includes versions in 11 European languages.",
        "The corpus contains articles from the political domain and is used to train our baseline system.",
        "We use the 6th version of the corpus.",
        "After cleaning, there are 1.3 million lines left for training.",
        "We use the last 2k lines for tuning and testing (1k for each), and the rest for training.",
        "Details of training, tuning, and testing data are listed in",
        "?",
        "EMEA Corpus (Tiedemann, 2009): EMEA is a parallel corpus made out of PDF documents from the European Medicines Agency.",
        "It contains articles from the medical domain, which is a good test bed for out-of-domain tasks.",
        "We use the first 2k pairs of sentences for tuning and testing (1k for each), and use the rest (1.1 million lines) for decipherment training.",
        "We split the training corpus in ways that no parallel sentences are included in the training set.",
        "The splitting methods are listed in Table 5.",
        "For decipherment training, we use lexical translation tables learned from the Europarl corpus to ini"
      ]
    },
    {
      "heading": "6.2 Results",
      "text": [
        "BLEU (Papineni et al2002) is used as a standard evaluation metric.",
        "We compare the following 3 systems in our experiments, and present the results in",
        "Our baseline system achieves 38.2 BLEU score on Europarl test set.",
        "In the second row of Table 6, the test set changes to EMEA, and the baseline BLEU score drops to 24.9.",
        "In the third row, the baseline score rises to 30.5 with a language model built from EMEA corpus.",
        "Although it is much higher than the previous baseline, we further improve it by including a new phrase table learnt from domain specific monolingual data.",
        "In a real out-of-domain task, we are unlikely to have any parallel data to tune weights for the new phrase table.",
        "Therefore, we can only set it manually.",
        "In experiments, each score in the new phrase table has a weight of 5, and the BLEU score rises up to 33.2.",
        "In the fourth row of the table, we assume that there is a small amount of domain specific parallel data for tuning.",
        "With better weights, our baseline BLEU score increases to 37.3, and our combined systems increase to 41.1 and 39.7 respectively.",
        "In the last row of the table, we compare the combined systems with an even better baseline.",
        "This time, the baseline is given half of the EMEA tuning set for training and uses the other half",
        "from non-parallel EMEA corpus for weight tuning.",
        "Results show that our combined systems still outperform the baseline.",
        "The phrase table learnt from monolingual data consists of both observed and unknown words.",
        "Table 7 shows the top 10 most frequent OOV words in the table learnt from non-parallel EMEA corpus.",
        "Among the 10 words, 9 have correct translations.",
        "It is interesting to see that our algorithm finds multiple correct translations for the word ?he?patique?.",
        "The only mistake in the table is sensible as French word ?pellicule?s?",
        "is translated into ?recubiertos con pel??cula?",
        "in Spanish."
      ]
    },
    {
      "heading": "7 Conclusion and Future Work",
      "text": [
        "We apply slice sampling to Bayesian Decipherment and show significant improvement in deciphering accuracy compared with the state of the art algorithm.",
        "Our method is not only accurate but also highly scalable.",
        "In experiments, we decipher at the scale of the English Gigaword corpus, which contains over billions of tokens and hundreds of thousands word types.",
        "We further show the value of our new decipherment algorithm by using it to improve out-of-domain translation.",
        "In the future, we will work with more language pairs, especially those with significant word re-orderings.",
        "Moreover, the monolingual corpora used in the experiments are far smaller than what our algorithm can handle.",
        "We will continue to work in scenarios where large amount of monolingual data is readily available.",
        "different experiments.",
        "Each row has a different set of training, tuning, and testing data.",
        "Baseline is trained on parallel data only.",
        "Tune LM and Test LM specify language models used for tuning and testing respectively.",
        "Decipher-CP and Decipher-NP use a phrase table learnt from comparable and non-parallel EMEA corpus respectively."
      ]
    },
    {
      "heading": "8 Acknowledgments",
      "text": [
        "This work was supported by NSF Grant 0904684.",
        "The authors would like to thank Philip Koehen, David Chiang, Jason Riesa, Ashish Vaswani, and Hui Zhang for their comments and suggestions."
      ]
    }
  ]
}
