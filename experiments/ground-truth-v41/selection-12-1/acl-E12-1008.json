{
  "info": {
    "authors": [
      "Carlos Gómez-Rodríguez",
      "Daniel Fernández-González"
    ],
    "book": "EACL",
    "id": "acl-E12-1008",
    "title": "Dependency Parsing with Undirected Graphs",
    "url": "https://aclweb.org/anthology/E12-1008",
    "year": 2012
  },
  "references": [
    "acl-D07-1013",
    "acl-H05-1066",
    "acl-J08-4003",
    "acl-P05-1013",
    "acl-P06-2066",
    "acl-P09-1039",
    "acl-P10-1110",
    "acl-P10-1151",
    "acl-W00-1205",
    "acl-W04-2407",
    "acl-W06-2920",
    "acl-W07-2218"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We introduce a new approach to transition-based dependency parsing in which the parser does not directly construct a dependency structure, but rather an undirected graph, which is then converted into a directed dependency tree in a post-processing step.",
        "This alleviates error propagation, since undirected parsers do not need to observe the single-head constraint.",
        "Undirected parsers can be obtained by simplifying existing transition-based parsers satisfying certain conditions.",
        "We apply this approach to obtain undirected variants of the planar and 2-planar parsers and of Covington's non-projective parser.",
        "We perform experiments on several datasets from the CoNLL-X shared task, showing that these variants outperform the original directed algorithms in most of the cases."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Dependency parsing has proven to be very useful for natural language processing tasks.",
        "Data-driven dependency parsers such as those by Nivre et al. (2004), McDonald et al. (2005), Titov and Henderson (2007), Martins et al. (2009) or Huang and Sagae (2010) are accurate and efficient, they can be trained from annotated data without the need for a grammar, and they provide a simple representation of syntax that maps to predicate-argument structure in a straightforward way.",
        "In particular, transition-based dependency parsers (Nivre, 2008) are a type of dependency parsing algorithms which use a model that scores transitions between parser states.",
        "Greedy deterministic search can be used to select the transition to be taken at each state, thus achieving linear or quadratic time complexity.",
        "0 1 2 3",
        "straint will incur in error propagation if they mistakenly build a dependency link 1 ?",
        "2 instead of 2 ?",
        "1 (dependency links are represented as arrows going from head to dependent).",
        "It has been shown by McDonald and Nivre (2007) that such parsers suffer from error propagation: an early erroneous choice can place the parser in an incorrect state that will in turn lead to more errors.",
        "For instance, suppose that a sentence whose correct analysis is the dependency graph in Figure 1 is analyzed by any bottom-up or left-to-right transition-based parser that outputs dependency trees, therefore obeying the single-head constraint (only one incoming arc is allowed per node).",
        "If the parser chooses an erroneous transition that leads it to build a dependency link from 1 to 2 instead of the correct link from 2 to 1, this will lead it to a state where the single-head constraint makes it illegal to create the link from 3 to 2.",
        "Therefore, a single erroneous choice will cause two attachment errors in the output tree.",
        "With the goal of minimizing these sources of errors, we obtain novel undirected variants of several parsers; namely, of the planar and 2 planar parsers by Gómez-Rodríguez and Nivre (2010) and the non-projective list-based parser described by Nivre (2008), which is based on Covington's algorithm (Covington, 2001).",
        "These variants work by collapsing the LEFT-ARC and RIGHT-ARC transitions in the original parsers, which create right-to-left and left-to-right dependency links, into a single ARC transition creating an undirected link.",
        "This has the advantage that the single-head constraint need not be observed during the parsing process, since the directed notions of head and dependent are lost in undirected graphs.",
        "This gives the parser more freedom and can prevent situations where enforcing the constraint leads to error propagation, as in Figure 1.",
        "On the other hand, these new algorithms have the disadvantage that their output is an undirected graph, which has to be post-processed to recover the direction of the dependency links and generate a valid dependency tree.",
        "Thus, some complexity is moved from the parsing process to this post-processing step; and each undirected parser will outperform the directed version only if the simplification of the parsing phase is able to avoid more errors than are generated by the post-processing.",
        "As will be seen in latter sections, experimental results indicate that this is in fact the case.",
        "The rest of this paper is organized as follows: Section 2 introduces some notation and concepts that we will use throughout the paper.",
        "In Section 3, we present the undirected versions of the parsers by Gómez-Rodríguez and Nivre (2010) and Nivre (2008), as well as some considerations about the feature models suitable to train them.",
        "In Section 4, we discuss post-processing techniques that can be used to recover dependency trees from undirected graphs.",
        "Section 5 presents an empirical study of the performance obtained by these parsers, and Section 6 contains a final discussion."
      ]
    },
    {
      "heading": "2 Preliminaries",
      "text": []
    },
    {
      "heading": "2.1 Dependency Graphs",
      "text": [
        "Let w = w1 .",
        ".",
        ".",
        "wn be an input string.",
        "A dependency graph for w is a directed graph G = (Vw, E), where Vw = {0, .",
        ".",
        ".",
        ", n} is the set of nodes, and E ?",
        "Vw ?",
        "Vw is the set of directed arcs.",
        "Each node in Vw encodes the position of a token in w, and each arc in E encodes a dependency relation between two tokens.",
        "We write i ?",
        "j to denote a directed arc (i, j), which will also be called a dependency link from i to j.1 We",
        "to simplify the presentation we will ignore labels throughout most of the paper.",
        "However, all the results and algorithms presented can be applied to labeled dependency graphs and will be so applied in the experimental evaluation.",
        "say that i is the head of j and, conversely, that j is a syntactic dependent of i.",
        "Given a dependency graph G = (Vw, E), we write i ??",
        "j ?",
        "E if there is a (possibly empty) directed path from i to j; and i ??",
        "j ?",
        "E if there is a (possibly empty) path between i and j in the undirected graph underlying G (omitting the references to E when clear from the context).",
        "Most dependency-based representations of syntax do not allow arbitrary dependency graphs, instead, they are restricted to acyclic graphs that have at most one head per node.",
        "Dependency graphs satisfying these constraints are called dependency forests.",
        "Definition 1 A dependency graph G is said to be a forest iff it satisfies:",
        "1.",
        "Acyclicity constraint: if i ??",
        "j, then not j ?",
        "i.",
        "2.",
        "Single-head constraint: if j ?",
        "i, then there",
        "is no k 6= j such that k ?",
        "i.",
        "A node that has no head in a dependency forest is called a root.",
        "Some dependency frameworks add the additional constraint that dependency forests have only one root (or, equivalently, that they are connected).",
        "Such a forest is called a dependency tree.",
        "A dependency tree can be obtained from any dependency forest by linking all of its root nodes as dependents of a dummy root node, conventionally located in position 0 of the input."
      ]
    },
    {
      "heading": "2.2 Transition Systems",
      "text": [
        "In the framework of Nivre (2008), transition-based parsers are described by means of a non-deterministic state machine called a transition system.",
        "Definition 2 A transition system for dependency parsing is a tuple S = (C, T, cs, Ct), where",
        "1.",
        "C is a set of possible parser configurations, 2.",
        "T is a finite set of transitions, which are partial functions t : C ?",
        "C, 3. cs is a total initialization function mapping each input string to a unique initial configuration, and 4.",
        "Ct ?",
        "C is a set of terminal configurations.",
        "To obtain a deterministic parser from a non-deterministic transition system, an oracle is used to deterministically select a single transition at",
        "each configuration.",
        "An oracle for a transition system S = (C, T, cs, Ct) is a function o : C ?",
        "T .",
        "Suitable oracles can be obtained in practice by training classifiers on treebank data (Nivre et al. 2004)."
      ]
    },
    {
      "heading": "2.3 The Planar, 2-Planar and Covington Transition Systems",
      "text": [
        "Our undirected dependency parsers are based on the planar and 2-planar transition systems by Gómez-Rodríguez and Nivre (2010) and the version of the Covington (2001) non-projective parser defined by Nivre (2008).",
        "We now outline these directed parsers briefly, a more detailed description can be found in the above references.",
        "The planar transition system by Gómez-Rodríguez and Nivre (2010) is a linear-time transition-based parser for planar dependency forests, i.e., forests whose dependency arcs do not cross when drawn above the words.",
        "The set of planar dependency structures is a very mild extension of that of projective structures (Kuhlmann and Nivre, 2006).",
        "Configurations in this system are of the form c = ?",
        "?, B,A?",
        "where ?",
        "and B are disjoint lists of nodes from Vw (for some input w), and A is a set of dependency links over Vw.",
        "The list B, called the buffer, holds the input words that are still to be read.",
        "The list ?, called the stack, is initially empty and is used to hold words that have dependency links pending to be created.",
        "The system is shown at the top in Figure 2, where the notation ?",
        "|i is used for a stack with top i and tail ?, and we invert the notation for the buffer for clarity (i.e., i |B as a buffer with top i and tail B).",
        "The system reads the input sentence and creates links in a left-to-right order by executing its four transitions, until it gets to a terminal configuration.",
        "A SHIFT transition moves the first (leftmost) node in the buffer to the top of the stack.",
        "Transitions LEFT-ARC and RIGHT-ARC create leftward or rightward link, respectively, involving the first node in the buffer and the topmost node in the stack.",
        "Finally, REDUCE transition is used to pop the top word from the stack when we have finished building arcs to or from it.",
        "The 2-planar transition system by  and Nivre (2010) is an extension of the planar system that uses two stacks, allowing it to recognize 2-planar structures, a larger set of dependency structures that has been shown to cover the vast majority of non-projective structures in a number of treebanks Gómez-Rodríguez and Nivre, 2010).",
        "This transition system, shown in Figure 2, has configurations of the form c = ?",
        "?0,?1, B,A?",
        ", where we call ?0 the active stack and ?1 the inactive stack.",
        "Its SHIFT, LEFT-ARC, RIGHT-ARC and REDUCE transitions work similarly to those in the planar parser, but while SHIFT pushes the first word in the buffer to both stacks; the other three transitions only work with the top of the active stack, ignoring the inactive one.",
        "Finally, a SWITCH transition is added that makes the active stack inactive and vice versa.",
        "Covington (2001) proposes several incremental parsing strategies for dependency representations and one of them can recover non-projective dependency graphs.",
        "Nivre (2008) implements a variant of this strategy as a transition system with configurations of the form c = ?",
        "?1, ?2, B,A?, where ?1 and ?2 are lists containing partially processed words and B is the buffer list of unprocessed words.",
        "The Covington non-projective transition system is shown at the bottom in Figure 2.",
        "At each configuration c = ?",
        "?1, ?2, B,A?, the parser has to consider whether any dependency arc should be created involving the top of the buffer and the words in ?1.",
        "A LEFT-ARC transition adds a link from the first node j in the buffer to the node in the head of the list ?1, which is moved to the list ?2 to signify that we have finished considering it as a possible head or dependent of j.",
        "The RIGHT-ARC transition does the same manipulation, but creating the symmetric link.",
        "A NO-ARC transition removes the head of the list ?1 and inserts it at the head of the list ?2 without creating any arcs: this transition is to be used where there is no dependency relation between the top node in the buffer and the head of ?1, but we still may want to create an arc involving the top of the buffer and other nodes in ?1.",
        "Finally, if we do not want to create any such arcs at all, we can execute a SHIFT transition, which advances the parsing process by removing the first node in the bufferB and inserting it at the head of a list obtained by concatenating",
        "?1 and ?2.",
        "This list becomes the new ?1, whereas ?2 is empty in the resulting configuration.",
        "Note that the Covington parser has quadratic complexity with respect to input length, while the planar and 2-planar parsers run in linear time."
      ]
    },
    {
      "heading": "3 The Undirected Parsers",
      "text": [
        "The transition systems defined in Section 2.3 share the common property that their LEFT-ARC and RIGHT-ARC have exactly the same effects except for the direction of the links that they create.",
        "We can take advantage of this property to define undirected versions of these transition systems, by transforming them as follows: ?",
        "Configurations are changed so that the arc set A is a set of undirected arcs, instead of directed arcs.",
        "?",
        "The LEFT-ARC and RIGHT-ARC transitions in each parser are collapsed into a single ARC transition that creates an undirected arc.",
        "?",
        "The preconditions of transitions that guarantee the single-head constraint are removed, since the notions of head and dependent are lost in undirected graphs.",
        "By performing these transformations and leaving the systems otherwise unchanged, we obtain the undirected variants of the planar, 2-planar and Covington algorithms that are shown in Figure 3.",
        "Note that the transformation can be applied to any transition system having LEFT-ARC and RIGHT-ARC transitions that are equal except for the direction of the created link, and thus col-lapsable into one.",
        "The above three transition systems fulfill this property, but not every transition system does.",
        "For example, the well-known arc-eager parser of Nivre (2003) pops a node from the stack when creating left arcs, and pushes a node to the stack when creating right arcs, so the transformation cannot be applied to it.2 2One might think that the arc-eager algorithm could still be transformed by converting each of its arc transitions into an undirected transition, without collapsing them into one.",
        "However, this would result into a parser that violates the acyclicity constraint, since the algorithm is designed in such a way that acyclicity is only guaranteed if the single-head constraint is kept.",
        "It is easy to see that this problem cannot happen in parsers where LEFT-ARC and RIGHT-ARC transitions have the same effect: in these, if a directed graph is not parsable in the original algorithm, its underlying undirected graph cannot not be parsable in the undirected variant."
      ]
    },
    {
      "heading": "3.1 Feature models",
      "text": [
        "Some of the features that are typically used to train transition-based dependency parsers depend on the direction of the arcs that have been built up to a certain point.",
        "For example, two such features for the planar parser could be the POS tag associated with the head of the topmost stack node, or the label of the arc going from the first node in the buffer to its leftmost dependent.3 As the notion of head and dependent is lost in undirected graphs, this kind of features cannot be used to train undirected parsers.",
        "Instead, we use features based on undirected relations between nodes.",
        "We found that the following kinds of features worked well in practice as a replacement for features depending on arc direction: ?",
        "Information about the ith node linked to a given node (topmost stack node, topmost buffer node, etc.)",
        "on the left or on the right, and about the associated undirected arc, typically for i = 1, 2, 3, ?",
        "Information about whether two nodes are linked or not in the undirected graph, and about the label of the arc between them, ?",
        "Information about the first left and right ?undirected siblings?",
        "of a given node, i.e., the first node q located to the left of the given node p such that p and q are linked to some common node r located to the right of both, and vice versa.",
        "Note that this notion of undirected siblings does not correspond exclusively to siblings in the directed graph, since it can also capture other second-order interactions, such as grandparents."
      ]
    },
    {
      "heading": "4 Reconstructing the dependency forest",
      "text": [
        "The modified transition systems presented in the previous section generate undirected graphs.",
        "To obtain complete dependency parsers that are able to produce directed dependency forests, we will need a reconstruction step that will assign a direction to the arcs in such a way that the single-head constraint is obeyed.",
        "This reconstruction step can be implemented by building a directed graph with weighted arcs corresponding to both possible directions of each undirected edge, and then finding an optimum branching to reduce it to a directed tree.",
        "3 These example features are taken from the default model for the planar parser in version 1.5 of MaltParser (Nivre et al., 2006).",
        "Different criteria for assigning weights to arcs provide different variants of the reconstruction technique.",
        "To describe these variants, we first introduce preliminary definitions.",
        "Let U = (Vw, E) be an undirected graph produced by an undirected parser for some string w. We define the following sets of arcs:",
        "Note that A1(U) represents the set of arcs obtained from assigning an orientation to an edge in U , except arcs whose dependent is the dummy root, which are disallowed.",
        "On the other hand, A2(U) contains all the possible arcs originating from the dummy root node, regardless of whether their underlying undirected edges are in U or not; this is so that reconstructions are allowed to link unattached tokens to the dummy root.",
        "The reconstruction process consists of finding a minimum branching (i.e. a directed minimum spanning tree) for a weighted directed graph obtained from assigning a cost c(i, j) to each arc (i, j) of the following directed graph:",
        "That is, we will find a dependency tree T = (Vw, AT ?",
        "A(U)) such that the sum of costs of the arcs in AT is minimal.",
        "In general, such a minimum branching can be calculated with the ChuLiu-Edmonds algorithm (Chu and Liu, 1965; Ed-monds, 1967).",
        "Since the graph D(U) has O(n) nodes and O(n) arcs for a string of length n, this can be done in O(n log n) if implemented as described by Tarjan (1977).",
        "However, applying these generic techniques is not necessary in this case: since our graph U is acyclic, the problem of reconstructing the forest can be reduced to choosing a root word for each connected component in the graph, linking it as a dependent of the dummy root and directing the other arcs in the component in the (unique) way that makes them point away from the root.",
        "It remains to see how to assign the costs c(i, j) to the arcs of D(U): different criteria for assigning scores will lead to different reconstructions."
      ]
    },
    {
      "heading": "4.1 Naive reconstruction",
      "text": [
        "A first, very simple reconstruction technique can be obtained by assigning arc costs to the arcs in A(U) as follows:",
        "This approach gives the same cost to all arcs obtained from the undirected graph U , while also allowing (at a higher cost) to attach any node to the dummy root.",
        "To obtain satisfactory results with this technique, we must train our parser to explicitly build undirected arcs from the dummy root node to the root word(s) of each sentence using arc transitions (note that this implies that we need to represent forests as trees, in the manner described at the end of Section 2.1).",
        "Under this assumption, it is easy to see that we can obtain the correct directed tree T for a sentence if it is provided with its underlying undirected tree U : the tree is obtained in O(n) as the unique orientation of U that makes each of its edges point away from the dummy root.",
        "This approach to reconstruction has the advantage of being very simple and not adding any complications to the parsing process, while guaranteeing that the correct directed tree will be recovered if the undirected tree for a sentence is generated correctly.",
        "However, it is not very robust, since the direction of all the arcs in the output depends on which node is chosen as sentence head and linked to the dummy root.",
        "Therefore, a parsing error affecting the undirected edge involving the dummy root may result in many dependency links being erroneous."
      ]
    },
    {
      "heading": "4.2 Label-based reconstruction",
      "text": [
        "To achieve a more robust reconstruction, we use labels to encode a preferred direction for dependency arcs.",
        "To do so, for each pre-existing label X in the training set, we create two labels Xl and Xr.",
        "The parser is then trained on a modified version of the training set where leftward links originally labelled X are labelled Xl, and rightward links originally labelled X are labelled Xr.",
        "Thus, the output of the parser on a new sentence will be an undirected graph where each edge has a label with an annotation indicating whether the reconstruction process should prefer to link the pair of nodes with a leftward or a rightward arc.",
        "We can then assign costs to our minimum branching algorithm so that it will return a tree agreeing with as many such annotations as possible.",
        "To do this, we call A1+(U) ?",
        "A1(U) the set of arcs in A1(U) that agree with the annotations, i.e., arcs (i, j) ?",
        "A1(U) where either i < j and i, j is labelledXr inU , or i > j and i, j is labelled Xl in U .",
        "We callA1?",
        "(U) the set of arcs inA1(U) that disagree with the annotations, i.e.,A1?",
        "(U) = A1(U)\\A1+(U).",
        "And we assign costs as follows:",
        "where n is the length of the string.",
        "With these costs, the minimum branching algorithm will find a tree which agrees with as many annotations as possible.",
        "Additional arcs from the root not corresponding to any edge in the output of the parser (i.e. arcs inA2(U) but not inA1(U)) will be used only if strictly necessary to guarantee connectedness, this is implemented by the high cost for these arcs.",
        "While this may be the simplest cost assignment to implement label-based reconstruction, we have found that better empirical results are obtained if we give the algorithm more freedom to create new arcs from the root, as follows:",
        "While the cost of arcs from the dummy root is still 2n, this is now so even for arcs that are in the output of the undirected parser, which had cost 1 before.",
        "Informally, this means that with this configuration the postprocessor does not ?trust?",
        "the links from the dummy root created by the parser, and may choose to change them if it is convenient to get a better agreement with label annotations (see Figure 4 for an example of the difference between both cost assignments).",
        "We believe that the better accuracy obtained with this criterion probably stems from the fact that it is biased towards changing links from the root, which tend to be more problematic for transition-based parsers, while respecting the parser output for links located deeper in the dependency structure, for which transition-based parsers tend to be more accurate (McDonald and Nivre, 2007).",
        "Note that both variants of label-based reconstruction have the property that, if the undirected parser produces the correct edges and labels for a parser with the label-based transformation, b) and c) The dependency graph obtained by each of the variants of the label-based reconstruction (note how the second variant moves an arc from the root).",
        "given sentence, then the obtained directed tree is guaranteed to be correct (as it will simply be the tree obtained by decoding the label annotations)."
      ]
    },
    {
      "heading": "5 Experiments",
      "text": [
        "In this section, we evaluate the performance of the undirected planar, 2-planar and Covington parsers on eight datasets from the CoNLL-X shared task (Buchholz and Marsi, 2006).",
        "Tables 1, 2 and 3 compare the accuracy of the undirected versions with naive and label-based reconstruction to that of the directed versions of the planar, 2-planar and Covington parsers, respectively.",
        "In addition, we provide a comparison to well-known state-of-the-art projective and non-projective parsers: the planar parsers are compared to the arc-eager projective parser by Nivre (2003), which is also restricted to planar structures; and the 2-planar parsers are compared with the arc-eager parser with pseudo-projective transformation of Nivre and Nilsson (2005), capable of handling non-planar dependencies.",
        "We use SVM classifiers from the LIBSVM package (Chang and Lin, 2001) for all the languages except Chinese, Czech and German.",
        "In these, we use the LIBLINEAR package (Fan et al., 2008) for classification, which reduces training time for these larger datasets; and feature models adapted to this system which, in the case of German, result in higher accuracy than published results using LIBSVM.",
        "The LIBSVM feature models for the arc-eager projective and pseudo-projective parsers are the same used by these parsers in the CoNLL-X shared task, where the pseudo-projective version of MaltParser was one of the two top performing systems (Buchholz and Marsi, 2006).",
        "For the 2 planar parser, we took the feature models from Gómez-Rodríguez and Nivre (2010) for the languages included in that paper.",
        "For all the algorithms and datasets, the feature models used for the undirected parsers were adapted from those of the directed parsers as described in Section 3.1.4 The results show that the use of undirected parsing with label-based reconstruction clearly improves the performance in the vast majority of the datasets for the planar and Covington algorithms, where in many cases it also improves upon the corresponding projective and non-projective state-of-the-art parsers provided for comparison.",
        "In the case of the 2-planar parser the results are less conclusive, with improvements over the directed versions in five out of the eight languages.",
        "The improvements in LAS obtained with label-based reconstruction over directed parsing are statistically significant at the .05 level5 for Danish, German and Portuguese in the case of the planar parser; and Czech, Danish and Turkish for Covington's parser.",
        "No statistically significant decrease in accuracy was detected in any of the algorithm/dataset combinations.",
        "As expected, the good results obtained by the undirected parsers with label-based reconstruction contrast with those obtained by the variants with root-based reconstruction, which performed worse in all the experiments."
      ]
    },
    {
      "heading": "6 Discussion",
      "text": [
        "We have presented novel variants of the planar and 2-planar transition-based parsers by Gómez-Rodríguez and Nivre (2010) and of Covington's non-projective parser (Covington, 2001; Nivre, 2008) which ignore the direction of dependency links, and reconstruction techniques that can be used to recover the direction of the arcs thus produced.",
        "The results obtained show that this idea of undirected parsing, together with the label",
        "based reconstruction technique of Section 4.2, improves parsing accuracy on most of the tested dataset/algorithm combinations, and it can outperform state-of-the-art transition-based parsers.",
        "The accuracy improvements achieved by relaxing the single-head constraint to mitigate error propagation were able to overcome the errors generated in the reconstruction phase, which were few: we observed empirically that the differences between the undirected LAS obtained from the undirected graph before the reconstruction and the final directed LAS are typically below 0.20%.",
        "This is true both for the naive and label-based transformations, indicating that both techniques are able to recover arc directions accurately, and the accuracy differences between them come mainly from the differences in training (e.g. having tentative arc direction as part of feature information in the label-based reconstruction and not in the naive one) rather than from the differences in the reconstruction methods themselves.",
        "The reason why we can apply the undirected simplification to the three parsers that we have used in this paper is that their LEFT-ARC and RIGHT-ARC transitions have the same effect except for the direction of the links they create.",
        "The same transformation and reconstruction techniques could be applied to any other transition-based dependency parsers sharing this property.",
        "The reconstruction techniques alone could potentially be applied to any dependency parser (transition-based or not) as long as it can be somehow converted to output undirected graphs.",
        "The idea of parsing with undirected relations between words has been applied before in the work on Link Grammar (Sleator and Temperley, 1991), but in that case the formalism itself works with undirected graphs, which are the final output of the parser.",
        "To our knowledge, the idea of using an undirected graph as an intermediate step towards obtaining a dependency structure has not been explored before."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "This research has been partially funded by the Spanish Ministry of Economy and Competitiveness and FEDER (projects TIN2010-18552-C03-01 and TIN2010-18552C03-02), Ministry of Education (FPU Grant Program) and Xunta de Galicia (Rede Galega de Recursos Lingu???sticos para unha Soc. do Con?ec.).",
        "The experiments were conducted with the help of computing resources provided by the Supercomputing Center of Galicia (CESGA).",
        "We thank Joakim Nivre for helpful input in the early stages of this work.",
        "postprocessing in comparison to the directed planar (Planar) and the MaltParser arc-eager projective (MaltP) algorithms, on eight datasets from the CoNLL-X shared task (Buchholz and Marsi, 2006): Arabic (Hajic?",
        "et al 2004), Chinese (Chen et al. 2003), Czech (Hajic?",
        "et al 2006), Danish (Kromann, 2003), German (Brants et al., 2002), Portuguese (Afonso et al. 2002), Swedish (Nilsson et al. 2005) and Turkish (Oflazer et al. 2003; Atalay et al. 2003).",
        "We show labelled (LAS) and unlabelled (UAS) attachment score excluding and including punctuation tokens in the scoring (the latter in brackets).",
        "Best results for each language are shown in boldface, and results where the undirected parser outperforms the directed version are marked with an asterisk.",
        "label-based (UCovingtonL) postprocessing in comparison to the directed algorithm (Covington).",
        "The meaning of the scores shown is as in Table 1."
      ]
    }
  ]
}
