{
  "info": {
    "authors": [
      "Liang Huang",
      "Suphan Fayong",
      "Yang Guo"
    ],
    "book": "NAACL",
    "id": "acl-N12-1015",
    "title": "Structured Perceptron with Inexact Search",
    "url": "https://aclweb.org/anthology/N12-1015",
    "year": 2012
  },
  "references": [
    "acl-D08-1059",
    "acl-E06-1011",
    "acl-J93-2004",
    "acl-P04-1015",
    "acl-P06-1096",
    "acl-P07-1096",
    "acl-P08-1067",
    "acl-P10-1110",
    "acl-W02-1001",
    "acl-W96-0213"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Most existing theory of structured prediction assumes exact inference, which is often intractable in many practical problems.",
        "This leads to the routine use of approximate inference such as beam search but there is not much theory behind it.",
        "Based on the structured perceptron, we propose a general framework of ?violation-fixing?",
        "perceptrons for inexact search with a theoretical guarantee for convergence under new separability conditions.",
        "This framework subsumes and justifies the popular heuristic ?early-update?",
        "for perceptron with beam search (Collins and Roark, 2004).",
        "We also propose several new update methods within this framework, among which the ?max-violation?",
        "method dramatically reduces training time (by 3 fold as compared to early-update) on state-of-the-art part-of-speech tagging and incremental parsing systems."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Discriminative structured prediction algorithms such as conditional random fields (Lafferty et al., 2001), structured perceptron (Collins, 2002), max-margin markov networks (Taskar et al., 2003), and structural SVMs (Tsochantaridis et al., 2005) lead to state-of-the-art performance on many structured prediction problems such as part-of-speech tagging, sequence labeling, and parsing.",
        "But despite their success, there remains a major problem: these learning algorithms all assume exact inference (over an exponentially-large search space), which is needed to ensure their theoretical properties such as convergence.",
        "This exactness assumption, however, rarely holds in practice since exact inference is often intractable in many important problems such as machine translation (Liang et al., 2006), incremental parsing (Collins and Roark, 2004; Huang and Sagae, 2010), and bottom-up parsing (McDonald and Pereira, 2006; Huang, 2008).",
        "This leads to routine use of approximate inference such as beam search as evidenced in the above-cited papers, but the inexactness unfortunately abandons existing theoretical guarantees of the learning algorithms, and besides notable exceptions discussed below and in Section 7, little is known for theoretical properties of structured prediction under inexact search.",
        "Among these notable exceptions, many examine how and which approximations break theoretical guarantees of existing learning algorithms (Kulesza and Pereira, 2007; Finley and Joachims, 2008), but we ask a deeper and practically more useful question: can we modify existing learning algorithms to accommodate the inexactness in inference, so that the theoretical properties are still maintained?",
        "For the structured perceptron, Collins and Roark (2004) provides a partial answer: they suggest variant called ?early update?",
        "for beam search, which updates on partial hypotheses when the correct solution falls out of the beam.",
        "This method works significantly better than standard perceptron, and is followed by later incremental parsers, for instance in (Zhang and Clark, 2008; Huang and Sagae, 2010).",
        "However, two problems remain: first, up till now there has been no theoretical justification for early update; and secondly, it makes learning extremely slow as witnessed by the above-cited papers because it only learns on partial examples and often requires 15?40 iterations to converge while normal perceptron converges in 5?10 iterations (Collins, 2002).",
        "We develop a theoretical framework of ?violation-fixing?",
        "perceptron that addresses these challenges.",
        "In particular, we make the following contributions: ?",
        "We show that, somewhat surprisingly, exact",
        "search is not required by perceptron convergence.",
        "All we need is that each update involves a ?violation?, i.e., the 1-best sequence has a higher model score than the correct sequence.",
        "Such an update is considered a ?valid update?, and any perceptron variant that maintains this is bound to converge.",
        "We call these variants ?violation-fixing perceptrons?",
        "(Section 3.1).",
        "?",
        "This theory explains why standard perceptron update may fail to work with inexact search, because violation is no longer guaranteed: the correct structure might indeed be preferred by the model, but was pruned during the search process (Sec.",
        "3.2).",
        "Such an update is thus considered invalid, and experiments show that invalid updates lead to bad learning (Sec.",
        "6.2).",
        "?",
        "We show that the early update is always valid and is thus a special case in our framework; this is the first theoretical justification for early update (Section 4).",
        "We also show that (a variant of) LaSO (Daume?",
        "and Marcu, 2005) is another special case (Section 7).",
        "?",
        "We then propose several other update methods within this framework (Section 5).",
        "Experiments in Section 6 confirm that among them, the max-violation method can learn equal or better models with dramatically reduced learning times (by 3 fold as compared to early update) on state-of-the-art part-of-speech tagging (Collins, 2002)1 and incremental parsing (Huang and Sagae, 2010) systems.",
        "We also found strong correlation between search error and invalid updates, suggesting that the advantage of valid update methods is more pronounced with harder inference problems.",
        "Our techniques are widely applicable to other str-cutured prediction problems which require inexact search like machine translation and protein folding."
      ]
    },
    {
      "heading": "2 Structured Perceptron",
      "text": [
        "We review the convergence properties of the standard structured perceptron (Collins, 2002) in our 1Incidentally, we achieve the best POS tagging accuracy to date (97.35%) on English Treebank by early update (Sec.",
        "6.1).",
        "Algorithm 1 Structured Perceptron (Collins, 2002).",
        "Input: data D = {(x(t), y(t))}nt=1 and feature map ?",
        "Output: weight vector w Let: EXACT(x,w) ?= argmaxs?Y(x) w ??",
        "(x, s) Let: ??",
        "(x, y, z) ?= ?",
        "(x, y)??",
        "(x, z)",
        "1: repeat 2: for each example (x, y) in D do 3: z ?",
        "EXACT(x,w) 4: if z 6= y then 5: w?",
        "w + ??",
        "(x, y, z) 6: until converged",
        "own notations that will be reused in later sections for non-exact search.",
        "We first define a new concept: Definition 1.",
        "The standard confusion set Cs(D) for training data D = {(x(t), y(t))}nt=1 is the set of triples (x, y, z) where z is a wrong label for input x: Cs(D) ?= {(x, y, z) |(x, y) ?",
        "D, z ?",
        "Y(x)?",
        "{y}}.",
        "The rest of the theory, including separation and violation, all builds upon this concept.",
        "We call such a triple S = ?D,?, C?",
        "a training scenario, and in the remainder of this section, we assume C = Cs(D), though later we will define other confusion sets to accommodate other update methods.",
        "Intuitively, this means model w is possible to mislabel example x (though not necessarily to z) since y is not its single highest scoring label under w. Lemma 1.",
        "Each update triple (x, y, z) in Algorithm 1 (line 5) is a violation in S = ?D,?, Cs(D)?.",
        "This lemma basically says exact search guarantees violation in each update, but as we will see in the convergence proof, violation itself is more fundamental than search exactness.",
        "Definition 4.",
        "The diameter R(S) for scenario S = ?D,?, C?",
        "is max(x,y,z)?C???",
        "(x, y, z)?.",
        "Theorem 1 (convergence, Collins).",
        "For a separable training scenario S = ?D,?, Cs(D)?",
        "with ?",
        "(S) > 0, the perceptron algorithm in Algorithm 1 will make finite number of updates (before convergence): err(S) ?",
        "R2(S)/?2(S).",
        "Proof.",
        "Let w(k) be the weight vector before the kth update; w(0) = 0.",
        "Suppose the kth update happens on the triple (x, y, z).",
        "We will bound ?w(k+1)?",
        "from",
        "two directions: 1. w(k+1) = w(k) + ??",
        "(x, y, z).",
        "Since scenario S is separable with max margin ?",
        "(S), there exists a unit oracle vector u that achieves this margin.",
        "Dot product both sides with u, we have u ?w(k+1) = u ?w(k) + u ???",
        "(x, y, z) ?",
        "u ?w(k) + ?",
        "(S) by Lemma 1 that (x, y, z) ?",
        "Cs(D) and by the definition of margin.",
        "By induction, we have u ?",
        "w(k+1) ?",
        "k?(S).",
        "Since for any two vectors a and b we have ?a??b?",
        "?",
        "a ?",
        "b, thus ?u??w(k+1)?",
        "?",
        "u ?w(k+1) ?",
        "k?(S).",
        "As u is a unit vector, we have ?w(k+1)?",
        "?",
        "k?(S).",
        "2.",
        "On the other hand, since ?a + b?2 = ?a?2 + ?b?2 +2 a ?b for any vectors a and b,we have",
        "By Lemma 1, the update triple is a violation so that w(k) ???",
        "(x, y, z) ?",
        "0, and that (x, y, z) ?",
        "Cs(D) thus ???",
        "(x, y, z)?2 ?",
        "R2(S) by the definition of diameter.",
        "By induction, we have ?w(k+1)?2 ?",
        "kR2(S).",
        "Algorithm 2 Local Violation-Fixing Perceptron.",
        "Input: training scenario S = ?D,?, C?",
        "1: repeat 2: for each example (x, y) in D do 3: (x, y?, z) = FINDVIOLATION(x, y,w) 4: if z 6= y then ?",
        "(x, y?, z) is a violation 5: w?",
        "w + ??",
        "(x, y?, z) 6: until converged Combining the two bounds, we have k2?2(S) ?",
        "?w(k+1)?2 ?",
        "kR2(S), thus k ?",
        "R2(S)/?2(S).",
        "3 Violation is All We Need",
        "We now draw the central observation of this work from part 2 of the above proof: note that exact search (argmax) is not required in the proof, instead, it just needs a violation, which is a much weaker condition.2 Exact search is simply used to ensure violation.",
        "In other words, if we can guarantee violation in each update (which we call ?valid update?",
        "), it does not matter whether or how exact the search is."
      ]
    },
    {
      "heading": "3.1 Violation-Fixing Perceptron",
      "text": [
        "This observation leads us to two generalized variants of perceptron which we call ?violation-fixing perceptrons?.",
        "The local version, Algorithm 2 still works on one example at a time, and searches for one violation (if any) in that example to update with.",
        "The global version, Algorithm 3, can update on any violation in the dataset at any time.",
        "We state the following generalized theorem: Theorem 2.",
        "For a separable training scenario S the perceptrons in Algorithms 2 and 3 both converge with the same update bounds of R2(S)/?2(S) as long as the FINDVIOLATION and FINDVIO-LATIONINDATA functions always return violation triples if there are any.",
        "Proof.",
        "Same as the proof to Theorem 1, except for replacing Lemma 1 in part 2 by the fact that the update triples are guaranteed to be violations.",
        "(Note a violation triple is by definition in the confusion set, thus we can still use separation and diameter).",
        "These generic violation-fixing perceptron algorithms can been seen as ?interfaces?",
        "(or APIs), 2Crammer and Singer (2003) further demonstrates that a convex combination of violations can also be used for update.",
        "1: repeat 2: (x, y, z)?",
        "FINDVIOLATIONINDATA(C,w) 3: if x = ?",
        "then break ?",
        "no more violation?",
        "4: w?",
        "w + ??",
        "(x, y, z) 5: until converged",
        "(e.g. u = (1, 2) can separate D with exact search).",
        "where later sections will supply different implementations of the FINDVIOLATION and FINDVIOLATIONINDATA subroutines, thus establishing alternative update methods for inexact search as special cases in this general framework."
      ]
    },
    {
      "heading": "3.2 Non-Convergence with Inexact Search",
      "text": [
        "What if we can not guarantee valid updates?",
        "Well, the convergence proof in Theorems 1 and 2 would break in part 2.",
        "This is exactly why standard structured perceptron may not work well with inexact search: with search errors it is no longer possible to guarantee violation in each update.",
        "For example, an inexact search method explores a (proper) subset of the search space Y ?w(x) ( Y(x), and finds a label",
        "?",
        "best one-step extension based on history 1: function GREEDYSEARCH(x,w) 2: z ?",
        "?",
        "?",
        "empty sequence 3: for i ?",
        "1 .",
        ".",
        ".",
        "|x |do 4: z ?",
        "BEST(x, z,w) 5: return z",
        "Theorem 3.",
        "For a separable training scenario S = ?D,?, Cs(D)?, if the argmax in Algorithm 1 is not exact, the perceptron might not converge.",
        "Proof.",
        "See the example in Figure 1.",
        "This situation happens very often in NLP: often the search space Y(x) is too big either because it does not factor locally, or because it is still too big after factorization, which requires some approximate search.",
        "In either case, updating the model w on a non-violation (i.e., ?invalid?)",
        "triple (x, y, z) does not make sense: it is not the model's problem: w does score the correct label y higher than the incorrect z; rather, it is a problem of the search, or its interaction with the model that prunes away the correct (sub)sequence during the search.",
        "What shall we do in this case?",
        "Collins and Roark (2004) suggest that instead of the standard full update, we should only update on the prefix (x, y[1:i], z[1:i]) up to the point i where the correct sequence falls off the beam.",
        "This intuitively makes a lot of sense, since up to i we can still guarantee violation, but after i we may not.",
        "The next section formalizes this intuition.",
        "4 Early Update is Violation-Fixing We now proceed to show that early update is always valid and it is thus a special case of the violation-fixing perceptron framework.",
        "First, let us study the simplest special case, greedy search (beam=1)."
      ]
    },
    {
      "heading": "4.1 Greedy Search and Early Update",
      "text": [
        "Greedy search is the simplest form of inexact search.",
        "Shown in Algorithm 4, at each position, we commit to the single best action (e.g., tag for the current word) given the previous actions and continue to the",
        "1: repeat 2: for each example (x, y) in D do 3: z ?",
        "?",
        "?",
        "empty sequence 4: for i ?",
        "1 .",
        ".",
        ".",
        "|x |do 5: z ?",
        "BEST(x, z,w) 6: if zi 6= yi then ?",
        "first wrong action 7: w?",
        "w + ??",
        "(x, y[1:i], z) ?",
        "early update 8: break ?",
        "skip the rest of this example 9: until converged next position.",
        "The notation Yi(x) denotes the set of",
        "possible actions at position i for example x (for instance, the set of possible tags for a word).",
        "The early update heuristic, originally proposed for beam search (Collins and Roark, 2004), now simplifies into ?update at the first wrong action?, since this is exactly the place where the correct sequence falls off the singleton beam (see Algorithm 5 for pseu-docode and Fig. 2).",
        "Informally, it is easy to show (below) that this kind of update is always a valid violation, but we need to redefine confusion set.",
        "Definition 5.",
        "The greedy confusion set Cg(D) for training data D = {(x(t), y(t))}nt=1 is the set of triples (x, y[1:i], z[1:i]) where y[1:i] is a i-prefix of the correct label y, and z[1:i] is an incorrect i-prefix that agrees with the correct prefix on all decisions except the last one:",
        "We can see intuitively that this new defintion is specially tailored to the early updates in greedy search.",
        "The concepts of separation/margin, violation, and diameter all change accordingly with this new confusion set.",
        "In particular, we say that a dataset D is greedily separable in representation",
        "?",
        "if and only if ?D,?, Cg(D)?",
        "is linearly separable, and we say (x, y?, z?)",
        "is a greedy violation if (x, y?, z?)",
        "?",
        "Cg(D) and w ???",
        "(x, y?, z?)",
        "?",
        "0.",
        "Algorithm 6 Alternative presentation of Alg.",
        "5 as a Local Violation-Fixing Perceptron (Alg.",
        "2).",
        "1: function FINDVIOLATION(x, y,w) 2: z ?",
        "?",
        "?",
        "empty sequence 3: for i ?",
        "1 .",
        ".",
        ".",
        "|x |do 4: z ?",
        "BEST(x, z,w) 5: if zi 6= yi then ?",
        "first wrong action 6: return (x, y[1:i], z) ?",
        "return for early update 7: return (x, y, y) ?",
        "success (z = y), no violation",
        "We now express early update for greedy search (Algorithm 5) in terms of violation-fixing perceptron.",
        "Algorithm 6 implements the FINDVIOLATION function for the generic Local Violation-Fixing Perceptron in Algorithm 2.",
        "Thus Algorithm 5 is equivalent to Algorithm 6 plugged into Algorithm 2.",
        "Lemma 2.",
        "Each triple (x, y[1:i], z) returned at line 6 in Algorithm 6 is a greedy violation.",
        "Proof.",
        "Let y?",
        "= y[1:i].",
        "Clearly at line 6, |y?",
        "|= i = |z |and y?i 6= zi.",
        "But y?j = zj for all j < i otherwise it would have returned before position i, so (x, y?, z) ?",
        "Cg(D).",
        "Also z = BEST(x, z,w), so w ??",
        "(x, z) ?",
        "w ??",
        "(x, y?",
        "), thus w ???",
        "(x, y?, z) ?",
        "0.",
        "Theorem 4 (convergence of greedy search with early update).",
        "For a separable training scenario S = ?D,?, Cg(D)?, the early update perceptron by plugging Algorithm 6 into Algorithm 2 will make finite number of updates (before convergence): err(S) < R2(S)/?2(S).",
        "Proof.",
        "By Lemma 2 and Theorem 2."
      ]
    },
    {
      "heading": "4.2 Beam Search and Early Update",
      "text": [
        "To formalize beam search, we need some notations: Definition 6 (k-best).",
        "We denote argtopkz?Z f(z) to return (a sorted list of) the top k unique z in terms of f(z), i.e., it returns a list B = [z(1), z(2), .",
        ".",
        ".",
        ", z(k)] where z(i) ?",
        "Z and f(z(1)) ?",
        "f(z(2)) ?",
        ".",
        ".",
        ".",
        "?",
        "f(z(k)) ?",
        "f(z?)",
        "for all z?",
        "?",
        "Z ?",
        "B.",
        "By unique we mean that no two elements are equivalent with respect to some equivalence relation, i.e., z(i) ?",
        "z(j) ?",
        "i = j.",
        "This equivalence relation is useful for dynamic programming (when used with beam search).",
        "For example, in trigram tagging, two tag sequences are equivalent if they are of the",
        "?",
        "top k (unique) extensions from the beam 1: function BEAMSEARCH(x,w, k) ?",
        "k is beam width 2: B0 ?",
        "[?]",
        "?",
        "initial beam 3: for i ?",
        "1 .",
        ".",
        ".",
        "|x |do 4: Bi ?",
        "BESTk(x,Bi?1,w) 5: return B|x|[0] ?",
        "best sequence in the final beam Algorithm 8 Early update for beam search (Collins and Roark 04) as Local Violation-Fixing Perceptron.",
        "1: function FINDVIOLATION(x, y,w) 2: B0 ?",
        "[?]",
        "3: for i ?",
        "1 .",
        ".",
        ".",
        "|x |do 4: Bi ?",
        "BESTk(x,Bi?1,w) 5: if y[1:i] /?",
        "Bi then ?",
        "correct seq.",
        "falls off beam 6: return (x, y[1:i],Bi[0]) ?",
        "update on prefix 7: return (x, y,B|x|[0]) ?",
        "full update if wrong final same length and if they agree on the last two tags,",
        "i.e. z ?",
        "z?",
        "iff.",
        "|z |= |z?",
        "|and z|z|?1:|z |= z?|z|?1:|z|.",
        "In incremental parsing this equivalence relation could be relevant bits of information on the last few trees on the stack (depending on feature templates), as suggested in (Huang and Sagae, 2010).",
        "3 Algorithm 7 shows the pseudocode for beam search.",
        "It is trivial to verify that greedy search is a special case of beam search with k = 1.",
        "However, the definition of confusion set changes considerably: Definition 7.",
        "The beam confusion set Cb(D) for training data D = {(x(t), y(t))}nt=1 is the set of triples (x, y[1:i], z[1:i]) where y[1:i] is a i-prefix of the correct label y, and z[1:i] is an incorrect i-prefix that differs from the correct prefix (in at least one place):",
        "Similarly, we say that a dataset D is beam separable in representation ?",
        "if and only if 3Note that when checking whether the correct sequence falls off the beam (line 5), we could either store the whole (sub)sequence for each candidate in the beam (which is what we do for non-DP anyway), or check if the equivalence class of the correct sequence is in the beam, i.e. Jy[1:i]K?",
        "?",
        "Bi, and if its backpointer points to Jy[1:i?1]K?.",
        "For example, in trigram tagging, we just check if ?yi?1, yi?",
        "?",
        "Bi and if its backpointer points to ?yi?2, yi?1?.",
        "best in the beam worst in the beam",
        "case when standard update is invalid (shown in red).",
        "The rectangle denotes the beam and the blue line segments denote the trajectory of the correct sequence.",
        "?D,?, Cb(D)?",
        "is linearly separable, and we say (x, y?, z?)",
        "is a beam violation if (x, y?, z?)",
        "?",
        "Cb(D) and w ???",
        "(x, y?, z?)",
        "?",
        "0.",
        "It is easy to verify that beam confusion set is superset of both greedy and standard confusion sets: for all dataset D, Cg(D) ( Cb(D), and Cs(D) ( Cb(D).",
        "This means that beam separability is the strongest condition among the three separabilities: Theorem 5.",
        "If a dataset D is beam separable, then it is also greedily and (standard) linear separable.",
        "We now present early update for beam search as a Local Violation Fixing Perceptron in Algorithm 8.",
        "See Figure 3 for an illustration.",
        "Lemma 3.",
        "Each update (lines 6 or 7 in Algorithm 8) involves a beam violation.",
        "Proof.",
        "Case 1: early update (line 6): Let z?",
        "= Bi[0] and y?",
        "= y[1:i].",
        "Case 2: full update (line 8): Let z?",
        "= B|x|[0] and y?",
        "= y.",
        "In both cases we have z?",
        "6= y?",
        "and |z?",
        "|= |y?|, thus (x, y?, z?)",
        "?",
        "Cb(D).",
        "Also we have w ?",
        "?",
        "(x, z?)",
        "?",
        "w ?",
        "?",
        "(x, y?)",
        "by defintion of argtop, so w ???",
        "(x, y?, z?)",
        "?",
        "0.",
        "Theorem 6 (convergence of beam search with early update).",
        "For a separable training scenario S = ?D,?, Cb(D)?, the early update perceptron by plugging Algorithm 8 into Algorithm 2 will make finite number of updates (before convergence): err(S) < R2(S)/?2(S).",
        "Proof.",
        "By Lemma 3 and Theorem 2."
      ]
    },
    {
      "heading": "5 New Update Methods for Inexact Search",
      "text": [
        "We now propose three novel update methods for inexact search within the framework of violation-fixing perceptron.",
        "These methods are inspired by early update but addresses its very limitation of slow learning.",
        "See Figure 3 for an illustration.",
        "1.",
        "?hybrid?",
        "update.",
        "When the standard update is valid (i.e., a violation), we perform it, otherwise we perform the early update.",
        "2.",
        "?max-violation?",
        "update.",
        "While there are",
        "more than one possible violations on one example x, we choose the triple that is most violated:",
        "3.",
        "?latest?",
        "update.",
        "Contrary to early update, we can also choose the latest point where the update is still a violation:",
        "All these three methods go beyond early update but can be represented in the Local Violation Fixing Perceptron (Algorithm 2), and are thus all guaranteed to converge.",
        "As we will see in the experiments, these new methods are motivated to address the major limitation of early update, that is, it learns too slowly since it only updates on prefixes and neglect the rest of the examples.",
        "Hybrid update is trying to do as much standard (?full?)",
        "updates as possible, and latest update further addresses the case when standard update is invalid: instead of backing-off to early update, it uses the longest possible update."
      ]
    },
    {
      "heading": "6 Experiments",
      "text": [
        "We conduct experiments on two typical structured learning tasks: part-of-speech tagging with a trigram model where exact search is possible, and incremental dependency parsing with arbitrary non-local features where exact search is intractable.",
        "We run both experiments on state-of-the-art implementations."
      ]
    },
    {
      "heading": "6.1 Part-of-Speech Tagging",
      "text": [
        "Following the standard split for part-of-speech tagging introduced by Collins (2002), we use sections 00?18 of the Penn Treebank (Marcus et al.,",
        "general, max-violation converges faster and better than early and standard updates, esp.",
        "in smallest beams.",
        "1993) for training, sections 19?21 as a held-out development set, and sections 22?24 for testing.",
        "Our baseline system is a faithful implementation of the perceptron tagger in Collins (2002), i.e., a trigram model with spelling features from Ratnaparkhi (1996), except that we replace one-count words as <unk>.",
        "With standard perceptron and exact search, our baseline system performs slightly better than Collins (2002) with a beam of 20 (M. Collins, p.c.).",
        "We then implemented beam search on top of dynamic programming and experimented with standard, early, hybrid, and max-violation update methods with various beam settings (b = 1, 2, 4, 7, 10).",
        "Figure 4(a) summarizes these experiments.",
        "We observe that, first of all, the standard update performs poorly with the smallest beams, esp.",
        "at b = 1 (greedy search), when search error is the most severe causing lots of invalid updates (see Figure 5).",
        "Secondly,max-violation is almost consistently the best-performing method (except for b = 4).",
        "Table 1 shows convergence rates, where max-violation update also converges faster than early and standard methods.",
        "In particular, at b = 1, it achieves a 19% error reduction over standard update, while converg",
        "converges to ?",
        "50%.",
        "This means search-wise, parsing is much harder than tagging, which explains why standard update does OK in tagging but terribly in parsing.",
        "The harder the search is, the more needed valid updates are.",
        "ing twice as fast as early update.4 This agrees with our intuition that by choosing the ?most-violated?",
        "triple for update, the perceptron should learn faster.",
        "Table 2 presents the final tagging results on the test set.",
        "For each of the five update methods, we choose the beam size at which it achieves the highest accuracy on the held-out.",
        "For standard update, its best held-out accuracy 97.17 is indeed achieved by exact search (i.e., b = +?)",
        "since it does not work well with beam search, but it costs 2.7 hours (162 minutes) to train.",
        "By contrast, the four valid update methods handle beam search better.",
        "The max-violation method achieves its highest held-out/test accuracies of 97.20 / 97.33 with a beam size of only 2, and only 26 minutes to train.",
        "Early update achieves the highest held-out/test accuracies of 97.22 / 97.35 across all update methods at the beam size of 4.",
        "This test accuracy is even better than Shen 4for tagging (but not parsing) the difference in per-iteration speed between early update and max-violation update is small.",
        "method b it time dev test early*",
        "ing (b = 8).",
        "Max-violation learns faster and better: it takes 4.6 hours (10 iterations) to reach 92.25 on held-out, compared with early update's 15.4 hours (38 iterations), even though the latter is faster in each iteration due to early stopping (esp.",
        "at the first few iterations).",
        "et al (2007), the best tagging accuracy reported on the Penn Treebank to date.5,6 To conclude, with valid update methods, we can learn a better tagging model with 5 times faster training than exact search."
      ]
    },
    {
      "heading": "6.2 Incremental Parsing",
      "text": [
        "While part-of-speech tagging is mainly a proof of concept, incremental parsing is much harder since non-local features rules out exact inference.",
        "We use the standard split for parsing: secs 02?",
        "21 for training, 22 as held-out, and 23 for testing.",
        "Our baseline system is a faithful reimplementation of the beam-search dynamic programming parser of Huang and Sagae (2010).",
        "Like most incremental parsers, it used early update as search error is severe.",
        "up to 5-gram which go beyond our local trigram window.",
        "We suspect that adding genuinely non-local features would demonstrate even better the advantages of valid update methods with beam search, since exact inference will no longer be tractable.",
        "We first confirm that, as reported by Huang and Sagae, early update learns very slowly, reaching 92.24 on held-out with 38 iterations (15.4 hours).",
        "We then experimented with the other update methods: standard, hybrid, latest, and max-violation, with beam size b = 1, 2, 4, 8.",
        "We found that, first of all, the standard update performs horribly on this task: at b = 1 it only achieves 60.04% on held-out, while at b = 8 it improves to 78.99% but is still vastly below all other methods.",
        "This is because search error is much more severe in incremental parsing (than in part-of-speech tagging), thus standard update produces an enormous amount of invalid updates even at b = 8 (see Figure 5).",
        "This suggests that the advantage of valid update methods is more pronounced with tougher search problems.",
        "Secondly, max-violation learns much faster (and better) than early update: it takes only 10 iterations (4.6 hours) to reach 92.25, compared with early update's 15.4 hours (see Fig. 6).",
        "At its peak, max-violation achieves 92.18 on test which is better than (Huang and Sagae, 2010).",
        "To conclude, we can train a parser with only 1/3 of training time with max-violation update, and the harder the search is, the more needed the valid update methods are."
      ]
    },
    {
      "heading": "7 Related Work and Discussions",
      "text": [
        "Besides the early update method of Collins and Roark (2004) which inspired us, this work is also related to the LaSO method of Daume?",
        "and Marcu (2005).",
        "LaSO is similar to early update, except that after each update, instead of skipping the rest of the example, LaSO continues on the same example with the correct hypothesis.",
        "For example, in the greedy case LaSO is just replacing the break statement in Algorithm 5 by 8?",
        ": zi = yi and in beam search it is replacing it with 8?",
        ": Bi = [y[1:i]].",
        "This is beyond our Local Violation-Fixing Perceptron since it makes more than one updates on one example, but can be easily represented as a Global Violation-Fixing Perceptron (Algorithm 3), since we can prove any further updates on this example is a violation (under the new weights).",
        "We thus establish LaSO as a special case within our framework.7 More interestingly, it is easy to verify that the greedy case of LaSO update is equivalent to training a local unstructured perceptron which independently classifies at each position based on history, which is related to SEARN (Daume?",
        "et al, 2009).",
        "Kulesza and Pereira (2007) study perceptron learning with approximate inference that overgen-erates instead of undergenerates as in our work, but the underlying idea is similar: by learning in a harder setting (LP-relaxed version in their case and prefix-augmented version in our case) we can learn the simpler original setting.",
        "Our ?beam separability?",
        "can be viewed as an instance of their ?algorithmic separability?.",
        "Finley and Joachims (2008) study similar approximate inference for structural SVMs.",
        "Our max-violation update is also related to other training methods for large-margin structured prediction, in particular the cutting-plane (Joachims et al., 2009) and subgradient (Ratliff et al., 2007) methods, but detailed exploration is left to future work."
      ]
    },
    {
      "heading": "8 Conclusions",
      "text": [
        "We have presented a unifying framework of ?violation-fixing?",
        "perceptron which guarantees convergence with inexact search.",
        "This theory satisfingly explained why standard perceptron might not work well with inexact search, and why the early update works.",
        "We also proposed some new variants within this framework, among which the max-violation method performs the best on state-of-the-art tagging and parsing systems, leading to better models with greatly reduced training times.",
        "Lastly, the advantage of valid update methods is more pronounced when search error is severe."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "We are grateful to the four anonymous reviewers, especially the one who wrote the comprehensive re"
      ]
    }
  ]
}
