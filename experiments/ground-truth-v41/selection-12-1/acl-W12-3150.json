{
  "info": {
    "authors": [
      "Philip Williams",
      "Philipp Koehn"
    ],
    "book": "Proceedings of the Seventh Workshop on Statistical Machine Translation",
    "id": "acl-W12-3150",
    "title": "GHKM Rule Extraction and Scope-3 Parsing in Moses",
    "url": "https://aclweb.org/anthology/W12-3150",
    "year": 2012
  },
  "references": [
    "acl-D07-1079",
    "acl-D10-1063",
    "acl-J03-1002",
    "acl-J07-2003",
    "acl-N04-1035",
    "acl-N06-1033",
    "acl-P03-1021",
    "acl-P05-1033",
    "acl-P06-1121",
    "acl-P07-2045",
    "acl-P10-1146",
    "acl-P11-2031",
    "acl-P11-2072",
    "acl-W06-1606",
    "acl-W06-3119",
    "acl-W08-0509",
    "acl-W10-1715"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We developed a string-to-tree system for English?German, achieving competitive results against a hierarchical model baseline.",
        "We provide details of our implementation of GHKM rule extraction and scope-3 parsing in the Moses toolkit.",
        "We compare systems trained on the same data using different grammar extraction methods."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Over the last few years, syntax-based rule extraction has largely developed along two lines, one originating in hierarchical phrase-based translation (Chiang, 2005; Chiang, 2007) and the other in GHKM (Galley et al., 2004; Galley et al., 2006).",
        "Hierarchical rule extraction generalizes the established phrase-based extraction method to produce formally-syntactic synchronous context-free grammar rules without any requirement for linguistic annotation of the training data.",
        "In subsequent work, the approach has been extended to incorporate linguistic annotation on the target side (as in SAMT (Zollmann and Venugopal, 2006)) or on both sides (Chiang, 2010).",
        "In contrast, GHKM places target-side syntactic structure at the heart of the rule extraction process, producing extended tree transducer rules that map between strings and tree fragments.",
        "Ultimately, both methods define rules according to a sentence pair's word-alignments.",
        "Without any restriction on rule size they will produce an exponentially large set of rules and so in practice only a subgrammar can be extracted.",
        "It is the differing rule selection heuristics that distinguish these two approaches, with hierarchical approaches being motivated by phrasal coverage and GHKM by target-side tree coverage.",
        "The Moses toolkit (Koehn et al., 2007) has included support for hierarchical phrase-based rule extraction since the decoder was first extended to support syntax-based translation (Hoang et al., 2009).",
        "In this paper we provide some implementation details for the recently-added GHKM rule extractor and for the related scope-3 decoding algorithm.",
        "We then describe the University of Edinburgh's GHKM-based English-German submission to the WMT translation task and present comparisons with hierarchical systems trained on the same data.",
        "To our knowledge, these are the first GHKM results presented for English-German, a language pair with a high degree of reordering and rich target-side morphology."
      ]
    },
    {
      "heading": "2 GHKM Rule Extraction in Moses",
      "text": [
        "A basic GHKM rule extractor was first developed for Moses during the fourth Machine Translation Marathon1 in 2010.",
        "We have recently extended it to support several key features that are described in the literature, namely: composition of rules (Galley et al., 2006), attachment of unaligned source words (Galley et al., 2004), and elimination of fully non-lexical unary rules (Chung et al., 2011).",
        "We provide some basic implementation details in the remainder of this section.",
        "In section 4 we present",
        "experimental results comparing performance against Moses?",
        "alternative rule extraction methods."
      ]
    },
    {
      "heading": "2.1 Composed Rules",
      "text": [
        "Composition of minimal GHKM rules into larger, contextually-richer rules has been found to significantly improve translation quality (Galley et al., 2006).",
        "Allowing any combination of adjacent minimal rules without restriction is unfeasible and so in practice various constraints are imposed on composition.",
        "Our implementation includes three configurable parameters for this purpose, which we describe with reference to the example alignment graph shown in Figure 1.",
        "All three are defined in terms of the target tree fragment.",
        "Rule depth is defined as the maximum distance from the composed rule's root node to any other node within the fragment, not counting preterminal expansions (such as NE ?",
        "Nikitin).",
        "By default, the rule depth is limited to three.",
        "If we consider the composition of rules rooted at the STOP node in Figure 1 then, among many other possibilities, this setting permits the formation of a rule with the target side: STOP ?",
        "das ist der Fall von PN-NK since the maximum distance from the rule's root node to another node is three (to APPR or to PN-NK).",
        "However, a rule with the target side: STOP ?",
        "das ist der Fall von NE Nikitin is not permitted since it has a rule depth of four (from STOP to either of the NE nodes).",
        "Node count is defined as the number of target tree nodes in the composed rule, excluding target words.",
        "The default limit is 15, which for the example is large enough to permit any possible composed rule (the full tree has a node count of 13).",
        "Rule size is the measure defined in De-Neefe et al. (2007): the number of non-part-of-speech, non-leaf constituent labels in the target tree.",
        "The default rule size limit is three."
      ]
    },
    {
      "heading": "2.2 Unaligned Source Words",
      "text": [
        "Unaligned source words are attached to the tree using the following heuristic: if there are aligned source words to both the left and the right of an unaligned source word then it is attached to the lowest common ancestor of its nearest such left and right neighbours.",
        "Otherwise, it is attached to the root of the parse tree."
      ]
    },
    {
      "heading": "2.3 Unary Rule Elimination",
      "text": [
        "Moses?",
        "chart decoder does not currently support the use of grammars containing fully non-lexical unary rules (such as NP ?",
        "X1 |NN1).",
        "Unless the --AllowUnary option is given, the rule extractor eliminates these rules using the method described in Chung et al. (2011)."
      ]
    },
    {
      "heading": "2.4 Scope Pruning",
      "text": [
        "Unlike hierarchical phrase-based rule extraction, GHKM places no restriction on the rank of the resulting rules.",
        "In order that the grammar can be parsed efficiently, one of two approaches is usually taken: (i) synchronous binarization (Zhang et al., 2006), which transforms the original grammar to a weakly equivalent form in which no rule has rank greater than two.",
        "This makes the grammar amenable to decoding with a standard chart-parsing algorithm such as CYK, and (ii) scope pruning (Hopkins and Langmead, 2010), which eliminates rules in order to produce a subgrammar that can be parsed in cubic time.",
        "Of these two approaches, Moses currently supports only the latter.",
        "Both rule extractors prune the extracted grammar to remove rules with scope greater than three.",
        "The next section describes the parsing algorithm that is used for scope-3 grammars."
      ]
    },
    {
      "heading": "3 Scope-3 Parsing in Moses",
      "text": [
        "Hopkins and Langmead (2010) show that a sentence of length n can be parsed using a scope-k grammar in O(nk) chart updates.",
        "In this section, we describe some details of Moses?",
        "implementation of their chart parsing method."
      ]
    },
    {
      "heading": "3.1 The Grammar Trie",
      "text": [
        "The grammar is stored in a trie-based data structure.",
        "Each edge is labelled with either a symbol from the source terminal vocabulary or a generic gap symbol, and the trie is constructed such that for any path originating at the root vertex, the sequence of edge labels represents the prefix of a rule's source right-hand-side (RHSs, also referred to as a rule pattern).",
        "Wherever a path corresponds to a complete RHSs, the vertex stores an associative array holding the set of grammar rules that share that RHSs.",
        "The associative array maps a rule's sequence of target non-terminal symbols to the subset of grammar rules that share those symbols.",
        "Figure 2 shows a sample of the grammar rules that can be extracted from the example alignment graph of Figure 1, and Figure 3 shows the corresponding grammar trie."
      ]
    },
    {
      "heading": "3.2 Initialization",
      "text": [
        "The first step is to construct a secondary trie that records all possible applications of rule patterns from the grammar to the sentence under consideration.",
        "This trie is built during a single depth-first traversal of the grammar trie in which the terminal edge labels are searched for in the input sentence.",
        "If a matching input word is found then the secondary trie is extended by one vertex for each sentence position at which the word occurs and trie traversal continues along that path.",
        "A search for a gap label always results in a match.",
        "Edges in the secondary trie are labelled with the matching symbol and the position of the word in the input sentence (or a null position for gap labels).",
        "Each vertex in the secondary trie stores a pointer to the corresponding grammar trie vertex.",
        "Once the secondary trie has been built, it is easy to determine the set of subspans to which each rule pattern applies.",
        "A set of pairs is recorded against each subspan, each pair holding a pointer to a grammar trie vertex and a record of the sentence positions covered by the symbols (which will be ambiguous if the pattern contains a sequence of k > 1 adjacent gap symbols covering more than k sentence positions).",
        "After this initialization step, the secondary trie is discarded."
      ]
    },
    {
      "heading": "3.3 Subspan Processing",
      "text": [
        "The parsing algorithm proceeds by processing chart cells in order of increasing span width (i.e. bottom-up).",
        "At each cell, a stack lattice is constructed for each rule pattern that was found during initialization.",
        "The stack lattice compactly represents all possible applications of that pattern over the span, together with pointers to the underlying hypothesis stacks for every gap.",
        "A full path through the lattice corresponds to a single application context.",
        "By selecting a derivation class (i.e. target-side non-terminal label) at each arc, the path can be bound to a set of grammar rules that differ only in the choice of target words or LHS label.",
        "Recall that for every rule pattern found during initialization, the corresponding grammar trie vertex was recorded and that the vertex holds an associative array in which the keys are sequences of target-side non-terminal labels and the mapped values are grammar rules (together with associated feature model scores).",
        "The algorithm now loops over the associated array's key sequences, searching the lattice for matching paths.",
        "Where found, the grammar rule is bound with a sequence of underlying stack pointers.",
        "The cell's stacks are then populated by applying cube pruning (Chiang, 2007) to the set of bound grammar rules."
      ]
    },
    {
      "heading": "4 Experiments",
      "text": [
        "This section describes the GHKM-based English-German system submitted by the University of Edinburgh.",
        "Subsequent to submission, a further set of comparative experiments were run using a hierarchical phrase-based system and a hierarchical system with target side syntactic annotation."
      ]
    },
    {
      "heading": "4.1 Data",
      "text": [
        "We made use of all available English-German European and News Commentary data.",
        "For the hierarchical phrase-based experiments, this totalled",
        "1.",
        "NP-PD ?",
        "the case of Alexander Nikitin |der Fall von Alexander Nikitin 2.",
        "NP-PD ?",
        "the case X1 |der Fall PP-MNR1 3.",
        "NP-PD ?",
        "X1 case X2 |ART1 Fall PP-MNR2 4.",
        "PP-MNR ?",
        "of X1 |von PN-NK1 5.",
        "PP-MNR ?",
        "of X1 X2 |von NE1 NE2",
        "associative array values.",
        "2,043,914 sentence pairs.",
        "For the target syntax experiments, the German-side of the parallel corpus was parsed using the BitPar2 parser.",
        "If a parse failed then the sentence pair was discarded, leaving a total of 2,028,556 pairs.",
        "The parallel corpus was then word-aligned using MGIZA++ (Gao and Vogel, 2008), a multi-threaded implementation of GIZA++ (Och and Ney, 2003).",
        "We used all available monolingual German data to train seven 5-gram language models (one each for Europarl, News Commentary, and the five News data sets).",
        "These were interpolated using weights optimised against the development set and the resulting language model was used in experiments.",
        "We used the SRILM toolkit (Stolcke, 2002) with Kneser-Ney smoothing (Chen and Goodman, 1998).",
        "The baseline system's feature weights were tuned on the news-test2008 dev set (2,051 sentence pairs) using Moses?",
        "implementation of minimum error rate training (Och, 2003)."
      ]
    },
    {
      "heading": "4.2 Rule Extraction",
      "text": [
        "For the hierarchical phrase-based model we used the default Moses rule extraction settings, which are taken from Chiang (2007).",
        "For target-annotated models, the syntactic constraints imposed by the parse trees reduce the grammar size significantly.",
        "This allows us to relax the rule extraction settings, which we have previously found to benefit translation quality, without producing an unusably large grammar.",
        "We use identical settings to those used in WMT's 2010 translation task (Koehn et al., 2010).",
        "Specifically, we relax the hierarchical phrase-based extraction settings in the following ways:",
        "?",
        "Up to seven source-side symbols are allowed.",
        "?",
        "Consecutive source non-terminals are permitted.",
        "?",
        "Single-word lexical phrases are allowed for hierarchical subphrase subtraction.",
        "?",
        "Initial phrases are limited to 15 source words (instead of 10).",
        "By using the scope-3 parser we can also relax the restriction on grammar rank.",
        "For comparison, we extract two target-annotated grammars, one with a maximum rank of two, and one with an unlimited rank but subject to scope-3 pruning.",
        "GHKM rule extraction uses the default settings3 as described in section 2.",
        "Table 1 shows the sizes of the extracted grammars after filtering for the newstest2011 test set.",
        "Filtering removes any rule in which the source right-hand-side contains a sequence of terminals and gaps that does not appear in any test set sentence."
      ]
    },
    {
      "heading": "4.3 Features",
      "text": [
        "Our feature functions include the n-gram language model probability of the derivation's target yield, its word count, and various scores for the synchronous derivation.",
        "We score grammar rules according to the following functions: ?",
        "p(RHSs|RHSt,LHS), the noisy-channel translation probability.",
        "?",
        "p(LHS,RHSt|RHSs), the direct translation probability.",
        "?",
        "plex (RHSt|RHSs) and plex (RHSs|RHSt), the direct and indirect lexical weights (Koehn et al., 2003).",
        "?",
        "ppcfg(FRAGt), the monolingual PCFG probability of the tree fragment from which the rule was extracted (GHKM and target-annotated systems only).",
        "This is defined as ?ni=1 p(ri), where r1 .",
        ".",
        ".",
        "rn are the constituent CFG rules of the fragment.",
        "The PCFG parameters are estimated from the parse of the target-side training data.",
        "All lexical CFG rules are given the probability 1.",
        "This is similar to the pcfg feature used in Marcu et al. (2006) and is intended to encourage the production of syntactically well-formed derivations.",
        "?",
        "exp(?1/count(r)), a rule rareness penalty.",
        "?",
        "exp(1), a rule penalty.",
        "The main grammar and glue grammars have distinct penalty features."
      ]
    },
    {
      "heading": "4.4 Decoder Settings",
      "text": [
        "For the submitted GHKM system we used a maximum chart span setting of 25.",
        "For the other systems we used settings that matched the rule extraction spans: 10 for hierarchical phrase-based, 15 for target syntax, and unlimited for GHKM.",
        "We used the scope-3 parsing algorithm (enabled using the option -parsing-algorithm 1) for all systems except the hierarchical system, which used the CYK+ algorithm (Chappelier and Rajman, 1998).",
        "For all systems we set the ttable-limit parameter to 50 (increased from the default value of 20).",
        "This setting controls the level of grammar pruning that is performed after loading: only the top scoring translations are retained for a given source RHS."
      ]
    },
    {
      "heading": "4.5 Results",
      "text": [
        "Following the recommendation of Clark et al. (2011), we ran the optimization three times and repeated evaluation with each set of feature weights.",
        "Table 2 presents the averaged single-reference BLEU scores.",
        "To give a rough indication of how much use the systems make of syntactic information for reordering, we also report glue rule statistics taken from the 1-best derivations.",
        "There is a huge variation in decoding time between the systems, much of which can be attributed to the differing chart span limits.",
        "To give a comparison of system performance we selected an 80-sentence subset of newstest2011, randomly choosing ten sentences of length 1-10, ten of length 11-20, and so on.",
        "We decoded the test set four times for each system, discarding the first set of results (to allow for filesystem cache priming) and then averaging the remaining three.",
        "Table 3 shows the total decoding times for each system and the peak virtual memory usage4.",
        "Figure 4 shows a plot of sentence length against decoding time for the two GHKM systems."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We developed a GHKM-based string-to-tree system for English to German, achieving competitive results compared to a hierarchical model baseline.",
        "We extended the Moses toolkit to include a GHKM rule extractor and scope-3 parsing algorithm and provided details of our implementation.",
        "We intend to further improve this system in future work.",
        "submitted system.",
        "Also shown is the average number of rule applications per sentence for the 1-best output of the three test sets, averaged over the three optimization runs."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We would like to thank the anonymous reviewers for their helpful feedback and suggestions.",
        "This work was supported by the EuroMatrixPlus project funded by the European Commission (7th Framework Programme) and made use of the resources provided by the Edinburgh Compute and Data Facility.",
        "The ECDF is partially supported by the eDIKT initiative.6 This work was also supported in part under the GALE program of the Defense Advanced Research Projects Agency, Contract No.",
        "HR001106-C-0022.",
        "The first author was supported by an"
      ]
    },
    {
      "heading": "EPSRC Studentship. References",
      "text": []
    }
  ]
}
