{
  "info": {
    "authors": [
      "Senka Drobac",
      "Miikka Silfverberg",
      "Anssi Yli-JyrÃ¤"
    ],
    "book": "Proceedings of the 10th International Workshop on Finite State Methods and Natural Language Processing",
    "id": "acl-W12-6210",
    "title": "Implementation of Replace Rules Using Preference Operator",
    "url": "https://aclweb.org/anthology/W12-6210",
    "year": 2012
  },
  "references": [
    "acl-C00-1038",
    "acl-C96-2105",
    "acl-E99-1017",
    "acl-P95-1003"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We explain the implementation of replace rules with the .r-glc. operator and preference relations.",
        "Our modular approach combines various preference constraints to form different replace rules.",
        "In addition to describing the method, we present illustrative examples."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The idea of HFST - Helsinki Finite-State Technology (Lind?n et al. 2009, 2011) is to provide open-source replicas of well-known tools for building morphologies, including XFST (Beesley and Kart-tunen 2003).",
        "HFST's lack of replace rules such as those supported by XFST, prompted us to implement them using the present method, which replicates XFST's behavior (with minor differences which will be detailed in later work), but will also allow easy expansion with new functionalities.",
        "The semantics of replacement rules mixes contextual conditions with replacement strategies that are specified by replace rule operators.",
        "This paper describes the implementation of replace rules using a preference operator, .r-glc., that disambiguates alternative replacement strategies according to a preference relation.",
        "The use of preference relations (Yli-Jyr?",
        "2008b) is similar to the worsener relations used by Gerdemann (2009).",
        "The current approach was first described in Yli-Jyr?",
        "(2008b), and is closely related to the matching-based finite-state approaches to optimality in OT phonology (Noord and Gerdemann 1999; Eisner 2000).",
        "The preference operator, .r-glc., is the reversal of generalized lenient composition (glc), a preference operator construct proposed by J?ger (2001).",
        "The implementation is developed using the HFST library, and is now a part of the same.",
        "The purpose of this paper is to explain a general method of compiling replace rules with .r-glc.",
        "operator and to show how preference constraints described in Yli-Jyr?",
        "(2008b) can be combined to form different replace rules.",
        "2 Notation The notation used in this paper is the standard regular expression notation extended with replace rule operators introduced and described in Beesley and Karttunen (2003).",
        "In a simple rule ?",
        "???",
        "??",
        "????",
        "???",
        "?_ ???,?",
        ", ??",
        "?_ ???",
        "op is a replace rule operator such as: ?, ?",
        ", ?",
        "@?, ?",
        "@>, ?, (?",
        "), ?",
        "; ?",
        "?",
        "???",
        "is the set of patterns in the input text that are overwritten in the output text by the alternative patterns, which are given as set ?",
        "?",
        "??",
        "?, where ??",
        "is a universal language and ??",
        "set of alphabetical symbols; ??",
        "and ??",
        "are left and right contexts and dir is context direction (||, //, \\\\ and \\/).",
        "Rules can also be parallel.",
        "Then they are divided with double comma (,,), or alternately with single comma if context is not specified.",
        "Operation Name X Y The concatenation of Y after X X |Y The disjunction of X and Y X:Y The cross product of X and Y, where X and Y denote languages X .o.",
        "Y The composition of X and Y, where X and Y denote relations X+ The Kleene plus X* The Kleene star proj1(X) The projection of the input language of the relation X proj2(X) The projection of the output language of the relation X Table 1 ?",
        "List of operations",
        "where ?",
        "and ?",
        "are left and right contexts from the replace rule, and ??",
        "and ??",
        "are expanded contexts, depending on which side the context matches.",
        "In the case when context must match on the upper side, ??",
        "and ??",
        "are: ??",
        "= ?",
        "??",
        "?",
        "B ?",
        "?.",
        "o. ?",
        "??",
        "??",
        "= ?",
        "??",
        "?",
        "B ?.",
        "o. ?",
        "??",
        "If they must match on the lower side: ??",
        "= ?.",
        "o. ?",
        "??",
        "?",
        "B ?",
        "??",
        "= ?.",
        "o. ?",
        "??",
        "?",
        "B where brackets are freely inserted (?)",
        "in the contexts and then composed with ?.",
        "In this example: ?",
        "?",
        "?",
        "??",
        "?",
        "?",
        "?",
        "?_ ??",
        "both contexts should match on the upper side of the replacement, so ??????????",
        "is: ??",
        "= ?",
        "?c ?",
        "B ?",
        "?.",
        "o. ?",
        "??",
        "??",
        "= d ??",
        "?",
        "B ?.",
        "o. ?",
        "??",
        "??",
        "= ( ??",
        "?",
        "|???)",
        "?",
        "??",
        "?",
        "?",
        "?",
        "?",
        "?",
        "?",
        "?",
        "( ??",
        "?",
        "|???)",
        "??????????",
        "= ??",
        "This way of compiling contexts allows every rule in a parallel replace rule to have its own context direction (||, //, \\\\, \\/).",
        "Therefore, rules like the following one are valid in this implementation: ?",
        "?",
        "?",
        "??",
        "?\\\\ ??",
        "?_ ??",
        "?, , ?",
        "?",
        "?",
        "??",
        "?// ??",
        "?_ ??",
        "Steps 4: Final operations Finally, to get the unconstrained replace transducer it is necessary to subtract ??????????",
        "from ???????",
        "?",
        ", remove diamond and do a negation of that relation.",
        "Let ?",
        "= ?",
        "?",
        "?",
        "?",
        "??",
        "??",
        "???????",
        "?, then: ?",
        "?",
        "?",
        "?",
        "??",
        "????????",
        "?",
        "??",
        "???????????",
        "?",
        "where ?",
        "??",
        "denotes removal of diamond.",
        "3.2 Constraints All the preference constraints were defined in Yli-Jyr?",
        "(2008), but since they were mostly difficult to interpret and implement, here is the list of the constraints written with regular expressions over the set of finite binary relations.",
        "First, let us define RP ?",
        "a regular expression often used in the restraints: ??",
        "= ?",
        "?",
        "??",
        ": 0 ?",
        "?0:?",
        "?",
        "????",
        "?",
        "?",
        "The left most preference is achieved by: ??",
        "= ?",
        "??",
        "?<: 0 ?",
        "?",
        ": 0 ?",
        "?",
        "???",
        "???",
        "?",
        "Right most preference: ??",
        "= ???",
        "?",
        "???",
        "?",
        "?",
        "?",
        "?",
        "?",
        "0 ???",
        "?",
        "?",
        "Longest match left to right:",
        "??",
        "???",
        ".",
        "If the same longest match contains epen-thesis, ??",
        "?",
        "??",
        "constraint should also be used.",
        "3.4 Removing brackets Removing brackets is simply achieved by applying ??",
        "?",
        "= ???",
        "?",
        "???",
        "constraint, where B is set of brackets we want to remove.",
        "Additionally, in HFST implementation, it is also required to remove the brackets from the transducers alphabets.",
        "4 Examples Let us show how the replace rule is compiled on different examples.",
        "Since it would take too much space to show whole transducers, we will show only output of the intermediate results applied to an input string.",
        "The first example shows how to achieve a non-optional replacement.",
        "Intermediate results of the replace rule ?",
        "?",
        "??",
        "?",
        "||??",
        "?_ ??",
        "is shown in the Table 2.",
        "Since the arrow demands non-optional replace-ment, the unconstrained bracketed replace, if applied to the input string ?",
        "??",
        "??",
        ", contains three possible results.",
        "The first result is the input string itself, which would be part of the non-optional replacement.",
        "The second result is necessary to filter out the first one.",
        "In this example, because of the restricting context, replacement is possible only in the middle, and therefore, it is bracketed with special brackets.",
        "Finally, the third result contains the bracketed replace relation.",
        "?",
        "?",
        "??",
        "?",
        "||??",
        "?_ ??",
        "UBT ????",
        "?",
        "??",
        "?",
        "?",
        "?",
        "??",
        "?",
        "??",
        "?",
        "?",
        "?",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        "?",
        "?",
        "?",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        "Table 2: Steps of the non optional replacement Once when we have the unconstrained bracketed replace transducer, we are ready to apply filters.",
        "First filter, ????",
        "?",
        "will filter out all results that contain smaller number of brackets in every posi-tion, without making difference to the type of brackets.",
        "In this example, it will filter out the first result, the one that does not have any brackets at all.",
        "The second filter, ??",
        "?",
        "?",
        "will filter out all the results containing ?",
        "?brackets because they don't contain the replace relation.",
        "Finally, to get the final result, it is necessary to remove brackets from the relation.",
        "Following examples will be shown on the input string ?",
        "??",
        "??",
        "??.",
        "Table 3 shows steps of building left to right longest match and Table 4 left to right shortest match.",
        "Both longest match and shortest match have the same first two steps.",
        "After building Unconstrained Bracketed Replace, we apply ??",
        "filter which finds all the results with left most brackets in every position and filters out all the rest.",
        "This contraints characteristic filters out the results without the brackets as well, so the result will be non-optional.",
        "In order to get the longest match, we apply another filter (??",
        "??? )",
        "to the result of the left most filter.",
        "This filter finds the longest of the bracketed matches with the same starting position.",
        "In the final step, if we apply filter ??",
        "????",
        "instead of ??",
        "???",
        ", we will get the shortest match (Table 4).",
        "?+ ?@?",
        "??",
        "?",
        "||??",
        "?_ ??",
        "UBT ??",
        "??",
        "???",
        "?",
        "??",
        "??",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        "??",
        "?",
        "?",
        ": ?",
        "?",
        ": ?",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        ": ?",
        "??",
        "?",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        "??",
        "?",
        "?",
        ": ?",
        "?",
        ": ?",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        ": ?",
        "??",
        "?",
        "?",
        ": ?",
        "??",
        ": ?",
        "?",
        "?",
        "be done to build an interactive interface.",
        "Addition-ally, we are planning to add support for two level contexts and parallel weighted rules.",
        "Acknowledgments The research leading to these results has received funding from the European Commission's 7th Framework Program under grant agreement n?",
        "238405 (CLARA).",
        "References Beesley, K.R., Karttunen, L.: Finite State Morphology.",
        "CSLI publications (2003) Eisner, J.: Directional constraint evaluation in optimality theory.",
        "In: 20th COLING 2000, Proceedings of the Conference, Saarbr?cken, Germany (2000) 257?263 Gerdemann, D. (2009).",
        "Mix and Match Replacement Rules.",
        "Proceedings of the Workshop on RANLP 2009 Workshop on Adaptation of Language Resources and Technology to New Domains, Borovets, Bulgaria, 2011, pages 39-47.",
        "Gerdemann, D., van Noord, G.: Approximation and exactness in Finite-State Optimality Theory.",
        "In Eis-ner, J., Karttunen, L., Th?riault, A., eds.",
        ": SIGPHON 2000, Finite State Phonology.",
        "(2000) Gerdemann, D., van Noord, G.: Transducers from rewrite rules with backreferences.",
        "In: 9th EACL 1999, Proceedings of the Conference.",
        "(1999) 126?133 J?ger, G.: Gradient constraints in Finite State OT: The unidirectional and the bidirectional case.",
        "In: Proceedings of FSMNLP 2001, an ESSLLI Workshop, Helsinki (2001) (35?40) Karttunen, L.: The replace operator.",
        "In: 33th ACL 1995, Proceedings of the Conference, Cambridge, MA, USA (1995) 16?23 Karttunen, L.: Directed replace operator.",
        "In Roche, E., Schabes, Y., eds.",
        ": Finitestate language processing, Cambridge, Massachusetts, A Bradford Book.",
        "The MIT Press (1996) 117?147 Kempe, A., Karttunen, L.: Parallel replacement in finite state calculus.",
        "In: 16th COLING 1996, Proc.",
        "Conf.",
        "Volume 2., Copenhagen, Denmark (1996) 622?627 Lind?n, K., Axelson, E., Hardwick, S., Silfverberg, M., Pirinen, T.: HFST - Framework for Compiling and Applying Morphologies, Communications in Computer and Information Science, vol.",
        "100, pp.",
        "67-85.",
        "Springer Berlin Heidelberg (2011) Lind?n, K., Silfverberg, M., Pirinen, T.: Hfst tools for morphology - an efficient open-source package for construction of morphological analyzers.",
        "In: Mahlow, C., Pietrowski, M.",
        "(eds.)",
        "State of the Art in Computational Morphology.",
        "Communications in Computer and Information Science, vol.",
        "41, pp.",
        "28-47.",
        "Springer Berlin Heidelberg (2009) Yli-Jyr?, A., Koskenniemi, K.: A new method for compiling parallel replacement rules.",
        "In Holub, J., ?d?rek, J., eds.",
        ": Implementation and Application of Automata, 12th International Conference, CIAA 2007, Revised Selected Papers.",
        "Volume 4783 of LNCS., Springer (2007) 320?321 Yli-Jyr?, A.: Applications of Diamonded Double Nega-tion.",
        "In Finite-state methods and natural language processing.",
        "Thomas Hanneforth and Kay-Michael W?rtzner.",
        "6th International Workshop, FSMNLP 2007.",
        "Potsdam, Germany, September 14-16.",
        "Revised Papers.",
        "Universit?tsverlag Potsdam (2008a) 6-30 Yli-Jyr?, A., Transducers from Parallel Replace Rules and Modes with Generalized Lenient Composition.",
        "In Finite-state methods and natural language pro-cessing.",
        "Thomas Hanneforth and Kay-Michael W?rtzner.",
        "6th International Workshop, FSMNLP 2007.",
        "Potsdam, Germany, September 14-16.",
        "Revised Papers.",
        "Universit?tsverlag Potsdam (2008b) 197-212"
      ]
    }
  ]
}
