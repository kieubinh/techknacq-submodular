{
  "info": {
    "authors": [
      "Luheng He",
      "Jennifer Gillenwater",
      "Ben Taskar"
    ],
    "book": "CoNLL",
    "id": "acl-W13-3505",
    "title": "Graph-Based Posterior Regularization for Semi-Supervised Structured Prediction",
    "url": "https://aclweb.org/anthology/W13-3505",
    "year": 2013
  },
  "references": [
    "acl-D07-1096",
    "acl-D10-1017",
    "acl-J93-2004",
    "acl-P08-1099",
    "acl-P11-1061",
    "acl-W06-2920"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We present a flexible formulation of semi-supervised learning for structured models, which seamlessly incorporates graph-based and more general supervision by extending the posterior regularization (PR) framework.",
        "Our extension allows for any regularizer that is a convex, differentiable function of the appropriate marginals.",
        "We show that surprisingly, non-linearity of such regularization does not increase the complexity of learning, provided we use multiplicative updates of the structured exponentiated gradient algorithm.",
        "We illustrate the extended framework by learning conditional random fields (CRFs) with quadratic penalties arising from a graph Laplacian.",
        "On sequential prediction tasks of handwriting recognition and part-of-speech (POS) tagging, our method makes significant gains over strong baselines."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Recent success of graph-based semi-supervised learning builds on access to plentiful unsupervised data and accurate similarity measures between data examples (Zhu et al., 2003; Joachims, 2003; Belkin et al., 2005; Zhu and Lafferty, 2005; Al-tun et al., 2005; Zhu, 2005; Chapelle et al., 2006; Subramanya and Bilmes, 2009; Subramanya et al., 2010; Das and Petrov, 2011).",
        "Many approaches, such as Joachims (2003) and Subramanya and Bilmes (2009) use graph-based learning in the transductive setting, where unlabeled examples are classified without learning a parametric predictive model.",
        "While predicted labels can then be leveraged to learn such a model (e.g. a CRF), this pipelined approach misses out on the benefits of modeling sequential correlations during graph propagation.",
        "In this work we seek to better integrate graph propagation with estimation of a structured, parametric predictive model.",
        "To do so, we build on the posterior regularization (PR) framework of Ganchev et al. (2010).",
        "PR is a principled means of providing weak supervision during structured model estimation.",
        "More concretely, PR introduces a penalty whenever the model's posteriors over latent variables contradict the specified weak supervision.",
        "Ganchev et al. (2010) show how to efficiently optimize a likelihood-plus-posterior-penalty type objective in the case where the penalty is linear in the model's marginals.",
        "Yet, there are many forms of supervision that cannot be expressed as a linear function of marginals.",
        "For example, graph Laplacian regularization.",
        "In this work, we extend PR to allow for penalties expressed as any convex, differentiable function of the marginals and derive an efficient optimization method for such penalties.",
        "In our experiments, we explore graph Laplacian posterior regularizers for two applications: handwriting recognition and POS tagging.",
        "The methods of Altun et al. (2005), Subramanya et al. (2010), and Das and Petrov (2011) are the most closely related to this work.",
        "Altun et al. (2005) describes coupling a graph regularizer with a max-margin objective for pitch accent prediction and handwriting recognition tasks.",
        "Their method suffers from scalability issues though; it relies on optimization in the dual, which requires inversion of a matrix whose dimension grows with graph size.",
        "The more recent work of Subramanya et al. (2010) tackles the POS tagging task and provides a more scalable method.",
        "Their method is a multi-step procedure that iterates two main steps, graph propagation and likelihood optimization, until convergence.",
        "Actually computing the optimum for the graph propagation step would require a matrix inversion similar to that used by Altun et al. (2005), but they skirt this issue by using an heuristic update rule.",
        "Unfortunately though, no",
        "guarantees for the quality of this update are established.",
        "Das and Petrov (2011) proceed very similarly, adapting the iterative procedure to include supervision from bi-text data, but applying the same heuristic update rule.",
        "The work we present here similarly avoids the complexity of a large matrix inversion and iterates steps related to graph propagation and likelihood optimization.",
        "But in contrast to Subramanya et al. (2010) and Das and Petrov (2011) it comes with guarantees for the optimality of each step and convergence of the overall procedure.",
        "Further, our approach is based on optimizing a joint objective, which affords easier analysis and extensions using other constraints or optimization methods.",
        "The key enabling insight is a surprising factorization of the non-linear regularizer, which can be exploited using multiplicative updates."
      ]
    },
    {
      "heading": "2 Posterior regularization",
      "text": [
        "We focus on the semi-supervised setting, showing how to extend the discriminative, penalty-based version of PR for a linear chain CRF.",
        "Our results apply more generally though to the unsupervised setting, the constraint-based versions of PR, and other graphical models.",
        "In the standard semi-supervised setting we are given n data instances, {x1, .",
        ".",
        ".",
        ",xn}, and labels {y1, .",
        ".",
        ".",
        ",yl} for the first l n instances.",
        "For simplicity of notation, we?ll assume each xi has T components.",
        "Modeling this data with a linear chain CRF, the standard conditional log-likelihood objective with a Gaussian prior (variance?",
        "?2) is:",
        "Note that this discriminative objective does not attempt to leverage the unlabeled data.",
        "Since p?",
        "decomposes according to the independence assumptions of a linear chain CRF, it can be expressed as:",
        "and the f are arbitrary feature functions.",
        "We assume f(y1, y0,x) receives a special ?start?",
        "marker for y0.",
        "In what follows, we refer to functions over the (yt, yt?1,x) as local factors, or p-factors; p?",
        "(y |x) decomposes as a product of p-factors.",
        "Given this decomposition, L and its gradient with respect to ?",
        "can be efficiently computed using the forward-backward algorithm for linear chains.",
        "This amounts to computing posterior marginals for each p-factor (yt, yt?1,x).",
        "Following the gradient suffices to find the global optimum of L, since likelihood is concave, and the Gaussian prior makes it strictly concave.",
        "Penalty-based posterior regularization (PR) modifies the likelihood objective by adding a ?penalty?",
        "term expressing prior knowledge about the posteriors (Ganchev et al., 2010).",
        "To allow for more efficient optimization, penalty terms are imposed on an auxiliary joint distribution q over the labels instead of directly on p?.",
        "Agreement between q and p?",
        "is encouraged by a KL term:",
        "where Y is a random variable that can take on any possible labeling y, and q(Y |xi) is a an arbitrary distribution over Y for each i1.",
        "The penalty term itself is restricted to be an essentially linear function of the p-factor marginals of q(Y |xi).",
        "To compactly express this, we first define some notation.",
        "Let mi denote the p-factor marginals of q(Y |xi).",
        "For first-order linear chain models, if K is the total number of labels a y variable can take on, then mi contains the marginals for t ?",
        "{1, .",
        ".",
        ".",
        ", T} and all K2 possible (yt, yt?1) label pairs.",
        "That is, mi is a length O(TK2) vector with entries:",
        "Stacking all these mi, we let m represent the O(nTK2) vector [m1, .",
        ".",
        ".",
        ",mn].",
        "We further define a matrix A of constraint features.",
        "The product Am is then the expectation of these features under q.",
        "Finally we have, with a vector b of limits, the following expression for the penalty term:",
        "where ||?||?",
        "denotes an arbitrary norm.",
        "This expression will be non-zero if the expected value of",
        "Am is larger than the limit b.",
        "The full posterior regularizer is then: R(?, q) = KL(q ?",
        "p?)",
        "+ ?hlin(m) , (6) where ?",
        "is a hyperparameter that controls the strength of the second term.",
        "Running example: Consider the task of part-of-speech (POS) tagging, where the y are tags and the x are words.",
        "To encourage every sentence to contain at least one verb, we can penalize if the expected number of verbs under the q distribution is less than 1.",
        "Specifically, if ?verb?",
        "is represented by tag number v, for sentence i we penalize unless:",
        "In the notation of Equation (5), these penalties correspond to: an n-row A matrix, where row i has?1's to select exactly the portion of m from Equation (7), and a limit b = ?1.",
        "We briefly note here that generalized expectation (Mann and McCallum, 2007; Mann and McCallum, 2008) can be used to impose similar penalties, but without the auxiliary q distribution.",
        "Unfortunately though, this means the expectation of the A features is with respect to p?, so computing the gradient requires the covariance between the constraint features in A and the model features f , under ?.",
        "For a linear chain CRF, this means the run time of forward-backward is squared, although some optimizations are possible.",
        "PR's use of the auxiliary q allows us to optimize more efficiently by splitting the problem into easier blocks.",
        "The new objective that combines likelihood with the PR penalty is: J (?, q) = L(?)",
        "?",
        "R(?, q).",
        "While optimizing L(?)",
        "is easy, finding max?,q J (?, q) is NP-hard even for the simplest models.",
        "To optimize J , Ganchev et al. (2010) employ an expectation maximization (EM) based method.",
        "At iteration t + 1, the algorithm updates q and ?",
        "as follows:",
        "where ?",
        "here is a hyperparameter that trades off between the labeled and unlabeled data.",
        "Though not stated above, note that in the E-step minimization over q(Y |xi) is constrained to the probability simplex.",
        "Ganchev et al. (2010) show that this E-step can be efficiently implemented, via projected gradient descent on the dual.",
        "The M-step is similar to optimizing the original L, but with a contribution from the unlabeled data that further encourages q and p?",
        "to agree.",
        "Thus, the M-step can be implemented via the same gradient ascent methods as used for L. As with standard EM, this method monotonically increases J and thus is guaranteed to converge to a local optimum.",
        "In this work, we contemplate what other types of posterior penalty terms besides hlin(m) are possible.",
        "In the subsequent section, we show that it is possible to extend the class of efficiently-optimizable PR penalties to encompass all convex, differentiable functions of the marginals."
      ]
    },
    {
      "heading": "3 Non-linear PR",
      "text": [
        "Let h(m) denote an arbitrary convex, differentiable function of the marginals of q.",
        "Replacing R's penalty term with h, we have: R?",
        "(?, q) = KL(q ?",
        "p?)",
        "+ ?h(m) (10) Let J?",
        "represent the full objective with R?.",
        "We show that J?",
        "can be efficiently optimized.",
        "Running example: Returning to our POS tagging example, let's consider one type of non-linear convex penalty that might be useful.",
        "Suppose our corpus has N unique trigrams, and we construct a graph G = (V,E,W ) where each vertex in V is a trigram and each edge (a, b) ?",
        "E has a weight wab that indicates the similarity of trigrams a and b.",
        "To use the information from this graph to inform our CRF, we can use the graph Laplacian: L = D?W , where D is a diagonal degree matrix with daa =?Nj=1waj .",
        "The form of L is such that for every vector v ?",
        "RN :",
        "The larger the disparity in v values of similar vertices, the larger the value of v>Lv.",
        "The matrix L is positive semi-definite, so v>Lv is",
        "convex in v. If each entry va is a linear function of the vector of marginals m described above, then v(m)>Lv(m) is convex in m. Thus, for any linear v(m), we can use this Laplacian expression as a PR penalty.",
        "For example, we can define v(m) such that h(m) applies a penalty if trigrams that are similar according to the graph have different expected taggings under the CRF model.",
        "To state this more formally, let's define a map-pingB : ({1, .",
        ".",
        ".",
        ", n}, {1, .",
        ".",
        ".",
        ", T}) 7?",
        "V from words in the corpus to vertices in the graph: B(i, t) = a implies word xit maps to vertex a.",
        "Then, for a given tag k, we have the following formula for the value of vertex a:",
        "There are several issues to overcome in showing that EM with these more general h(m) can still be run efficiently and will still reach a local optimum.",
        "First, we have to show that the optimal q for the E-step minimization can still be compactly representable as a product of p-factors."
      ]
    },
    {
      "heading": "3.1 Decomposition",
      "text": [
        "Theorem 1.",
        "If h(m) is a convex, differentiable function of q's p-factor marginals, q?",
        "= argminq R?",
        "(?, q) decomposes as a product of p-factors.",
        "Proof.",
        "Consider the E-step gradient of R?",
        "(?, q) with respect to q.",
        "Using the shorthand qiy for",
        "Here, ?m?qiy is just a 0-1 vector indicating which of the marginals from m apply to qiy.",
        "For example, for yt = k and yt?1 = j, the marginal mit,k,j is relevant.",
        "We can more simply write:",
        "Setting the gradient equal to zero and solving for qiy, we see that it must take the following form:",
        "From this expression, it is clear that qiy is proportional to a product of p-factors.",
        "Running example: Recall the graph Laplacian penalty, discussed above for a particular tag k. Summing over all tags, the penalty is:",
        "In words: for a given k, this gradient is positive if node B(i, t) has larger probability of taking tag k than its close neighbors.",
        "Moving in the direction opposite the gradient encourages similar taggings for similar trigrams.",
        "Theorem 1 confirms that the optimal q will decompose as desired, but does not address whether we can efficiently find this q.",
        "Previous PR work optimized the E-step in the dual.",
        "But while the dual is easy to compute in closed form for norms or linear functions, for arbitrary convex functions the dual is often non-trivial.",
        "Running example: For the case of a graph Laplacian regularizer, in the primal the penalty takes the form of a quadratic program: v>Lv.",
        "Unfortunately, the dual of a quadratic program contains a matrix inverse, L?1 (van de Panne and Whinston, 1964).",
        "Taking a matrix inverse is expensive, which makes optimization in the dual unattractive.",
        "Since moving to the dual would be inefficient, optimizing R?",
        "will require some form of gradient descent on the qiy.",
        "However, the standard gradient",
        "where ?",
        "is the step size, does not result in a feasible optimization scheme, for several reasons.",
        "First, it is possible for the updated q to be outside the probability simplex.",
        "To be sure it remains in the simplex would require a projection step on the full, exponential-size set of all qiy, for each example xi.",
        "Second, the updated q may not be proportional to a product of p-factors.",
        "To be concrete, suppose the starting point is qiy = p?",
        "(y |xi), which does decompose as a product of p-factors.",
        "Then after the first gradient update, we have:",
        "Unfortunately, while p?",
        "(y |xi) decomposes as a product of p-factors, the other term decomposes as a sum.",
        "Naturally, as we discuss in the following section, multiplicative updates are more suitable."
      ]
    },
    {
      "heading": "3.2 Exponentiated Gradient",
      "text": [
        "The exponentiated gradient descent (EGD) algorithm was proposed by Kivinen and Warmuth (1995), who illustrate its application to linear prediction.",
        "More recently, Collins et al. (2005) and Collins et al. (2008) extended EGD to exploit factorization in structured models.",
        "The most important aspect of EGD for us is that a variable's update formula takes a multiplicative rather than an additive form.",
        "Specifically, the update for qiy is: qiy ?",
        "qiy exp",
        "Lemma 2.",
        "EGD update Equation (17) preserves decomposition of q into p-factors.",
        "Proof.",
        "Applying the multiplicative EGD update formula to qiy, we see that its new value equals the following product:",
        "up to a normalization constant.",
        "Since qiy and p?",
        "(y |xi) both decompose as a product of p-factors and since the update term is another product of p-factors, the updated expression is itself a product of p-factors (up to normalization).",
        "Note that normalization is not an issue with the EGD updates.",
        "Since q retains its decomposition, the normalization can be efficiently computed using forward-backward.",
        "Thus, Lemma 2 moves us much closer to the goal of running EM efficiently, though there remain several stumbling blocks.",
        "First and foremost, we cannot afford to actually apply EGD to each qiy, as there are an exponential number of them.",
        "Thankfully, we can show these EGD updates are equivalent to following the gradient on a much smaller set of values.",
        "In particular, letting F represent the dimension of m, which for example is O(nTK2) for linear chains, we have the following result.",
        "Lemma 3.",
        "Given the gradient vector ?h(m)?m , one step of EGD on R?",
        "(?, q) can be completed in time O(F ), where F is the dimension ofm.",
        "Proof.",
        "First, we re-express qiy in log-linear form.",
        "Applying Lemma 2, we know that qiy is proportional to a product of p-factors This means that there must exist some factors r such that qiy can be written:",
        "Re-expressing ?R?",
        "?qiy given these r, we have:",
        "with respect to y.",
        "This means that we can just update the individual r factors as follows: ri,t(yt, yt?1)?",
        "(1?",
        "?",
        ")ri,t(yt, yt?1) +",
        "Note that if we start from qiy = p?",
        "(y |xi), then the initial ri,t(yt, yt?1) are just ?>f(yt, yt?1,xi).",
        "To conclude, since the number of r functions is equal to the dimension ofm, the overall update is linear in the number of marginals.",
        "At this point, just one small issue remains: how expensive is computing ?h(m)?m ?",
        "Work analyzingthe reverse mode of automatic differentiation indicates that if computing a function h requires c operations, then computing its gradient vector requires no more than O(c) operations (Griewank, 1988).",
        "Thus, as long as our penalty function is",
        "itself efficiently computable, the gradient vector will be too.",
        "We conclude by observing that our efficient algorithm converges to a local optimum.",
        "Theorem 4.",
        "The above EGD-based EM algorithm for optimizing J?",
        "(?, q) converges to a local optimum of this objective.",
        "Proof.",
        "The M-step remains unchanged from standard PR EM, and as such is strictly convex in ?.",
        "The E-step is strictly convex in q, since KL-divergence is strictly convex and h(m) is convex.",
        "Applying EGD, we know that we can efficiently find the E-step optimum.",
        "Therefore, the EGD-based EM algorithm efficiently implements coordinate ascent on J?",
        "(?, q), with each step monotonically increasing J?",
        ": J?",
        "(?t, qt) ?",
        "J?",
        "(?t, qt+1) ?",
        "J?",
        "(?t+1, qt+1) .",
        "Hence, we have shown that it is possible to efficiently use an arbitrary convex, differentiable function of the marginals, h(m), as a PR penalty function.",
        "In the following section, we apply one such function ?",
        "the graph Laplacian quadratic from the running example ?",
        "to several tasks."
      ]
    },
    {
      "heading": "4 Experiments",
      "text": [
        "We evaluate the effect of a graph Laplacian PR penalty on two different sequence prediction tasks: part-of-speech (POS) tagging and handwriting recognition.",
        "Our experiments are conducted in a semi-supervised setting, where only a small number, l, of labeled sequences are available during training.",
        "Both the l labeled sequences and the remainder of the dataset (instances l + 1 through n) are used to construct a graph Laplacian2.",
        "We train a second-order CRF using the methods described in Section 3 and report results for a test set consisting of instances l + 1 through n."
      ]
    },
    {
      "heading": "4.1 Graph construction",
      "text": [
        "For each task we define a symmetric similarity function on the task's vertices V , sim : V ?",
        "V 7?",
        "R, and build the graph based on its values.",
        "Specifically, denoting the k nearest neighbors (NN) of node u by Nk(u), we use the following mutual k-NN criterion to decide which edges to include: (u, v) ?",
        "E ??",
        "u ?",
        "Nk(v) ?",
        "v ?",
        "Nk(u) ."
      ]
    },
    {
      "heading": "4.2 Part-of-speech tagging",
      "text": [
        "We experiment on ten languages.",
        "Our English (EN) data is from the Penn Treebank (Marcus et al., 1993), Italian (IT) and Greek (EL) are from CoNLL-2007 (Nivre et al., 2007), and the remaining languages in Figure 1 (a): German (DE), Spanish (ES), Portuguese (PT), Danish (DA), Slovene (SL), Swedish (SV), and Dutch (NL) are from CoNLL-X (Buchholz and Marsi, 2006).",
        "We use a universal tag set (Das et al., 2012) throughout.",
        "For each language, we first construct a mutual 60-NN graph3 on trigram types, excluding trigrams whose center word is punctuation.",
        "Our smallest graph (Slovene) contains 25,198 nodes while the largest (English) has 611,730.",
        "For the similarity function sim(u, v), we follow the method used in (Subramanya et al., 2010) and (Das and Petrov, 2011), but with a somewhat modified feature set.",
        "For instance, while (Subramanya et al., 2010) uses suffixes of the trigram's center word, we find this type of feature is too easy for unrelated trigrams to match, leading to a noisy graph.",
        "Let a trigram and its left/right context be denoted by the 5-gram (w0, w1, w2, w3, w4).",
        "Then the features we use to build the graph are: ?",
        "Trigram features: w12, w13, w23, w2, suffix(w3)w2, suffix(w1)w2 ?",
        "Context features: w0134, w012, w023, w024, w124, w234, w01, w02, w24, w34 where suffix indicates common suffixes collected from Wiktionary data.",
        "For a given feature f and trigram type t, the value of the feature is determined by pointwise mutual information (PMI): log #(f?t)#(f)#(t) .",
        "Then, for each pair of trigram types, sim(u, v) is given by the cosine similarity of the trigrams?",
        "feature vectors.",
        "For the second-order CRF, we use a fairly standard set of features: ?",
        "Emission features: 1(yt = k ?",
        "f(xt?",
        ")), where k can be any POS tag and t?",
        "?",
        "{t, t ?",
        "1, t + 1}.",
        "The f(xt?)",
        "takes the form of a function from the following set: one indicator for each word, lowercased word, and suf",
        "fix, and also is-capitalized, is-punctuation, is-digit, contains-hyphen, and contains-period.",
        "?",
        "Transition features: For any POS tags k1, k2, k3, we have a feature 1(yt = k1, yt?1 = k2, yt+1 = k3) and its backoffs (indicators for one or two matching tags)."
      ]
    },
    {
      "heading": "4.3 Handwriting recognition",
      "text": [
        "The handwriting dataset we use was collected by Kassel (1995) and filtered to 6,877 words (Taskar et al., 2003).",
        "For each word, the first letter is removed so that every remaining letter is one of the English language's 26 lowercase letters.",
        "Again, we first build a mutual NN graph.",
        "In this case, we use 20-NN, since our graph has fewer nodes and a larger set of possible node identities (26 letters instead of 12 tags).",
        "Each node in this graph is one letter from the dataset, for a total of 52,152 nodes.",
        "As a first step, we compute cosine similarity on the pixels of each pair of nodes, and then consider only pairs with a similarity greater than 0.3.",
        "Next, we apply the Fast Earth Mover's distance E?MD(u, v) (Pele and Werman, 2009) with default parameters to compute the dissimilarity of each pair of images.",
        "We convert these into similarities via: s(u, v) = exp",
        "where we set the variance ?EMD = 10.",
        "The final similarity function sim(u, v) is the weighted combination of the similarity of the nodes (u, v) and their left neighbors (ul, vl) and right neighbors (ur, vr) from their respective words: sim(u, v) = ?s(u, v)+(1??",
        ")(s(ul, vl)+s(ur, vr)) where we fix ?",
        "= 0.8.",
        "For the second-order CRF, the transition features are same as for POS tagging, but with tags replaced by the English alphabet.",
        "The emission features take a similar form, but with different meanings for the f(xt?)",
        "indicator functions.",
        "Specifically, there is one indicator for each pixel location, with value 1 if the pixel is turned on.",
        "As there are many more emission than transition features, we count the number of fired emission and transition features, say fe and ft, then discount all emission features, multiplying them by ftfe to balance the amount of supervision."
      ]
    },
    {
      "heading": "4.4 Baselines",
      "text": [
        "We compare our posterior regularization (PR) results with three baselines.",
        "We also include results for the first EM iteration of our PR method (PR1), to show there is still significant optimization occurring after the first iteration.",
        "The first baseline is graph propagation (GP).",
        "Specifically, we start from uniform posteriors for all the unlabeled nodes in the graph, then for each tag/letter k and each node v we apply the gradient update:",
        "until convergence.",
        "We then select the tag/letter with the largest probability as the prediction for a node.",
        "If multiple tokens are mapped to a node, then all receive the same prediction.",
        "The second baseline incorporates both graph propagation and sequence information.",
        "As a first step, we run the GP baseline, then use the decoding as additional labeled data to train a second-order CRF (see GP?CRF results).",
        "The third baseline is simply a second-order CRF, trained on the l labeled examples."
      ]
    },
    {
      "heading": "4.5 Training details",
      "text": [
        "For optimizing the CRF, we use L-BFGS (Bert-sekas, 2004) and a Gaussian prior with ?",
        "= 100 (chosen by cross-validation on the labeled training examples).",
        "The final predictions are obtained via posterior decoding.",
        "For PR, we run EM for at most 20 iterations, which is enough for convergence of the combined objective J?",
        "(?, q).",
        "We cross-validate the constraint strength parameter ?",
        "over the following values: {0.1, 0.5, 1.0, 2.0}, ultimately selecting ?",
        "= 1 for the POS tagging task and ?",
        "= 0.1 for the handwriting recognition task."
      ]
    },
    {
      "heading": "4.6 Results and analysis",
      "text": [
        "POS tagging.",
        "For each language, we randomly sample 1000 labeled examples and split them into 10 non-overlapping training sets of size l = 100.",
        "Figure 1 (a) shows the average error and its standard deviation for these training sets.",
        "If for each language we take the difference between the average error of PR and that of the best of the three baselines, the min, average, and max improvements are: 2.69%, 4.06%, and 5.35%.",
        "When analyzing the results, we observed that one region where PR makes substantial gains over the",
        "tagging error of one method; the left-to-right order of the methods is the same as in the legend.",
        "Whiskers indicate standard deviations.",
        "The final set of bars is an average across all languages.",
        "See supplement for a table with the exact numbers.",
        "(b): POS results on one language for a range of l. CRF baseline is on unseen words (words that do not occur in the set of l labeled examples).",
        "If we measure performance only on such words, the gain of PR over CRF is 6.7%.",
        "We also test with l = {50, 100, 150, 200, 300, 400, 500} on one language to illustrate how PR performs with different amounts of supervision.",
        "Figure 1 (b) shows that even when l = 500 our PR method is still able to provide improvement over the best baseline.",
        "Handwriting recognition.",
        "For this task, the overall dataset contains 55 distinct word types.",
        "Thus, we set l = 110 and sample 10 training sets such that each contains 2 examples of each of word.",
        "Note that due to the well-balanced training sets, baselines are fairly high here compared to other similar work with this dataset.",
        "Table 1 shows there is an average improvement of 4.93% over the best of the three baselines.",
        "Even in a simpler setting closer to that of POS tagging, where we just draw l = 100 samples randomly, there are many cases where PR beats the baselines.",
        "Figure 2 shows predictions from such a setting and provides general intuition as to why PR does well on handwriting recognition.",
        "For the word ?Wobble?",
        "(with the first letter removed), the CRF predicts ?obble?",
        "as ?ovely?, because of it relies heavily on sequential information; in our small training set, bigrams ?ov?",
        "(2 times) and ?ly?",
        "(12 times) are more frequent than ?ob?",
        "(1 time) and ?le?",
        "(7 times).",
        "GP correctly predicts these letters because the graph connects them to good neighbors.",
        "However, GP mislabels ?l?",
        "as ?i?, since most of this letter's neighbors are i?s.",
        "The coupling of GP and CRF via PR links the neighbor information with bigram information ?",
        "?bl?",
        "(5 times) is more frequent than ?bi?",
        "in the training set ?",
        "to yield the correct labeling.",
        "l t l l l i i i l i l l l l l"
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We have presented an efficient extension of the posterior regularization (PR) framework to a more general class of penalty functions.",
        "Encouraging results using a graph Laplacian penalty suggest potential applications to a much larger class of weakly supervised problems."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": []
    }
  ]
}
