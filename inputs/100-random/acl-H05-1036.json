{
  "info": {
    "authors": [
      "Jason M. Eisner",
      "Eric Goldlust",
      "Noah A. Smith"
    ],
    "book": "Human Language Technology Conference and Empirical Methods in Natural Language Processing",
    "id": "acl-H05-1036",
    "title": "Compiling Comp Ling: Weighted Dynamic Programming and the Dyna Language",
    "url": "https://aclweb.org/anthology/H05-1036",
    "year": 2005
  },
  "references": [
    "acl-H05-1060",
    "acl-J03-1006",
    "acl-J95-2002",
    "acl-J97-3002",
    "acl-J98-2004",
    "acl-J99-4004",
    "acl-N03-1016",
    "acl-N03-1021",
    "acl-P02-1001",
    "acl-P02-1017",
    "acl-P03-1054",
    "acl-P04-1062",
    "acl-P04-3032",
    "acl-P05-1044",
    "acl-P83-1021",
    "acl-P92-1017",
    "acl-P96-1033",
    "acl-P99-1059",
    "acl-W04-3207",
    "acl-W05-1504",
    "acl-W98-1115"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Weighted deduction with aggregation is a powerful theoretical formalism that encompasses many NLP algorithms.",
        "This paper proposes a declarative specification language, Dyna; gives general agenda-based algorithms for computing weights and gradients; briefly discusses Dyna-to-Dyna program transformations; and shows that a first implementation of a Dyna-to-C++ compiler produces code that is efficient enough for real NLP research, though still several times slower than hand-crafted code."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "In this paper, we generalize some modern probabilistic parsing techniques to a broader class of weighted deductive algorithms.",
        "Our implemented system encapsulates these implementation techniques behind a clean interface – a small high-level specification language, Dyna, which compiles into C++ classes.",
        "This system should help the HLT community to experiment more easily with new models and algorithms."
      ]
    },
    {
      "heading": "1.1 Dynamic programming as deduction",
      "text": [
        "The “parsing as deduction” framework (Pereira and Warren, 1983) is now over 20 years old.",
        "It provides an elegant notation for specifying a variety of parsing algorithms (Shieber et al., 1995), including algorithms for probabilistic or other semiring-weighted parsing (Goodman, 1999).",
        "In the parsing community, new algorithms are often stated simply as a set of deductive inference rules (Sikkel, 1997; Eisner and Satta, 1999).",
        "It is also straightforward to specify other NLP algorithms this way.",
        "Syntactic MT models, language models, and stack decoders can be easily described using deductive rules.",
        "So can operations on finite-state and infinite-state machines.",
        "\"We thank Joshua Goodman, David McAllester, and Paul Ruhlen for useful early discussions; pioneer users Markus Dreyer, David Smith, and Roy Tromble for their feedback and input; John Blatz for discussion of program transformations; and several reviewers for useful criticism.",
        "This work was supported by NSF ITR grant IIS-0313193, ONR MURI grant N00014-01-1-0685, and a Hertz Foundation fellowship to the third author.",
        "The views expressed are not necessarily endorsed by the sponsors."
      ]
    },
    {
      "heading": "1.2 The role of toolkits",
      "text": [
        "One might regard deductive inference as merely a helpful perspective for teaching old algorithms and thinking about new ones, linking NLP to logic and classical AI.",
        "Real implementations would then be carefully hand-coded in a traditional language.",
        "That was the view ten years ago of finite-state machines – that FSMs were part of the theoretical backbone of CL, linking the field to the theory of computation.",
        "Starting in the mid-1990’s, however, finite-state methods came to the center of applied NLP as researchers at Xerox, AT&T, Groningen and elsewhere improved the expressive power of FSMs by moving from automata to transducers, adding semiring weights, and developing powerful new regular-expression operators and algorithms for these cases.",
        "They also developed software.",
        "Karttunen et al.",
        "(1996) built an FSM toolkit that allowed construction of morphological analyzers for many languages.",
        "Mohri et al.",
        "(1998) built a weighted toolkit that implemented novel algorithms (e.g., weighted minimization, on-the-fly composition) and scaled up to handle large-vocabulary continuous ASR.",
        "At the same time, renewed community-wide interest in shallow methods for information extraction, chunking, MT, and dialogue processing meant that such off-the-shelf FS toolkits became the core of diverse systems used in cutting-edge research.",
        "The weakness of FSMs, of course, is that they are only finite-state.",
        "One would like something like AT&T’s FSM toolkit that also handles the various formalisms now under consideration for lexicalized grammars, non-context-free grammars, and syntax-based MT – and hold the promise of extending to other formalisms and applications not yet imagined.",
        "We believe that deductive inference should play the role of regular expressions and FSMs, providing the theoretical foundation for such an effort.",
        "Many engineering ideas in the field can be regarded, we",
        "1. :- double item=0.",
        "% declares that all item values are doubles, default is 0 2. constit(X,I,K) += rewrite(X,W) * word(W,I,K).",
        "% a constituent is either a word ... 3. constit(X,I,K) += rewrite(X,Y,Z) * constit(Y,I,J) * constit(Z,J,K).",
        "% ... or a combination of two adjacent subconstituents 4. goal += constit(“ s”,0,N) whenever ?endsat(N).",
        "% a parse is any s constituent that covers the input string",
        "believe, as ideas for how to specify, transform, or compile systems of inference rules."
      ]
    },
    {
      "heading": "2 A Language for Deductive Systems",
      "text": [
        "Any toolkit needs an interface.",
        "For example, FS toolkits offer a regular expression language.",
        "We propose a simple but Turing-complete language, Dyna, for specifying weighted deductive-inference algorithms.",
        "We illustrate it here by example; see http://dyna.org for more details and a tutorial.",
        "The short Dyna program in Fig. 1 expresses the inside algorithm for PCFGs (i.e., the probabilistic generalization of CKY recognition).",
        "Its 3 inference rules schematically specify many equations, over an arbitrary number of unknowns.",
        "This is possible bcause the unknowns (items) have structured names (terms) such as constit(“ s”,0,3).",
        "They resemble typed variables in a C program, but we use variable instead to refer to the capitalized identifiers X, I, K, ... in lines 2–4.",
        "Each rule gives a consequent on the left-hand side of the +=, which can be built by combining the antecedents on the right-hand side.1 Lines 2–4 are equational schemas that specify how to compute the value of items such as constit(“ s”,0,3) from the values of other items.",
        "Using the summation operator +=, lines 2– 3 say that for any X, I, and K, constit(X,I,K) is defined by summing over the remaining variables, as EW rewrite(X,W)*word(W,I,K) + EY,Z,J rewrite(X,Y,Z)*constit(Y,I,J)*constit(Z,J,K).",
        "For example, constit(“ s”,0,3) is a sum of quantities such as rewrite(“s”, “np”, “vp”)*constit(“np”,0,1)*constit(“vp”,1,3).",
        "The whenever operator in line 4 specifies a side condition that restricts the set of expressions in the sum (i.e., only when N is the sentence length).",
        "To fully define the system of equations, non-default values (in this case, non-zero values) should be asserted for some axioms at runtime.",
        "(Axioms, shown in bold in Fig. 1, are items that never appear",
        "as a consequent.)",
        "If the PCFG contains a rewrite rule np – * Mary with probability p(Mary I np)=0.005, the user should assert that rewrite(“np”, “Mary”) has value 0.005.",
        "If the input is John loves Mary, values of 1 should be asserted for word(“John”,0,1), word(“ loves”,1,2), word(“Mary”,2,3), and endsat(3).",
        "Given the axioms as base cases, the equations in Fig. 1 enable deduction of values for other items.",
        "The value of the theorem constit(“ s”,0,3) will be the inside probability Os (0, 3),2 and the value of goal will be the total probability of all parses.",
        "If one replaces += by max= throughout, then constit(“ s”,0,3) will accumulate the maximum rather than the sum of these quantities, and goal will accumulate the probability of the best parse.",
        "With different input, the same program carries out lattice parsing.",
        "Simply assert axioms that correspond to (weighted) lattice arcs, such as word(“John”,17,50), where 17 and 50 are arbitrary terms denoting states in the lattice.",
        "It is also quite straightforward to lexicalize the nonterminals or extend to synchronous grammars.",
        "A related context-free parsing strategy, shown in Fig. 2, is Earley’s algorithm.",
        "These equations illustrate nested terms such as lists.",
        "The side condition in line 2 prevents building any constituent until one has built a left context that calls for it."
      ]
    },
    {
      "heading": "3 Relation to Previous Work",
      "text": [
        "There is a large relevant literature.",
        "Some of the well-known CL papers, notably Goodman (1999), were already mentioned in section 1.1.",
        "Our project has three main points of difference from these.",
        "First, we provide an efficient, scalable, open-source implementation, in the form of a compiler from Dyna to C++ classes.",
        "(Related work is in §7.2.)",
        "The C++ classes are efficient and easy to use, with statements such as c[rewrite(“np”,2,3)]=0.005 to assert axiom values into a chart named c (i.e., a deduc",
        "1. need(‘‘s’’,0) = 1.",
        "% begin by looking for an s that starts at position 0 2. constit(Nonterm/Needed,I,I) += rewrite(Nonterm,Needed) whenever ?need(Nonterm, I).",
        "% traditional predict step 3. constit(Nonterm/Needed,I,K) += constit(Nonterm/cons(W,Needed),I,J) * word(W,J,K).",
        "% traditional scan step 4. constit(Nonterm/Needed,I,K) += constit(Nonterm,cons(X,Needed),I,J) * constit(X/nil,J,K).",
        "% traditional complete step 5. goal += constit(“s”/nil,0,N) whenever ?endsat(N).",
        "% we want a complete s constituent covering the sentence 6. need(Nonterm,J) += constit(/cons(Nonterm, _ ), _,J).",
        "% Note: underscore matches anything (anonymous wildcard)",
        "tive database) and expressions like c[goal] to extract the values of the resulting theorems, which are computed as needed.",
        "The C++ classes also give access to the proof forest (e.g., the forest of parse trees), and integrate with parameter optimization code.",
        "Second, we fully generalize the agenda-based strategy of Shieber et al.",
        "(1995) to the weighted case – in particular supporting a prioritized agenda.",
        "That allows probabilities to guide the search for the best parse(s), a crucial technique in state-of-the-art context-free parsers.3 We also give a “reverse” agenda algorithm to compute gradients or outside probabilities for parameter estimation.",
        "Third, regarding weights, the Dyna language is designed to express systems of arbitrary, heterogeneous equations over item values.",
        "In previous work such as (Goodman, 1999; Nederhof, 2003), one only specifies the inference rules as unweighted Horn clauses, and then weights are added automatically in a standard way: all values have the same type 'W, and all rules transform to equations of the form c ®= al ® a2 ® • • • ® ak, where ® and give 'W the structure of a semiring.4 In Dyna one writes these equations explicitly in place of Horn clauses (Fig.",
        "1).",
        "Accordingly, heterogeneous Dyna programs, to be supported soon by our compiler, will allow items of different types to have values of different types, computed by different aggregation operations over arbitrary right-hand-side ex",
        "pressions.",
        "This allows specification of a wider class of algorithms from NLP and elsewhere (e.g., minimum expected loss decoding, smoothing formulas, neural networks, game tree analysis, and constraint programming).",
        "Although §4 and §5 have space to present only techniques for the semiring case, these can be generalized.",
        "Our approach may be most closely related to deductive databases, which even in their heyday were apparently ignored by the CL community (except for Minnen, 1996).",
        "Deductive database systems permit inference rules that can derive new database facts from old ones.",
        "They are essentially declarative logic programming languages (with restrictions or extensions) that are – or could be – implemented using efficient database techniques.",
        "Some implemented deductive databases such as CORAL (Ra-makrishnan et al., 1994) and LOLA (Zukowski and Freitag, 1997) support aggregation (as in Dyna’s +=, log+=, max=, ... ), although only “stratified” forms of it that exclude unary CFG rule cycles.6 Ross and Sagiv (1992) (and in a more restricted way, Kifer and Subrahmanian,1992) come closest to our notion of attaching aggregable values to terms.",
        "Among deductive or other database systems, Dyna is perhaps unusual in that its goal is not to support transactional databases or ad hoc queries, but rather to serve as an abstract layer for specifying an algorithm, such as a dynamic programming (DP) algorithm.",
        "Thus, the Dyna program already implicitly or explicitly specifies all queries that will be needed.",
        "This allows compilation into a hard-coded C++ implementation.",
        "The compiler’s job is to support these queries by laying out and indexing the database relations in memory in a way that resembles hand-designed data structures for the algorithm in question.",
        "The compiler has many choices to make here; we ultimately hope to implement feedback-directed optimization, using profiled sample runs on typical data.",
        "For example, a sparse grammar should lead to different strategies than a dense one."
      ]
    },
    {
      "heading": "4 Computing Theorem Values",
      "text": [
        "Fig.",
        "1 specifies a set of equations but not how to solve them.",
        "Any declarative specification language must be backed up by a solver for the class of specifiable problems.",
        "In our continuing work to develop a range of compiler strategies for arbitrary Dyna programs, we have been inspired by the CL commu-nity’s experience in building efficient parsers.",
        "In this paper and in our current implementation, we give only the algorithms for what we call weighted dynamic programs, in which all axioms and theorems are variable-free.",
        "This means that a consequent may only contain variables that already appear elsewhere in the rule.",
        "We further restrict to semiring-weighted programs as in (Goodman, 1999).",
        "But with a few more tricks not given here, the algorithms can be generalized to a wider class of heterogeneous weighted logic programs.8"
      ]
    },
    {
      "heading": "4.1 Desired properties",
      "text": [
        "Computation is triggered when the user requests the value of one or more particular items, such as goal.",
        "Our algorithm must have several properties in order to substitute for manually written code.",
        "Soundness.",
        "The algorithm cannot be guaranteed to terminate (since it is possible to write arbitrary Turing machines in Dyna).",
        "However, if it does terminate, it should return values from a valid model of the program, i.e., values that simultaneously satisfy all the equations expressed by the program.",
        "Reasonable completeness.",
        "The computation should indeed terminate for programs of interest to the NLP community, such as parsing under a probabilistic grammar – even if the grammar has 7Some relations might be left unmaterialized and computed on demand, with optional memoization and flushing of memos.",
        "8Heterogeneous programs may propagate non-additive updates, which arbitrarily modify one of the inputs to an aggregation.",
        "Non-dynamic programs require non-ground items in the chart, complicating both storage and queries against the chart.",
        "1. for each axiom a, set agenda[a] := value of axiom a 2. while there is an item a with agenda[a] # 0 3.",
        "(* remove an item from the agenda and move its value to the chart *) 4. choose such an a 5.",
        "A := agenda[a]; agenda[a] := 0 6. old := chart[a]; chart[a] := chart[a] ® A 7. if chart[a] # old (* onlypropagate actual changes *) 8.",
        "(* compute new resulting updates and place them on the agenda *) 9. for each inference rule “c ®= al ® a2 ® ® ak” 10. for i from 1 to k 11. for each way of instantiating the rule’s variables such that ai = a",
        "left recursion, unary rule cycles, or c-productions.",
        "This appears to rule out pure top-down (“backward-chaining”) approaches.",
        "Efficiency.",
        "Returning the value of goal should do only as much computation as necessary.",
        "To return goal, one may not need to compute the values of all items.9 In particular, finding the best parse should not require finding all parses (in contrast to Goodman (1999) and Zhou and Sato (2003)).",
        "Approximation techniques such as pruning and best-first search must also be supported for practicality."
      ]
    },
    {
      "heading": "4.2 The agenda algorithm",
      "text": [
        "Our basic algorithm (Fig.",
        "3) is a weighted agenda-based algorithm that works only with rules of the form c ®= al ® a2 ® • • • ® ak.",
        "® must distribute over ®.",
        "Further, the default value for items (line 1 of Fig. 1) must be the semiring’s zero element, denoted 0.10 Agenda-based deduction maintains two indexed data structures: the agenda and the chart.",
        "chart[a] stores the current value of item a.",
        "The agenda holds future work that arises from assertions or from previous changes to the chart: agenda[a] stores an incremental update to be added (using ®) to chart[a] in future.",
        "If chart[a] or agenda[a] is not stored, it is 9 This also affects completeness, as it sometimes enables the computation of goal to terminate even if the program as a whole contains some irrelevant non-terminating computation.",
        "Even in practical cases, the runtime of computing all items is often prohibitive, e.g., proportional to n6 or worse for a dense tree-adjoining grammar or synchronous grammar.",
        "10It satisfies x ® 0 = x, x ® 0 = 0 for all x.",
        "Also, this algorithm requires ® to distribute over ®.",
        "Dyna’s semantics requires ® to be associative and commutative.",
        "12. agenda[c] ®=",
        "taken to be the default 0.",
        "When item a is removed from the agenda, its chart weight is updated by the increment value.",
        "This change is then propagated to other items c, via rules of the form c ®= • • • with a on the right-hand-side.",
        "The resulting changes to c are placed back on the agenda and carried out only later.",
        "The unweighted agenda-based algorithm (Shieber et al., 1995) may be regarded as the case where",
        "the natural further generalization to any semiring.",
        "How is this a further generalization?",
        "Since ® (unlike V and max) might not be idempotent, we must take care to avoid erroneous double-counting if the antecedent a combines with, or produces, another copy of itself.1 1 For instance, if the input contains c words, line 2 of Fig. 1 may get instantiated as con",
        "constit(“np”,5,5).",
        "This is why we save the old values of agenda[a] and chart[a] as A and old, and why line 12 is complex."
      ]
    },
    {
      "heading": "4.3 Side conditions",
      "text": [
        "We now extend Fig. 3 to handle Dyna’s side conditions, i.e., rules of the form",
        "We discuss only the simple side conditions treated in previous literature, which we write as",
        "Here, ?bj is true or false according to whether there exists an unweighted proof of bj.",
        "Again, what is new here?",
        "Nederhof (2003) considers only max= with a uniform-cost agenda discipline (see §4.5), which guarantees that no item will be removed more than once from the agenda.",
        "We wish to support other cases, so we must take care that a second update to ai will not retrigger rules of which ai is a side condition.",
        "For simplicity, let us reformulate the above rule as c ®= al ® a2 0 ... 0 ak, ® ?bk,+l ® ... ® ?bk, where ?bi is now treated as having value 0 or 1 (the identity for ®) rather than false or true respectively.",
        "11 An agenda update that increases x by 0.3 will increase r * x * x by r * (0.6x + 0.09).",
        "Hence, the rule x += r * x * x must propagate a new increase of that size to x, via the agenda.",
        "We may now use Fig. 3, but now any aj might have the form ?bj.",
        "Then in line 12, chart[aj] will be chart[?bj], which is defined as 1 or 0 according to whether chart[bj] is stored (i.e., whether bj has been derived).",
        "Also, if ai = ?a at line 11 (rather than ai = a), then A in line 12 is replaced by A?, where we have set A?",
        ":= chart?a] at line 5."
      ]
    },
    {
      "heading": "4.4 Convergence",
      "text": [
        "Whether the agenda algorithm halts depends on the Dyna program and the input.",
        "Like any other Turing-complete language, Dyna gives you enough freedom to write undesirable programs.",
        "Most NLP algorithms do terminate, of course, and this remains true under the agenda algorithm.",
        "For typical algorithms, only finitely many different items (theorems) can be derived from a given finite input (set of axioms).",
        "12 This ensures termination if one is doing unweighted deduction with N ®, ®) = ({T, F}, V, A), since the test at line 7 ensures that no item is processed more than once.13 The same test ensures termination if one is searching for the best proof or parse with (say)",
        "negated log probabilities.",
        "Positive-weight cycles will not affect the min.",
        "(Negative-weight cycles, however, would correctly cause the computation to diverge; these do not arise with probabilities.)",
        "If one is using ('W, ®, ®) = (1\" moo, +, *) to compute the total weight of all proofs or parses, as in the inside algorithm, then Dyna must solve a system of nonlinear equations.",
        "The agenda algorithm does this by iterative approximation (propagating updates around any cycles in the proof graph until numerical convergence), essentially as suggested by Stolcke (1995) for the case of Earley’s algorithm.",
        "14 Again, the computation may diverge.",
        "One can declare the conditions under which items of a particular type (constit or goal) should be treated as having converged.",
        "Then asking for the value of goal will run the agenda algorithm not until the agenda is empty, but only until chart[goal] has converged by this criterion."
      ]
    },
    {
      "heading": "4.5 Prioritization",
      "text": [
        "The order in which items are chosen at line 4 does not affect the soundness of the agenda algorithm, but can greatly affect its speed.",
        "We implement the agenda as a priority queue whose priority function may be specified by the user.15 Charniak et al.",
        "(1998) and Caraballo and Charniak (1998) showed that, when seeking the best parse (using min= or max=), best-first parsing can be extremely effective.",
        "Klein and Manning (2003a) went on to describe admissible heuristics and an A* framework for parsing.",
        "For A* in our general framework, the priority of item a should be an estimate of the value of the best proof of goal that uses a.",
        "(This non-standard formulation is carefully chosen.16) If so, goal is guaranteed to converge the very first time it is selected from the priority-queue agenda.",
        "Prioritizing “good” items first can also be useful in other circumstances.",
        "The inside-outside training algorithm requires one to find all parses, but finding the high-probability parses first allows one to ignore the rest by “early stopping.” In all these schemes (even A*), processing promising items as soon as possible risks having to reprocess them if their values change later.",
        "Thus, this strategy should be balanced against the “topological sort” strategy of waiting to process an item until its value has (probably) converged.17 Ulti-15At present by writing a C++ function; ultimately within Dyna, by defining items such as priority(constit(“ s”,0,3)).",
        "16It is correct for proofs that incorporate two copies of a’s value, or – more important – no copies of a’s value because a is a side condition.",
        "Thus, it recognizes that a low-probability item must have high priority if it could be used as a side condition in a higher-probability parse (though this cannot happen for the side conditions derived by the magic templates transformation (§6)).",
        "Note also that a’s own value (Nederhof, 2003) might not be an optimistic estimate, if negative weights are present.",
        "17 In parsing, for example, one often processes narrower constituents before wider ones.",
        "But such strategies do not always exist, or break down in the presence of unary rule cycles, or cannot be automatically found.",
        "Goodman’s (1999) strategy of building all items and sorting them before computing any weights is wise only if one genuinely wants to build all items.",
        "mately we hope to learn priority functions that effectively balance these two strategies (especially in the context of early stopping)."
      ]
    },
    {
      "heading": "4.6 Matching, indexing, and interning",
      "text": [
        "The crucial work in Fig. 3 occurs in the iteration over instantiated rules at lines 9–11.",
        "In practice, we restructure this triply nested loop as follows, where each line retains the variable bindings that result from the unification in the previous line:",
        "9. for each antecedent pattern ai that appears in some program rule r and unifies with a 10. for each way of simultaneously unifying i’s remaining antecedent patterns al.... ai_1, ai+1, ... ak with items that may have non-0 value in the chart 11. construct i’s consequent c (* all vars are bound *)",
        "Our implementation of line 9 tests a against all of the antecedent patterns at once, using a tree of simple “if ” tests (generated by the Dyna-to-C++ compiler) to share work across patterns.",
        "As an example, a = constit(“np”,3,8) will match two antecedents at line 3 of Fig. 1, but will fail to match in line 4.",
        "Because a is variable-free (for DPs), a full unification algorithm is not necessary, even though an antecedent pattern can contain repeated variables and nested subterms.",
        "Line 10 rapidly looks up the rule’s other antecedents using indices that are automatically maintained on the chart.",
        "For example, once con-stit(“np”,4,8) has matched antecedent 2 of line 3 of Fig. 1, the compiled code consults a maintained list of the chart constituents that start at position 8 (i.e., items of the form constit(Z,8,K) that have already been derived).",
        "Suppose one of these is con-stit(“vp”,8,15): then the code finds the rule’s remaining antecedent by consulting a list of items of the form rewrite(X,“np”,“vp”).",
        "That leads it to construct consequents such as constit(“s”,4,15) at line 11.",
        "By default, equal terms are represented by equal pointers.",
        "While this means terms must be “interned” when constructed (requiring hash lookup), it enforces structure-sharing and allows any term to be rapidly copied, hashed, or equality-tested without dereferencing the pointer.",
        "18 Each of the above paragraphs conceals many decisions that affect runtime.",
        "This presents future opportunities for feedback-directed optimization, where profiled runs on typical data influence the compiler."
      ]
    },
    {
      "heading": "5 Computing Gradients",
      "text": [
        "The value of goal is afunction of the axioms’ values.",
        "If the function is differentiable, we may want to get its gradient with respect to its parameters (the axiom values), to aid in numerically optimizing it."
      ]
    },
    {
      "heading": "5.1 Gradients by symbolic differentiation",
      "text": [
        "The gradient computation can be derived from the original by a program transformation.",
        "For each item a in the original program – in particular, for each axiom – the new program will also compute a new item g(a), whose value is agoal/aa.",
        "Thus, given weighted axioms, the new program computes both goal and Vgoal.",
        "An optimization algorithm such as conjugate gradient can use this information to tune the axiom weights to maximize goal.",
        "An alternative is the EM algorithm (Dempster et al., 1977) for probabilistic generative models such as PCFGs.",
        "Luckily the same program serves, since for such models, the E count (expected count) of an item a can be found as a • g(a)/goal.",
        "In other words, the inside-outside algorithm has the same structure as computing the function and its gradient.",
        "The GRADIENT transformation is simple.",
        "For example,19 given a rule c += a1 * a2 * • • • * ak' whenever ?bkl+l & & ?bk, we add a new rule g(ai) += g(c) * al * ... * ai-1 * ai+l * ... * ak/ whenever ?ai, for each i = 1, 2,..., V. (The original rule remains, since we need inside values to compute outside values.)",
        "This strategy for computing the gradient agoal/aa via the chain rule is an example of automatic differentiation in the reverse mode (Griewank and Corliss, 1991), known in the neural network community as back-propagation."
      ]
    },
    {
      "heading": "5.2 Gradients by back-propagation",
      "text": [
        "However, what if goal might be computed only approximately, by early stopping before convergence (§4.5)?",
        "To avoid confusing the optimizer, we want the exact gradient of the approximate function.",
        "To do this, we “unwind” the computation of goal, undoing the value updates while building up the gradient values.",
        "The idea is to differentiate an “unrolled” version of the original computation (Williams and Zipser, 1989), in which an item at 19More generally, g(ai) = agoal/aai = E. agoal/ac ac/aai = E. g(c) • ac/aai by the chain rule.",
        "1. for each a, gchart[a] := 0 and gagenda[a] := 0 (* respectively hold 8goal/8chart[a] ando9goal/8agenda[a] *) 2. gchart[goal] := 1 3. for each (a, A, old) triple that was considered at line 8 of Fig. 3, but in the reverse order (* o is agenda [a] *) 4. r := gchart[a] (* will accumulate gagenda[a]here *) 5. for each inference rule “c += al * a2 * * ak” 6. for i from 1 to k 7. for each way of instantiating the rule’s variables such that ai = a 8. for h from 1 to k such that ah is not a side cond.",
        "time t is considered to be a different variable (possibly with different value) than the same item at time t + 1.",
        "The reverse pass must recover earlier values.",
        "Our somewhat tricky algorithm is shown in Fig. 4.",
        "At line 3, a stack is needed to remember the sequence of (a, old, A) triples from the original computation.20 It is a more efficient version of the “tape” usually used in automatic differentiation.",
        "For example, it uses 0(n2) rather than 0(n 3) space for the CKY algorithm.",
        "The trick is that Fig. 3 does not record all its computations, but only its sequence of items.",
        "Fig.",
        "4 then reruns the inference rules to reconstruct the computations in an acceptable order.",
        "This method is a generalization of Eisner’s (2001) prioritized forward-backward algorithm for infinite-state machines.",
        "As Eisner (2001) pointed out, the tape created on the first forward pass can also be used to speed up later passes (i.e., after the numerical optimizer has adjusted the axiom weights).21 20If one is willing to risk floating-point error, then one can store only (a, old) on the stack and recover A as chart[a] – old.",
        "Also, agenda [a] and gagenda [a] can be stored in the same location, as they are only used during the forward and the backward pass, respectively.",
        "21 In brief, a later forward pass that chooses a at Fig. 3, line 4 according to the recorded tape order (1) is faster than using a priority queue, (2) avoids ordering-related discontinuities in the objective function as the axiom weights change, (3) can prune by skipping useless updates a that scarcely affected goal (e.g.,"
      ]
    },
    {
      "heading": "5.3 Parameter estimation",
      "text": [
        "To support parameter training using these gradients, our implementation of Dyna includes a training module, DynaMITE.",
        "DynaMITE supports the EM algorithm (and many variants), supervised and unsupervised training of log-linear (“maximum entropy”) models using quasi-Newton methods, and smoothing-parameter tuning on development data.",
        "As an object-oriented C++ library, it also facilitates rapid implementation of new estimation techniques (Smith and Eisner, 2004; Smith and Eisner, 2005)."
      ]
    },
    {
      "heading": "6 Program Transformations",
      "text": [
        "Another interest of Dyna is that its high-level specifications can be manipulated by mechanical source-to-source program transformations.",
        "This makes it possible to derive new algorithms from old ones.",
        "§5.1 already sketched the gradient transformation for finding Vgoal.",
        "We note a few other examples.",
        "Bounding transformations generate a new program that computes upper or lower bounds on goal, via generic bounding techniques (Prieditis, 1993; Culberson and Schaeffer, 1998).",
        "The A* heuristics explored by Klein and Manning (2003a) can be seen as resulting from bounding transformations.",
        "With John Blatz, we are also exploring transformations that can result in asymptotically more efficient computations of goal.",
        "Their unweighted versions are well-known in the logic programming community (Tamaki and Sato, 1984; Ramakrish-nan, 1991).",
        "Folding introduces new intermediate items, perhaps exploiting the distributive law; applications include parsing speedups such as (Eisner and Satta, 1999), as well as well-known techniques for speeding up multi-way database joins, constraint programming, or marginalization of graphical models.",
        "Unfolding eliminates items; it can be used to specialize a parser to a particular grammar and then to eliminate unary rules.",
        "Magic templates introduce top-down filtering into the search strategy and can be used to derive Earley’s algorithm (Minnen, 1996), to introduce left-corner filters, and to restrict FSM constructions to build only accessible states.",
        "Finally, there are low-level optimizations.",
        "Term constituents not in any good parse) by consulting gagenda[a] values that the previous backward pass can have written onto the tape (overwriting 0 or old).",
        "transformations restructure terms to change their layout in memory.",
        "We are also exploring the introduction of declarations that control which items use the agenda or are memoized in the chart.",
        "This can be used to support lazy or “on-the-fly” computation (Mohri et al., 1998) and asymptotic space-saving tricks (Binder et al., 1997)."
      ]
    },
    {
      "heading": "7 Usefulness of the Implementation 7.1 Applications",
      "text": [
        "The current Dyna compiler has proved indispensable in our own recent projects, in the sense that we would not have attempted many of them without it.",
        "In some cases, we were experimenting with genuinely new algorithms not supported by any existing tool, as in our work on dependency-length-limited parsing (Eisner and Smith, 2005b) and loosely syntax-based machine translation (Eisner and D. Smith, 2005).",
        "(Dyna would have been equally helpful in the first author’s earlier work on new algorithms for lexicalized and CCG parsing, syntactic MT, transformational syntax, trainable parameterized FSMs, and finite-state phonology.)",
        "In other cases (Smith and Eisner, 2004; Smith and Smith, 2004; Smith et al., 2005), Dyna let us quickly replicate, tweak, and combine useful techniques from the literature.",
        "These techniques included unweighted FS morphology, conditional random fields (Lafferty et al., 2001), synchronous parsers (Wu, 1997; Melamed, 2003), lexicalized parsers (Eisner and Satta, 1999),22 partially supervised training a` la (Pereira and Schabes, 1992),23 and grammar induction (Klein and Manning, 2002).",
        "These replications were easy to write and extend, and to train via §5.2."
      ]
    },
    {
      "heading": "7.2 Experiments",
      "text": [
        "We compared the current Dyna compiler to hand-built systems on a variety of parsing tasks.",
        "These problems were chosen not for their novelty or interesting structure, but for the availability of existing well-tuned implementations.",
        "Best parse.",
        "We compared a Dyna CFG parser to the Java parser of Klein and Manning (2003b),24",
        "on the same grammar.",
        "Fig.",
        "5 shows the results.",
        "Dyna’s disadvantage is greater on longer sentences – probably because its greater memory consumption results in worse cache behavior.",
        "25 We also compared a Dyna CKY parser to our own hand-built implementation, C++PARSE.",
        "C++PARSE is designed like the Dyna parser but includes a few storage and indexing optimizations that Dyna does not yet have.",
        "Fig.",
        "6 shows the 5 fold speedup from these optimizations on binarizedTreebank parsing with a large 119K-rule grammar.",
        "The sharp diagonal indicates that C++PARSE is simply a better-tuned version of the Dyna parser.",
        "These optimizations and others are now being incorporated into the Dyna compiler, and are expected 25 Unlike Java, Dyna does not yet decide automatically when to perform garbage collection.",
        "In our experiment, garbage collection was called explicitly after each sentence and counted as part of the runtime (typically 0.25 seconds for 10-word sentences, 5 seconds for 40-word sentences).",
        "99% 99.99% uniform 89.3 (4.5) 90.3 (4.6) after 1 EM iteration 82.9 (6.8) 85.2 (6.9) after 2 EM iterations 77.1 (8.4) 79.1 (8.3) after 3 EM iterations 71.6 (9.4) 73.7 (9.5) after 4 EM iterations 66.8 (10.0) 68.8 (10.2) after 5 iterations 62.9 (10.3) 65.0 (10.5)",
        "the percentage of agenda runtime (mean across 1409 sentences, and standard deviation) required to get within 99% or 99.99% of the true value of goal.",
        "to provide similar speedups, putting Dyna’s parser in the ballpark of the Klein & Manning parser.",
        "Importantly, these improvements will speed up existing Dyna programs through recompilation.",
        "Inside parsing.",
        "Johnson (2000) provides a C implementation of the inside-outside algorithm for EM training of PCFGs.",
        "We ran five iterations of EM on the WSJ10 corpus26 using the Treebank grammar from that corpus.",
        "Dyna took 4.1 times longer.",
        "Early stopping.",
        "An advantage of the weighted agenda discipline (§4.2) is that, with a reasonable priority function such as an item’s inside probability, the inside algorithm can be stopped early with an estimate of goal’s value.",
        "To measure the goodness of this early estimate, we tracked the progression of goal’s value as each sentence was being parsed.",
        "In most instances, and especially after more EM iterations, the estimate was very tight long before all the weight had been accumulated (Table 1).",
        "This suggests that early stopping is a useful training speedup.",
        "PRISM.",
        "The implemented tool most similar to Dyna that we have found is PRISM (Zhou and Sato, 2003), a probabilistic Prolog with efficient tabling and compilation.",
        "PRISM inherits expressive power from Prolog but handles only probabilities, not general semirings (or even side conditions).27 In CKY parsing tests, PRISM was able to handle only a small fraction of the Penn Treebank ruleset (2,400 high-probability rules) and tended to crash on long sentences.",
        "Dyna is designed for real-world use: it consistently parses over 10 x faster than PRISM and scales to full-sized problems.",
        "IBAL (Pfeffer, 2001) is an elegant and powerful language for probabilistic modeling; it generalizes Bayesian networks in interesting ways.28 Since",
        "PCFGs and marginalization can be succinctly expressed in IBAL, we attempted a performance comparison on the task of the inside algorithm (Fig.",
        "1).",
        "Unfortunately, IBAL’s algorithm appears not to terminate if the PCFG contains any kind of recursion reachable from the start symbol."
      ]
    },
    {
      "heading": "8 Conclusions",
      "text": [
        "Weighted deduction is a powerful theoretical formalism that encompasses many NLP algorithms (Goodman, 1999).",
        "We have given a bottom-up “inside” algorithm for general semiring-weighted deduction, based on a prioritized agenda, and a general “outside” algorithm that correctly computes weight gradients even when the inside algorithm is pruned.",
        "We have also proposed a declarative language, Dyna, that replaces Prolog’s Horn clauses with “Horn equations” over terms with values.",
        "Dyna can express more than the semiring-weighted dynamic programs treated in this paper.",
        "Our ongoing work concerns the full Dyna language, program transformations, and feedback-directed optimization.",
        "Finally, we evaluated our first implementation of a Dyna-to-C++ compiler (download and documentation at http: //dyna.",
        "org).",
        "We hope it will facilitate EMNLP research, just as FS toolkits have done for the FS case.",
        "It produces code that is slower than hand-crafted code but acceptably fast for our NLP research, where it has been extremely helpful."
      ]
    }
  ]
}
