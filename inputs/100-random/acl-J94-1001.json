{
  "info": {
    "authors": [
      "Mark Johnson"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J94-1001",
    "title": "Computing With Features as Formulae",
    "url": "https://aclweb.org/anthology/J94-1001",
    "year": 1994
  },
  "references": [
    "acl-C86-1045",
    "acl-C86-1156",
    "acl-C88-1060",
    "acl-C88-1061",
    "acl-C90-1003",
    "acl-C90-2018",
    "acl-E91-1007",
    "acl-E93-1004",
    "acl-J88-4001",
    "acl-J90-1002",
    "acl-J91-2001",
    "acl-J92-2002",
    "acl-J92-4004",
    "acl-J93-4001",
    "acl-P83-1020",
    "acl-P84-1008",
    "acl-P86-1038",
    "acl-P87-1013",
    "acl-P87-1033",
    "acl-P88-1029",
    "acl-P88-1035",
    "acl-P90-1022",
    "acl-P91-1002",
    "acl-P91-1042"
  ],
  "sections": [
    {
      "text": [
        "This paper extends the approach to feature structures developed in Johnson (1991a), which uses Schtinfinkel-Bernays' formulae to express feature structure constraints.",
        "These are shown to be a disjunctive generalization of Datalog clauses, as used in database theory.",
        "This paper provides a fixed-point characterization of the minimal models of these formulae that serves as the theoretical foundation of a forward-chaining algorithm for determining their satisfiability.",
        "This algorithm, which generalizes the standard attribute-value unification algorithm, is also recognizable as a nondeterministic variant of the semi-naive bottom-up algorithm for evaluating Datalog programs, further strengthening the connection between the theory of feature structures and databases."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Despite their simplicity, a surprisingly wide range of linguistic phenomena can be described in terms of simple equality constraints on values in attribute-value structures, which are a particularly simple kind of feature structure (see Shieber 1986; Johnson 1988; Uszkoreit 1986; and Bresnan 1982 for examples of some of these analyses).",
        "But some phenomena do not seem to be able to be described in such a pure 'unification' framework.",
        "For example, the analysis of conjunctions in LFG (Kaplan and Maxwell 1988b) and the formalizations of Discourse Representation Theory (Kamp 1981) presented in Johnson and Klein (1986) and Johnson and Kay (1990) require additional mechanisms for representing and manipulating aggregates or sets of values in ways that are beyond the capability of such \"pure\" attribute-value systems.",
        "Further, sortal constraints (which also cannot be expressed as simple equality constraints) can be used to formulate simpler and more comprehensible grammars (Carpenter 1992; Carpenter and Pollard 1991; Pollard and Sag 1987, 1992).",
        "Versions of both of these kinds of constraint, as well as the familiar attribute-value constraints, can be expressed as SchOnfinkel-Bernays' formulae (as demonstrated in Johnson 1991a, 1991b), so that the problem of determining the satisfiability of a system of such constraints is reduced to the satisfiability problem for the corresponding formula.",
        "This class of formulae (defined in Section 3.1) seems to be expressive enough for most linguistic purposes when used with an external phrase-structure backbone.",
        "That is, these formulae are used as annotations on phrase structure rules in the manner described in, e.g., Kaplan and Bresnan (1982), Shieber (1986), and Johnson (1988).",
        "This paper extends the author's previous paper on the topic (Johnson 1991a) by sketching several other linguistic applications of Schiinfinkel-Bernays' formulae (including a version of D-theory [Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992I), and presenting a least-fixed-point theorem that serves as the theoretical basis for a \"forwardchaining\" algorithm for determining satisfiability of Schonfinkel-Bernays' formulae.",
        "Interestingly, this algorithm can be viewed both as a straightforward generalization",
        "of the standard attribute-value unification algorithm and also as a nondeterministic variant of the semi-naive evaluation method for Datalog clauses.",
        "Several extended \"unification-based\" constraint formalisms have been developed.",
        "In this paper, the term \"feature structure\" denotes any kind of structured entity used as a component of a category label.",
        "An attribute-value structure is a particularly simple kind of feature structure of the kind used in \"pure\" unification-based frameworks (Shieber 1986).",
        "Some extensions to the basic attribute-value framework are rather weak, e.g., allowing disjunctive and negative constraints and preserving decidability.1 Such systems require an \"off-line\" phrase structure backbone to which these constraints are attached.",
        "It seems that most of the constraints that can be expressed in these formalisms can be expressed as SchEinfinkel-Bernays' formulae, the constraint formalism described below.",
        "A second class of extended constraint formalisms has been devised to be capable of expressing the entire grammar as systems of constraints and as far as I know, for all of these systems the problem of determining the satisfiability of an arbitrary system of constraints that they can express is undecidable.2 This is because the recognition problem for an arbitrary \"unification-based\" grammar is undecidable unless the size of the phrase structure tree is constrained somehow, e.g., by the offline parsability constraint (Johnson 1988; Kaplan and Bresnan 1982; Pereira 1982; Shieber 1992), but there seems to be no natural way to impose such constraints in these systems because the encoding of the phrase structure tree in the feature structure is not distinguished from other features.' Thus in order to maintain decidability the system described here is not designed to be capable of expressing phrase structure constraints directly, and must be used with an external phrase-structure component, as in LFG (Bresnan 1982).",
        "(However, Bob Carpenter [p.c.]",
        "points out that one can impose a bound on the size of the feature structure that can serve as an analysis [say, some polynomial of the length of the input], and so ensure decidability.)",
        "Interestingly, a first-order logic-based approach similar to the one presented in this paper can also be developed for extended constraint formalisms capable of expressing the entire grammar, but this is not discussed further here; see Johnson (in press b) for details.",
        "In the approach developed here SchOnfinkel-Bernays' formulae are used to express a variety of feature structure constraints.",
        "Previous work has shown that these formulae are expressive enough to define arbitrary disjunctions and negations of constraints (Johnson 1990a, 1990b), a kind of 'set-valued' entity (Johnson 1991a), and they can be used to impose useful sort constraints (Johnson 1991b).",
        "The expression of D-theory constraints on nodes in trees is discussed in this paper.",
        "This paper extends the ideas in these earlier papers with theoretical results that suggest a forward-chaining algorithm for determining the satisfiability of an arbitrary Schiinfinkel-Bernays' formula.",
        "This generalizes the standard feature-graph unification algorithm and is closely related to the semi-naive bottom-up algorithm used in database theory.",
        "I For examples of this approach see Dawar and Vijay-Shanker (1990), DOrre and Eisele (1990), Johnson (1988, 1990a, 1990b, 1991a, 1991b, in press a), Karttunen (1984), Kasper (1987a, 19871), 1988), Kasper and Rounds (1986, 1990), Langholm (1989), Pereira (1987), and Smolka (1992).",
        "Specifically, it is shown that the satisfying Herbrand models of an arbitrary SchOn-finkel-Bernays' formula are the fix points of certain functions, and that the least fixed points of these functions are all of the models of the formula that are \"minimal\" in a certain sense.",
        "This leads to a forward-chaining algorithm for computing all of the atomic consequences of a SchOnfinkel-Bernays' formula; the fixed-point theorem shows that this suffices to determine the satisfiability of an arbitrary SchOnfinkel-Bernays' formula."
      ]
    },
    {
      "heading": "2. Constraints, Partial Information, and Feature Structures",
      "text": [
        "This approach exploits the fact that constraints on well-formed linguistic structures (e.g., well-formedness constraints imposed by the grammar) do not need to be isomorphic to the structures that satisfy them.",
        "Although the distinction between constraints and structures that satisfy them might seem too obvious to warrant comment, it is not made in most work on feature structures.",
        "A common view holds that feature structures are inherently \"partially specified\" entities, which \"unify\" or merge with other feature structures to yield more instantiated feature structures in an \"information-preserving\" way (Shieber 1986).",
        "If two feature structures contain \"contradictory information,\" then it is impossible to merge them to produce a consistent object; unification is then said to fail.",
        "The feature structure for an utterance is the result (if one exists) of unifying all of the feature structures for the lexical entries and syntactic rules in appropriate ways.",
        "Thus in this view feature structures play two roles; not only do they serve as linguistic structures, but they are also used to encode constraints that the linguistic structures must satisfy (see Section 2.10 of Johnson (1988) for an extended discussion).",
        "That is, under this view feature structures serve not only as linguistic structures that may or may not satisfy a constraint, but are also interpreted as 'representing' or 'describing' all of the feature structures that they subsume.",
        "Given this dual role for feature structures, it is important in this approach that if a feature structure S satisfies a constraint a, then every feature structure subsumed by S should also satisfy a (Pereira 1987).",
        "If this \"upward closure\" property holds, then the set of feature structures satisfying any constraint can be represented by the set of its \"minimal models.\"",
        "Unfortunately, many useful constraints do not have this property.",
        "For example, under a classical interpretation, the set of feature structures satisfying negated feature structure constraints are not upward-closed (Moshier and Rounds 1987).",
        "The work described in this paper pursues a different approach.",
        "Following Kaplan and Bresnan (1982), feature structures are only (components of) linguistic structures, and not partial descriptions of (other) linguistic structures.",
        "As such, a feature structure either does or does not satisfy any particular set of constraints.",
        "An utterance is well-formed just in case there is some linguistic structure that satisfies all of the constraints imposed by the grammar and has the phonological form of that utterance as its phonological form (which itself is just another constraint that the structure must satisfy).",
        "Since the relationship between a feature structure and a constraint that it satisfies is essentially the same as the relationship between an interpretation and a formula that is true under that interpretation, it seems natural to conceive of a constraint as a kind of formula (in a format that allows efficient computational manipulation) that has feature structures as its intended interpretations.",
        "This approach is more general in that it does not rely on the upward-closure property, and it allows constraints on feature structures to have a structure quite different from the feature structures that they constrain.",
        "The subsumption relation on",
        "feature structures plays no special role in this approach; specifically, it is not required that the set of structures that satisfy a constraint be upward-closed.",
        "In general, a linguistic structure S must satisfy several constraints, say al, , in order to be well formed, so in order to solve the recognition and parsing problems, all we need do is determine if there are any S that satisfy al, , a,,, and if so, describe them somehow.",
        "It is convenient to devise a language for expressing constraints, so that the al are well-formed formulae of this language, and its satisfaction relation is exactly the satisfaction relation mentioned above.",
        "Viewed from this perspective, the problem of determining if there is a structure S that satisfies the constraints at, ..., a, is the same as the problem of determining if the formula a is satisfiable, where a is al A • • • A a,, and conjunction is given the standard interpretation.",
        "Algorithms for deciding the satisfiability of arbitrary formulae in this language (if they exist) can therefore be used to determine the satisfiability of the linguistic constraints.",
        "Moreover, if a a' then a' is a true description of every model of a, i.e., the logical consequences of a are descriptions of every well-formed linguistic structure that satisfies the constraints.",
        "Thus the logic of the constraint language provides in principle all the necessary tools for determining if a set of constraints are satisfiable, and if they are, providing descriptions of the satisfying structures.",
        "From this perspective, an \"information state\" is a kind of formula, and \"unifying\" two such information states is accomplished by conjoining them and simplifying the resulting formula, not by some manipulation of their models.",
        "Partial information states are those that are satisfied by more than one interpretation.",
        "The consequence relation corresponds to the subsumption relation of traditional unification grammar (a formula a \"contains more information\" than formula a' iff a a`), and unsatisfiability corresponds to unification failure."
      ]
    },
    {
      "heading": "3. Languages for Expressing Feature Structure Constraints",
      "text": [
        "There are many different possible constraint languages.",
        "Specialized languages can be constructed specifically for the task of expressing feature structure constraints (such as Kasper and Rounds's FDL [Kasper and Rounds 19901 and Johnson's attribute-value languages [Johnson 19881).",
        "Alternatively, the constraints may be able to be expressed in some standard language, so that the satisfiability problem for linguistic constraints is reduced to the satisfiability problem for that language, as is done here.' Johnson (1990a), following a suggestion first made in Kaplan and Bresnan (1982), showed how attribute-value constraints could be formalized in the quantifier-free subset of first-order logic, while later work (Johnson 1991a, 1991b) proposed a different formalization in the Scheinfinkel-Bernays' subset of first-order formulae.' Roughly speaking, there is a trade-off between the expressive power of a language and its computational tractability.",
        "For example, the satisfiability problem for the language consisting of conjunctions of equalities and inequalities of first-order terms can",
        "be decided in quasilinear time using the congruence-closure algorithm, but this language can only express conjunctions of feature-value equalities and inequalities.",
        "If this language is extended to allow disjunctions (so that disjunctive feature-value constraints can be expressed), the satisfiability problem becomes NP-complete (Gallier 1986; Kasper and Rounds 1990; Nelson and Oppen 1980).",
        "Since disjunctive constraints seem to be a practical necessity for describing natural languages (Barton, Berwick, and Ristad 1987; Karttunen 1984), most practical feature structure systems will probably have NP-hard satisfiability problems.",
        "Given that we have to solve an NP-hard problem anyway, it seems reasonable to investigate the most expressive feature structure constraint language that has an NP-complete satisfiability problem.",
        "The Schtinfinkel-Bernays' class, used in the manner described here, appears to be the most expressive language for feature structure constraints proposed in the literature so far whose satisfiability problem is no harder than NP."
      ]
    },
    {
      "heading": "3.1 The Schtinfinkel-Bernays' Class",
      "text": [
        "The Schonfinkel-Bernays' class (hereafter 513) is the class of first-order closed prenex formulae without function symbols in which no existential quantifier occurs in the scope of any universal quantifier.",
        "That is, a formula is in SB iff it has no free variables and is of the form",
        "where o contains no quantifier symbols or function symbols.",
        "SB formulae are a proper subset of first-order formulae, and they are interpreted in exactly the same way as first-order formulae.",
        "The body a may contain boolean connectives (including negation), which can be used to express arbitrary boolean combinations of constraints.",
        "Unlike the satisfiability problem for full first-order logic, which is undecidable (co-recursively enumerable), the satisfiability problem for SB is decidable; in fact it is PSPACE-complete (Lewis and Papadimitriou 1981).",
        "Further, if SB„ is the class of SB formulae with n or fewer universal quantifiers, then for any fixed n the satisfiability problem for 513,, is NP-complete (Lewis 1980).",
        "In the applications described here, the number of universal quantifiers is fixed (i.e., it does not vary with the utterance or even with the grammar), so the corresponding satisfiability problems are all NP-complete.",
        "The class of SB formulae is interesting for other reasons besides its ability to express a wide range of linguistic constraints.",
        "As shown below, the class of SB formulae in clausal form constitute an extension of Datalog that allows disjunctive consequents."
      ]
    },
    {
      "heading": "3.2 Formalizing Attribute-Value Structures Using SIB",
      "text": [
        "SB is both simple and expressive enough that grammar designers might choose to state linguistic constraints directly in SB, rather than in terms of attributes and values.",
        "Nevertheless, it is important to understand how the properties of attribute-value structures can be stated in SB, since many of the techniques used to formalize them can be applied to other linguistically interesting structures as well.",
        "In fact there are several ways of formalizing attribute-value structures in SB, all of which seem to be linguistically equivalent.",
        "What follows is a formalization in SB that allows values to be used as attributes and allows attributes to be quantified over (this is handy for stating \"sort constraints\"), but no special claims are made for it over and above any other SB formalization.",
        "Following Johnson (1991b), attribute-value feature structures can be specified in SB in the following way.",
        "We can conceptualize of attribute-value arcs as instances of",
        "a three-place relation arc, where arc(x, a, y) means that there is an arc leaving node x labeled a pointing to node y.6 Of course, not all interpretations qualify as attribute-value structures; e.g., those which satisfy both arc(x, a, y) and arc(x, a, z) for some y z violate the requirement that there is at most one arc with any given label leaving any node.",
        "We can express this requirement as an SB formula that is true in the intended interpretations (namely attribute-value feature structures)."
      ]
    },
    {
      "heading": "Vx Va Vy Vz arc(x,a,y) A arc(x,a,z) y = z. (1)",
      "text": [
        "Similarly, we can express the properties of the \"attribute-value constants\" with SB formulae.",
        "Let con be a property (i.e., a one-place relation) true of the \"attribute-value constant\" elements.",
        "These elements are required to have no arcs leaving them.",
        "The following formula expresses this requirement.",
        "Note that the word \"constant\" in the name \"attribute-value constant\" is misleading here, since in this framework not all SB constant symbols will denote attribute-value \"constants.\"",
        "More precisely, being an 'attribute-value constant' is a property of an individual in an interpretation (i.e., an element of a feature structure), whereas being a constant is a property of a symbol in a formula.",
        "Constants can be used to denote complex attribute-value entities as well as attribute-value constants.",
        "Finally, we require that the names of attribute-value constants denote distinct attribute-value constants.",
        "We reserve a finite subset N of the constants of our language for use as the names of attribute-value constants, and require that they satisfy the following schemata.'",
        "Schema (3) requires each symbol in N to denote an attribute-value constant, and schema (4) enforces distinctness in essentially the same manner as that used in the specification systems of algebraic data-type theory (Kapur and Musser 1987).",
        "Formulas (1) and (2) and the instances of schemata (3) and (4) can be regarded as defining attribute-value feature structures.",
        "These axioms are quite permissive: in",
        "(i) For each c in N, Vi Vy c(x) A c(y) x y.",
        "(Uniqueness) (ii) For each c in N, Vx c(x) con(x).",
        "(Constant property) (iii) For each distinct pair ci, c2 in N, Vx ti (cl(x) A c2(x)).",
        "(Disjointness)",
        "Three constraints expressed as formulae and also depicted graphically.",
        "addition to the usual finite acyclic feature structures, they allow infinite structures, cyclic structures, structures in which complex values serve as attributes, etc.",
        "While ruled out by fiat in standard treatments, admitting these additional structures causes no linguistic difficulties that I am aware of (in fact, some analyses crucially depend on their existence, as described in section 2.1.3 of Johnson [19881), so in the interests of parsimony additional constraints that forbid them are not stipulated.",
        "In fact, because SB formulae possess the finite model property (i.e., if an SB formula has a model, then it has a finite model), restricting attention to finite models does not change the set of satisfiable SB formulae.",
        "Therefore it could have no effect on the set of well-formed utterances.",
        "Cyclic feature structures can be prohibited with a constraint formalizable in SB, as described in Johnson (1991b), and one can express a constraint in SB that requires that all attributes are \"attribute-value constants\" (even though there appears to be no linguistic motivation for such a constraint, and indeed, some analyses crucially depend on this not being the case, as pointed out in Johnson [19881).",
        "To summarize, the simplest SB axioms defining attribute-value structures are quite permissive, allowing a wider range of structures to count as attribute-value structures than many other formalizations.",
        "However, all of the major restrictions on attribute-value structures discussed in the literature either have no effect whatsoever in this framework, or else can be directly stated as additional SB constraints."
      ]
    },
    {
      "heading": "3.3 Expressing Feature Structure Constraints with SB",
      "text": [
        "In this approach, simple attribute-value constraints are represented by quantifier-free atomic formulae.",
        "For example, a constraint that the value of n's ai arc is b1 would be represented by the atom arc(n, b1), a constraint that the value of n's a2 arc is b2 is represented by arc(n, a2, b2), and a constraint that the value of n's al arc is the same as the value of its a2 arc is represented by the conjunction arc(n, al, rit) A arc(n, a2, 11') (n' is the single value of both arcs).",
        "These three constraints are depicted graphically in Figure 1.",
        "Note that the graphs in this figure are (depictions of) formulae, not attribute-value feature structures.",
        "Attribute-value \"unification\" is the conjunction and simplification of the formulae expressing the constraints to be unified.",
        "If all three constraints in the example of Figure 1 are conjoined together with axioms (1-3) above, then by (1) it follows that bi nt = b2.",
        "Further, if b1 and b2 are distinct constant symbols in N (thus they name attribute-value constants), then b1 b2 is an instance of (4), and the conjunction is therefore unsatisfiable.",
        "For further examples and a discussion of how the disjunction and negation of attribute-value constraints are transparently representable as SB formulae, see Johnson (1991a, 1991b).",
        "A major motivation for using SB is that a wide variety of constraints, in addition to standard attribute-value constraints, can be expressed using it.",
        "This allows a grammar developer to introduce a wide variety of \"designer features\" with possibly idiosyncratic, customized properties, while guaranteeing that the composite system is decidable (usually in NP-time, as noted above).",
        "For example, suppose we want to impose sort restrictions of the following kind.",
        "To abbreviate the lexical entries of verbs we might introduce the one-place predicate 3rd-sg, where 3rd-sg(x) indicates that the value of x's person attribute is 3rd and x's number attribute is singular.",
        "This constraint can be expressed using the following SB formula.",
        "Similarly, constraints that restrict the possible values of certain attributes can be imposed.",
        "For example, one might want to require that the value of every arc labeled number is either singular or plural.",
        "This constraint can be expressed as the following SB formula.",
        "These examples demonstrate only a small fraction of the variety of the feature structure constraints that can be expressed in SB.",
        "Even though all of these examples are based on attribute-value features, other sorts of features can be described in SB as well.",
        "For example, Johnson (1991a) shows how to formulate a variety of constraints on `set-valued' features in SB."
      ]
    },
    {
      "heading": "3.4 Expressing Tree Structure Constraints with SB Formulae",
      "text": [
        "Inspired by the work on description theory or 'D-theory' (Marcus, Hindle, and Fleck 1983; Vijay-Shanker 1992), this section shows how some elementary constraints on precedence and dominance in a tree can be expressed as SB formulae.",
        "It differs from that work in that different kinds of constraints are expressible (Vijay-Shanker was concerned with the formalization of a different kind of grammar), and that all of the constraints expressible in the system described below are decidable (this follows from the fact that they are defined and expressed using SchOnfinkeI-Bernays' formulae).",
        "These constraints are intended to appear as annotations on phrase structure rules (in the same way that attribute-value constraints do) and could be used to enforce a variety of \"long-distance\" relationships, such as the co and contra-indexing constraints of binding theory (i.e., equality and inequality constraints on the values of index attributes).",
        "The axiomatization begins by defining the primitive tree structure relations precedes and dominates.",
        "Once these primitive tree structure relations are defined, they can be used to approximate more complex relationships such as c-commands , as described below.",
        "All of these axioms are in the SchEinfinkel-Bernays' class, so the satisfiability of arbitrary boolean combinations of such constraints is decidable.",
        "First, note that the standard definition of trees in terms of the binary relations < (linear precedence) and D (domination) can be expressed directly as SchEinfinkel-Bernays' formulae.",
        "The axioms presented below are just the definitions of trees given in Partee, ter Meulen, and Wall (1990) and Wall (1972) using the syntax of first-order logic.",
        "Axioms (7a-c) require that < is a strict partial order, and axioms (8a-c) require",
        "Finally, the following axioms (implicit in the standard treatments cited above) require the precedence and dominance relations to range over tree nodes.",
        "This concludes the specification of linear precedence and dominance relations over nodes.",
        "We now turn to the specification of other relations in terms of these.",
        "The proper dominance relation F can be defined in terms of dominance as follows.",
        "However, many interesting linguistic relations cannot be defined by SchOnfinkel-Bernays' axioms.",
        "For example, the c-commands relation C is defined by the following formula (which says that x c-commands y iff x does not dominate y, and every node z that properly dominates x also properly dominates y).",
        "It is easy to see that this definition is not equivalent to a Schenfinkel-Bernays' formula by expanding the equivalence into two implications and moving the embedded quantifier out.",
        "First, we can abandon the attempt to work within the Schonfinkel-Bernays' class, and work with some other language.",
        "Rounds (1988) describes such a language called up, whose decidability follows from the fact that the domain of quantification is",
        " restricted (just as in SB).",
        "However, it seems to be difficult to devise a decidable system capable of simultaneously expressing both tree structure and the variety of feature structure constraints that the SB approach described here can.",
        "Blackburn, Gardent, and Meyer-viol (1993) introduce a modal language LT for describing trees decorated with feature structures, whose satisfiability problem is undecidable.",
        "In the long run, such specialized \"designer logics\" may provide the most satisfying integration of tree structure and feature structure constraints.",
        "Second, the 'one-sided' approximation (14a) can be used in place of the correct axiom (14).",
        "The effect of using such one-sided approximations was investigated in Johnson (1991a).",
        "It was shown there that if is a formula such as the one in (14) and is the one-sided approximation (14a), then for any formula y+(C) in which C only appears positively, A q;+F(C) is satisfiable iff A co+ (C) is satisfiable.",
        "That is, if we are concerned only with positively occurring constraints, we can simplify (14) to (14a), i.e., ignore (14b), without affecting constraint satisfiability.",
        "Third, we can regard formulae such as (14) as the \"macro\" (15), used to expand constraints at the interface between the syntactic rules and the constraint solver.",
        "This \"macro expansion\" rewrites c-commands constraints into boolean combinations of constraints that the constraint solver can handle.",
        "The second and the third approaches differ in important ways.",
        "In the second approach, c-commands is a relation that is \"understood\" by the constraint solver (albeit only in its one-sided form), so it can be used to define other relations.",
        "In the third approach, c-commands constraints are not primitive constraints, so relations defined in terms of c-commands must also be expressible in terms of \"macro expansion.\"",
        "In the second approach, constraints are quantifier-free formulae (quantifiers appear only in the axioms), so the satisfiability problem is in NP.",
        "But in the third approach, macro expansion produces formulae that contain additional quantifiers, so the satisfiability problem may be PSPACE-complete."
      ]
    },
    {
      "heading": "3.5 Limitations on Constraints Expressible with SB Formulae",
      "text": [
        "Of course, SB is not as expressive as full first-order logic.",
        "It is incapable of expressing functional relationships, since these require an existential quantifier inside the scope of a universal quantifier.",
        "This means, among other things, that it is impossible to state a constraint in SB requiring that a certain node must exist (as was noted in the discussion of c-command in the previous section) or that all nodes possess certain attributes.",
        "Thus for example, the following constraint, which requires that every tensed entity possess number and person attributes, is a first-order formula that is not in SB, since it requires a functional relationship between entities with tense attributes and the values of their number and person attributes.",
        "Similarly, a number of other extensions to the basic attribute-value framework discussed in the literature cannot be formalized in SB.",
        "Subsumption constraints, used in the treatment of (natural language) conjunction, are not expressible as SB formulae because the satisfiability problem for conjunctions of subsumption and attribute-value constraints is undecidable (Thirre and Rounds 1992).",
        "Positively occurring functional",
        "Equality axiom schemata for a first-order formula r,o.",
        "uncertainty constraints, used in the LFG treatment of long-distance dependencies (Kaplan and Zaenen 1989) appear to have a decidable satisfiability problem (Kaplan and Maxwell 1988a), but the satisfiability problem for arbitrary boolean combinations of functional uncertainty constraints is undecidable (Keller 1991), so these cannot be expressed using SB formulae either (since the quantifier-free subclass of SB is closed under boolean operations)."
      ]
    },
    {
      "heading": "3.6 The Equality Relation",
      "text": [
        "In this paper the intended interpretation of the equality relation is identity; i.e., a b if and only if a and h denote the same individual.",
        "However, for some purposes (e.g., in the least-fixed-point characterization of minimal models given below) this \"special\" interpretation of the equality complicates matters, and it is more convenient to treat the equality relation as a \"normal\" relation that is defined by a set of axioms E. The idea is that E has the property that a formula cp is satisfiable under the identity interpretation of equality if and only if {y} U E is satisfiable in an interpretation in which equality is not given any special treatment.",
        "In effect, the axioms E require that the equality relation denotes an equivalence relation, and permit the substitution of equals for equals.",
        "Together these imply that no predicate can distinguish equal individuals.",
        "This means that in terms of satisfiability and the consequence relation, exactly the same results are obtained irrespective of whether equality is treated as identity or defined by the axioms E. Such treatments of equality in first-order logic are well known and described in standard texts.",
        "For example, Chang and Lee (1973) give the axiom schemata in Figure 2, which generates syntactic equality axioms E for a first-order formula co, and prove that E has the properties just described.' What is important here is that for an SB formula co the instances of the axiom schemata are all SB formulae, and there are only finitely many instances of these schemata.",
        "This means that for an arbitrary SB formula cp there is another SB formula such that co is satisfiable with respect to an identity interpretation of equality if and only if cp/14.",
        "is satisfiable with respect to an interpretation in which equality is treated like any other relation.",
        "Thus a method for determining the satisfiability of SB formulae without equality can be used to determine satisfiability of SB formulae in which equality is interpreted as identity.",
        "(17) Vx x x.",
        "(18) Vx Vyx=y – >y=x.",
        "(19) Vx Va Vy Vx1 x = x1 A arc(x , a, y) arc(xi, a, y).",
        "(20) Vx Vrt Vy Val a = a1 A arc(x, y) arc(x, y)• (21) Vx Va Vy Vyi y = y1 A arc(x, a y) arc(x, a, yi).",
        "(22) Vc1 Vc2 c = c1 A con(c) cori(ci).",
        "(23) Vx Vy x y A 3rd-sg(x) 3rd-sg(y).",
        "The equality axioms for arc, con, and 3rd-sg predicates.",
        "For example, consider the 513 formulae in (1-4) and (5-16).",
        "These contain the three-place relation symbol arc and the one-place relation symbols con and 3rd-sg.",
        "The equality axioms obtained from schemata (E1 – E4) for any system of constraints that mention just these relations are given in.",
        "Figure 3."
      ]
    },
    {
      "heading": "4. Clausal Form and Disjunctive Datalog",
      "text": [
        "It is technically easier to work with a syntactically restricted class of SB formulae where the body of each formula has a particular syntactic form known as clausal form or Skotem standard form."
      ]
    },
    {
      "heading": "Definition",
      "text": [
        "A clause is a formula of the form coV--•V – cr„,1/tqlV-••VO„, where each ai and i3j is an atomic formula (i.e., is of the form p(ti,..., ti,)), and m, n > 0.",
        "A formula yo is in clausal form iff it is a conjunction of clauses.",
        "The a1 are called negative literals and the /3j are called positive literals.",
        "A clause for which m 0 (i.e., one that consists solely of positive literals) is called a positive clause, and one for which n = 0 (i.e., one that consists solely of negative literals) is called a negative clause.",
        "A clause for which n = 1 is called a definite clause.",
        "A Horn clause is a clause for which n < 1, i.e., either a negative clause or a definite clause.",
        "Abusing notation somewhat, a formula y in clausal form will sometimes also be treated as the set of the clauses that make up the conjunction y.",
        "Similarly, because clauses are used as rewriting rules below, the clause – cylV---V – an,V/3-1V-••Vi3, will sometimes be written as the equivalent implication ozi A • A am ,(31 V • • • V Ow A formula ;a in clausal form does not contain any quantifier symbols.",
        "As is standard, all variables in o are treated as implicitly universally quantified at the clausal level.",
        "Existentially quantified variables in SB formulae are inessential, in that they can always be directly replaced by Skolem constants.",
        "Restricting attention to SB formulae in clausal form imposes no real restriction on the class of constraints expressible.",
        "Standard procedures for transforming first-order formulae into clausal form, such as the ones described in Chang and Lee (1973), Duffy"
      ]
    },
    {
      "heading": "5. Determining the Satisfiability of SB Formulae",
      "text": [
        "This section describes a forward-chaining algorithm for determining the satisfiability of SB formulae in clausal form.",
        "This algorithm is a nondeterministic variant of the semi-naive evaluation method for Datalog clauses in which the union-find algorithm is used to efficiently maintain equivalence classes of equal terms.",
        "It is also recognizable as a generalization of the standard unification algorithm for feature structures to arbitrary Horn SB constraints.' The treatment is informal because the goal of the section is to point out several important standard implementation techniques rather than to advance a totally new algorithm.",
        "The key intuition behind the algorithm is this.",
        "To demonstrate the satisfiability of a set S of clauses, it is sufficient to exhibit a set A of ground atoms drawn from the Herbrand base of S such that the following conditions hold (the next section proves this assertion).",
        "(a) For no ground instance – al V • V – c of any negative clause in S are all of 4 , ar,' in A.",
        "(If they were, then that clause would be falsified by A.)",
        "(b) For each ground instance 31' V • • • V of a positive clause in S, at least one of the 811 is in A.",
        "(c) For each ground instance a; A • • A V • • V of an implication in 5, if all of the a;, are in A then so is at least one of the O.; (In fact, the other two conditions are just special cases of this condition.)",
        "9 It is a generalization of the algorithm described in Hegner (1991), which treats Horn combinations of attribute-value constraints."
      ]
    },
    {
      "heading": "5.1 Naive Evaluation",
      "text": [
        "One could attempt to find such a set A in the following manner.",
        "First, one nondeterministically selects a a; from each of the ground instances of the positive clauses in S and adds these to A.",
        "Then one attempts to close A with respect to condition (c); if all of the antecedents a; , .",
        "cx„` of some (ground instance of an) implication are in A, then one of the consequents , ,,(3„/ is nondeterministically selected and added to A, unless at least one of them is already present.",
        "(Of course, all such nondeterministic paths might have to be investigated.)",
        "Periodically, condition (a) is checked; if it fails to hold, then this nondeterministic path on the search for A must be abandoned.",
        "Nondeterminism arises solely from the presence of disjunction in consequents of clauses; if S is a set of Horn clauses then the fixed-point calculation proceeds deterministically.",
        "Ignoring the checking of condition (a), the method is essentially computing a fixed-point of the nonnegative clauses in S via a kind of iterative approximation known as naive evaluation.",
        "Naive evaluation is unnecessarily computationally inefficient.",
        "Once the set A is large enough to require an atom a to be added to A, naive evaluation \"rediscovers\" this requirement on all subsequent passes."
      ]
    },
    {
      "heading": "5.2 Semi-Naive Evaluation",
      "text": [
        "Semi-naive evaluation avoids rediscovering the same fact in the same way by insisting that each time a clause is applied at least one of the antecedents was just discovered on the previous round (Ullman 1988, 1989).",
        "This is done by maintaining two sets of atoms, A and AA, where A is the set of atoms discovered one or more iterations ago, and AA is the set of atoms discovered at the last iteration.",
        "The nondeterministic semi-naive algorithm for computing a set A (if it exists) is sketched in Figure 4.",
        "In that algorithm choose is a \"function\" that nondeterministically picks one member from its set argument; it can be implemented using, e.g., backtracking.",
        "Ullman describes methods of matching clauses in S against the sets A and AA that avoids calculating all of the ground instances of the clauses in S. The semi-naive algorithm can be used directly with the syntactic equality axioms given in Section 3.4 as a decision procedure for SB formulae, and hence for systems of feature structure constraints.",
        "However, the resulting system is inefficient because the equality axioms, specifically the instances of schemata (E2) and (E3), cause the \"copying\" of any atom containing an argument that appears in an equality atom to all members of the equivalence class containing that argument.",
        "For example, if p(a), q(b) and a = b are atoms in A, then instances of (E2) and (E3) ensure that p(b), q(a) and b ---= a will be added to AA and thence to A.",
        "In general, if it is discovered that n constants al, a, are equal, then A will ultimately contain the n2 equalities ai a3, 1 < i < n, 1 < j < n, as well as at least n \"copies\" of any predicate containing any a,."
      ]
    },
    {
      "heading": "5.3 Union-Find and Equality",
      "text": [
        "As noted above, the equality axioms ensure that the relation that the equality symbol denotes is an equivalence relation and the substitutivity of equals for equals.",
        "in general, the union-find algorithm (Corman, Leiserson, and Rivest 1990; Gallier 1986; Nelson and Oppen 1980) maintains the equivalence classes of the equality relation far more efficiently than an approach that uses the syntactic equality axioms.",
        "The equivalence classes are encoded by associating each constant with a pointer that is either null or points to another constant, where a points to b only if a =-- b.",
        "These pointer correspond exactly to the \"invisible pointers\" used in standard implementations of the attribute-value unification algorithm.",
        "The semi-naive algorithm for computing A.",
        "The find operation dereferences its argument, i.e., it follows these pointers until it reaches a constant with a null pointer, which is the equivalence classes' representative.",
        "Just as in the standard attribute-value unification algorithm, all arguments are always dereferenced before they are used.",
        "The union operation, called whenever an atom a = 6 is added to the set A, merges their equivalence classes by redirecting the pointer associated with the representative of one of them to point to the representative of the other.' In this approach, only atoms that contain the redirected constant need to be added to AA and thence to A.",
        "For example, if p(a) and q(b) are atoms in A and the equality a = b is discovered, causing a to be redirected to b, then only p(b) is added to AA, and thence to A.",
        "Further, the \"original\" atom p(a) is no longer required; indeed, the new atom p(b) is exactly an argument-dereferenced variant of the old atom, so it is not necessary to copy the atom at all.",
        "In general, equalities between n items are represented by n – 1 nonnull pointers, and copying of atoms can be avoided by argument dereferencing."
      ]
    },
    {
      "heading": "5.4 An Example",
      "text": [
        "This section presents a very simple example that demonstrates the semi-naive algorithm and the union-find techniques.",
        "The clauses used are the attribute-value axiom schemata (1-4) and the axioms defining the sort 3rd-sg (5), as well as the additional 10 The union-find algorithm achieves quasilinear running time when it incorporates path compression and union by rank (Corman, Leiserson, and Rivest 1990).",
        "AA° = {3rd-sg(u), arc(u, number, v), con (sg) , con(pl), con (3rd)} On the first iteration we note that the antecedents of both clauses defining the sort 3rd-sg are satisfied (with x bound to u), so Ayll is given as follows.",
        "In the second iteration the antecedents of the first attribute-value axiom are satisfied, so AA2 contains an equality atom.",
        "The equality atom causes v to be redirected to sg, and at this stage the inconsistency of the derived atom v = sg in ,AA2 with the input constraint v 0 sg in S is detected.",
        "(It may be helpful to think of the constraint v 0 sg as the equivalent clause v = sg -- false).",
        "The algorithm therefore returns with failure, indicating that the set S is unsatisfiable.",
        "At the point at which the inconsistency is detected, the set A contains the following atoms, where v sg indicates that v is redirected to sg.",
        "The correspondence of this procedure to the standard attribute-value unification algorithm is quite strong.",
        "In this procedure, the attribute-value axiom (1) detects situations in which some node has two arcs with the same label pointing to, say, y and z.",
        "If such",
        "a situation arises, the equality y = z is inferred, which results in y being redirected to z and causes all of the arcs leaving y to be added to AA, where they will be compared with the arcs leaving z.",
        "The other attribute-value axiom schemata (2-4) detect constant–constant and constant–complex clashes, causing failure if one is found.",
        "Efficient processing demands that the atoms in A be indexed by their arguments to speed up the matching atoms with the antecedents of clauses.",
        "One way of doing this is to store on each constant a list of the atoms in which that constant appears.",
        "Such an index has the same structure as the standard graph encoding of feature structure constraints."
      ]
    },
    {
      "heading": "6. A Fixed-Point Theorem",
      "text": [
        "We now turn to the theoretical justification of the bottom-up forward-chaining procedures sketched in the last section, and show that such methods will find a model for a set of SB formulae in clausal form if one exists.",
        "This section demonstrates that an SB formula in clausal form is satisfiable if and only if a bottom-up forward-chaining procedure finds a deductively closed set of atoms A.",
        "A similar theorem for the case in which all the clauses are Horn clauses is presented in Lloyd (1984); this section extends that work to arbitrary clauses.",
        "It presents a characterization of the models of an arbitrary first-order formula co in clausal form in terms of the least-fixed points of a set {T,, x} of partial functions from Herbrand interpretations to Herbrand interpretations.",
        "These functions have the property that A is a Herbrand interpretation that satisfies if and only if the least-fixed point of at least one of them is a submodel of A.",
        "For SB formulae this set of functions is finite and the least-fixed points are reached in a finitely bounded number of iterations.",
        "Since the procedures described in the last section calculate the Least-fixed points of these functions, they can be used to determine the satisfiability of an arbitrary SB formula as well as all of its ground atomic consequences.",
        "The functions T, x play a similiar role here to one that the transformation Tp plays in the least-fixed-point semantics of Horn clause programs.",
        "Informally, each function in the set {T„,x} corresponds to one whole sequence of nondeterministic choices of disjuncts in non-Horn clauses that could be made during an iterative approximation of the least-fixed point.",
        "This section is based on Sections 5 and 6 of Chapter 1 of Lloyd (1984), to which the reader should turn for further details.",
        "The fixed-point theorem holds for arbitrary first-order formulae in clausal form, but the set {T„„,x} is finite if and only if y does not contain any function symbols, i.e., cp is an SB formula.",
        "Equality is not treated specially, so the formula co must contain appropriate equality axioms, as mentioned above.",
        "Let U be the Herbrand universe with respect to (i.e., the set of all terms that can be constructed using the constant and function symbols appearing in co),\" and let B„ be the set of all ground atoms that can be formed using the predicate symbols of with elements of U as arguments.",
        "A Herbrand interpretation A is a subset of B.",
        "Note that the set of Herbrand interpretations 2B.",
        "partially ordered by the subset relation forms a complete lattice.",
        "Further, U and hence are finite iff c.0 is an SB formula.",
        "(If co is in clausal form but is not an SB formula then it must contain a function symbol, so its Herbrand universe U is infinite.)",
        "That is, a Herbrand interpretation trivially falsifies a set of clauses co just in case some negative clause in co is false in that interpretation.",
        "Clearly, any such interpretation cannot satisfy co, but the converse does not hold: there are interpretations that do not trivially falsify co but still do not satisfy cp because they do not satisfy one or more of the nonnegative clauses in y.",
        "We turn now to the nonnegative clauses in cp.",
        "The idea is that even if A does not satisfy a ground instance al A - - - A at,„ /3-; V • • • V /3:, of some nonnegative clause in co, we can extend A so that it does so by adding one of the 0:.",
        "The chief technical difficulty here is caused by the nondeterminism involved in deciding which of the 0: to add, and a device called a \"choice function\" is introduced to choose, for each ground instance of a clause, which of the atoms in its consequent will be added to A if its antecedent is contained in A.",
        "A choice function for a clause al A A am – > 01 V • • V a., is therefore a function from all possible ways of grounding that clause to one of the A."
      ]
    },
    {
      "heading": "Definition",
      "text": [
        "A choice function for a clause c (al A • • • A am 31 V - • • V On) is any function in (V,- U) [1,...,n], where V, is the set of variables in the clause c. That is, a choice function for a clause is a function from variable assignments to an integer representing one of the clause's consequents.",
        "Tt is so named because for each variable assignment (i.e., each way of grounding the variables in yo) it \"chooses\" an atom from the consequent of the clause.",
        "Horn clauses have only one choice function, and negative clauses have no choice functions at all.",
        "Note that since U is finite for SB formulae, there are a finite number of variable assignment functions for any SB clause and hence only a finite number of choice functions for any SB clause.",
        "A choice function x for a set of clauses (p is a function from cp to choice functions such that for each nonnegative clause c in co, x(c) is a choice function for c (the value that x takes on negative clauses is ignored).",
        "Clearly, a choice function exists for every set of clauses.",
        "Given a set of clauses cp and a choice function x for yo, we define a function F from Herbrand interpretations to Herbrand interpretations as follows."
      ]
    },
    {
      "heading": "Definition",
      "text": [
        "Fc,,x is a function in 213'P n' that is defined as follows.",
        "and for all variable assignments 0 :V, U such that 0(01), , O(an) E A and i = x(c)(0)} Intuitively, Fw corresponds to one nondeterministic step in the 'bottom-up' construction of a Herbrand model for co described in the previous section.",
        "If A makes the antecedent of some ground instance of some clause in yo true, then we use the choice function x to pick an atom in the consequent of that ground clause and add it to the interpretation.",
        "Different choice functions x represent different sequences of nondeterministic choices, and result in the construction of possibly different interpretations.",
        "The following lemma, based directly on proposition 6.3 of Lloyd (1984), notes the continuity (and therefore the monotonicity) of F „.x.",
        "Lemma 1 The function F„,x is continuous.",
        "That is, if X is a directed subset of 23P (i.e., every finite subset of X has an upper bound in X) then F„0„(lub(X)) = (X)).",
        "The continuity of F c,,x immediately implies the convergence of the sequence (Fiv,x (0)); the value that it converges to is called the Least-fixed point of F„,,x, written Ifp(F,x).",
        "Note that if co is in 93 then there is an integer k such that lfp(Fc,„,x) = Fk,7 x(0); this follows directly from the monotonicity of F„,,,x and the finiteness of B.",
        "The function Fp,x and a condition requiring that the interpretation produced does not trivially falsify the set of clauses cp together define the partial function T,p,x."
      ]
    },
    {
      "heading": "Definition",
      "text": [
        "T„,, is a partial function in 2B‘, 2Bw that is defined as follows.",
        "7\",,,x(A) = F,,,(A) if F,,,(A) does not trivially falsify (p, and is undefined otherwise.",
        "Note that if the sequence (Tv ot (A)) is defined for all i then (7;,x (A)) = (Pc,,,x (A)).",
        "enjoys the following kind of monotonicity.",
        "Lemma 2"
      ]
    },
    {
      "heading": "Suppose A C A'. Then Tcp,x (A) is defined if T ,x(A') is defined, and T,p,x (A) c Tp,x(A'). Proof",
      "text": [
        "If A trivially falsifies y then A' does too, so T,,,x (A) is defined if Ts„,x (A') is defined.",
        "If Tw(A') is defined then T,p,x(A) F w,x(A) C = ,x(A1).",
        "❑ The following lemma shows that Herbrand models of y contain fixed points of T„:,,x for some choice function x for co. Lemma 3 For all Herbrand interpretations A, A J p iff there exists a choice function x for yo such that Tp.,(A) C A."
      ]
    },
    {
      "heading": "Proof",
      "text": [
        "We begin first with the left-to-right component of the proof.",
        "If A cp, then A does not trivially falsify , so Tv„,, (A) is defined.",
        "Now we show how to find for each satisfying interpretation A a choice function x such that T,,,x(A) = A.",
        "Since A satisfies (p, for every nonnegative clause c = A • - A a„, 81 V V. • V N) in co and for every variable assignment function B for the variables in c, if (01),..., 0(an) E A, then by the truth conditions for implication and disjunction, some (9(A) E A as well.",
        "Thus, for all B such that 0(ai), ,0(an) E A let x(c)(8) be any i such that 8(i3) E A, and let x(c) (0) take any permissible value otherwise.",
        "Hence T,,,,x(A) = = A.",
        "Now suppose Tc„,x (A) C A.",
        "Since T„,,,x (A) is defined, A does not trivially falsify any negative clause in cc.",
        "Let c (01 /1••Act,,, – 4 oi V • V ) be any nonnegative clause in cp, and let 0 E V, U be any variable assignment function for the variables in c. If 0(ai), ... Act, ) E A then 0(A) E T,,x(A) C A as well, where i = x(c)(0), so A c and hence A co. ❑ The following theorem shows that a formula is satisfiable if and only if the least-fixed point of at least one of the exists.",
        "It justifies the decision procedures presented in the previous section, which operate by searching for such least-fixed points.",
        "The proof actually establishes something stronger, viz., that every Herbrand model of co is an extension of the least-fixed points of one or more of the Tc,,x.",
        "Thus an enumeration of all of the least-fixed points of the T„,x yields all of the \"minimal models\" of p (although it is not clear that these are in fact necessary for recognition or parsing, as discussed above).",
        "Theorem cp is satisfiable if and only if there exists a choice function x for (p such that Ifp(T„,,x) exists."
      ]
    },
    {
      "heading": "Proof",
      "text": [
        "If Ifp(T„,x) exists then by Lemma 3, Ifp(T,„.,) cp.",
        "Now suppose A is a Herbrand interpretation that satisfies Lemma 3 asserts the existence of a choice function x such that Tvo, (A) exists and T„,x (A) C A.",
        "By Lemma 2 and the fixed point property noted above lfp(T„,,x) exists, since lfp(T„,,x) (0) C T,,,(7x(A) C A.",
        "❑ It is important to recognize that these \"minimal models\" are in general not upward-closed: an extension A' of a model A can trivially falsify p even though A does not.",
        "This is essentially Moshier's (1988) and Pereira's (1987) observation that in the presence of negation the set of models is not upwardly closed.",
        "We conclude this section with the observation that the positive consequences of a formula co can be \"read off\" its least-fixed points."
      ]
    },
    {
      "heading": "Corollary",
      "text": [
        "co is satisfiable iff for some choice function x for (p, lfp(T,po„) exists.",
        "Moreover, if 01 V • • • V 0, is any disjunction of ground atoms, j3 iff for all choice functions x for p such that lfp(T„,,x) exists, at least one of the is in Ifp(T,,x)."
      ]
    },
    {
      "heading": "7. Conclusion",
      "text": [
        "The main goal of this paper was to demonstrate from a computational perspective that Schonfinkel-Bernays' formulae are a natural generalization of (boolean.",
        "combinations of) attribute-value feature structure constraints.",
        "From a computational complexity perspective we noted that the satisfiability problem for 5-8 formulae with a bounded number of quantifiers is NP-complete, so it is no harder than the satisfiability problem for disjunctive attribute-value constraints.",
        "From a more practical perspective, a semi-naive bottom-up evaluation strategy using union-find methods to handle equality generalizes the standard attribute-value \"unification\" algorithm to arbitrary SB constraints in clausal form.",
        "Because it treats standard attribute-value constraints in approximately the same way as the standard unification algorithm, and because it can incorporate the same kinds of indexing that the latter algorithm employs, the generalized algorithm should be able to determine the satisfiability of attribute-value constraints with approximately the same efficiency as the standard attribute-value unification algorithm.",
        "In generalizing attribute-value constraints to SB formulae, we noted that in clausal form the SB formulae constitute a disjunctive extension to Datalog, and that the standard attribute-value unification algorithm is closely related to a version of semi-naive evaluation algorithm used to evaluate Datalog clauses.",
        "This offers another perspective on feature structure constraints; they can be seen as kinds of databases containing information about the linguistic structures they describe.",
        "Perhaps the greatest weakness of this work is the lack of an efficient method for treating disjunctive constraints.",
        "The backtracking strategy suggested in the body of the paper can be extremely inefficient, even with 'toy' grammars.",
        "This problem is not unique to this approach; rather, it is endemic to most complex feature-based approaches to natural language processing, as evidenced by the volume of literature on the subject.",
        "As discussed in Section 3, the satisfiability problem for SB formula with a fixed number of universal quantifiers is NP-hard, so all known algorithms require exponential time in the worst case, and unless P=NP no tractable general-purpose algorithm for determining the satisfiability of SB formulae exists.",
        "With present technology, the best we can hope for is an algorithm that performs adequately on the types of problems that we actually encounter.",
        "Sometimes disjunctive constraints can be (automatically) transformed into nondis-junctive ones, thus avoiding the problem entirely.",
        "For example, Alshawi (1992) describes a technique attributed to Colmerauer for transforming disjunctions of finite-domain feature-value constraints into conjunctions.",
        "Kasper (1988) and Hegner (1991) point out that Horn clauses, although technically disjunctions, can be handled considerably more efficiently than general disjunctive constraints.",
        "The forward-chaining mechanisms that they propose for treating these constraints appear to be special cases of the semi-naive algorithm sketched in this paper.",
        "Unfortunately, I know of no general adequate method for handling the disjunctive constraints that arise in real grammars with acceptable efficiency.",
        "The techniques discussed by Maxwell and Kaplan (1991, 1992) seem most directly compatible with the approach described in this paper, and the methods described by Kasper (1987b), Eisele and DOrre (1988), and Emele (1991) might have important applications as well."
      ]
    },
    {
      "heading": "Acknowledgment",
      "text": [
        "I would like to thank Johan van Benthem, Bob Carpenter, Stephen Hegner, Ronald M. Kaplan, Edward Stabler and the participants of the feature structures seminar at the Institut fur maschinelle Sprachverarbeitung, Universitat Stuttgart, for their suggestions and comments.",
        "All responsibility for errors rests with me, of course."
      ]
    },
    {
      "heading": "References",
      "text": [
        "Alt-Kaci, Hassan (1984).",
        "A lattice theoretic approach to computation based on a calculus of",
        "Mark Johnson Computing with Features as Formulae"
      ]
    },
    {
      "heading": "Appendix A: SB Formulae in Disjunctive Datalog Format",
      "text": []
    }
  ]
}
