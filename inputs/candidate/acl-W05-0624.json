{
  "info": {
    "authors": [
      "Richard Johansson",
      "Pierre Nugues"
    ],
    "book": "Conference on Computational Natural Language Learning CoNLL",
    "id": "acl-W05-0624",
    "title": "Sparse Bayesian Classification of Predicate Arguments",
    "url": "https://aclweb.org/anthology/W05-0624",
    "year": 2005
  },
  "references": [
    "acl-J02-3001",
    "acl-W04-0814",
    "acl-W05-0620"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We present an application of Sparse Bayesian Learning to the task of semantic role labeling, and we demonstrate that this method produces smaller classifiers than the popular Support Vector approach.",
        "We describe the classification strategy and the features used by the classifier.",
        "In particular, the contribution of six parse tree path features is investigated."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Generalized linear classifiers, in particular Support Vector Machines (SVMs), have recently been successfully applied to the task of semantic role identification and classification (Pradhan et al., 2005), inter alia.",
        "Although the SVM approach has a number of properties that make it attractive (above all, excellent software packages exist), it also has drawbacks.",
        "First, the resulting classifier is slow since it makes heavy use of kernel function evaluations.",
        "This is especially the case in the presence of noise (since each misclassified example has to be stored as a bound support vector).",
        "The number of support vectors typically grows with the number of training examples.",
        "Although there exist optimization methods that speed up the computations, the main drawback of the SVM approach is still the classification speed.",
        "Another point is that it is necessary to tune the parameters (typically C and 'y).",
        "This makes it necessary to train repeatedly using cross-validation to find the best combination of parameter values.",
        "Also, the output of the decision function of the SVM is not probabilistic.",
        "There are methods to map the decision function onto a probability output using the sigmoid function, but they are considered somewhat ad-hoc (see (Tipping, 2001) for a discussion).",
        "In this paper, we apply a recent learning paradigm, namely Sparse Bayesian learning, or more specifically the Relevance Vector learning method, to the problem of role classification.",
        "Its principal advantages compared to the SVM approach are:",
        "• It typically utilizes fewer examples compared to the SVM, which makes the classifier faster.",
        "• It uses no C parameter, which reduces the need for cross-validation.",
        "• The decision function is adapted for probabilistic output.",
        "• Arbitrary basis functions can be used.",
        "Its significant drawback is that the training procedure relies heavily on dense linear algebra, and is thus difficult to scale up to large training sets and may be prone to numerical difficulties.",
        "For a description of the task and the data, see (Car-reras and Màrquez, 2005)."
      ]
    },
    {
      "heading": "2 Sparse Bayesian Learning and the Relevance Vector Machine",
      "text": [
        "The Sparse Bayesian method is described in detail in (Tipping, 2001).",
        "Like other generalized linear learning methods, the resulting binary classifier has the form sign f (x) = sign �m aifi(x) + b",
        "where the fz are basis functions.",
        "Training the model then consists of finding a suitable a = (b, a1,... , am) given a data set (X, Y).",
        "Analogous with the SVM approach, we can let fz(x) = k(x, xz), where xz is an example from the training set and k a function.",
        "We have then arrived at the Relevance Vector Machine (RVM).",
        "There are however no restrictions on the function k (such as Mercer’s condition for SVM).",
        "We use the Gaussian kernel k(x, y) = exp( – � I x – y I2) throughout this work.",
        "We first model the probability of a positive example as a sigmoid applied to f (x).",
        "This can be used to write the likelihood function P(YIX,a).",
        "Instead of a conventional ML approach (maximizing the likelihood with respect to a, which would give an overfit model), we now adopt a Bayesian approach and encode the model preferences using priors on a.",
        "For each az, we introduce a parameter sz and assume that az E N(0, sz 1) (i.e. Gaussian).",
        "This is in effect an “Occam penalty” that encodes our preference for sparse models.",
        "We should finally specify the distributions of the sz.",
        "However, we make the simplifying assumption that their distribution is flat (noninformative).",
        "We now find the maximum of the marginal likelihood, or “evidence”, with respect to s, that is",
        "This integral is not tractable, hence we approximate the integrand using a Gaussian centered at the mode of the integrand (Laplace’s approximation).",
        "The marginal likelihood can then be differentiated with respect to s, and maximized using iterative methods such as gradient descent.",
        "The algorithm thus proceeds iteratively as follows: First maximize the penalized likelihood function P(Y IX, a)p(a Is) with respect to a (for example via the Newton-Raphson method), then update the parameters sz.",
        "This goes on until a convergence criterion is met, for example that the sz changes are small enough.",
        "During iteration, the sz parameters for redundant examples tend to infinity.",
        "They (and the corresponding columns of the kernel matrix) are then removed from the model.",
        "This is necessary because of numerical stability and also reduces the training time considerably.",
        "We implemented the RVM training method using the ATLAS (Whaley et al., 2000) implementation of the BLAS and LAPACK standard linear algebra APIs.",
        "To make the algorithm scale up, we used a working-set strategy that used the results of partial solutions to train the final classifier.",
        "Our implementation is based on the original description of the algorithm (Tipping, 2001) rather than the greedy optimized version (Tipping and Faul, 2003), since preliminary experiments suggested a decrease in classification accuracy.",
        "Our current implementation can handle training sets up to about 30000 examples.",
        "We used the conventional one-versus-one method for multiclass classification.",
        "Although the Sparse Bayesian paradigm is theoretically not limited to binary classifiers, this is of little use in practice, since the size of the Hessian matrix (used while maximizing the likelihood and updating s) grows with the number of classes."
      ]
    },
    {
      "heading": "3 System Description",
      "text": [
        "Like previous systems for semantic role identification and classification, we used an approach based on classification of nodes in the constituent tree.",
        "To simplify training, we used the soft-prune approach as described in (Pradhan et al., 2005), which means that before classification, the nodes were filtered through a binary classifier that classifies them as having a semantic role or not (NON-NULL or NULL).",
        "The NULL nodes missed by the filter were included in the training set for the final classifier.",
        "Since our current implementation of the RVM training algorithm does not scale up to large training sets, training on the whole PropBank was infeasible.",
        "We instead trained the multiclass classifier on sections 15 –18, and used an SVM for the soft-pruning classifier, which was then trained on the remaining sections.",
        "The excellent LIBSVM (Chang and Lin, 2001) package was used to train the SVM.",
        "The features used by the classifiers can be grouped into predicate and node features.",
        "Of the node features, we here pay most attention to the parse tree path features."
      ]
    },
    {
      "heading": "3.1 Predicate Features",
      "text": [
        "We used the following predicate features, all of which first appeared in (Gildea and Jurafsky, 2002).",
        "• Predicate lemma.",
        "• Subcategorization frame.",
        "• Voice.",
        "3.2 Node Features • Head word and head POS.",
        "Like most previous work, we used the head rules of Collins to extract this feature.",
        "• Position.",
        "A binary feature that describes if the node is before or after the predicate token.",
        "• Phrase type (PT), that is the label of the constituent.",
        "• Named entity.",
        "Type of the first contained NE.",
        "• Governing category.",
        "As in (Gildea and Jurafsky, 2002), this was used to distinguish subjects from objects.",
        "For an NP, this is either S or VP.",
        "• Path features.",
        "(See next subsection.)",
        "For prepositional phrases, we attached the preposition to the PT and replaced head word and head POS with those of the first contained NP."
      ]
    },
    {
      "heading": "3.3 Parse Tree Path Features",
      "text": [
        "Previous studies have shown that the parse tree path feature, used by almost all systems since (Gildea and Jurafsky, 2002), is salient for argument identification.",
        "However, it is extremely sparse (which makes the system learn slowly) and is dependent on the quality of the parse tree.",
        "We therefore investigated the contribution of the following features in order to come up with a combination of path features that leads to a robust system that generalizes well.",
        "• Constituent tree path.",
        "As in (Gildea and Jurafsky, 2002), this feature represents the path (consisting of step directions and PTs of the nodes traversed) from the node to the predicate, for example NPTVPIVB for a typical object.",
        "Removing the direction (as in (Pradhan et al., 2005)) improved neither precision nor recall.",
        "• Partial path.",
        "To reduce sparsity, we introduced a partial path feature (as in (Pradhan et al., 2005)), which consists of the path from the node to the lowest common ancestor.",
        "• Dependency tree path.",
        "We believe that la",
        "beled dependency paths provide more information about grammatical functions (and, implicitly, semantic relationships) than the raw constituent structure.",
        "Since the grammatical functions are not directly available from the parse trees, we investigated two approximations of dependency arc labels: first, the POSs of the head tokens; secondly, the PTs of the head node and its immediate parent (such labels were used in (Ahn et al., 2004)).",
        "• Shallow path.",
        "Since the UPC shallow parsers",
        "were expected to be more robust than the full parsers, we used a shallow path feature.",
        "We first built a parse tree using clause and chunk bracketing, and the shallow path feature was then constructed like the constituent tree path.",
        "• Subpaths.",
        "All subpaths of the constituent path.",
        "We used the parse trees from Charniak’s parser to derive all paths except for the shallow path."
      ]
    },
    {
      "heading": "4 Results",
      "text": []
    },
    {
      "heading": "4.1 Comparison with SVM",
      "text": [
        "The binary classifiers that comprise the one-versus-one multiclass classifier were 89% – 98% smaller when using RVM compared to SVM.",
        "However, the performance dropped by about 2 percent.",
        "The reason for the drop is possibly that the classifier uses a number of features with extremely sparse distributions (two word features and three path features)."
      ]
    },
    {
      "heading": "4.2 Path Feature Contributions",
      "text": [
        "To estimate the contribution of each path feature, we measured the difference in performance between a system that used all six features and one where one of the features had been removed.",
        "Table 2 shows the results for each of the six features.",
        "For the final system, we used the dependency tree path with PT pairs, the shallow path, and the partial path."
      ]
    },
    {
      "heading": "4.3 Final System Results",
      "text": [
        "The results of the complete system on the test sets are shown in Table 1.",
        "The smaller training set (as mentioned above, we used only sections 15 – 18",
        "for the role classifier) causes the result to be significantly lower than state of the art (F-measure of 79.4, reported in (Pradhan et al., 2005))."
      ]
    },
    {
      "heading": "5 Conclusion and Future Work",
      "text": [
        "We have provided an application of Relevance Vector Machines to a large-scale NLP task.",
        "The resulting classifiers are drastically smaller that those produced by the SV training methods.",
        "On the other hand, the classification accuracy is lower, probably because of the use of lexicalized features.",
        "The results on the Brown test set shows that the genre has a significant impact on the performance.",
        "An evaluation of the contribution of six parse tree",
        "path features suggests that dependency tree paths are more useful for semantic role labeling than the traditional constituent tree path.",
        "In the future, we will investigate if it is possible to incorporate the y parameter into the probability model, thus eliminating the need for cross-validation completely.",
        "In addition, the training algorithm will need to be redesigned to scale up to larger training sets.",
        "The learning paradigm is still young and optimized methods (such as for SVM) have yet to appear.",
        "One possible direction is the greedy method described in (Tipping and Faul, 2003)."
      ]
    }
  ]
}
