{
  "info": {
    "authors": [
      "Sebastian Riedel",
      "Ruken Cakici",
      "Ivan Meza-Ruiz"
    ],
    "book": "Conference on Computational Natural Language Learning CoNLL",
    "id": "acl-W06-2934",
    "title": "Multi-Lingual Dependency Parsing With Incremental Integer Linear Programming",
    "url": "https://aclweb.org/anthology/W06-2934",
    "year": 2006
  },
  "references": [
    "acl-E06-1011",
    "acl-H05-1066",
    "acl-P05-1012"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Our approach to dependency parsing is based on the linear model of McDonald et al.",
        "(McDonald et al., 2005b).",
        "Instead of solving the linear model using the Maximum Spanning Tree algorithm we propose an incremental Integer Linear Programming formulation of the problem that allows us to enforce linguistic constraints.",
        "Our results show only marginal improvements over the non-constrained parser.",
        "In addition to the fact that many parses did not violate any constraints in the first place this can be attributed to three reasons: 1) the next best solution that fulfils the constraints yields equal or less accuracy, 2) noisy POS tags and 3) occasionally our inference algorithm was too slow and decoding timed out."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "This paper presents our submission for the CoNLL 2006 shared task of multilingual dependency parsing.",
        "Our parser is inspired by McDonald et al.",
        "(2005a) which treats the task as the search for the highest scoring Maximum Spanning Tree (MST) in a graph.",
        "This framework is efficient for both projective and non-projective parsing and provides an online learning algorithm which combined with a rich feature set creates state-of-the-art performance across multiple languages (McDonald and Pereira, 2006).",
        "However, McDonald and Pereira (2006) mention the restrictive nature of this parsing algorithm.",
        "In their original framework, features are only defined over single attachment decisions.",
        "This leads to cases where basic linguistic constraints are not satisfied (e.g. verbs with two subjects).",
        "In this paper we present a novel way to implement the parsing algorithms for projective and non-projective parsing based on a more generic incremental Integer Linear Programming (ILP) approach.",
        "This allows us to include additional global constraints that can be used to impose linguistic information.",
        "The rest of the paper is organised in the following way.",
        "First we give an overview of the Integer Linear Programming model and how we trained its parameters.",
        "We then describe our feature and constraint sets for the 12 different languages of the task (Hajiˇc et al., 2004; Chen et al., 2003; B¨ohmov´a et al., 2003; Kromann, 2003; van der Beek et al., 2002; Brants et al., 2002; Kawata and Bartels, 2000; Afonso et al., 2002; Dˇzeroski et al., 2006; Civit Torruella and Marti Antonin, 2002; Nilsson et al., 2005; Oflazer et al., 2003; Atalay et al., 2003).",
        "Finally, our results are discussed and error analyses for Chinese and Turkish are presented."
      ]
    },
    {
      "heading": "2 Model",
      "text": [
        "Our model is based on the linear model presented in McDonald et al.",
        "(2005a),",
        "where x is a sentence, y a parse and s a score function over sentence-parse pairs.",
        "f (2, j) is a multidi",
        "Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL -X), pages 226–230, New York City, June 2006. c�2006 Association for Computational Linguistics mensional feature vector representation of the edge from token i to token j and w the corresponding weight vector.",
        "Decoding in this model amounts to finding the y for a given x that maximises s (x, y)",
        "and y contains no cycles, attaches exactly one head to each non-root token and no head to the root node."
      ]
    },
    {
      "heading": "2.1 Decoding",
      "text": [
        "Instead of using the MST algorithm (McDonald et al., 2005b) to maximise equation 1, we present an equivalent ILP formulation of the problem.",
        "An advantage of a general purpose inference technique is the addition of further linguistically motivated constraints.",
        "For instance, we can add constraints that enforce that a verb can not have more than one subject argument or that coordination arguments should have compatible types.",
        "Roth and Yih (2005) is similarly motivated and uses ILP to deal with additional hard constraints in a Conditional Random Field model for Semantic Role Labelling.",
        "There are several explicit formulations of the MST problem as integer programs in the literature (Williams, 2002).",
        "They are based on the concept of eliminating subtours (cycles), cuts (disconnections) or requiring intervertex flows (paths).",
        "However, in practice these cause long solving times.",
        "While the first two types yield an exponential number of constraints, the latter one scales cubically but produces non-fractional solutions in its relaxed version, causing long runtime of the branch and bound algorithm.",
        "In practice solving models of this form did not converge after hours even for small sentences.",
        "To get around this problem we followed an incremental approach akin to Warme (1998).",
        "Instead of adding constraints that forbid all possible cycles in advance (this would result in an exponential number of constraints) we first solve the problem without any cycle constraints.",
        "Only if the result contains cycles we add constraints that forbid these cycles and run the solver again.",
        "This process is repeated until no more violated constraints are found.",
        "Figure 1 shows this algorithm.",
        "Groetschel et al.",
        "(1981) showed that such an approach will converge after a polynomial number of iterations with respect to the number of variables.",
        "1.",
        "Solve IP Pi 2.",
        "Find violated constraints C in the solution of Pi 3. if C = 0 we are done 4.",
        "Pi�1=Pi�C 5. i = i + 1 6. goto (1)",
        "In practice, this technique showed fast convergence (less than 10 iterations) in most cases, yielding solving times of less than 0.5 seconds.",
        "However, for some sentences in certain languages, such as Chinese or Swedish, an optimal solution could not be found after 500 iterations.",
        "In the following section we present the bjective function, variables and linear constraints that make up the Integer Linear Program."
      ]
    },
    {
      "heading": "2.1.1 Variables",
      "text": [
        "In the implementation1 of McDonald et al.",
        "(2005b) dependency labels are handled by finding the best scoring label for a given token pair so that",
        "goes into Equation 1.",
        "This is only exact as long as no further constraints are added.",
        "Since our aim is to add constraints our variables need to explicitly model label decisions.",
        "Therefore, we introduce binary variables li,j,labelbi E 0..n, j E �..n, label E bestb (i, j) where n is the number of tokens and the index 0 represents the root token.",
        "bestb (i, j) is the set of b labels with maximal s (i, j, label).",
        "li,j,label equals 1 if there is a dependency with the label label between token i (head) and j (child), 0 otherwise.",
        "Furthermore, we introduce binary auxiliary variables di,jbi E 0..n, j E �..n representing the existence of a dependency between tokens i and j.",
        "We connect these to the li,j,label variables by a constraint",
        "Given the above variables our objective function can be represented as",
        "with a suitable k."
      ]
    },
    {
      "heading": "2.1.3 Constraints Added in Advance",
      "text": [
        "Only One Head In all our languages every token has exactly one head.",
        "This yields",
        "for the artificial root node.",
        "Typed Arity Constraints We might encounter solutions of the basic model that contain, for instance, verbs with two subjects.",
        "To forbid these we simply augment our model with constraints such as",
        "for all verbs i in a sentence."
      ]
    },
    {
      "heading": "2.1.4 Incremental Constraints",
      "text": [
        "No Cycles If a solution contains one or more cycles C we add the following constraints to our IP: For every c E C we add",
        "to forbid c. Coordination Argument Constraints In coordination conjuncts have to be of compatible types.",
        "For example, nouns can not coordinate with verbs.",
        "We implemented this constraint by checking the parses for occurrences of incompatible arguments.",
        "If we find two arguments j, k for a conjunction i: di,j and di,k and j is a noun and k is a verb then we add di,j + di,k < 1 to forbid configurations in which both dependencies are active.",
        "Projective Parsing In the incremental ILP framework projective parsing can be easily implemented by checking for crossing dependencies after each iteration and forbidding them in the next.",
        "If we see two dependencies that cross, di,j and dk,l, we add the constraint di,j + dk,l < 1 to prevent this in the next iteration.",
        "This can also be used to prevent specific types of crossings.",
        "For instance, in Dutch we could only allow crossing dependencies as long as none of the dependencies is a “Determiner” relation."
      ]
    },
    {
      "heading": "2.2 Training",
      "text": [
        "We used single-best MIRA(Crammer and Singer, 2003).For all experiments we used 10 training iterations and non-projective decoding.",
        "Note that we used the original spanning tree algorithm for decoding during training as it was faster."
      ]
    },
    {
      "heading": "3 System Summary",
      "text": [
        "We use four different feature sets.",
        "The first feature set, BASELINE, is taken from McDonald and Pereira (2005b).",
        "It uses the FORM and the POSTAG fields.",
        "This set also includes features that combine the label and POS tag of head and child such as (Label, POSHead) and (Label, POSChild_�).",
        "For our Arabic and Japanese development sets we obtained the best results with this configuration.",
        "We also use this configuration for Chinese, German and Portuguese because training with other configurations took too much time (more than 7 days).",
        "The BASELINE also uses pseudo-coarse-POS tag (1st character of the POSTAG) and pseudo-lemma tag (4 characters of the FORM when the length is more than 3).",
        "For the next configuration we substitute these pseudo-tags by the CPOSTAG and LEMMA fields that were given in the data.",
        "This configuration was used for Czech because for other configurations training could not be finished in time.",
        "The third feature set tries to exploit the generic FEATS field, which can contain a list features such as case and gender.",
        "A set of features per dependency is extracted using this information.",
        "It consists of cross product of the features in FEATS.",
        "We used this configuration for Danish, Dutch, Spanish",
        "and Turkish where it showed the best results during development.",
        "The fourth feature set uses the triplet of label, POS child and head as a feature such as (Label, POSHead, POSChild).",
        "It also uses the CPOSTAG and LEMMA fields for the head.",
        "This configuration is used for Slovene and Swedish data where it performed best during development.",
        "Finally, we add constraints for Chinese, Dutch, Japanese and Slovene.",
        "In particular, arity constraints to Chinese and Slovene, coordination and arity constraints to Dutch, arity and selective projectivity constraints for Japanese 2.",
        "For all experiments b was set to 2.",
        "We did not apply additional constraints to any other languages due to lack of time."
      ]
    },
    {
      "heading": "4 Results",
      "text": [
        "Our results on the test set are shown in Table 1.",
        "Our results are well above the average for all languages but Czech.",
        "For Chinese we perform significantly better than all other participants (p = 0.00) and we are in the top three entries for Dutch, German, Danish.",
        "Although Dutch and Chinese are languages were we included additional constraints, our scores are not a result of these.",
        "Table 2 compares the result for the languages with additional constraints.",
        "Adding constraints only marginally helps to improve the system (in the case of Slovene a bug in our implementation even degraded accuracy).",
        "A more detailed explanation to this observation is given in the following section.",
        "A possible explanation for our high accuracy in Chinese could be the fact that we were not able to optimise the feature set on the development set (see the previous section).",
        "Maybe this prevented us from overfitting.",
        "It should be noted that we did use non-projective parsing for Chinese, although the corpus was fully projective.",
        "Our worst results in comparison with other participants can be seen for Czech.",
        "We attribute this to the reduced training set we had to use in order to produce a model in time, even when using the original MST algorithm."
      ]
    },
    {
      "heading": "4.1 Chinese",
      "text": [
        "For Chinese the parser was augmented with a set of constraints that disallowed more than one argument of the types head, goal, nominal, range, theme, reason, DUMMY, DUMMY1 and DUMMY2.",
        "By enforcing arity constraints we could either turn wrong labels/heads into right ones and improve accuracy or turn right labels/heads into wrong ones and degrade accuracy.",
        "For the test set the number of improvements (36) was higher than the number of errors (22).",
        "However, this margin was outweighed by a few sentences we could not properly process because our inference method timed out.",
        "Our overall improvement was thus unimpressive 7 tokens.",
        "In the context of duplicate “head” dependencies (that is, dependencies labelled “head”) the number of sentences where accuracy dropped far outweighed the number of sentences where improvements could be gained.",
        "Removing the arity constraints on “head” labels therefore should improve our results.",
        "This shows the importance of good second best dependencies.",
        "If the dependency with the second highest score is the actual gold dependency and its score is close to the highest score, we are likely to pick this dependency in the presence of additional constraints.",
        "On the other hand, if the dependency with the second highest score is not the gold one and its score is too high, we will probably include this dependency in order to fulfil the constraints.",
        "There may be some further improvement to be gained if we train our model using k-best MIRA with k > 1 since it optimises weights with respect to the k best parses."
      ]
    },
    {
      "heading": "4.2 Turkish",
      "text": [
        "There is a considerable gap between the unlabelled and labelled results for Turkish.",
        "And in terms of labels the POS type Noun gives the worst performance because many times a subject was classified as object or vice a versa.",
        "Case information in Turkish assigns argument roles for nouns by marking different semantic roles.",
        "Many errors in the Turkish data might have been caused by the fact that this information was not adequately used.",
        "Instead of fine-tuning our feature set to Turkish we used the feature cross product as de",
        "scribed in Section 3.",
        "Some of the rather meaningless combinations might have neutralised the effect of sensible ones.",
        "We believe that using morphological case information in a sound way would improve both the unlabelled and the labelled dependencies.",
        "However, we have not performed a separate experiment to test if using the case information alone would improve the system any better.",
        "This could be the focus of future work."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "In this work we presented a novel way of solving the linear model of McDonald et al.",
        "(2005a) for projective and non-projective parsing based on an incremental ILP approach.",
        "This allowed us to include additional linguistics constraints such as “a verb can only have one subject.” Due to time constraints we applied additional constraints to only four languages.",
        "For each one we gained better results than the baseline without constraints, however, this improvement was only marginal.",
        "This can be attributed to 4 main reasons: Firstly, the next best solution that fulfils the constraints was even worse (Chinese).",
        "Secondly, noisy POS tags caused coordination constraints to fail (Dutch).",
        "Thirdly, inference timed out (Chinese) and fourthly, constraints were not violated that often in the first place (Japanese).",
        "However, the effect of the first problem might be reduced by training with a higher k. The second problem could partly be overcome by using a better tagger or by a special treatment within the constraint handling for word types which are likely to be mistagged.",
        "The third problem could be avoidable by adding constraints during the branch and bound algorithm, avoiding the need to resolve the full problem “from scratch” for every constraint added.",
        "With these remedies significant improvements to the accuracy for some languages might be possible."
      ]
    },
    {
      "heading": "6 Acknowledgements",
      "text": [
        "We would like to thank Beata Kouchnir, Abhishek Arun and James Clarke for their help during the course of this project."
      ]
    }
  ]
}
