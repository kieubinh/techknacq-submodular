{
  "info": {
    "authors": [
      "Sebastian Riedel",
      "David Smith",
      "Andrew McCallum"
    ],
    "book": "EMNLP",
    "id": "acl-D12-1067",
    "title": "Parse, Price and Cutâ€“-Delayed Column and Row Generation for Graph Based Parsers",
    "url": "https://aclweb.org/anthology/D12-1067",
    "year": 2012
  },
  "references": [
    "acl-D07-1001",
    "acl-D07-1096",
    "acl-D08-1016",
    "acl-D10-1001",
    "acl-D10-1125",
    "acl-D11-1022",
    "acl-E06-1011",
    "acl-H05-1066",
    "acl-N03-1016",
    "acl-N06-1054",
    "acl-N07-1011",
    "acl-N10-1117",
    "acl-N12-1054",
    "acl-P05-1012",
    "acl-P05-1022",
    "acl-P09-1039",
    "acl-P10-1001",
    "acl-W04-2401",
    "acl-W06-1616",
    "acl-W06-2920"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Graph-based dependency parsers suffer from the sheer number of higher order edges they need to (a) score and (b) consider during optimization.",
        "Here we show that when working with LP relaxations, large fractions of these edges can be pruned before they are fully scored?without any loss of optimality guarantees and, hence, accuracy.",
        "This is achieved by iteratively parsing with a subset of higher-order edges, adding higher-order edges that may improve the score of the current solution, and adding higher-order edges that are implied by the current best first order edges.",
        "This amounts to delayed column and row generation in the LP relaxation and is guaranteed to provide the optimal LP solution.",
        "For second order grandparent models, our method considers, or scores, no more than 6?13% of the second order edges of the full model.",
        "This yields up to an eightfold parsing speedup, while providing the same empirical accuracy and certificates of optimality as working with the full LP relaxation.",
        "We also provide a tighter LP formulation for grandparent models that leads to a smaller integrality gap and higher speed."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Many problems in NLP, and structured prediction in general, can be cast as finding high-scoring structures based on a large set of candidate parts.",
        "For example, in second order graph-based dependency parsing (K?bler et al2009) we have to choose a quadratic number of first order and a cubic number of second order edges such that the graph is both high-scoring and a tree.",
        "In coreference, we have to select high-scoring clusters of mentions from an exponential number of candidate clusters, such that each mention is in exactly one cluster (Culotta et al., 2007).",
        "In segmentation of citation strings, we need to consider a quadratic number of possible segments such that every token is part of exactly one segment (Poon and Domingos, 2007).",
        "What makes such problems challenging is the large number of possible parts to consider.",
        "This number not only affects the cost of search or optimization but also slows down the process of scoring parts before they enter the optimization problem.",
        "For example, the cubic grandparent edges in second-order dependency parsing slow down dynamic programs (McDonald and Pereira, 2006), belief propagation (Smith and Eisner, 2008) and LP solvers (Martins et al2009), since there are more value functions to evaluate, more messages to pass, or more variables to consider.",
        "But to even calculate the score for each part we need a cubic number of operations that usually involve expensive feature extraction.",
        "This step often becomes a major bottleneck in parsing, and structured prediction in general.",
        "Candidate parts can often be heuristically pruned.",
        "In the case of dependency parsing, previous work has used coarse-to-fine strategies where simpler first order models are used to prune unlikely first order edges, and hence all corresponding higher order edges (Koo and Collins, 2010; Martins et al. 2009; Riedel and Clarke, 2006).",
        "While such methods can be effective, they are more convoluted, often require training of addition models as well as tuning of thresholding hyper-parameters, and usually provide no guarantees of optimality.",
        "We present an approach that can solve problems with large sets of candidate parts without considering all of these parts in either optimization or scor",
        "ing.",
        "And in contrast to most pruning heuristics, our algorithm can give certificates of optimality before having optimized over, or even scored, all parts.",
        "It does so without the need of auxiliary models or tuning of threshold parameters.",
        "This is achieved by a delayed column and row generation algorithm that iteratively solves an LP relaxation over a small subset of current candidate parts, and then finds new candidates that score highly and can be inserted into the current optimal solution without removing high scoring existing structure.",
        "The latter step subtracts from the cost of a part the price of resources the part requires, and is often referred as pricing.",
        "Sometimes parts may score highly after pricing, but are necessary in order to make the current solution feasible.",
        "We add such parts in a step that roughly amounts to violated cuts to the LP.",
        "We illustrate our approach in terms of a second-order grandparent model for dependency parsing.",
        "We solve these models by iteratively parsing, pricing, and cutting.",
        "To this end we use a variant of the LP relaxation formulated by Martins et al2009).",
        "Our variant of this LP is designed to be amenable to column generation.",
        "It also turns out to be a tighter outer bound that leads to fewer fractional solutions and faster runtimes.",
        "To find high scoring grandparent edges without explicitly enumerating all of them, we prune out a large fraction using factorized upper bounds on grandparent scores.",
        "Our parse, price and cut algorithm is evaluated using a non-projective grandparent model on three languages.",
        "Compared to a brute force approach of solving the full LP, we only score about 10% of the grandparent edges, consider only 8% in optimization, and so observe an increase in parsing speed of up to 750%.",
        "This is possible without loss of optimality, and hence accuracy.",
        "We also find that our extended LP formulation leads to a 15% reduction of fractional solutions, up to 12 times higher speed, and generally higher accuracy when compared to the grandparent formulation of Martins et al2009)."
      ]
    },
    {
      "heading": "2 Graph-Based Dependency Parsing",
      "text": [
        "Dependency trees are representations of the syntactic structure of a sentence (Nivre et al2007).",
        "They determine, for each token of a sentence, the syntactic head the token is modifying.",
        "As a lightweight alternative to phrase-based constituency trees, dependency representations have by now seen widespread use in the community in various domains such as question answering, machine translation, and information extraction.",
        "To simplify further exposition, we now formalize the task, and mostly follow the notation of Martins et al.",
        "(2009).",
        "Consider a sentence x = ?t0, t1, .",
        ".",
        ".",
        ", tn?",
        "where t1, .",
        ".",
        ".",
        ", tn correspond to the n tokens of the sentence, and t0 is an artificial root token.",
        "Let V , {0, .",
        ".",
        ".",
        ", n} be a set of vertices corresponding to the tokens in x, and C ?",
        "V ?V a set of candidate directed edges.",
        "Then a directed graph y ?",
        "C is a legal dependency parse if and only if it is a tree over V rooted at vertex 0.",
        "Given a sentence x, we use Y to denote the set of its legal parses.",
        "Note that all of the above definitions depend on x, but for simplicity we omit this dependency in our notation."
      ]
    },
    {
      "heading": "2.1 Arc-Factored Models",
      "text": [
        "Graph-based models define parametrized scoring functions that are trained to discriminate between correct and incorrect parse trees.",
        "So called arc-factored or first order models are the most basic variant of such functions: they assess the quality of a tree by scoring each edge in isolation (McDonald et al., 2005b; McDonald et al2005a).",
        "Formally, arc-factored models are scoring functions of the form",
        "where w is a weight vector and s?h,m?",
        "(x,w) scores the edge ?h,m?",
        "with respect to sentence x and weightsw.",
        "From here on we will omit both x andw from our notation if they are clear from the context.",
        "Given such a scoring function, parsing amounts to solving:"
      ]
    },
    {
      "heading": "2.2 Higher Order Models",
      "text": [
        "Arc-factored models cannot capture higher order dependencies between two or more edges.",
        "Higher order models remedy this by introducing scores for larger configurations of edges appearing in the",
        "tree (McDonald and Pereira, 2006).",
        "For example, in grandparent models, the score of a tree also includes a score sgp?g,p,c?",
        "for each grandparent-parent-child triple ?g, p, c?",
        ":",
        "There are other variants of higher order models that include, in addition to grandparent triples, pairs of siblings (adjacent or not) or third order edges.",
        "However, to illustrate our approach we will focus on grandparent models and note that most of what we present can be generalized to other higher order models."
      ]
    },
    {
      "heading": "2.3 Feature Templates",
      "text": [
        "For our later exposition the factored and parametrized nature of the scoring functions will be crucial.",
        "In the following we therefore illustrate this property in more detail.",
        "The scoring functions for arcs or higher order edges usually decompose into a sum of feature template scores.",
        "For example, the grandparent edge score sgp?g,p,c?",
        "is defined as sgp?g,p,c?",
        ",",
        "where T gp is the set of grandparent templates, and each template t ?",
        "T gp defines a scoring function sgp,t?g,p,c?",
        "to assess a specific property of the grandparent-parent-child edge ?g, p, c?.",
        "The template scores again decompose.",
        "Considering grandparent scores, we get st?g,p,c?",
        ", w",
        "where hti is an attribute of token ti, say h",
        "Part-of-Speech (ti).",
        "The term dtg,p,c corresponds to a representation of the relation between tokens corresponding to g, p and g. For example, for template 101 it could return their relative positions to each other: d101g,p,c , ?I [g > p] , I [g > c] , I [p > c]?",
        ".",
        "(6) The feature function f t maps the representations of g, p and c into a vector space.",
        "For the purposes of our work this mapping is not important, and hence we omit details."
      ]
    },
    {
      "heading": "2.4 Learning",
      "text": [
        "The scoring functions we consider are parametrized by a family of per-template weight vectors w = ?wt?t?T .",
        "During learning we need to estimate w such that our scoring functions learns to differentiate between correct and incorrect parse trees.",
        "This can be achieved in many ways: large margin training, maximizing conditional likelihood, or variants in between.",
        "In this work we follow Smith and Eis-ner (2008) and train the models with stochastic gradient descent on the conditional log-likelihood of the training data, using belief propagation in order to calculate approximate gradients."
      ]
    },
    {
      "heading": "3 LP and ILP Formulations",
      "text": [
        "Riedel and Clarke (2006) showed that dependency parsing can be framed as Integer Linear Program (ILP), and efficiently solved using an off-the-shelf optimizer if a cutting plane approach is used.1 Compared to tailor made dynamic programs, such generic solvers give the practitioner more modeling flexibility (Martins et al2009), albeit at the cost of efficiency.",
        "Likewise, compared to approximate solvers, ILP and Linear Program (LP) formulations can give strong guarantees of optimality.",
        "The study of Linear LP relaxations of dependency parsing has also lead to effective alternative methods for parsing, such as dual decomposition (Koo et al2010; Rush et al2010).",
        "As we see later, the capability of LP solvers to calculate dual solutions is also crucial for efficient and exact pruning.",
        "Note, however, that dynamic programs provide dual solutions as well (see section 4.5 for more details)."
      ]
    },
    {
      "heading": "3.1 Arc-Factored Models",
      "text": [
        "To represent a parse y ?",
        "Y we first introduce an vector of variables z , ?za?a where za is 1 if a ?",
        "y and 0 otherwise.",
        "With this representation parsing amounts to finding a vector z that corresponds to a legal parse tree and that maximizes ?",
        "a zasa.",
        "One way to achieve this is to search through the convex hull of all legal incidence vectors, knowing that any linear objectives would take on its maximum on one of the hull's vertices.",
        "We will use Z to denote this convex hull of incidence vectors of legal parse trees,",
        "and callZ the arborescence polytope (Martins et al. 2009).",
        "The Minkowski-Weyl theorem tells us thatZ can be represented as an intersection of halfspaces, or constraints, Z = {z|Az ?",
        "b}.",
        "Hence optimal dependency parsing, in theory, can be addressed using LPs.",
        "However, it is difficult to describe Z with a compact number of constraints and variables that lend themselves to efficient optimization.",
        "In general we therefore work with relaxations, or outer bounds, on Z .",
        "Such outer bounds are designed to cut off all illegal integer solutions of the problem, but still allow for fractional solutions.",
        "In case the optimum is achieved at an integer vertex of the outer bound, it is clear that we have found the optimal solution to the original problem.",
        "In case we find a fractional point, we need to map it onto Z (e.g., by projection or rounding).",
        "Alternatively, we can use the outer bound together with 0/1 constraints on z, and then employ an ILP solver (say, branch-and-bound) to find the true optimum.",
        "Given the NP-hardness of ILP, this will generally be slow.",
        "In the following we will present the outer bound Z?",
        "?",
        "Z proposed by Martins et al2009).",
        "Compared to the representation Riedel and Clarke (2006), this bound has the benefit a small polynomial number of constraints.",
        "Note, however, that often exponentially many constraints can be efficiently handled if polynomial separation algorithms exists, and that such representations can lead to tighter outer bounds.",
        "The constraints we employ are: No Head For Root In a dependency tree the root node never has a head.",
        "While this could be captured through linear constraints, it is easier to simply restrict the candidate set C to never contain edges of the form ?",
        "?, 0?.",
        "Exactly One Head for Non-Roots Any non-root token has to have exactly one head token.",
        "We can enforce this property through the set of constraints:",
        "No Cycles A parse tree cannot have cycles.",
        "This is equivalent, together with the head constraints above, to enforcing that the tree be fully connected.",
        "Martins et al2009) capture this connectivity constraint using a single commodity flow formulation.",
        "This requires the introduction of flow variables ?",
        ", ?",
        "?a?a?C .",
        "By enforcing that token 0 has n outgoing flow, ?",
        "and that flow is zero on disabled arcs ??h,m?",
        "?",
        "nz?h,m?, (NoFlow) connectivity can be ensured.",
        "Assuming we have such a representation, parsing with an LP relaxation amounts to solving"
      ]
    },
    {
      "heading": "3.2 Higher Order Models",
      "text": [
        "The 1st-Order LP can be easily extended to capture second (or higher) order models.",
        "For for the case of grandparent models, this amounts to introducing another class of variables, zgpg,p,c, that indicate if the parse contains both the edge ?g, p?",
        "and the edge ?p, c?.",
        "With the help of the indicators zgp we can represent the second order objective as a linear function.",
        "We now need an outer bound on the convex hull of vectors ?z, zgp?",
        "where z is a legal parse tree and zgp is a consistent set of grandparent indicators.",
        "We will refer to this convex hull as the grandparent polytope Zgp.",
        "We can reuse the constraints A of section 3.1 to ensure that z is in Z .",
        "To make sure zgp is consistent with z, Martins et al2009) linearize the equivalence zgpg,p,c ?",
        "zg,p ?",
        "zp,c we know to hold for legal incidence vectors, yielding",
        "There are additional constraints we know to hold in Zgp.",
        "First, we know that for any active edge ?p, c?",
        "?",
        "y with p > 0 there is exactly one grandparent edge ?g, p, c?.",
        "Likewise, for an inactive edge ?p, c?",
        "/?",
        "y there must be no grandparent edge ?g, p, c?.",
        "This can be captured through the constraint:",
        "We also know that if an edge ?g, p?",
        "in inactive, there must not be any grandparent edge ?g, p, c?",
        "that goes through ?g, p?",
        ":",
        "It can be easily shown that for integer solutions the constraints ArcGP and GPArc of Martins et al2009) are sufficient conditions for consistency between z and zgp.",
        "It can equally be shown that the same holds for the constraints OneGP and NoGP.",
        "However, when working with LP relaxations, the two polytopes have different fractional vertices.",
        "Hence, by combining both constraint sets, we can get a tighter outer bound on the grandparent polytope Zgp.",
        "In section 6 we show empirically that this combined polytope in fact leads to fewer fractional solutions.",
        "Note that when using the union of all four types of constraints, the NoGP constraint is implied by the constraint GPArc (left) by summing over c on both sides, and can hence be omitted."
      ]
    },
    {
      "heading": "4 Parse, Price and Cut",
      "text": [
        "We now introduce our parsing algorithm.",
        "To this end, we first give a general description of column and row generation for LPs; then, we illustrate how these techniques can be applied to dependency parsing."
      ]
    },
    {
      "heading": "4.1 Column and Row Generation",
      "text": [
        "LPs often have too many variables and constraints to be efficiently solved.",
        "In such cases delayed column and row generation can substantially reduce runtime by lazily adding variables only when needed (Gilmore and Gomory, 1961; L?bbecke and Desrosiers, 2004).",
        "To illustrate column and row generation let us consider the following general primal LP and its corresponding dual problem:",
        "subject to A??",
        "?",
        "s. Say you are given a primal feasible z?",
        "and a dual feasible ??",
        "for which complementary slackness holds: for all variables i we have z?i > 0?",
        "si =",
        "an optimal primal solution, ??",
        "and optimal dual solution, and that both objectives meet at these values (Bertsekas, 1999).",
        "The idea behind delayed column and row generation is to only consider a small subset of variables (or columns) I and subset of constraints (or rows) J .",
        "Optimizing over this restricted problem, either with an off-the-shelf solver or a more specialized method, yields the pair",
        "of partial primal and dual solutions.",
        "This pair is feasible and complementary with respect to variables I and constraints J .",
        "We can extend it to a solution (z?,y?)",
        "over all variables and constraints by heuristically setting the remaining primal and dual variables.",
        "If it so happens that (z?,y?)",
        "is feasible and complementary for all variables and constraints, we have found the optimal solution.",
        "If not, we add the constraints and variables for which feasibility and slackness are violated, and resolve the new partial problem.",
        "In practice, the uninstantiated primal and dual variables are often set to 0.",
        "In this case complementary slackness holds trivially, and we only need to find violated primal and dual constraints.",
        "For primal constraints, ?",
        "i ziai,j ?",
        "bi, searching for violating constraints j is the well-known separation step in cutting plane algorithms.",
        "For the dual constraints, ?",
        "j ?jai,j ?",
        "si, the same problem is referred to as pricing.",
        "Pricing is often framed as searching for all, or some, variables i with positive reduced cost ri , si?",
        "?",
        "j ?jai,j .",
        "Note that while these problems are, naturally, dual to each other, they can have very different flavors.",
        "When we assess dual constraints we need to calculate a cost si for variable i, and usually this cost would be different for different i.",
        "For primal constraints the corresponding right-hand-sides are usually much more homogenous.",
        "Algorithm 1 Parse, Price and Cut.",
        "Require: Initial candidate edges and hyperedges P .",
        "Ensure: The optimal z.",
        "1: repeat 2: z,?",
        "?",
        "parse(P ) 3: N ?",
        "price(?)",
        "4: M ?",
        "cut(z) 5: P ?",
        "P ?N ?M 6: until N = ?",
        "?M = ?",
        "7: return z",
        "The reduced cost ri = si ?",
        "?",
        "j ?jai,j has several interesting interpretations.",
        "First, intuitively it measures the score we could gain by setting zi = 1, and subtracts an estimate of what we would loose because zi = 1 may compete with other variables for shared resources (constraints).",
        "Second, it corresponds to the coefficient of zi in the Lagrangian",
        "possible primal objective with zi = k. This means that ri = Uzi=1 ?",
        "Uzi=0 is the difference between an upper bound that considers zi = 1, and one that considers zi = 0.",
        "The tighter the bound Uzi=0 is, the closer ri is to an upper bound on the maximal increase we can get for setting zi to 1.",
        "At convergence of column generation, complementary slackness guarantees that Uzi=0 is tight for all z",
        "hence ri is a true an upper bound."
      ]
    },
    {
      "heading": "4.2 Application to Dependency Parsing",
      "text": [
        "The grandparent formulation in section 3.2 has a cubic number of variables z?g,p,c?",
        "as well as a cubic number of constraints.",
        "For longer sentences this number can slow us down in two ways.",
        "First, the optimizer works with a large search space, and will naturally become slower.",
        "Second, for every grandparent edge we need to calculate the score s?g,p,c?, and this calculation can often be a major bottleneck, in particular when using complex feature functions.",
        "To overcome this bottleneck, our parse, price and cut algorithm, as shown in algorithm 1, uses column and row generation.",
        "In particular, it lazily instantiates the grandparent edge variables zgp?g,p,c?, and the corresponding cubic number of constraints.",
        "All uninstantiated variables are implicitly set to 0.",
        "The algorithm requires some initial set of variables to start with.",
        "In our case this set P contains all first-order edges ?h,m?",
        "in the candidate set C, and for each of these one grandparent edge ?0, h,m?.",
        "The primary purpose of these grandparent edges is to ensure feasibility of the OneGP constraints.",
        "In step 2, the algorithm parses with the current set of candidates P by solving the corresponding LP relaxation.",
        "The LP contains all columns and constraints that involve the edges and grandparent edges of P .",
        "The solver returns both the best primal solution z (for both edges and grandparents), and a complementary dual solution ?.",
        "In step 3 the dual variables?",
        "are used to find uninstantiated grandparent edges ?g, p, c?",
        "with positive reduced cost.",
        "The price routine returns such edges in N .",
        "In step 4 the primal solution is inspected for violations of constraint ArcGP.",
        "The cut routine performs this operation, and returns M , the set of edges ?g, p, c?",
        "that violate ArcGP.",
        "In step 5 the algorithm converges if no more constraint violations, or promising new columns, can be found.",
        "If there have been violations (M 6= ?)",
        "or promising columns (N 6= ?",
        "), steps 2 to 4 are repeated, with the newly found parts added to the problem.",
        "Note that LP solvers can be efficiently warm-started after columns and rows have been added, and hence the cost of calls to the solver in step 2 is substantially reduced after the first iteration."
      ]
    },
    {
      "heading": "4.3 Pricing",
      "text": [
        "In the pricing step we need to efficiently find a set of grandparent edge variables zgp?g,p,c?",
        "with positive reduced cost, or the empty set if no such variables exist.",
        "Let ?OneGP?p,c?",
        "be the dual variables for the OneGP constraints and ?NoGP?g,p?",
        "the duals for constraints NoGP.",
        "Then for the reduced cost of zgp?g,p,c?",
        "we know that:",
        "Notice that the duals for the remaining two constraints ArcGP and GPArc do not appear in this equation.",
        "This is valid because we can safely set their duals to zero without violating dual feasibility or complementary slackness of the solution returned by the solver.",
        "A naive pricing implementation would exhaustively iterate over all ?g, p, c?",
        "and evaluate r?g,p,c?",
        "for each.",
        "In this case we can still substantially reduce the number of grandparent variables that enter the LP, provided many of these variables have non-positive reduced cost.",
        "However, we still need to calculate the score s?g,p,c?",
        "for each ?g, p, c?, an expensive operation we hope to avoid.",
        "In the following we present an upper bound on the reduced cost, r?gp?g,p,c?",
        "?",
        "r gp ?g,p,c?, which decomposes in a way that allows for more efficient search.",
        "Using this bound, we find all new grandparent edges N?",
        "for which this upper bound is positive:",
        "Next we prune away all but the grandparent edges for which the exact reduced cost is positive: N ?",
        "N?",
        "\\ {e : rgpe > 0} .",
        "(10) Our bound r?gp?g,p,c?",
        "on the reduced cost of ?g, p, c?",
        "is based on an upper bound s?gp?g,p,??",
        "?",
        "maxc s gp ?g,p,c?",
        "on the grandparent score involving ?g, p?",
        "as grandparent and parent, and the bound s?gp??,p,c?",
        "?",
        "maxg s gp ?g,p,c?",
        "on the grandparent score involving ?p, c?",
        "as parent and child.",
        "Concretely, we have",
        "To find edges ?g, p, c?",
        "for which this bound is positive, we can filter out all edges ?p, c?",
        "such that",
        "filtering step cuts off a substantial number of edges, and is the main reason why can avoid scoring all edges.",
        "Next we filter, for each remaining ?p, c?, all possible grandparents g according to the definition of r?gp?g,p,c?.",
        "This again allows us to avoid calling the",
        "straints are used, the corresponding dual variables have no sign constraints.",
        "Hence we could not make the same argument for ?OneGP?p,c?",
        ".",
        "grandparent scoring function on ?g, p, c?, and yields the candidate set N?",
        ".",
        "Only if r?gp?g,p,c?",
        "is positive do we have to evaluate the exact reduced cost and score.",
        "What remains to be done is the calculation of upper bounds s?gp?g,p,??",
        "and s?",
        "gp ??,p,c?.",
        "Our bounds factor into per-template bounds according to the definitions in section 2.3.",
        "In particular, we have",
        "where s?t??,p,c?",
        "is a per-template upper bound defined as s?gp,t??,p,c?",
        ", max",
        "That is, we maximize over all possible attribute values v any token g could have, and any possible relation e a token g can have to p and c. Notice that these bounds can be calculated offline, and hence amortize after deployment of the parser.",
        "To price variables, we use the duals returned by the solver.",
        "This is a valid default strategy, but may lead to ?",
        "with overcautious reduced costs.",
        "Note, however, that we can arbitrary alter ?",
        "to minimize reduced costs of uninstantiated variables, as long as we ensure that feasibility and complementary slackness are maintained for the instantiated problem.",
        "We use this flexibility for increasing ?OneGP?p,c?",
        ", and hence lowering reduced costs zgp?g,p,c?",
        "for all tokens c. Assume that z?p,c?",
        "= 0 and let r?p,c?",
        "= ?",
        "OneGP ?p,c?",
        "+ K be the current reduced cost for z?p,c?",
        "in the instantiated problem.",
        "Here K is a value depending on s?p,c?",
        "and the remaining constraints z?p,c?",
        "is involved in.",
        "We know that r?p,c?",
        "?",
        "0 due to dual feasibility and hence r?p,c?",
        "may be 0, but note that r?p,c?",
        "< 0 in many cases.",
        "In such cases we can increase ?OneGP?p,c?",
        "to ?K and get r?p,c?",
        "= 0.",
        "With respect to z?p,c?",
        "this maintains dual feasibility (because r?p,c?",
        "?",
        "0) and complementary slackness (because z?p,c?",
        "= 0).",
        "Furthermore, with respect to the zgp?g,p,c?",
        "for all tokens c this also maintains feasibility (because the increased ?OneGP?p,c?",
        "appears with negative sign in 8) and complementary slackness (because zgp?g,p,c?",
        "= 0 due to z?p,c?",
        "= 0)."
      ]
    },
    {
      "heading": "4.4 Separation",
      "text": [
        "What happens if both z?g,p?",
        "and z?p,c?",
        "are active while zgp?g,p,c?",
        "is still implicitly set to 0?",
        "In this case we violate constraint ArcGP.",
        "We could remedy this by adding the cut z?g,p?",
        "+ z?p,c?",
        "?",
        "1, resolve the LP, and then use the dual variable corresponding to this constraint to get an updated reduced cost r?g,p,c?.",
        "However, in practice we found this does not happen as often, and when it does, it is cheaper for us to add the corresponding column r?g,p,c?",
        "right away instead of waiting to the next iteration to price it.",
        "To find all pairs of variables for z?g,p?",
        "+ z?p,c?",
        "?",
        "1 is violated, we first filter out all edges ?h,m?",
        "for which z?h,m?",
        "= 0 as these automatically satisfy any ArcGP constraint they appear in.",
        "Now for each z?g,p?",
        "> 0 all z?p,c?",
        "> 0 are found, and if their sum is larger than 1, the corresponding grandparent edge ?g, p, c?",
        "is returned in the result set."
      ]
    },
    {
      "heading": "4.5 Column Generation in Dynamic Programs",
      "text": [
        "Column and Row Generation can substantially reduce the runtime of an off-the-shelf LP solver, as we will find in section 6.",
        "Perhaps somewhat surprisingly, it can also be applied in the context of dynamic programs.",
        "It is well known that for each dynamic program there is an equivalent polynomial LP formulation (Martin et al1990).",
        "Roughly speaking, in this formulation primal variables correspond to state transitions, and dual variables to value functions (e.g., the forward scores in the Viterbi algorithm).",
        "In pilot studies we have already used DCG to speed up (exact) Viterbi on linear chains (Belanger et al2012).",
        "We believe it could be equally applied to dynamic programs for higher order dependency parsing."
      ]
    },
    {
      "heading": "5 Related Work",
      "text": [
        "Our work is most similar in spirit to the relaxation method presented by Riedel and Smith (2010) that incrementally adds second order edges to a graphical model based on a gain measure?the analog of our reduced cost.",
        "However, they always score every higher order edge, and also provide no certificates of optimality.",
        "Several works in parsing, and in MAP inference in general, perform some variant of row generation (Riedel and Clarke, 2006; Tromble and Eis-ner, 2006; Sontag and Jaakkola, 2007; Sontag et al. 2008).",
        "However, none of the corresponding methods lazily add columns, too.",
        "The cutting plane method of Riedel (2008) can omit columns, but only if their coefficient is negative.",
        "By using the notion of reduced costs we can also omit columns with positive coefficient.",
        "Niepert (2010) applies column generation, but his method is limited to the case of k-Bounded MAP Inference.",
        "Several ILP and LP formulations of dependency parsing have been proposed.",
        "Our formulation is inspired by Martins et al2009), and hence uses fewer constraints than Riedel and Clarke (2006).",
        "For the case of grandparent edges, our formulation also improves upon the outer bound of Martins et al2009) in terms of speed, tightness, and utility for column generation.",
        "Other recent LP relaxations are based on dual decomposition (Rush et al2010; Koo et al., 2010; Martins et al2011).",
        "These relaxations allow the practitioner to utilize tailor-made dynamic programs for tractable substructure, but still every edge needs to be scored.",
        "Given that column generation can also be applied in dynamic programs (see section 4.5), our algorithm could in fact accelerate dual decomposition parsing as well.",
        "Pruning methods are a major part of many structured prediction algorithms in general, and of parsing algorithms in particular (Charniak and Johnson, 2005; Martins et al2009; Koo and Collins, 2010; Rush and Petrov, 2012).",
        "Generally these methods follow a coarse-to-fine scheme in which simpler models filter out large fractions of edges.",
        "Such methods are effective, but require tuning of threshold parameters, training of additional models, and generally lead to more complex pipelines that are harder to analyze and have fewer theoretical guarantees.",
        "A* search (Ahuja et al1993) has been used to search for optimal parse trees, for example by Klein and Manning (2003) or, for dependency parsing, by Dienes et al2003).",
        "There is a direct relation between both A* and Column Generation based on an LP formulation of the shortest path problem.",
        "Roughly speaking, in this formulation any feasible dual assignments correspond to a consistent (and thus admissible) heuristic, and the corresponding reduced costs can be used as edge weights.",
        "Run",
        "ning Dijkstra's algorithm with these weights then amounts to A*.",
        "Column generation for the shortest path problem can then be understood as a method to lazily construct a consistent heuristic.",
        "In every step this method finds edges for which consistency is violated, and updates the heuristic such that all these edges are consistent."
      ]
    },
    {
      "heading": "6 Experiments",
      "text": [
        "We claim that LP relaxations for higher order parsing can be solved without considering, and scoring, all candidate higher order edges.",
        "In practice, how many grandparent edges do we need to score, and how many do we need to add to the optimization problem?",
        "And what kind of reduction in runtime does this reduction in edges lead to?",
        "We have also pointed out that our outer bound on the grandparent polytope of legal edge and grandparent vectors is tighter than the one presented by Martins et al2009).",
        "What effect does this bound have on the number of fractional solutions and the overall accuracy?",
        "To answer these questions we will focus on a set of non-projective grandparent models, but point out that our method and formulation can be easily extended to projective parsing as well as other types of higher order edges.",
        "We use the Danish test data of Buchholz and Marsi (2006) and the Italian and Hungarian test datasets of Nivre et al2007)."
      ]
    },
    {
      "heading": "6.1 Impact of Price and Cut",
      "text": [
        "Table 1 compares brute force optimization (BF) with the full model, in spirit of Martins et al2009), to running parse, price and cut (PPC) on the same model.",
        "This model contains all constraints presented in 3.2.",
        "The table shows the average number of parsed sentences per second, the average objective, number of grandparent edges scored and added, all relative to the brute force approach.",
        "We also present the average unlabeled accuracy, and the percentage of sentences with integer solutions.",
        "This number shows us how often we not only found the optimal solution to the LP relaxation, but also the optimal solution to the full ILP.",
        "We first note that both systems achieve the same objective, and therefore, also the same accuracy.",
        "This is expected, given that column and row generation are known to yield optimal solutions.",
        "Next we see that the number of grandparent edges scored and added to the problem is reduced to 5?13% of the full model.",
        "This leads to up to 760% improvement in speed.",
        "This improvement comes for free, without any sacrifice in optimality or guarantees.",
        "We also notice that in all cases at least 97% of the sentences have no fractional solutions, and are therefore optimal even with respect to the ILP.",
        "Table 1 also shows that our bounds on reduced costs are relatively tight.",
        "For example, in the case of Italian we score only one percent more grandparent edges than we actually need to add.",
        "Our fastest PCC parser processes about one sentence per second.",
        "This speed falls below the reported numbers of Martins et al2009) of about 0.6 seconds per sentence.",
        "Crucially, however, in contrast to their work, our speed is achieved without any first-order pruning.",
        "In addition, we expect further improvements in runtime by optimizing the implementation of our pricing algorithm."
      ]
    },
    {
      "heading": "6.2 Tighter Grandparent Polytope",
      "text": [
        "To investigate how the additional grandparent constraints in section 3.2 help, we compare three models, this time without PPC.",
        "The first model follows Martins et al2009) and uses constraints ArcGP and GPArc only.",
        "The second model uses only constraints OneGP and NoGP.",
        "The final model incorporates all four constraints.",
        "Table 2 shows speed relative to the baseline model with constraints ArcGP and GPArc, as well as the percentage of integer solutions and the average unlabeled accuracy?all for the Italian and Hungarian datasets.",
        "We notice that the full model has less fractional solutions than the partial models, and either substantially (Italian) or slightly (Hungarian) faster runtimes than ArcGP+GPArc.",
        "Interestingly, both sets of constraints in isolation perform worse, in particular the OneGP and NoGP model."
      ]
    },
    {
      "heading": "7 Conclusion",
      "text": [
        "We have presented a novel method for parsing in second order grandparent models, and a general blueprint for more efficient and optimal structured prediction.",
        "Our method lazily instantiates candidate parts based on their reduced cost, and on constraint"
      ]
    },
    {
      "heading": "Italian Hungarian Danish BF PPC BF PPC BF PPC",
      "text": [
        "Sent./sec.",
        "relative to BF 100% 760% 100% 380% 100% 390% GPs Scored relative to BF 100% 6% 100% 12% 100% 13% GPs Added relative to BF 100% 5% 100% 7% 100% 7% Objective rel.",
        "to BF 100% 100% 100% 100% 100% 100%",
        "ent polytope, for nonprojective parsing of Italian and Danish.",
        "violations.",
        "This allows us to discard a large fraction of parts during both scoring and optimization, leading to nearly 800% speed-ups without loss of accuracy and certificates.",
        "We also present a tighter bound on the grandparent polytope that is useful in its own right.",
        "Delayed column and row generation is very useful when solving large LPs with off-the-shelf solvers.",
        "Given the multitude of work in NLP that uses LPs and ILPs in this way (Roth and Yih, 2004; Clarke and Lapata, 2007), we hope that our approach will prove itself useful for other applications.",
        "We stress that this approach can also be used when working with dynamic programs, as pointed out in section 4.5, and therefore also in the context of dual decomposition.",
        "This suggests even wider applicability, and usefulness in various structured prediction problems.",
        "The underlying paradigm could also be useful for more approximate methods.",
        "In this paradigm, algorithms maintain an estimate of the cost of certain resources (duals), and use these estimates to guide search and the propose new structures.",
        "For example, a local-search based dependency parser could estimate how contested certain tokens, or edges, are, and then use these estimates to choose better next proposals.",
        "The notion of reduced cost can give guidance on what such estimates should look like."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "This work was supported in part by the Center for Intelligent Information Retrieval and the University of Massachusetts and in part by UPenn NSF medium IIS-0803847.",
        "We gratefully acknowledge the support of Defense Advanced Research Projects Agency (DARPA) Machine Reading Program under Air Force Research Laboratory (AFRL) prime contract no.",
        "FA8750-09-C-0181.",
        "Any opinions, findings, and conclusion or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA, AFRL, or the US government."
      ]
    }
  ]
}
