{
  "info": {
    "authors": [
      "Daniel Gildea"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J12-3008",
    "title": "On the String Translations Produced by Multi Bottomâ€“Up Tree Transducers",
    "url": "https://aclweb.org/anthology/J12-3008",
    "year": 2012
  },
  "references": [
    "acl-C90-3045",
    "acl-H05-1101",
    "acl-J07-2003",
    "acl-J09-4009",
    "acl-J94-1004",
    "acl-J97-3002",
    "acl-N03-1021",
    "acl-N10-1130",
    "acl-P02-1039",
    "acl-P04-1084",
    "acl-P06-1121",
    "acl-P87-1015",
    "acl-P92-1012",
    "acl-W06-3119"
  ],
  "sections": [
    {
      "text": [
        "Tree transducers are defined as relations between trees, but in syntax-based machine translation, we are ultimately concerned with the relations between the strings at the yields of the input and output trees.",
        "We examine the formal power of Multi Bottom-Up Tree Transducers from this point of view."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Many current approaches to syntax-based statistical machine translation fall under the theoretical framework of synchronous tree substitution grammars (STSGs).",
        "Tree substitution grammars (TSGs) generalize context-free grammars (CFGs) in that each rule expands a nonterminal to produce an arbitrarily large tree fragment, rather than a fragment of depth one as in a CFG.",
        "Synchronous TSGs generate tree fragments in the source and target languages in parallel, with each rule producing a tree fragment in either language.",
        "Systems such as that of Galley et al. (2006) extract STSG rules from parallel bilingual text that has been automatically parsed in one language, and the STSG nonterminals correspond to nonterminals in these parse trees.",
        "Chiang's (2007) Hiero system produces simpler STSGs with a single nonterminal.",
        "STSGs have the advantage that they can naturally express many reordering and restructuring operations necessary for machine translation (MT).",
        "They have the disadvantage, however, that they are not closed under composition (Maletti et al. 2009).",
        "Therefore, if one wishes to construct anMT system as a pipeline of STSG operations, the result may not be expressible as an STSG.",
        "Recently, Maletti (2010) has argued that multi bottom?up tree transducers (MBOTs) (Lilin 1981; Arnold and Dauchet 1982; Engelfriet, Lilin, and Maletti 2009) provide a useful representation for natural language processing applications because they generalize STSGs, but have the added advantage of being closed under composition.",
        "MBOTs generalize traditional bottom?up tree transducers in that they allow transducer states to pass more than one output subtree up to subsequent transducer operations.",
        "The number of subtrees taken by a state is called its rank.",
        "MBOTs are linear and non-deleting; that is, operations cannot copy or delete arbitrarily large tree fragments.",
        "Although STSGs and MBOTs both perform operations on trees, it is important to note that, in MT, we are primarily interested in translational relations between strings.",
        "Tree operations such as those provided by STSGs are ultimately tools to translate a string in one natural language into a string in another.",
        "Whereas MBOTs originate in the tree transducer literature and are defined to take a tree as input, MT systems such as those of Galley et al. (2006) and Chiang (2007) find a parse of the source language sentence as part of the translation process, and the decoding algorithm, introduced by Yamada and Knight (2002), has more in common with CYK parsing than with simulating a tree transducer.",
        "In this article, we investigate the power of MBOTs, and of compositions of STSGs in particular, in terms of the set of string translations that they generate.",
        "We relate MBOTs and compositions of STSGs to existing grammatical formalisms defined on strings through five main results, which we outline subsequently.",
        "The first four results serve to situate general MBOTs among string formalisms, and the fifth result addresses MBOTs resulting from compositions of STSGs in particular.",
        "Our first result is that the translations produced by MBOTs are a subset of those produced by linear context-free rewriting systems (LCFRSs) (Vijay-Shankar, Weir, and Joshi 1987).",
        "LCFRS provides a very general framework that subsumes CFG, tree adjoining grammar (TAG; Joshi, Levy, and Takahashi 1975; Joshi and Schabes 1997), and more complex systems, as well as synchronous context-free grammar (SCFG) (Aho and Ullman 1972) and synchronous tree adjoining grammar (STAG) (Shieber and Schabes 1990; Schabes and Shieber 1994) in the context of translation.",
        "LCFRS allows grammar nonterminals to generate more than one span in the final string; the number of spans produced by an LCFRS nonterminal corresponds to the rank of an MBOT state.",
        "Our second result states that the translations produced by MBOTs are equivalent to a specific restricted form of LCFRS, which we call 1-m-LCFRS.",
        "From the construction relating MBOTs and 1-m-LCFRSs follow results about the source and target sides of the translations produced by MBOTs.",
        "In particular, our third result is that the translations produced by MBOTs are context-free within the source language, and hence are strictly less powerful than LCFRSs.",
        "This implies that MBOTs are not as general as STAGs, for example.",
        "Similarly, MBOTs are not as general as the generalized multitext grammars proposed for machine translation by Melamed (2003), which retain the full power of LCFRSs in each language (Melamed, Satta, and Wellington 2004).",
        "Our fourth result is that the output of an MBOT, when viewed as a string language, does retain the full power of LCFRSs.",
        "This fact is mentioned by Engelfriet, Lilin, and Maletti (2009, page 586), although no explicit construction is given.",
        "Our final result specifically addresses the string translations that result from compositions of STSGs, with the goal of better understanding the complexity of using such compositions in machine translation systems.",
        "We show that the translations produced by compositions of STSGs are more powerful than those produced by single STSGs, or, equivalently, by SCFGs.",
        "Although it is known that STSGs are not closed under composition, the proofs used previously in the literature rely on differences in tree structure, and do not generate string translations that cannot be generated by STSG.",
        "Our result implies that current approaches to machine translation decoding will need to be extended to handle arbitrary compositions of STSGs.",
        "We now turn to give definitions of MBOTs and LCFRSs in the next section, before presenting our results on general MBOTs in Section 3, and our result on compositions of STSGs in Section 4."
      ]
    },
    {
      "heading": "2. Preliminaries",
      "text": [
        "A ranked alphabet is an alphabet where each symbol has an integer rank, denoting the number of children the symbol takes in a tree.",
        "T?",
        "denotes the set of trees constructed",
        "Gildea On the String Translations Produced by Multi Bottom?Up Tree Transducers from ranked alphabet ?.",
        "We use parentheses to write trees: for example, a(b, c, d) is an element of T?",
        "if a is an element of ?",
        "with rank 3, and b, c, and d are elements of ?",
        "with rank 0.",
        "Similarly, given a ranked alphabet ?",
        "and a set X, ?",
        "(X) denotes the set of trees consisting of a single symbol of ?",
        "of rank k dominating a sequence of k elements from X.",
        "We use T?",
        "(X) to denote the set of arbitrarily sized trees constructed from ranked alphabet ?",
        "having items from set X at some leaf positions.",
        "That is, T?",
        "(X) is the smallest set such thatX ?",
        "T?",
        "(X) and ?",
        "(t1, .",
        ".",
        ".",
        ", tk) ?",
        "T?",
        "(X) if ?",
        "is an element of?with rank k, and t1, .",
        ".",
        ".",
        ", tk ?",
        "T?(X).",
        "Amulti bottom?up tree transducer (MBOT) (Lilin 1981; Arnold and Dauchet 1982; Engelfriet, Lilin, and Maletti 2009; Maletti 2010) is a system (S,?,?,F,R) where: S,?, and?",
        "are ranked alphabets of states, input symbols, and output symbols, respectively.",
        "F ?",
        "S is a set of accepting states.",
        "R is a finite set of rules l?",
        "r where, using a set of variables X, l ?",
        "T?",
        "(S(X)), and r ?",
        "S(T?",
        "(X)) such that: ?",
        "every x ?",
        "X that occurs in l occurs exactly once in r and vice versa, and ?",
        "l ?",
        "S(X) or r ?",
        "S(X).",
        "One step in an MBOT transduction is performed by rewriting a local tree fragment as specified by one of the rules in R. We replace the fragment l with r, copying the subtree under each variable in l to the location of the corresponding variable in r. Transducer rules apply bottom?up from the leaves of the input tree, as shown in Figure 1, and must terminate in an accepting state.",
        "We use underlined symbols for the transducer states, in order to distinguish them from the symbols of the input and output alphabets.",
        "We define a translation to be a set of string pairs, and we define the yield of an MBOT M to be the set of string pairs (s, t) such that there exist: a tree s?",
        "?",
        "T?",
        "having s as its yield, a tree t?",
        "?",
        "T?",
        "having t as its yield, and a transduction from s?",
        "to t?",
        "that is accepted byM.",
        "We refer to s as the source side and t as the target side of the translation.",
        "We use the notation source(T) to denote the set of source strings of a translation T, source(T) = {s |(s, t) ?",
        "T}, and we use the notation target(T) to denote the set of target strings.",
        "We use the notation yield(MBOT) to denote the set of translations produced by the set of all MBOTs.",
        "A linear context-free rewriting system (LCFRS) is defined as a system (VN,VT,P,S), where VN is a set of nonterminal symbols, VT is a set of terminal symbols, P is a set of productions, and S ?",
        "VN is a distinguished start symbol.",
        "Associated with each nonterminal B is a fanout ?",
        "(B), which tells how many spans B covers in the final string.",
        "Productions p ?",
        "P take the form: p : A?",
        "g(B1,B2, .",
        ".",
        ".",
        ",Br), where A,B1, .",
        ".",
        ".",
        ",Br ?",
        "VN, and g is a function g : (V",
        "?",
        "(A), which specifies how to assemble the ?r i=1?",
        "(Bi) spans of the righthand side nonterminals into the ?",
        "(A) spans of the lefthand side nonterminal.",
        "The function gmust be linear and non-erasing, which means that if we write g(?x1,1, .",
        ".",
        ".",
        ", x1,?",
        "(B1 )?, .",
        ".",
        ".",
        ", ?xr,1, .",
        ".",
        ".",
        ", xr,?",
        "(Br )?)",
        "= ?t1, .",
        ".",
        ".",
        ", t?(A)?",
        "the tuple of strings ?t1, .",
        ".",
        ".",
        ", t?(A)?",
        "on the right-hand side contains each variable xi,j from the left-hand side exactly once, and may also contain terminals from VT.",
        "The process of generating a string from an LCFRS grammar consists of first choosing, top?down, a production to expand each nonterminal, and then, bottom?up, applying the functions",
        "Figure 1 Step-by-step example of an MBOT tree transduction.",
        "The left column shows the transducer rule applied at each step; only the last rule contains variables, whereas the others contain alphabet symbols of rank zero at their leaves.",
        "State VPQ has rank two, and states NP and S have rank one.",
        "associated with each production to build the string.",
        "We refer to the tree induced by top?",
        "down nonterminal expansions of an LCFRS as the derivation tree, or sometimes simply as a derivation.",
        "As an example of how the LCFRS framework subsumes grammatical formalisms such as CFG, consider the following CFG:",
        "This grammar corresponds to the following grammar in LCFRS notation:",
        "Here, all nonterminals have fanout one, reflected in the fact that all tuples defining the productions?",
        "functions contain just one string.",
        "Just as CFG is equivalent to LCFRS with fanout 1, SCFG and TAG can be represented as LCFRS with fanout 2.",
        "Higher values of fanout allow strictly more powerful grammars (Rambow and Satta 1999).",
        "Polynomial-time parsing is possible for any fixed LCFRS grammar, but the degree of",
        "Gildea On the String Translations Produced by Multi Bottom?Up Tree Transducers the polynomial depends on the grammar.",
        "Parsing general LCFRS grammars, where the grammar is considered part of the input, is NP-complete (Satta 1992).",
        "Following Melamed, Satta, and Wellington (2004), we represent translation in LCFRS by using a special symbol # to separate the strings of the two languages.",
        "Our LCFRS grammars will only generate strings of the form s#t, where s and t are strings not containing the symbol #, and we will identify s as the source string and t as the target string.",
        "We use the notation trans(LCFRS) to denote the set of translations that can be produced by taking the string language of some LCFRS and splitting each string into a pair at the location of the # symbol.",
        "3.",
        "Translations Produced by General MBOTs In this section, we relate the yield of general MBOTs to string rewriting systems.",
        "To begin, we show that the translation produced by any MBOT is also produced by an LCFRS by giving a straightforward construction for converting MBOT rules to LCFRS rules.",
        "We first consider MBOT rules having only variables, as opposed to alphabet symbols of rank zero, at their leaves.",
        "For an MBOT rule l?",
        "r with l ?",
        "T?",
        "(S(X)), let S1,S2, .",
        ".",
        ".",
        ",Sk be the sequence of states appearing from left to right immediately above the leaves of l. Without loss of generality, we will name the variables such that xi,j is the jth child of the ith state, Si, and the sequence of variables at the leaves of l, read from left to right, is: x1,1, .",
        ".",
        ".",
        ", x1,d(S1 ), .",
        ".",
        ".",
        ", xk,1, .",
        ".",
        ".",
        ", xk,d(Sk ), where d(Si) is the rank of state Si.",
        "Let S0 be the state symbol at the root of the right-hand-side (r.h.s.)",
        "tree r ?",
        "S(T?(X)).",
        "Let ?",
        "and ?",
        "be functions such that x?(1),?",
        "(1), x?(2),?",
        "(2), .",
        ".",
        ".",
        ", x?(n),?",
        "(n) is the sequence of variables at the leaves of r read from left to right.",
        "We will call this sequence the yield of r. Finally, let p(i) for 1 ?",
        "i ?",
        "d(S0) be the position in the yield of r of the rightmost leaf of S0's ith child.",
        "Thus, for all i, 1 ?",
        "p(i) ?",
        "n. Given this notation, the LCFRS rule corresponding to the MBOT rule l?",
        "r is constructed as S0 ?",
        "g(S1,S2, .",
        ".",
        ".",
        ",Sk).",
        "The LCFRS nonterminal Si has fanout equal to the corresponding MBOT state's rank plus one: ?",
        "(Si) = d(Si)+ 1.",
        "This is because the LCFRS nonterminal has one span in the source language, and d(Si) spans in the target language of the translation.",
        "The combination function for the LCFRS rule",
        "Here we use ei for the variables in the LCFRS rule corresponding to spans in the input tree of the MBOT, and fi,j for variables corresponding to the output tree.",
        "The pattern in which these spans fit together is specified by the functions ?",
        "and ?",
        "that were read off of the MBOT rule.",
        "Examples of the conversion of an MBOT rule to an LCFRS rule are shown in",
        "case converting SVO (as in English) to VSO (as in Arabic) word order.",
        "The states of an MBOT rule derived from an STSG rule always have rank 1.",
        "In the resulting LCFRS rule, this means that every nonterminal in the grammar has fanout 2, corresponding to one span in the source language string and one span in the target language string of the translation.",
        "This is what we would expect, given that, in terms of the translations produced, STSG is equivalent to SCFG (because the internal tree structure of the rules is irrelevant), and SCFG falls within the class of LCFRS grammars of fanout 2.",
        "Figure 2b shows a more general example, where the states of the MBOT rule have rank > 1.",
        "Now we extend this construction to handle tree symbols of rank zero, which correspond to terminal symbols in the LCFRS.",
        "Let ?0 be the sequence of rank zero symbols appearing at the leaves of l to the left of x1,1, and let ?i for 1 ?",
        "i ?",
        "k be the sequence of rank zero symbols to the right of xi,d(Si ), and to the left of xi+1,1 if i < k. Let ?i,j be the sequence of symbols of rank zero at the leaves of r appearing in the subtree under the ith child of S0 after the jth variable in this subtree and before the j+ 1th variable, with ?i,0 being to the left of the first variable, and ?i,p(i) being to the right of the last variable.",
        "We can add these sequences of terminal symbols to the LCFRS rule as follows:",
        "An example of this conversion is shown in Figure 3.",
        "In this example, ?1 = of, ?1,1 =?, all other ?",
        "and ?",
        "values are the empty string, and d(S0) = 1.",
        "We refer to the LCFRS rule constructed from MBOT rule l?",
        "r as pl?r.",
        "Figure 2 Examples of the conversion of an MBOT rule to an LCFRS rule.",
        "Gildea On the String Translations Produced by Multi Bottom?Up Tree Transducers Figure 3 Conversion of an MBOT rule with symbols of rank zero to an LCFRS production with terminals.",
        "Finally, we add a start rule rule S?",
        "g(Si), g(?e, f ?)",
        "= ?e#f ?",
        "for each Si ?",
        "F to generate all final states Si of the MBOT from the start symbol S of the LCFRS.",
        "We now show that the language of the LCFRS constructed from a given MBOT is identical to the yield of the MBOT.",
        "We represent MBOT transductions as derivation trees, where each node is labeled with an MBOT rule, and each node's children are the rules used to produce the subtrees matched by any variables in the rule.",
        "We can construct an LCFRS derivation tree by simply relabeling each node with the LCFRS rule constructed from the node's MBOT rule.",
        "Because, in the MBOT derivation tree, each node has children which produce the states required by the the MBOT rule's left-hand side (l.h.s.",
        "), it also holds that, in the LCFRS derivation tree, each node has as its children rules which expand the set of nonterminals appearing in the parent's r.h.s.",
        "Therefore the LCFRS tree constitutes a valid derivation.",
        "Given the mapping from MBOT derivations to LCFRS derivations, the following lemma relates the strings produced by the derivations: Lemma 1 Let TMBOT be an MBOT derivation tree with I as its input tree and O as its output tree, and construct TLCFRS by mapping each node nMBOT in TMBOT to a node nLCFRS labeled with the LCFRS production constructed from the rule at nMBOT.",
        "Let ?t0, t1, .",
        ".",
        ".",
        ", tk?",
        "be the string tuple returned by the LCFRS combination function at any node nLCFRS in TLCFRS.",
        "The string t0 contains the yield of the node of I at which the MBOT rule at the node of TMBOT corresponding to nLCFRS was applied.",
        "Furthermore, the strings t1, .",
        ".",
        ".",
        ", tk contain the k yields of the k MBOT output subtrees (subtrees of O) that are found as children of the root (state symbol) of the MBOT rule's right-hand side.",
        "Proof When we apply the LCFRS combination functions to build the string produced by the LCFRS derivation, the sequence of function applications corresponds exactly to the bottom?up application ofMBOT rules to the input tree.",
        "Let us refer to the tuple returned by one LCFRS combination function g as ?t0, t1, .",
        ".",
        ".",
        ", tk?.",
        "An MBOT rule applying at the bottom of the input tree cannot contain any variables, and for MBOT rules of this type, our construction produces an LCFRS rule with a combination function of the form: g() = ?",
        "?0,?1,0, .",
        ".",
        ".",
        ",?k,0?",
        "taking no arguments and returning string constants equal to the yield of the MBOT rule's l.h.s, and the sequence of yields of the k subtrees under the r.h.s.",
        "'s root.",
        "Now we consider how further rules in the LCFRS derivation make use of the tuple ?t0, t1, .",
        ".",
        ".",
        ", tk?.",
        "Our LCFRS combination functions always concatenate the first elements of the input tuple in order, adding any terminals present in the portion of the input tree matched by the MBOT's l.h.s.",
        "Thus the combination functions maintain the property that the first element in the resulting tuple, t0, contains the yield of the subtree of the input tree where the corresponding MBOT rule applied.",
        "The combination functions combine the remaining elements in their input tuples in the same order given by the MBOT rule's r.h.s., again adding any terminals added to the output tree by the MBOT rule.",
        "Thus, at each step, the strings t1, .",
        ".",
        ".",
        ", tk returned by LCFRS combination functions contain the k yields of the k MBOT output subtrees found as children of the root (state symbol) of the MBOT rule's r.h.s.",
        "By induction, the lemma holds at each node in the derivation tree.",
        "The correspondence between LCFRS string tuples and MBOT tree yields gives us our first result:",
        "From a given MBOT, construct an LCFRS as described previously.",
        "For any transduction of the MBOT, from Lemma 1, there exists an LCFRS derivation which produces a string consisting of the yield of the MBOT's input and output trees joined by the # symbol.",
        "In the other direction, we note that any valid derivation of the LCFRS corresponds to an MBOT transduction on some input tree; this input tree can be constructed by assembling the left-hand sides of the MBOT rules from which the LCFRS rules of the LCFRS derivation were originally constructed.",
        "Because there is a one-to-one correspondence between LCFRS and MBOT derivations, the translation produced by the LCFRS and the yield of the MBOT are identical.",
        "Because we can construct an LCFRS generating the same translation as the yield of any given MBOT, we see that yield(MBOT) ?",
        "trans(LCFRS).",
        "The translations produced by MBOTs are equivalent to the translations produced by a certain restricted class of LCFRS grammars, which we now specify precisely.",
        "Theorem 2 The class of translations yield(MBOT) is equivalent to yield(1-m-LCFRS), where 1-m-LCFRS is defined to be the class of LCFRS grammars where each rule either is a start rule of the form S?",
        "g(Si), g(?e, f ?)",
        "= ?e#f ?, or meets both of the following conditions: The combination function keeps the two sides of the translation separate.",
        "That is, it must be possible to write g(?e1, f1,1, .",
        ".",
        ".",
        ", f1,?1?, .",
        ".",
        ".",
        ", ?er, fr,1, .",
        ".",
        ".",
        ", fr,?r?)",
        "as g1(?e1?, .",
        ".",
        ".",
        ", ?er?",
        ")+ g2(?",
        "f1,1, .",
        ".",
        ".",
        ", f1,?1?, .",
        ".",
        ".",
        ", ?",
        "fr,1, .",
        ".",
        ".",
        ", fr,?r?)",
        "where + represents tuple concatenation, for some functions g1 and g2.",
        "The function g1 returns a tuple of length 1.",
        "Gildea On the String Translations Produced by Multi Bottom?Up Tree Transducers Proof Our construction for transforming an MBOT to an LCFRS produces LCFRS grammars satisfying the given constraints, so yield(MBOT) ?",
        "trans(1-m-LCFRS).",
        "To show the other direction, we will construct an MBOT from a 1-m-LCFRS.",
        "For each 1-m-LCFRS rule of the form",
        "where each ?i is a string of terminals, and each symbol ti,j is either a variable fi?,j?",
        ", or a single terminal, we construct the MBOT rule:",
        "By the same reasoning used for our construction of LCFRS grammars from MBOTs, there is a one-to-one correspondence between derivation trees of the 1-m-LCFRS and the constructed MBOT, and the yield strings also correspond at each node in the derivation trees.",
        "Therefore, yield(1-m-LCFRS) ?",
        "yield(MBOT).",
        "Because we have containment in both directions, yield(MBOT) = trans(1-mLCFRS).",
        "We now move on to consider the languages formed by the source and target projections of MBOT translations.",
        "Grammars of the class 1-m-LCFRS have the property that, for any nonterminal A (other than the start symbol S) having fanout ?",
        "(A), one span is always realized in the source string (to the left of the # separator), and ?(A)?",
        "1 spans are always realized in the target language (to the right of the separator).",
        "This property is introduced by the start rules S?",
        "g(Si), g(?e, f ?)",
        "= ?e#f ?",
        "and is maintained by all further productions because of the condition on 1-m-LCFRS that the combination function must keep the two sides of translation separate.",
        "For a 1-m-LCFRS rule constructed from an MBOT, we define the rule's source language projection to be the rule obtained by discarding all the target language spans, as well as the separator symbol # in the case of the start productions.",
        "The definition of 1-m-LCFRS guarantees that the combination function returning a rule's l.h.s.",
        "source span needs to have only the r.h.s.",
        "source spans available as arguments.",
        "For an LCFRS G, we define L(G) to be the language produced by G. We define source(G) to be the LCFRS obtained by projecting each rule in G. Because more than one rule may have the same projection, we label the rules of source(G) with their origin rule, preserving a one-to-one correspondence between rules in the two grammars.",
        "Similarly, we obtain a rule's target language projection by discarding the source language spans, and define target(G) to be the resulting grammar.",
        "There is a valid derivation tree in the source language projection for each valid derivation tree in the full LCFRS, because for any expansion rewriting a nonterminal of fanout ?",
        "(A) in the full grammar, we can apply the projected rule to the corresponding nonterminal of fanout 1 in the projected derivation.",
        "In the other direction, for any expansion in a derivation of the source projection, a nonterminal of fanout ?",
        "(A) will be available for expansion in the corresponding derivation of the full LCFRS.",
        "Because there is a one-to-one correspondence between derivations in the full LCFRS and its source projection, the language generated by the source projection is the source of the translation generated by the original LCFRS.",
        "By the same reasoning, there is a one-to-one correspondence between derivations in the target projection and the full LCFRS, and the language produced by the target projection is the target side of the translation of the full LCFRS.",
        "Lemma 2 implies that it is safe to evaluate the power of the source and target projections of the LCFRS independently.",
        "This fact leads to our next result.",
        "In the LCFRS generated by our construction, all nonterminals have fanout 1 in the source side of the translation.",
        "Therefore, the source side of the translation is a context-free language, and an MBOT cannot represent the following translation: {(anbncndn, anbncndn) |n ?",
        "1} which is produced by an STAG (Shieber and Schabes 1990; Schabes and Shieber 1994).",
        "Because STAG is a type of LCFRS, yield(MBOT) trans(LCFRS).",
        "Although the source side of the translation produced by an MBOT must be a context-free language, we now show that the target side can be any language produced by an LCFRS.",
        "Given an input LCFRS, we can construct an MBOT whose target side corresponds to the rules in the original LCFRS, and whose source simply accepts derivation trees of the LCFRS.",
        "To make this precise, given an LCFRS rule in the general form:",
        "Gildea On the String Translations Produced by Multi Bottom?Up Tree Transducers where each symbol ti,j is either some variable xi?,j?",
        "or a terminal from the alphabet of the LCFRS, we construct the MBOT rule:",
        "where the MBOT's input alphabet contains a symbol S for each LCFRS nonterminal S, and the MBOT's output alphabet contains ?",
        "(S) symbols Si for each LCFRS nonterminal S. This construction for converting an LCFRS to an MBOT shows that LCFRS ?",
        "target(yield(MBOT)).",
        "Given our earlier construction for generating the target projection of the LCFRS derived from an MBOT, we know that target(yield(MBOT))?",
        "LCFRS.",
        "Combining these two facts yields the theorem."
      ]
    },
    {
      "heading": "4. Composition of STSGs",
      "text": [
        "Maletti et al. (2009) discuss the composition of extended top?down tree transducers, which are equivalent to STSGs, as shown by Maletti (2010).",
        "They show that this formalism is not closed under composition in terms of the tree transformations that are possible.",
        "In this article, we focus on the string yields of the formalisms under discussion, and from this point of view we now examine the question of whether the yield of the composition of two STSGs is itself the yield of an STSG in general.",
        "It is important to note that, although we focus on the yield of the composition, in our notion of STSG composition, the tree structure output by the first STSG still serves as input to the second STSG.",
        "Maletti et al. (2009) give two tree transformations as counterexamples to the compo-sitionality of STSG, shown in Figure 4.",
        "From the point of view of string yield, both of the transformations are equivalent to an STSG rule that simply copies the three variables with no re-ordering.",
        "Thus, these counterexamples are not sufficient to show that the yield of the composition of two STSGs is not the yield of an STSG.",
        "We now present two STSGs, shown in MBOT notation in Figures 5 and 6, whose composition is not a translation produced by an STSG.",
        "The essence of this counterexample, explained in more detail subsequently, is that rules from the two STSGs apply in an overlapping manner to unboundedly long sequences, as in the example of Arnold Figure 4 Examples of tree transformations not contained in STSG, from Maletti et al. (2009).",
        "Here Gn denotes a unary chain of G's of arbitrary length.",
        "and Dauchet (1982, section 3.4).",
        "To this approach we add a reordering pattern which results in a translation that we will show not to be possible with STSG.",
        "The heart of each MBOT is the first rule, which reverses the order of adjacent sequences of c's and d?s.",
        "The MBOT of Figure 5 generates the translation:",
        "i=1 indicates the string concatenation x1x2 ?",
        "?",
        "?",
        "xn.",
        "Here we have 2 repeated sequences of characters c and d, each occurring ni times, with each integer ni for 1 ?",
        "i ?",
        "2 varying freely.",
        "The secondMBOT reverses sequences of c's and d's in a pattern that is offset by one from the pattern of the first MBOT.",
        "It produces the translation:",
        "When we compose the two MBOTs, the yield of the resulting transducer is the translation:",
        "Gildea On the String Translations Produced by Multi Bottom?Up Tree Transducers where",
        "A visualization of the alignment pattern of this translation is shown in Figure 7.",
        "We will show that Tcrisscross cannot be produced by any SCFG.",
        "We define an SCFG to be a system (V,?,?,P,S) where V is a set of nonterminals, ?",
        "and ?",
        "are the terminal alphabets of the source and target language respectively, S ?",
        "V is a distinguished start symbol, and P is a set of productions of the following general form:",
        "Translation resulting from MBOT composition with = 8.",
        "where ? is a permutation of length n, and the variables Xi for 0 ?",
        "i ?",
        "n range over nonterminal symbols (for example, X1 and X2 may both stand for nonterminal A).",
        "In SCFG productions, the l.h.s.",
        "nonterminal rewrites into a string of terminals and nonterminals in both the source and target languages, and pairs of r.h.s.",
        "nonterminals that are linked by the same superscript index must be further rewritten by the same rule.",
        "In terms of string translations, STSGs and SCFGs are equivalent, because any SCFG is also an STSG with rules of depth 1, and any STSG can be converted to an SCFG with the same string translation by simply removing the internal tree nodes in each rule.",
        "We will adopt SCFG terminology for our proof because the internal structure of STSG rules is not relevant to our result.",
        "For a fixed value of , the translation Tcrisscross can be produced by an SCFG of rank 2 , shown in Figure 8, because one rule can produce 2 nonterminals arranged in the permutation of Figure 7.",
        "(In the context of SCFGs, rank refers to the maximum number of nonterminals on the r.h.s. of a rule.)",
        "We will show that strings of this form cannot be produced by any SCFG of rank less than 2 .",
        "Intuitively, factoring the alignment pattern of Figure 7 into smaller SCFG rules would require identifying subsequences in the two languages that are consistently aligned to one another, and, as can be seen from the figure, no such subsequences exist.",
        "Because can be unboundedly large in our translation, the translation cannot be produced by any SCFG of fixed rank.",
        "We will assume, without loss of generality, that any SCFG is written in a normal form such that each rule's r.h.s.",
        "either contains only terminals in each language, or contains only nonterminals.",
        "An SCFG can be transformed into this normal form by applying the following procedure to each rule:",
        "1.",
        "Associate each sequence of terminals with the preceding nonterminal, or the following nonterminal in the case of initial terminals.",
        "2.",
        "Replace each group consisting of a nonterminal and its associated terminals with a fresh nonterminal A, and add a rule rewriting A as the group in source and target.",
        "(Nonterminals with no associated terminals may be left intact.)",
        "3.",
        "In each rule created in the previous step, replace each sequence of",
        "increasing in the English side of the derivation.",
        "The preterminal permutation of the derivation, (3,2,1), is the sequence of indices on the Chinese side in the last step before any terminals are produced.",
        "In an SCFG derivation, nonterminals in either language are linked as shown in Figure 10.",
        "We restrict derivations to apply rules producing terminals after applying all other rules.",
        "We refer to nonterminals at the last step in which the sentential form consists exclusively of nonterminals as preterminals, and we refer to a pair of linked preterminals as an aligned preterminal pair.",
        "Assuming that aligned preterminal pairs are indexed consecutively in the source side of the sentential form, we refer to the sequence of indices in the target side as the preterminal permutation of a derivation.",
        "For example, the preterminal permutation of the derivation in Figure 10 is (3,2,1).",
        "The permutation of any sentential form of an SCFG of rank r can be produced by composing permutations of length no greater than r, by induction over the length of the derivation.",
        "Thus, while the permutation (3,2,1) of our example can be produced by composing permutations of length 2, the preterminal permutation (2,4,1,3) can never be produced by an SCFG of rank 2 (Wu 1997).",
        "In fact, this restriction also applies to subsequences of the preterminal permutation.",
        "Lemma 3 Let ?",
        "be a preterminal permutation produced by an SCFG derivation containing rules of maximum rank r, and let ??",
        "be a permutation obtained from ?",
        "by removing some elements and renumbering the remaining elements with a strictly increasing function.",
        "Then ??",
        "falls within the class of compositions of permutations of length r. Proof From each rule in the derivation producing preterminal permutation ?, construct a new rule by removing any nonterminals whose indices were removed from ?.",
        "The resulting sequence of rules produces preterminal permutation ??",
        "and contains rules of rank no greater than r. As an example of Lemma 3, removing any element from the permutation (3,2,1) results in the permutation (2,1), which can still (trivially) be produced by an SCFG of rank 2.",
        "We will make use of another general fact about SCFGs, which we derive by applying Ogden's Lemma (Ogden 1968), a generalized pumping lemma for context-free languages, to the source language of an SCFG.",
        "Lemma 4 (Ogden's Lemma) For each context-free grammar G = (V,?,P,S) there is an integer k such that for any word ?",
        "in L(G), if any k or more distinct positions in ?",
        "are designated as distinguished,",
        "then there is some A in V and there are words ?, ?, ?, ?, and ?",
        "in ??",
        "such that: S??",
        "?A?",
        "??",
        "??A??",
        "??",
        "?????",
        "= ?, and hence ??m??m?",
        "?",
        "L(G) for all m ?",
        "0. ?",
        "contains at least one of the distinguished positions.",
        "Either ?",
        "and ?",
        "both contain distinguished positions, or ?",
        "and ?",
        "both contain distinguished positions.",
        "???",
        "contains at most k distinguished positions.",
        "Ogden's lemma can be extended as follows to apply to SCFGs.",
        "Lemma 5 For each SCFG G = (V,?,?,P,S) having source alphabet?",
        "and target alhabet?, there is an integer k such that for any string pair (?,??)",
        "in L(G), if any k or more distinct positions in ?",
        "are designated as distinguished, then there is some A in V and there are words ?, ?, ?, ?, and ?",
        "in ??",
        "and ?",
        "?, ?",
        "?, ?",
        "?, ?",
        "?, and ??",
        "in??",
        "such that:",
        "?",
        "contains at least one of the distinguished positions.",
        "Either ?",
        "and ?",
        "both contain distinguished positions, or ?",
        "and ?",
        "both contain distinguished positions.",
        "???",
        "contains at most k distinguished positions.",
        "Note that there are no guarantees on the form of ?",
        "?, ?",
        "?, ?",
        "?, ?",
        "?, and ?",
        "?, and indeed these may all be the empty string.",
        "Proof There must exist some sequence of rules in the source projection of Gwhich licenses the derivation A??",
        "?A?.",
        "If we write the jth rule in this sequence as Aj ?",
        "?j, there must exist a synchronous rule in G of the form Aj ?",
        "?j, ?",
        "?j that rewrites the same nonterminal.",
        "Thus G licenses a synchronous derivation (A",
        ")??",
        "(?A 1 ?, ?",
        "?A 1 ??)",
        "can be repeated any number of times, the string pairs (??m?",
        "?m?, ??(??)m??(??)m??)",
        "(3) are generated by the SCFG for all m ?",
        "0.",
        "The further conditions on ?, ?, ?, ?, and ?",
        "follow directly from Ogden's Lemma.",
        "We refer to a substring arising from a term cni or dni in the definition of Tcrisscross (Equation (2)) as a run.",
        "In order to distinguish runs, we refer the run arising from cni or dni as the ith run.",
        "We refer to the pair (cni , cni ) or (dni , dni ) consisting of the ith run in the source and target strings as the ith aligned run.",
        "We now use Lemma 5 to show that aligned runs must be generated from aligned preterminal pairs.",
        "Lemma 6 Assume that some SCFG G?",
        "generates the translation Tcrisscross for some fixed .",
        "There exists a constant k such that, in any derivation of grammarG?",
        "having each ni > k, for any i, 1 ?",
        "i ?",
        "2 , there exists at least one aligned preterminal pair among the subsequences of source and target preterminals generating the ith aligned run.",
        "Proof We consider a source string ?, (?, ??)",
        "?",
        "Tcrisscross, such that the length ni of each run is greater than the constant k of Lemma 5.",
        "For a fixed i, 1 ?",
        "i ?",
        "2 , we consider the distinguished positions to be all and only the terminals in the ith run.",
        "This implies that the run can be pumped to be arbitrarily long; indeed, this follows from the definition of the language itself.",
        "Because our distinguished positions are within the ith run, and because Lemma 5 guarantees that either ?, ?, and ?",
        "all contain distinguished positions or ?, ?, and ?",
        "all contain distinguished positions, we are guaranteed that either ?",
        "or ?",
        "lies entirely within the ith run.",
        "Consider the case where ?",
        "lies within the run.",
        "We must consider three possibilities for the location of ?",
        "in the string:",
        "have the same form as ????",
        "?, with the exception that the ith and jth runs are extended from lengths ni and nj to some greater lengths n",
        "crisscross, for each source string, only one target string is permitted.",
        "For string pairs of the form of Equation (3) to belong to Tcrisscross, ?",
        "?",
        "and ??",
        "must lie within the ith and jth aligned runs in the target side.",
        "Because the permutation of Figure 7 cannot be decomposed, there must exist some k such that the kth aligned run lies between the ith and jth aligned runs in one side of the translation, and outside the ith and jth aligned runs in the other side of the translation.",
        "If this were not the case, we would be able to decompose the permutation by factoring out the subsequence between the ith and jth runs on both sides of the translation.",
        "Consider the case where the kth aligned run lies between the ith and jth aligned runs in the source side, and therefore is a substring of ? in the source, and a substring of either ??",
        "or ??",
        "in the target.",
        "We apply Lemma 5 a second time, with all terminals of the kth run as the distinguished positions, to the derivation (A, A)??",
        "(?, ??)",
        "by taking A as the start symbol of the grammar.",
        "This implies that there exist ?",
        "?,",
        "and all strings (??m??n???",
        "?n?m?, ??(??)m(???)n???(???)n(??)m??)",
        "are members of the translation Tcrisscross.",
        "Either ??",
        "or ??",
        "is a substring of source side of the kth aligned run, so the kth aligned run can be pumped to be arbitrarily long in the source without changing its length in the target.",
        "This contradicts the definition of Tcrisscross.",
        "Similarly, the case where the kth aligned run lies between ?",
        "?",
        "and ??",
        "in the target leads to a contradiction.",
        "Thus the assumption that j = imust be false.",
        "Because Cases 2 and 3 are impossible, ?",
        "must lie entirely within the ith run.",
        "Similarly, in the case where ?",
        "contains distinguished positions, ?must lie within the ith run.",
        "Thus both ?",
        "and ?",
        "always lie entirely within the ith aligned run.",
        "Because the ?",
        "and ?",
        "lie within the ith aligned run, the strings ??m??m?",
        "have the same form as ????",
        "?, with the exception that the ith run is extended from length ni to some greater length n?i .",
        "For the pairs of Equation (3) to be members of the translation, ??",
        "and ??",
        "must be substrings of the ith aligned run in the target.",
        "Because ?m?",
        "?m and (??)m??(??",
        ")m were derived from the same nonterminal, the two sequences of preterminals generating these two strings consist of aligned preterminal pairs.",
        "Because both ?m?",
        "?m and (??)m??(??",
        ")m are substrings of the ith aligned run, we have at least one aligned preterminal pair among the source and target preterminal sequences generating",
        "Assume that some SCFG G?",
        "generates the translation Tcrisscross for some fixed .",
        "There exists a constant k such that, if (?,??)",
        "is a string pair generated by G?",
        "having each ni > k, any derivation of (?,??)",
        "with grammar G?",
        "must contain a rule of rank at least 2 .",
        "Proof Because the choice of i in Lemma 6 was arbitrary, each aligned run must contain at least one aligned preterminal pair.",
        "If we select one such preterminal pair from each run, the associated permutation is that of Figure 7.",
        "This permutation cannot be decomposed, so, by Lemma 3, it cannot be generated by an SCFG derivation containing only rules of rank less than 2 .",
        "We will use one more general fact about SCFGs to prove our main result.",
        "Lemma 8 Let G be an SCFG and let T = L(G) be the translation it produces.",
        "Let F be a finite state machine, and let R = L(F) be the regular language it accepts.",
        "Let T?",
        "be the translation derived by intersecting the source strings of T with R T?",
        "= {(s, t) |(s, t) ?",
        "T, s ?",
        "R}",
        "Gildea On the String Translations Produced by Multi Bottom?Up Tree Transducers Then there exists an SCFG G?",
        "such that T?",
        "= L(G?).",
        "Proof Let V be the nonterminal set of G, and let S be the state set of F. Construct the SCFG G?",
        "with nonterminal set V ?",
        "S?",
        "S by applying the construction of Bar-Hillel, Perles, and Shamir (1961) for intersection of a CFG and finite state machine to the source side of each rule in G. Now we are ready for our main result.",
        "Theorem 5",
        "Assume that some SCFG G generates Tcrisscross.",
        "Note that T crisscross is the result of intersecting the source of Tcrisscross with the regular language a[c +d+]a.",
        "By Lemma 8, we can construct an SCFG G generating Tcrisscross.",
        "By Lemma 7, for each , G has rank at least",
        ".",
        "The intersection construction does not increase the rank of the grammar, so G has rank at least 2 .",
        "Because is unbounded in the definition of Tcrisscross, and because any SCFG has a finite maximum rank, Tcrisscross cannot be produced by any SCFG."
      ]
    },
    {
      "heading": "4.1 Implications for Machine Translation",
      "text": [
        "The ability of MBOTs to represent the composition of STSGs is given as a motivation for the MBOT formalism byMaletti (2010), but this raises the issue of whether synchronous parsing and machine translation decoding can be undertaken efficiently for MBOTs resulting from the composition of STSGs.",
        "In discussing the complexity of synchronous parsing problems, we distinguish the case where the grammar is considered part of the input, and the case where the grammar is fixed, and only the source and target strings are considered part of the input.",
        "For SCFGs, synchronous parsing is NP-complete when the grammar is considered part of the input and can have arbitrary rank.",
        "For any fixed grammar, however, synchronous parsing is possible in time polynomial in the lengths of the source and target strings, with the degree of the polynomial depending on the rank of the fixed SCFG (Satta and Peserico 2005).",
        "Because MBOTs subsume SCFGs, the problem of recognizing whether a string pair belongs to the translation produced by an arbitrary MBOT, when the MBOT is considered part of the input, is also NP-complete.",
        "Given our construction for converting an MBOT to an LCFRS, we can use standard LCFRS tabular parsing techniques to determine whether a given string pair belongs to the translation defined by the yield of a fixed MBOT.",
        "As with arbitrary-rank SCFG, LCFRS parsing is polynomial in the length of the input string pair, but the degree of the polynomial depends on the complexity of the MBOT.",
        "To be precise, the degree of the polynomial for LCFRS parsing is",
        "d(Si)) when applied to MBOTs.",
        "If we restrict ourselves to MBOTs that are derived from the composition of STSGs, synchronous parsing is NP-complete if the STSGs to compose are part of the input, because a single STSG suffices.",
        "For a composition of fixed STSGs, we obtain a fixed MBOT, and polynomial time parsing is possible.",
        "Theorem 5 indicates that we cannot apply SCFG parsing techniques off the shelf, but rather that we must implement some type of more general parsing system.",
        "Either of the STSGs used in our proof of Theorem 5",
        " can be binarized and synchronously parsed in time O(n6), but tabular parsing for the LCFRS resulting from composition has higher complexity.",
        "Thus, composing STSGs generally increases the complexity of synchronous parsing.",
        "The problem of language-model?integrated decoding with synchronous grammars is closely related to that of synchronous parsing; both problems can be seen as intersecting the grammar with a fixed source-language string and a finite-state machine constraining the target-language string.",
        "The widely used decoding algorithms for SCFG (Yamada and Knight 2002; Zollmann and Venugopal 2006; Huang et al. 2009) search for the highest-scoring translation when combining scores from a weighted SCFG and a weighted finite-state language model.",
        "As with SCFG, language-model?integrated decoding for weighted MBOTs can be performed by adding n-gram language model state to each candidate target language span.",
        "This, as with synchronous parsing, gives an algorithm which is polynomial in the length of the input sentence for a fixed MBOT, but with an exponent that depends on the complexity of the MBOT.",
        "Furthermore, Theorem 5 indicates that SCFG-based decoding techniques cannot be applied off the shelf to compositions of STSGs, and that composition of STSGs in general increases decoding complexity.",
        "Finally, we note that finding the highest-scoring translation without incorporating a language model is equivalent to parsing with the source or target projection of the MBOT used to model translation.",
        "For the source language of the MBOT, this implies time O(n3) because the problem reduces to CFG parsing.",
        "For the target language of the MBOT, this implies polynomial-time parsing, where the degree of the polynomial depends on the MBOT, as a result of Theorem 4."
      ]
    },
    {
      "heading": "5. Conclusion",
      "text": [
        "MBOTs are desirable for natural language processing applications because they are closed under composition and can be used to represent sequences of transformations of the type performed by STSGs.",
        "However, the string translations produced by MBOTs representing compositions of STSGs are strictly more powerful than the string translations produced by STSGs, which are equivalent to the translations produced by SCFGs.",
        "From the point of view of machine translation, because parsing with general LCFRS is NP-complete, restrictions on the power of MBOTs will be necessary in order to achieve polynomial?time algorithms for synchronous parsing and language-model?integrated decoding.",
        "Our result on the string translations produced by compositions of STSGs implies that algorithms for SCFG-based synchronous parsing or language-model-integrated decoding cannot be applied directly to these problems, and that composing STSGs generally increases the complexity of these problems.",
        "Developing parsing algorithms specific to compositions of STSGs, as well as possible restrictions on the STSGs to be composed, presents an interesting area for future work."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We are grateful for extensive feedback on earlier versions of this work from Giorgio Satta, Andreas Maletti, Adam Purtee, and three anonymous reviewers.",
        "This work was partially funded by NSF grant IIS-0910611."
      ]
    }
  ]
}
