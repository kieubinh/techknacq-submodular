{
  "info": {
    "authors": [
      "Fan Bu",
      "Hang Li",
      "Xiaoyan Zhu"
    ],
    "book": "ACL",
    "id": "acl-P12-1047",
    "title": "String Rewriting Kernel",
    "url": "https://aclweb.org/anthology/P12-1047",
    "year": 2012
  },
  "references": [
    "acl-C08-1066",
    "acl-I05-5002",
    "acl-N03-1003",
    "acl-N06-1006",
    "acl-N10-1145",
    "acl-P08-1077",
    "acl-W04-3219",
    "acl-W06-1603",
    "acl-W07-1401",
    "acl-W07-1412",
    "acl-W07-1423"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Learning for sentence rewriting is a fundamental task in natural language processing and information retrieval.",
        "In this paper, we propose a new class of kernel functions, referred to as string rewriting kernel, to address the problem.",
        "A string rewriting kernel measures the similarity between two pairs of strings, each pair representing rewriting of a string.",
        "It can capture the lexical and structural similarity between two pairs of sentences without the need of constructing syntactic trees.",
        "We further propose an instance of string rewriting kernel which can be computed efficiently.",
        "Experimental results on benchmark datasets show that our method can achieve better results than state-of-the-art methods on two sentence rewriting learning tasks: paraphrase identification and recognizing textual entailment."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Learning for sentence rewriting is a fundamental task in natural language processing and information retrieval, which includes paraphrasing, textual entailment and transformation between query and document title in search.",
        "The key question here is how to represent the rewriting of sentences.",
        "In previous research on sentence rewriting learning such as paraphrase identification and recognizing textual entailment, most representations are based on the lexicons (Zhang and Patrick, 2005; Lintean and Rus, 2011; de Marneffe et al., 2006) or the syntactic trees (Das and Smith, wrote .",
        "Shakespeare wrote Hamlet.",
        "* was written by .",
        "Hamlet was written by Shakespeare.",
        "and (B) is a rewriting of sentence.",
        "2009; Heilman and Smith, 2010) of the sentence pairs.",
        "In (Lin and Pantel, 2001; Barzilay and Lee, 2003), rewriting rules serve as underlying representations for paraphrase generation/discovery.",
        "Motivated by the work, we represent rewriting of sentences by all possible rewriting rules that can be applied into it.",
        "For example, in Fig. 1, (A) is one rewriting rule that can be applied into the sentence rewriting (B).",
        "Specifically, we propose a new class of kernel functions (Scho?lkopf and Smola, 2002), called string rewriting kernel (SRK), which defines the similarity between two rewritings (pairs) of strings as the inner product between them in the feature space induced by all the rewriting rules.",
        "SRK is different from existing kernels in that it is for rewriting and defined on two pairs of strings.",
        "SRK can capture the lexical and structural similarity between rewritings of sentences and does not need to parse the sentences and create the syntactic trees of them.",
        "One challenge for using SRK lies in the high computational cost of straightforwardly computing the kernel, because it involves two rewritings of strings (i.e., four strings) and a large number of rewriting rules.",
        "We are able to develop an instance of SRK, referred to as kb-SRK, which directly computes the number of common rewriting rules without explic",
        "itly calculating the inner product between feature vectors, and thus drastically reduce the time complexity.",
        "Experimental results on benchmark datasets show that SRK achieves better results than the state-of-the-art methods in paraphrase identification and recognizing textual entailment.",
        "Note that SRK is very flexible to the formulations of sentences.",
        "For example, informally written sentences such as long queries in search can also be effectively handled."
      ]
    },
    {
      "heading": "2 Related Work",
      "text": [
        "The string kernel function, first proposed by Lodhi et al. (2002), measures the similarity between two strings by their shared substrings.",
        "Leslie et al. (2002) proposed the k-spectrum kernel which represents strings by their contiguous substrings of length k. Leslie et al. (2004) further proposed a number of string kernels including the wildcard kernel to facilitate inexact matching between the strings.",
        "The string kernels defined on two pairs of objects (including strings) were also developed, which decompose the similarity into product of similarities between individual objects using tensor product (Basil-ico and Hofmann, 2004; Ben-Hur and Noble, 2005) or Cartesian product (Kashima et al., 2009).",
        "The task of paraphrasing usually consists of paraphrase pattern generation and paraphrase identification.",
        "Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003).",
        "Paraphrase identification is to identify whether two given sentences are a paraphrase of each other.",
        "The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classification task.",
        "Among the most successful methods, Wan et al. (2006) enriched the feature set by the BLEU metric and dependency relations.",
        "Das and Smith (2009) used the quasi-synchronous grammar formalism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency labels from aligned trees.",
        "The task of recognizing textual entailment is to decide whether the hypothesis sentence can be entailed by the premise sentence (Giampiccolo et al., 2007).",
        "In recognizing textual entailment, de Marneffe et al. (2006) classified sentences pairs on the basis of word alignments.",
        "MacCartney and Manning (2008) used an inference procedure based on natural logic and combined it with the methods by de Marneffe et al. (2006).",
        "Harmeling (2007) and Heilman and Smith (2010) classified sequence pairs based on transformation on syntactic trees.",
        "Zanzotto et al. (2007) used a kernel method on syntactic tree pairs (Moschitti and Zanzotto, 2007)."
      ]
    },
    {
      "heading": "3 Kernel Approach to Sentence",
      "text": []
    },
    {
      "heading": "Re-Writing Learning",
      "text": [
        "We formalize sentence rewriting learning as a kernel method.",
        "Following the literature of string kernel, we use the terms ?string?",
        "and ?character?",
        "instead of ?sentence?",
        "and ?word?.",
        "Suppose that we are given training data consisting of rewritings of strings and their responses",
        "where ?",
        "denotes the character set, ??",
        "=",
        "notes the string set, which is the Kleene closure of set ?, Y denotes the set of responses, and n is the number of instances.",
        "(si, ti) is a rewriting consisting of the source string si and the target string ti.",
        "yi is the response which can be a category, ordinal number, or real number.",
        "In this paper, for simplicity we assume that Y = {?1} (e.g. paraphrase/nonparaphrase).",
        "Given a new string rewriting (s, t) ?",
        "????",
        "?, our goal is to predict its response y.",
        "That is, the training data consists of binary classes of string re-writings, and the prediction is made for the new rewriting based on learning from the training data.",
        "We take the kernel approach to address the learning task.",
        "The kernel on rewritings of strings is defined as",
        "satisfying for all (si, ti), (s j, t j) ?",
        "????",
        "?, K((si, ti),(s j, t j)) = ??",
        "(si, ti),?",
        "(s j, t j)?",
        "where ?",
        "maps each rewriting (pair) of strings into a high dimensional Hilbert space H , referred to as",
        "feature space.",
        "By the representer theorem (Kimel-dorf and Wahba, 1971; Scho?lkopf and Smola, 2002), it can be shown that the response y of a new string rewriting (s, t) can always be represented as",
        "?iyiK((si, ti),(s, t))) where ?i ?",
        "0,(i = 1, ?",
        "?",
        "?",
        ",n) are parameters.",
        "That is, it is determined by a linear combination of the similarities between the new instance and the instances in training set.",
        "It is also known that by employing a learning model such as SVM (Vapnik, 2000), such a linear combination can be automatically learned by solving a quadratic optimization problem.",
        "The question then becomes how to design the kernel function for the task."
      ]
    },
    {
      "heading": "4 String Rewriting Kernel",
      "text": [
        "Let ?",
        "be the set of characters and ??",
        "be the set of strings.",
        "Let wildcard domain D ?",
        "??",
        "be the set of strings which can be replaced by wildcards.",
        "The string rewriting kernel measures the similarity between two string rewritings through the rewriting rules that can be applied into them.",
        "Formally, given rewriting rule set R and wildcard domain D, the string rewriting kernel (SRK) is defined as",
        "where n is the number of contiguous substring pairs of (s, t) that rewriting rule r matches, i is the number of wildcards in r, and ?",
        "?",
        "(0,1] is a factor punishing each occurrence of wildcard.",
        "A rewriting rule is defined as a triple r = (?s,?t ,?)",
        "where ?s,?t ?",
        "(?",
        "?",
        "{?})?",
        "denote source and target string patterns and ?",
        "?",
        "ind?(?s)?",
        "ind?",
        "(?t) denotes the alignments between the wildcards in the two string patterns.",
        "Here ind?(? )",
        "denotes the set of indexes of wildcards in ?",
        ".",
        "We say that a rewriting rule (?s,?t ,?)",
        "matches a string pair (s, t), if and only if string patterns 's and ?t can be changed into s and t respectively by substituting each wildcard in the string patterns with an element in the strings, where the elements are defined in the wildcard domain D and the wildcards ?s[i] and ?t [ j] are substituted by the same elements, when there is an alignment (i, j) ?",
        "?",
        ".",
        "For example, the rewriting rule in Fig. 1 (A) can be formally written as r = (?",
        "s,?",
        "t,?)",
        "where ?",
        "s = (?,wrote,?",
        "), ?",
        "t = (?,was,written,by,?)",
        "and ?",
        "= {(1,5),(3,1)}.",
        "It matches with the string pair in Fig. 1 (B).",
        "String rewriting kernel is a class of kernels which depends on rewriting rule set R and wildcard domain D. Here we provide some examples.",
        "Obviously, the effectiveness and efficiency of SRK depend on the choice of R and D.",
        "(k,k)(x,y) is a special case (m=k) of the (k,m)-wildcard kernel proposed by Leslie et al. (2004).",
        "Both kernels shown above are represented as the product of two kernels defined separately on strings s1,s2 and t1, t2, and that is to say that they do not consider the alignment relations between the strings."
      ]
    },
    {
      "heading": "5 K-gram Bijective String Rewriting Kernel",
      "text": [
        "Next we propose another instance of string rewriting kernel, called the k-gram bijective string rewriting kernel (kb-SRK).",
        "As will be seen, kb-SRK can be computed efficiently, although it is defined on two pairs of strings and is not decomposed (note that ps-SRK and pw-SRK are decomposed)."
      ]
    },
    {
      "heading": "5.1 Definition",
      "text": [
        "The kb-SRK has the following properties: (1) A wildcard can only substitute a single character, denoted as ???.",
        "(2) The two string patterns in a rewriting rule are of length k. (3) The alignment relation in a rewriting rule is bijective, i.e., there is a one-to-one mapping between the wildcards in",
        "the string patterns.",
        "Formally, the k-gram bijective string rewriting kernel Kk is defined as a string rewriting kernel under the rewriting rule set R = {(?s,?t ,?",
        ")|?s,?t ?",
        "(??{?})k,?",
        "is bijective} and the wildcard domain D = ?.",
        "Since each rewriting rule contains two string patterns of length k and each wildcard can only substitute one character, a rewriting rule can only match k-gram pairs in (s, t).",
        "We can rewrite Eq.",
        "(2) as",
        "For ease of computation, we rewrite kb-SRK as"
      ]
    },
    {
      "heading": "5.2 Algorithm for Computing Kernel",
      "text": [
        "A straightforward computation of kb-SRK would be intractable.",
        "The computation of Kk in Eq.",
        "(4) needs computations of K?k conducted O((n?",
        "k + 1)4) times, where n denotes the maximum length of strings.",
        "Furthermore, the computation of K?k in Eq.",
        "(5) needs to perform matching of all the rewriting rules with the two k-gram pairs (?s1 , ?t1), (?s2 , ?t2), which has time complexity O(k!).",
        "In this section, we will introduce an efficient algorithm, which can compute K?k and Kk with the time complexities of O(k) and O(kn2), respectively.",
        "The latter is verified empirically.",
        "For ease of manipulation, our method transforms the computation of kernel on k-grams into the computation on a new data structure called lists of doubles.",
        "We first explain how to make the transformation.",
        "Suppose that ?1,?2 ?",
        "?k are k-grams, we use ?1[i] and ?2[i] to represent the i-th characters of them.",
        "We call a pair of characters a double.",
        "Thus ???",
        "denotes the set of doubles and ?Ds ,?Dt ?",
        "(?",
        "?",
        "from the two k-gram pairs in Fig. 2.",
        "Non-identical doubles are in bold.",
        "?",
        ")k denote lists of doubles.",
        "The following operation combines two k-grams into a list of doubles.",
        "We denotes ?1 ?",
        "?2[i] as the i-th element of the list.",
        "Fig.",
        "3 shows example lists of doubles combined from k-grams.",
        "We introduce the set of identical doubles I = {(c,c)|c ?",
        "?}",
        "and the set of non-identical doubles",
        "We define the set of rewriting rules for double lists RD = {rD = (?Ds ,?Dt ,?",
        ")|?Ds ,?Dt ?",
        "(I?{?})k,?",
        "is a bijective alignment} where ?Ds and ?Dt are lists of identical doubles including wildcards and with length k. We say rule rD matches a pair of double lists (?Ds ,?Dt ) iff.",
        "?Ds ,?Dt can be changed into ?Ds and ?Dt by substituting each wildcard pair to a double in ???",
        ", and the double substituting the wildcard pair ?Ds [i] and ?Dt [ j] must be an identical double when there is an alignment (i, j) ?",
        "?",
        ".",
        "The rule set defined here and the rule set in Sec. 4 only differ on the elements where rewriting occurs.",
        "Fig.",
        "4 (B) shows an example of rewriting rule for double lists.",
        "The pair of double lists in Fig. 3 can match with the rewriting rule.",
        "We consider how to compute K?k by extending the computation from k-grams to double lists.",
        "The following lemma shows that computing the weighted sum of rewriting rules matching k-gram pairs (?s1 ,?t1) and (?s2 ,?t2) is equivalent to computing the weighted sum of rewriting rules for double lists matching (?s1?",
        "?s2 ,?t1?",
        "?t2).",
        "pairs shown in Fig. 2, there is a corresponding rewriting rule for double lists (B) matching the pair of double lists shown in Fig. 3.",
        "shown in Fig. 3.",
        "Doubles not appearing in both ?Ds and ?Dt are not shown.",
        "Lemma 1.",
        "For any two k-gram pairs (?s1 ,?t1) and (?s2 ,?t2), there exists a one-to-one mapping from the set of rewriting rules matching them to the set of rewriting rules matching the corresponding double lists (?s1?",
        "?s2 ,?t1??t2).",
        "The rewriting rule in Fig. 4 (A) matches the k-gram pairs in Fig. 2.",
        "Equivalently, the rewriting rule for double lists in Fig. 4 (B) matches the pair of double lists in Fig. 3.",
        "By lemma 1 and Eq.",
        "5, we",
        "where ?",
        "?rD(?Ds ,?Dt ) = ?",
        "2i if the rewriting rule for double lists rD with i wildcards matches (?Ds ,?Dt ), otherwise ?",
        "?rD(?Ds ,?Dt ) = 0.",
        "To get K?k, we just need to compute the weighted sum of rewriting rules for double lists matching (?s1 ?",
        "?s2 ,?t1 ??t2).",
        "Thus, we can work on the ?combined?",
        "pair of double lists instead of two pairs of k-grams.",
        "Instead of enumerating all possible rewriting rules and checking whether they can match the given pair of double lists, we only calculate the number of possibilities of ?generating?",
        "from the pair of double lists to the rewriting rules matching it, which can be carried out efficiently.",
        "We say that a rewriting rule of double lists can be generated from a pair of double lists (?Ds , ?Dt ), if they match with each other.",
        "From the definition of RD, in each generation, the identical doubles in ?Ds and ?Dt can be either or not substituted by an aligned wildcard pair in the re-writing",
        "Input: k-gram pair (?s1 ,?t1) and (?s2 ,?t2)",
        "rule, and all the non-identical doubles in ?Ds and ?Dt must be substituted by aligned wildcard pairs.",
        "From this observation and Eq.",
        "6, K?k only depends on the number of times each double occurs in the double lists.",
        "Let e be a double.",
        "We denote #e(?D) as the number of times e occurs in the list of doubles ?D.",
        "Also, for a set of doubles S?",
        "??",
        "?, we denote #S(?D) as a vector in which each element represents #e(?D) of each double e ?",
        "S. We can find a function g such",
        "Alg.",
        "1 shows how to compute K?k.",
        "#???(.)",
        "is computed from the two pairs of k-grams in line 1-2.",
        "The final score is made through the iterative calculation on the two lists (lines 4-8).",
        "The key of Alg.",
        "1 is the calculation of ge based on a(e)i (line 7).",
        "Here we use a",
        "(e) i to denote the number of possibilities for which i pairs of aligned wildcards can be generated from e in both ?Ds and ?Dt .",
        "a (e) i can be computed as follows.",
        "(1) If e ?",
        "N and #e(?Ds ) 6= #e(?Dt ), then a (e)",
        "for any i.",
        "(2) If e?N and #e(?Ds ) = #e(?Dt ) = j, then a (e) j = j!",
        "and a(e)i = 0 for any i 6= j.",
        "(3) If e ?",
        "I, then a(e)i =",
        "We next explain the rationale behind the above computations.",
        "In (1), since #e(?Ds ) 6= #e(?Dt ), it is impossible to generate a rewriting rule in which all",
        "the occurrences of non-identical double e are substituted by pairs of aligned wildcards.",
        "In (2), j pairs of aligned wildcards can be generated from all the occurrences of non-identical double e in both ?Ds and ?Dt .",
        "The number of combinations thus is j!.",
        "In (3), a pair of aligned wildcards can either be generated or not from a pair of identical doubles in ?Ds and ?Dt .",
        "We can select i occurrences of identical double e from ?Ds , i occurrences from ?Dt , and generate all possible aligned wildcards from them.",
        "In the loop of lines 4-8, we only need to consider a(e)i for 0?",
        "i?min{#e(?Ds ),#e(?Dt )}, because a(e)i = 0 for the rest of i.",
        "To sum up, Eq.",
        "7 can be computed as below, which is exactly the computation at lines 3-8.",
        "For the k-gram pairs in Fig. 2, we first create lists of doubles in Fig. 3 and compute #???(?)",
        "for them (lines 1-2 of Alg.",
        "1), as shown in Fig. 5.",
        "We next compute Kk from #???",
        "(?Ds ) and #???",
        "(?Dt ) in Fig. 5 (lines 3-8 of Alg.",
        "1) and obtain Kk = (1)(1+ ?",
        "2)(?",
        "2)(2?",
        "4)(1 + 6?",
        "2 + 6?",
        "4) = 12?",
        "12 + 24?",
        "10 + 14?",
        "8 +2?",
        "6.",
        "Algorithm 2 shows how to compute Kk.",
        "It prepares two maps ms and mt and two vectors of counters cs and ct .",
        "In ms and mt , each key #N(.)",
        "maps a set of values #???(.).",
        "Counters cs and ct count the frequency of each #???(.).",
        "Recall that #N(?s1?",
        "?s2) denotes a vector whose element is #e(?s1 ?",
        "?s2) for e ?",
        "N.",
        "#???",
        "(?s1 ?",
        "?s2) denotes a vector whose element is #e(?s1?",
        "?s2) where e is any possible double.",
        "One can easily verify the output of the algorithm is exactly the value of Kk.",
        "First,",
        "#N(?t1 ??t2).",
        "Therefore, we only need to consider those ?s1 ?",
        "?s2 and ?t1 ?",
        "?t2 which have the same key (lines 10-13).",
        "We group the k-gram pairs by their key in lines 2-5 and lines 6-9.",
        "Moreover, the following relation holds",
        "Input: string pair (s1, t1) and (s2, t2), window size k Output: Kk((s1, t1),(s2, t2))",
        "other k-grams.",
        "Therefore, we only need to take #???(?s1?",
        "?s2) and #???(?t1?",
        "?t2) as the value under each key and count its frequency.",
        "That is to say,",
        "#???",
        "provides sufficient statistics for computing K?k.",
        "The quantity g(vs,vt) in line 13 is computed by Alg.",
        "1 (lines 3-8)."
      ]
    },
    {
      "heading": "5.3 Time Complexity",
      "text": [
        "The time complexities of Alg.",
        "1 and Alg.",
        "2 are shown below.",
        "For Alg.",
        "1, lines 1-2 can be executed in O(k).",
        "The time for executing line 7 is less than #e(?Ds ) + #e(?Dt ) + 1 for each e satisfying #e(?Ds ) 6= 0 or #e(?Dt ) 6= 0 .",
        "Since ?e????",
        "#e(?Ds ) = ?e????",
        "#e(?Dt ) = k, the time for executing lines 3-8 is less than 4k, which results in the O(k) time complexity of Alg.",
        "1.",
        "For Alg.",
        "2, we denote n = max{|s1|, |s2|, |t1|, |t2|}.",
        "It is easy to see that if the maps and counters in the algorithm are implemented by hash maps, the time complexities of lines 2-5 and lines 6-9 are O(kn2).",
        "However, analyzing the time complexity of lines 10-",
        "of the number of times computing g(vs,vt) in line 13, denoted as C.",
        "By Lemma 2, each ms[key] contains at most n?",
        "k + 1 elements.",
        "Together with the fact that ?key ms[key] = (n?",
        "k + 1) 2, Theorem 1 is proved.",
        "It can be also proved that C is O(n2) when k = 1.",
        "Empirical study shows that O(n3) is a loose upper bound for C. Let navg denote the average length of s1, t1, s2 and t2.",
        "Our experiment on all pairs of sentences on MSR Paraphrase (Fig.",
        "6) shows that C is in the same order of n2avg in the worst case and C/n",
        "avg decreases with increasing k in both average case and worst case, which indicates that C is O(n2) and the overall time complexity of Alg.",
        "2 is O(kn2)."
      ]
    },
    {
      "heading": "6 Experiments",
      "text": [
        "We evaluated the performances of the three types of string rewriting kernels on paraphrase identification and recognizing textual entailment: pairwise k-spectrum kernel (ps-SRK), pairwise k-wildcard kernel (pw-SRK), and k-gram bijective string rewriting kernel (kb-SRK).",
        "We set ?",
        "= 1 for all kernels.",
        "The performances were measured by accuracy (e.g. percentage of correct classifications).",
        "In both experiments, we used LIBSVM with default parameters (Chang et al., 2011) as the classifier.",
        "All the sentences in the training and test sets were segmented into words by the tokenizer at OpenNLP (Baldrige et al., ).",
        "We further conducted stemming on the words with Iveonik English Stem-mer (http://www.iveonik.com/ ).",
        "We normalized each kernel by K?",
        "(x,y) = K(x,y)?",
        "K(x,x)K(y,y) and then tried them under different window sizes k. We also tried to combine the kernels with two lexical features ?unigram precision and recall?",
        "proposed in (Wan et al., 2006), referred to as PR.",
        "For each kernel K, we tested the window size settings of K1 + ...+Kkmax (kmax ?",
        "{1,2,3,4}) together with the combination with PR and we report the best accuracies of them in Tab 1 and"
      ]
    },
    {
      "heading": "Tab 2. 6.1 Paraphrase Identification",
      "text": [
        "The task of paraphrase identification is to examine whether two sentences have the same meaning.",
        "We trained and tested all the methods on the MSR Paraphrase Corpus (Dolan and Brockett, 2005; Quirk et al., 2004) consisting of 4,076 sentence pairs for training and 1,725 sentence pairs for testing.",
        "The experimental results on different SRKs are shown in Table 1.",
        "It can be seen that kb-SRK outperforms ps-SRK and pw-SRK.",
        "The results by the state-of-the-art methods reported in previous work are also included in Table 1. kb-SRK outperforms the existing lexical approach (Zhang and Patrick, 2005) and kernel approach (Lintean and Rus, 2011).",
        "It also works better than the other approaches listed in the table, which use syntactic trees or dependency",
        "ent maximum window size kmax on MSRP.",
        "ity.",
        "By comparing the results of kb-SRK and pw-SRK we can see that the bijective property in kb-SRK is really helpful for improving the performance (note that both methods use wildcards).",
        "Furthermore, the performances of kb-SRK with and without combining PR increase dramatically with increasing kmax and reach the peaks (better than state-of-the-art) when kmax is four, which shows the power of the lexical and structural similarity captured by kb-SRK."
      ]
    },
    {
      "heading": "6.2 Recognizing Textual Entailment",
      "text": [
        "Recognizing textual entailment is to determine whether a sentence (sometimes a short paragraph) can entail the other sentence (Giampiccolo et al., 2007).",
        "RTE-3 is a widely used benchmark dataset.",
        "Following the common practice, we combined the development set of RTE-3 and the whole datasets of RTE-1 and RTE-2 as training data and took the test set of RTE-3 as test data.",
        "The train and test sets contain 3,767 and 800 sentence pairs.",
        "The results are shown in Table 2.",
        "Again, kb-SRK outperforms ps-SRK and pw-SRK.",
        "As indicated in (Heilman and Smith, 2010), the top-performing RTE systems are often built with significant engi",
        "ent maximum window size kmax on RTE-3.",
        "neering efforts.",
        "Therefore, we only compare with the six systems which involves less engineering.",
        "kb-SRK still outperforms most of those state-of-the-art methods even if it does not exploit any other lexical semantic sources and syntactic analysis tools.",
        "Fig.",
        "8 shows the results of the kernels under different parameter settings.",
        "Again, the results of ps-SRK and pw-SRK without combining PR are too low to be shown (all below 55%).",
        "We can see that PR is an effective method for this dataset and the overall performances are substantially improved after combining it with the kernels.",
        "The performance of kb-SRK reaches the peak when window size becomes two."
      ]
    },
    {
      "heading": "7 Conclusion",
      "text": [
        "In this paper, we have proposed a novel class of kernel functions for sentence re-writing, called string rewriting kernel (SRK).",
        "SRK measures the lexical and structural similarity between two pairs of sentences without using syntactic trees.",
        "The approach is theoretically sound and is flexible to formulations of sentences.",
        "A specific instance of SRK, referred to as kb-SRK, has been developed which can balance the effectiveness and efficiency for sentence re-writing.",
        "Experimental results show that kb-SRK achieve better results than state-of-the-art methods on paraphrase identification and recognizing textual entailment."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "This work is supported by the National Basic Research Program (973 Program) No.",
        "2012CB316301."
      ]
    }
  ]
}
