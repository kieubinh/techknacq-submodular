{
  "info": {
    "authors": [
      "Alexander Rush",
      "Yin-Wen Chang",
      "Michael Collins"
    ],
    "book": "EMNLP",
    "id": "acl-D13-1022",
    "title": "Optimal Beam Search for Machine Translation",
    "url": "https://aclweb.org/anthology/D13-1022",
    "year": 2013
  },
  "references": [
    "acl-D10-1027",
    "acl-D11-1003",
    "acl-D12-1067",
    "acl-E09-1044",
    "acl-H05-1021",
    "acl-J03-1005",
    "acl-J07-2003",
    "acl-J10-3008",
    "acl-J99-4005",
    "acl-N09-2002",
    "acl-P01-1030",
    "acl-P06-1098",
    "acl-P07-1019",
    "acl-P07-2045",
    "acl-P09-1038",
    "acl-P10-4002",
    "acl-P11-1008",
    "acl-W01-1408",
    "acl-W05-1506",
    "acl-W06-3602"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Beam search is a fast and empirically effective method for translation decoding, but it lacks formal guarantees about search error.",
        "We develop a new decoding algorithm that combines the speed of beam search with the optimal certificate property of Lagrangian relaxation, and apply it to phrase-and syntax-based translation decoding.",
        "The new method is efficient, utilizes standard MT algorithms, and returns an exact solution on the majority of translation examples in our test data.",
        "The algorithm is 3.5 times faster than an optimized incremental constraint-based decoder for phrase-based translation and 4 times faster for syntax-based translation."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Beam search (Koehn et al., 2003) and cube pruning (Chiang, 2007) have become the de facto decoding algorithms for phrase-and syntax-based translation.",
        "The algorithms are central to large-scale machine translation systems due to their efficiency and tendency to produce high-quality translations (Koehn, 2004; Koehn et al., 2007; Dyer et al., 2010).",
        "However despite practical effectiveness, neither algorithm provides any bound on possible decoding error.",
        "In this work we present a variant of beam search decoding for phrase-and syntax-based translation.",
        "The motivation is to exploit the effectiveness and efficiency of beam search, but still maintain formal guarantees.",
        "The algorithm has the following benefits: ?",
        "In theory, it can provide a certificate of optimality; in practice, we show that it produces optimal hypotheses, with certificates of optimality,",
        "on the vast majority of examples.",
        "?",
        "It utilizes well-studied algorithms and extends off-the-shelf beam search decoders.",
        "?",
        "Empirically it is very fast, results show that it is 3.5 times faster than an optimized incremental constraint-based solver.",
        "While our focus is on fast decoding for machine translation, the algorithm we present can be applied to a variety of dynamic programming-based decoding problems.",
        "The method only relies on having a constrained beam search algorithm and a fast unconstrained search algorithm.",
        "Similar algorithms exist for many NLP tasks.",
        "We begin in Section 2 by describing constrained hypergraph search and showing how it generalizes translation decoding.",
        "Section 3 introduces a variant of beam search that is, in theory, able to produce a certificate of optimality.",
        "Section 4 shows how to improve the effectiveness of beam search by using weights derived from Lagrangian relaxation.",
        "Section 5 puts everything together to derive a fast beam search algorithm that is often optimal in practice.",
        "Experiments compare the new algorithm with several variants of beam search, cube pruning, A?",
        "search, and relaxation-based decoders on two translation tasks.",
        "The optimal beam search algorithm is able to find exact solutions with certificates of optimality on 99% of translation examples, significantly more than other baselines.",
        "Additionally the optimal",
        "beam search algorithm is much faster than other exact methods."
      ]
    },
    {
      "heading": "2 Background",
      "text": [
        "The focus of this work is decoding for statistical machine translation.",
        "Given a source sentence, the goal is to find the target sentence that maximizes a combination of translation model and language model scores.",
        "In order to analyze this decoding problem, we first abstract away from the specifics of translation into a general form, known as a hypergraph.",
        "In this section, we describe the hypergraph formalism and its relation to machine translation."
      ]
    },
    {
      "heading": "2.1 Notation",
      "text": [
        "Throughout the paper, scalars and vectors are written in lowercase, matrices are written in uppercase, and sets are written in script-case, e.g. X .",
        "All vectors are assumed to be column vectors.",
        "The function ?",
        "(j) yields an indicator vector with ?",
        "(j)j = 1 and ?",
        "(j)i = 0 for all i 6= j."
      ]
    },
    {
      "heading": "2.2 Hypergraphs and Search",
      "text": [
        "A directed hypergraph is a pair (V, E) where V = {1 .",
        ".",
        ".",
        "|V|} is a set of vertices, and E is a set of directed hyperedges.",
        "Each hyperedge e ?",
        "E is a tuple?",
        "?v2, .",
        ".",
        ".",
        ", v|v|?, v1 ?",
        "where vi ?",
        "V for i ?",
        "{1 .",
        ".",
        ".",
        "|v|}.",
        "The head of the hyperedge is h(e) = v1.",
        "The tail of the hyperedge is the ordered sequence t(e) = ?v2, .",
        ".",
        ".",
        ", v|v|?.",
        "The size of the tail |t(e) |may vary across different hyperedges, but |t(e) |?",
        "1 for all edges and is bounded by a constant.",
        "A directed graph is a directed hypergraph with |t(e) |= 1 for all edges e ?",
        "E .",
        "Each vertex v ?",
        "V is either a non-terminal or a terminal in the hypergraph.",
        "The set of non-terminals is N = {v ?",
        "V : h(e) = v for some e ?",
        "E}.",
        "Conversely, the set of terminals is defined as T = V\\N .",
        "All directed hypergraphs used in this work are acyclic: informally this implies that no hyperpath (as defined below) contains the same vertex more than once (see Martin et al. (1990) for a full definition).",
        "Acyclicity implies a partial topological ordering of the vertices.",
        "We also assume there is a distinguished root vertex 1 where for all e ?",
        "E , 1 6?",
        "t(e).",
        "Next we define a hyperpath as x ?",
        "{0, 1}|E |where x(e) = 1 if hyperedge e is used in the hyperpath, procedure BESTPATHSCORE(?, ? )",
        "pi[v]?",
        "0 for all v ?",
        "T for e ?",
        "E in topological order do",
        "strained hypergraph search.",
        "Note that this version only returns the highest score: maxx?X ?>x+ ?",
        ".",
        "The optimal hyperpath can be found by including back-pointers.",
        "x(e) = 0 otherwise.",
        "The set of valid hyperpaths is defined as",
        "The first problem we consider is unconstrained hypergraph search.",
        "Let ?",
        "?",
        "R|E |be the weight vector for the hypergraph and let ?",
        "?",
        "R be a weight offset.",
        "The unconstrained search problem is to find",
        "This maximization can be computed for any weights and directed acyclic hypergraph in time O(|E|) using dynamic programming.",
        "Figure 1 shows this algorithm which is simply a version of the CKY algorithm.",
        "Next consider a variant of this problem: constrained hypergraph search.",
        "Constraints will be necessary for both phrase-and syntax-based decoding.",
        "In phrase-based models, the constraints will ensure that each source word is translated exactly once.",
        "In syntax-based models, the constraints will be used to intersect a translation forest with a language model.",
        "In the constrained hypergraph problem, hyperpaths must fulfill additional linear hyperedge constraints.",
        "Define the set of constrained hyperpaths as",
        "where we have a constraint matrix A ?",
        "R|b|?|E| and vector b ?",
        "R|b |encoding |b |constraints.",
        "The optimal constrained hyperpath is x?",
        "= arg maxx?X ?",
        "?>x+ ?",
        ".",
        "Note that the constrained hypergraph search problem may be NP-Hard.",
        "Crucially this is true even when the corresponding unconstrained search problem is solvable in polynomial time.",
        "For instance, phrase-based decoding is known to be NP-Hard (Knight, 1999), but we will see that it can be expressed as a polynomial-sized hypergraph with constraints.",
        "Example: Phrase-Based Machine Translation Consider translating a source sentencew1 .",
        ".",
        ".",
        "w|w |to a target sentence in a language with vocabulary ?.",
        "A simple phrase-based translation model consists of a",
        "tuple (P, ?, ?)",
        "with ?",
        "P; a set of pairs (q, r) where q1 .",
        ".",
        ".",
        "q|q |is a sequence of source-language words and r1 .",
        ".",
        ".",
        "r|r| is a sequence of target-language words drawn from the target vocabulary ?.",
        "?",
        "?",
        ": R|P|; parameters for the translation model mapping each pair in P to a real-valued score.",
        "?",
        "?",
        ": R|??",
        "?|; parameters of the language model mapping a bigram of target-language words to a real-valued score.",
        "The translation decoding problem is to find the best derivation for a given source sentence.",
        "A derivation consists of a sequence of phrases p = p1 .",
        ".",
        ".",
        "pn.",
        "Define a phrase as a tuple (q, r, j, k) consisting of a span in the source sentence q = wj .",
        ".",
        ".",
        "wk and a sequence of target words r1 .",
        ".",
        ".",
        "r|r|, with (q, r) ?",
        "P .",
        "We say the source words wj .",
        ".",
        ".",
        "wk are translated to r. The score of a derivation, f(p), is the sum of the translation score of each phrase plus the language model score of the target sentence",
        "where u is the sequence of words in ?",
        "formed by concatenating the phrases r(p1) .",
        ".",
        ".",
        "r(pn), with boundary cases u0 = <s> and u|u|+1 = </s>.",
        "Crucially for a derivation to be valid it must satisfy an additional condition: it must translate every source word exactly once.",
        "The decoding problem for phrase-based translation is to find the highest-scoring derivation satisfying this property.",
        "We can represent this decoding problem as a constrained hypergraph using the construction of Chang and Collins (2011).",
        "The hypergraph weights encode the translation and language model scores, and its structure ensures that the count of source words translated is |w|, i.e. the length of the source sentence.",
        "Each vertex will remember the preceding target-language word and the count of source words translated so far.",
        "The hypergraph, which for this problem is also a directed graph, takes the following form.",
        "?",
        "Vertices v ?",
        "V are labeled (c, u) where c ?",
        "{1 .",
        ".",
        ".",
        "|w|} is the count of source words translated and u ?",
        "?",
        "is the last target-language word produced by a partial hypothesis at this vertex.",
        "Additionally there is an initial terminal vertex labeled (0,<s>).",
        "?",
        "There is a hyperedge e ?",
        "E with head (c?, u?)",
        "and tail ?",
        "(c, u)?",
        "if there is a valid corresponding phrase (q, r, j, k) such that c?",
        "= c + |q |and u?",
        "= r|r|, i.e. c ?",
        "is the count of words translated and u?",
        "is the last word of target phrase r. We call this phrase p(e).",
        "The weight of this hyperedge, ?",
        "(e), is the translation model score of the pair plus its language model score",
        "?",
        "To handle the end boundary, there are hyperedges with head 1 and tail ?",
        "(|w|, u)?",
        "for all u ?",
        "?.",
        "The weight of these edges is the cost of the stop bigram following u, i.e.",
        "?(u,</s>).",
        "While any valid derivation corresponds to a hyperpath in this graph, a hyperpath may not correspond to a valid derivation.",
        "For instance, a hyperpath may translate some source words more than once or not at all.",
        "{(les, the), (pauvres, poor), (sont demunis, don't have any money)}.",
        "Hyperedges are color-coded by source words translated: orange for les1, green for pauvres2, and red for sont3 demunis4.",
        "The dotted lines show an invalid hyperpath x that has signature Ax = ?0, 0, 2, 2?",
        "6= ?1, 1, 1, 1?",
        ".",
        "We handle this problem by adding additional constraints.",
        "For all source words i ?",
        "{1 .",
        ".",
        ".",
        "|w|}, define ?",
        "as the set of hyperedges that translate wi",
        "Next define |w |constraints enforcing that each word in the source sentence is translated exactly once",
        "These linear constraints can be represented with a matrix A ?",
        "{0, 1}|w|?|E |where the rows correspond to source indices and the columns correspond to edges.",
        "We call the product Ax the signature, where in this case (Ax)i is the number of times word i has been translated.",
        "The full set of constrained hyperpaths is X ?",
        "= {x ?",
        "X : Ax = 1 }, and the best derivation under this phrase-based translation model has score maxx?X ?",
        "?>x+ ?",
        ".",
        "Figure 2.2 shows an example hypergraph with constraints for translating the sentence les pauvres sont demunis into English using a simple set of phrases.",
        "Even in this small example, many of the possible hyperpaths violate the constraints and correspond to invalid derivations.",
        "Example: Syntax-Based Machine Translation Syntax-based machine translation with a language model can also be expressed as a constrained hypergraph problem.",
        "For the sake of space, we omit the definition.",
        "See Rush and Collins (2011) for an in-depth description of the constraint matrix used for syntax-based translation."
      ]
    },
    {
      "heading": "3 A Variant of Beam Search",
      "text": [
        "This section describes a variant of the beam search algorithm for finding the highest-scoring constrained hyperpath.",
        "The algorithm uses three main techniques: (1) dynamic programming with additional signature information to satisfy the constraints, (2) beam pruning where some, possibly optimal, hypotheses are discarded, and (3) branch-and-bound-style application of upper and lower bounds to discard provably non-optimal hypotheses.",
        "Any solution returned by the algorithm will be a valid constrained hyperpath and a member of X ?.",
        "Additionally the algorithm returns a certificate flag opt that, if true, indicates that no beam pruning was used, implying the solution returned is optimal.",
        "Generally it will be hard to produce a certificate even by reducing the amount of beam pruning; however in the next section we will introduce a method based on Lagrangian relaxation to tighten the upper bounds.",
        "These bounds will help eliminate most solutions before they trigger pruning."
      ]
    },
    {
      "heading": "3.1 Algorithm",
      "text": [
        "Figure 3 shows the complete beam search algorithm.",
        "At its core it is a dynamic programming algorithm filling in the chart pi.",
        "The beam search chart indexes hypotheses by vertex v ?",
        "V as well as a signature sig ?",
        "R|b |where |b |is the number of constraints.",
        "A new hypothesis is constructed from each hyperedge and all possible signatures of tail nodes.",
        "We define the function SIGS to take the tail of an edge and re",
        "turn the set of possible signature combinations",
        "where the product is the Cartesian product over sets.",
        "Line 8 loops over this entire set.2 For hypothesis x, the algorithm ensures that its signature sig is equal to Ax.",
        "This property is updated on line 9.",
        "The signature provides proof that a hypothesis is still valid.",
        "Let the function CHECK(sig) return true if the hypothesis can still fulfill the constraints.",
        "For example, in phrase-based decoding, we will define CHECK(sig) = (sig ?",
        "1); this ensures that each word has been translated 0 or 1 times.",
        "This check is applied on line 11.",
        "Unfortunately maintaining all signatures is inefficient.",
        "For example we will see that in phrase-based decoding the signature is a bit-string recording which source words have been translated; the number of possible bit-strings is exponential in the length of the sentence.",
        "The algorithm includes two methods for removing hypotheses, bounding and pruning.",
        "Bounding allows us to discard provably non-optimal solutions.",
        "The algorithm takes as arguments a lower bound on the optimal score lb ?",
        "?>x?",
        "+ ?",
        ", and computes upper bounds on the outside score for all vertices v: ubs[v], i.e. an overestimate of the score for completing the hyperpath from v. If a hypothesis has score s, it can only be optimal if s+ ubs[v] ?",
        "lb.",
        "This bound check is performed on line 11.",
        "Pruning removes weak partial solutions based on problem-specific checks.",
        "The algorithm invokes the black-box function, PRUNE, on line 13, passing it a pruning parameter ?",
        "and a vertex-signature pair.",
        "The parameter ?",
        "controls a threshold for pruning.",
        "For instance for phrase-based translation, it specifies a hard-limit on the number of hypotheses to retain.",
        "The function returns true if it prunes from the chart.",
        "Note that pruning may remove optimal hypotheses, so we set the certificate flag opt to false if the chart",
        "is modified.",
        "2For simplicity we write this loop over the entire set.",
        "In practice it is important to use data structures to optimize lookup.",
        "See Tillmann (2006) and Huang and Chiang (2005).",
        "1: procedure BEAMSEARCH(?, ?, lb, ?)",
        "2: ubs?",
        "OUTSIDE(?, ?)",
        "3: opt?",
        "true 4: pi[v, sig]?",
        "??",
        "for all v ?",
        "V, sig ?",
        "R|b| 5: pi[v, 0]?",
        "0 for all v ?",
        "T 6: for e ?",
        "E in topological order do 7: ?",
        "?v2, .",
        ".",
        ".",
        ", v|v|?, v1?",
        "?",
        "e 8: for sig(2) .",
        ".",
        ".",
        "sig(|v|) ?",
        "SIGS(v2, .",
        ".",
        ".",
        ", v|v|) do 9: sig ?",
        "A?",
        "(e) +",
        "dynamic programming to produce a lower bound on the optimal constrained solution and, possibly, a certificate of optimality.",
        "Function OUTSIDE computes upper bounds on outside scores.",
        "Function SIGS enumerates all possible tail signatures.",
        "Function CHECK identifies signatures that do not violate constraints.",
        "Bounds lb and ubs are used to remove provably non-optimal solutions.",
        "Function PRUNE, taking parameter ?, returns true if it prunes hypotheses from pi that could be optimal.",
        "This variant on beam search satisfies the following two properties (recall x?",
        "is the optimal constrained solution) Property 3.1 (Primal Feasibility).",
        "The returned score lb?",
        "lower bounds the optimal constrained score, that is lb?",
        "?",
        "?>x?",
        "+ ?",
        ".",
        "Property 3.2 (Dual Certificate).",
        "If beam search returns with opt = true, then the returned score is optimal, i.e. lb?",
        "= ?>x?",
        "+ ?",
        ".",
        "An immediate consequence of Property 3.1 is that the output of beam search, lb?, can be used as the input lb for future runs of the algorithm.",
        "Furthermore,",
        "pi[v?, sig?]?",
        "??",
        "for all v?, sig?",
        "?",
        "D if D = ?",
        "then return true else return false Input: [ (v, sig) the last hypothesis added to the chart ?",
        "?",
        "Z # of hypotheses to retain Output: true, if pi is modified",
        "Set C contains all hypotheses with ||sig||1 source words translated.",
        "The function prunes all but the top-?",
        "scoring hypotheses in this set.",
        "if we loosen the amount of beam pruning by adjusting the pruning parameter ?",
        "we can produce tighter lower bounds and discard more hypotheses.",
        "We can then iteratively apply this idea with a sequence of parameters ?1 .",
        ".",
        ".",
        "?K producing lower bounds lb(1) through lb(K).",
        "We return to this idea in Section 5.",
        "Example: Phrase-based Beam Search.",
        "Recall that the constraints for phrase-based translation consist of a binary matrix A ?",
        "{0, 1}|w|?|E |and vector b = 1.",
        "The value sigi is therefore the number of times source word i has been translated in the hypothesis.",
        "We define the predicate CHECK as CHECK(sig) = (sig ?",
        "1) in order to remove hypotheses that already translate a source word more than once, and are therefore invalid.",
        "For this reason, phrase-based signatures are called bit-strings.",
        "A common beam pruning strategy is to group together items into a set C and retain a (possibly complete) subset.",
        "An example phrase-based beam pruner is given in Figure 4.",
        "It groups together hypotheses based on ||sigi||1, i.e. the number of source words translated, and applies a hard pruning filter that retains only the ?",
        "highest-scoring items (v, sig) ?",
        "C based on pi[v, sig]."
      ]
    },
    {
      "heading": "3.2 Computing Upper Bounds",
      "text": [
        "Define the setO(v, x) to contain all outside edges of vertex v in hyperpath x (informally, hyperedges that do not have v as an ancestor).",
        "For all v ?",
        "V , we set the upper bounds, ubs, to be the best unconstrained outside score",
        "This upper bound can be efficiently computed for all vertices using the standard outside dynamic programming algorithm.",
        "We will refer to this algorithm as OUTSIDE(?, ?",
        ").",
        "Unfortunately, as we will see, these upper bounds are often quite loose.",
        "The issue is that unconstrained outside paths are able to violate the constraints without being penalized, and therefore greatly overestimate the score."
      ]
    },
    {
      "heading": "4 Finding Tighter Bounds with Lagrangian Relaxation",
      "text": [
        "Beam search produces a certificate only if beam pruning is never used.",
        "In the case of phrase-based translation, the certificate is dependent on all groups C having ?",
        "or less hypotheses.",
        "The only way to ensure this is to bound out enough hypotheses to avoid pruning.",
        "The effectiveness of the bounding inequality, s + ubs[v] < lb, in removing hypotheses is directly dependent on the tightness of the bounds.",
        "In this section we propose using Lagrangian relaxation to improve these bounds.",
        "We first give a brief overview of the method and then apply it to computing bounds.",
        "Our experiments show that this approach is very effective at finding certificates."
      ]
    },
    {
      "heading": "4.1 Algorithm",
      "text": [
        "In Lagrangian relaxation, instead of solving the constrained search problem, we relax the constraints and solve an unconstrained hypergraph problem with modified weights.",
        "Recall the constrained hypergraph problem: max",
        "grangian dual of this optimization problem is",
        "maximization is over X , so for any value of ?, L(?)",
        "can be calculated as BestPathScore(?",
        "?, ?",
        "?).",
        "Note that for all valid constrained hyperpaths x ?",
        "X ?",
        "the termAx?b equals 0, which implies that these hyperpaths have the same score under the modified weights as under the original weights, ?>x + ?",
        "= ??>x+?",
        "?.",
        "This leads to the following two properties,",
        "for k in 1 .",
        ".",
        ".K do ?",
        "(k),ub, opt?",
        "LRROUND(?k, ?",
        "(k?1)) if opt then return ?",
        "(k),ub, opt",
        "rithm repeatedly calls LRROUND to compute the subgradient, update the dual vector, and check for a certificate.",
        "where x ?",
        "X is the hyperpath computed within the max, Property 4.1 (Dual Feasibility).",
        "The valueL(?)",
        "upper bounds the optimal solution, that is L(?)",
        "?",
        "some upper bound; however, to help beam search, we want as tight a bound as possible: min?",
        "L(?).",
        "The Lagrangian relaxation algorithm, shown in Figure 5, uses subgradient descent to find this minimum.",
        "The subgradient of L(?)",
        "is Ax ?",
        "b where x is the argmax of the modified objective x = arg maxx?X ?",
        "?>x + ?",
        "?.",
        "Subgradient descent iteratively solves unconstrained hypergraph search problems to compute these subgradients and updates ?.",
        "See Rush and Collins (2012) for an extensive discussion of this style of optimization in natural language processing.",
        "Example: Phrase-based Relaxation.",
        "For phrase-based translation, we expand out the Lagrangian to",
        "The weight of each edge ?",
        "(e) is modified by the dual variables ?i for each source word translated by the edge, i.e. if (q, r, j, k) = p(e), then the score is modified by ?k i=j ?i.",
        "A solution under these weights may use source words multiple times or not at all.",
        "However if the solution uses each source word exactly once (Ax = 1), then we have a certificate and the solution is optimal."
      ]
    },
    {
      "heading": "4.2 Utilizing Upper Bounds in Beam Search",
      "text": [
        "For many problems, it may not be possible to satisfy Property 4.2 by running the subgradient algorithm alone.",
        "Yet even for these problems, applying subgradient descent will produce an improved estimate of the upper bound, min?",
        "L(?).",
        "To utilize these improved bounds, we simply replace the weights in beam search and the outside algorithm with the modified weights from Lagrangian relaxation, ??",
        "and ?",
        "?.",
        "Since the result of beam search must be a valid constrained hyperpath x ?",
        "X ?, and for all x ?",
        "X ?, ?>x + ?",
        "= ?",
        "?>x + ?",
        "?, this substitution does not alter the necessary properties of the algorithm; i.e. if the algorithm returns with opt equal to true, then the solution is optimal.",
        "Additionally the computation of upper bounds now becomes",
        "These outside paths may still violate constraints, but the modified weights now include penalty terms to discourage common violations."
      ]
    },
    {
      "heading": "5 Optimal Beam Search",
      "text": [
        "The optimality of the beam search algorithm is dependent on the tightness of the upper and lower bounds.",
        "We can produce better lower bounds by varying the pruning parameter ?",
        "; we can produce better upper bounds by running Lagrangian relaxation.",
        "In this section we combine these two ideas and present a complete optimal beam search algorithm.",
        "Our general strategy will be to use Lagrangian relaxation to compute modified weights and to use beam search over these modified weights to attempt to find an optimal solution.",
        "One simple method for doing this, shown at the top of Figure 6, is to run",
        "in stages.",
        "The algorithm first runs Lagrangian relaxation to compute the best ?",
        "vector.",
        "The algorithm then iteratively runs beam search using the parameter sequence ?k.",
        "These parameters allow the algorithm to loosen the amount of beam pruning.",
        "For example in phrase based pruning, we would raise the number of hypotheses stored per group until no beam pruning occurs.",
        "A clear disadvantage of the staged approach is that it needs to wait until Lagrangian relaxation is completed before even running beam search.",
        "Often beam search will be able to quickly find an optimal solution even with good but non-optimal ?.",
        "In other cases, beam search may still improve the lower bound lb.",
        "This motivates the alternating algorithm OPT-BEAM shown Figure 6.",
        "In each round, the algorithm alternates between computing subgradients to tighten ubs and running beam search to maximize lb.",
        "In early rounds we set ?",
        "for aggressive beam pruning, and as the upper bounds get tighter, we loosen pruning to try to get a certificate.",
        "If at any point either a primal or dual certificate is found, the algorithm returns the optimal solution."
      ]
    },
    {
      "heading": "6 Related Work",
      "text": [
        "Approximate methods based on beam search and cube-pruning have been widely studied for phrase-based (Koehn et al., 2003; Tillmann and Ney, 2003; Tillmann, 2006) and syntax-based translation models (Chiang, 2007; Huang and Chiang, 2007; Watanabe et al., 2006; Huang and Mi, 2010).",
        "There is a line of work proposing exact algorithms for machine translation decoding.",
        "Exact decoders are often slow in practice, but help quantify the errors made by other methods.",
        "Exact algorithms proposed for IBM model 4 include ILP (Germann et al., 2001), cutting plane (Riedel and Clarke, 2009), and multi-pass A* search (Och et al., 2001).",
        "Zaslavskiy et al. (2009) formulate phrase-based decoding as a traveling salesman problem (TSP) and use a TSP decoder.",
        "Exact decoding algorithms based on finite state transducers (FST) (Iglesias et al., 2009) have been studied on phrase-based models with limited reordering (Kumar and Byrne, 2005).",
        "Exact decoding based on FST is also feasible for certain hierarchical grammars (de Gispert et al., 2010).",
        "Chang procedure OPTBEAMSTAGED(?, ?)",
        "?,ub, opt?LAGRANGIANRELAXATION(?)",
        "if opt then return ub",
        "for k in 1 .",
        ".",
        ".K do lb(k), opt?",
        "BEAMSEARCH(?",
        "?, ?",
        "?, lb(k?1), ?k) if opt then return lb(k)",
        "for k in 1 .",
        ".",
        ".K do ?",
        "(k),ub(k), opt?",
        "LRROUND(?k, ?",
        "(k?1)) if opt then return ub(k) ??",
        "?",
        "?",
        "?A>?",
        "(k) ?",
        "?",
        "?",
        "?",
        "+ ?",
        "(k)>b lb(k), opt?",
        "BEAMSEARCH(?",
        "?, ?",
        "?, lb(k?1), ?k) if opt then return lb(k)",
        "find the optimal ?, uses ?",
        "to compute upper bounds, and then repeatedly runs beam search with pruning sequence ?1 .",
        ".",
        ".",
        "?k.",
        "Alternating switches between running a round of Lagrangian relaxation and a round of beam search with the updated ?.",
        "If either produces a certificate it returns the result.",
        "and Collins (2011) and Rush and Collins (2011) develop Lagrangian relaxation-based approaches for exact machine translation.",
        "Apart from translation decoding, this paper is closely related to work on column generation for NLP.",
        "Riedel et al. (2012) and Belanger et al. (2012) relate column generation to beam search and produce exact solutions for parsing and tagging problems.",
        "The latter work also gives conditions for when beam search-style decoding is optimal."
      ]
    },
    {
      "heading": "7 Results",
      "text": [
        "To evaluate the effectiveness of optimal beam search for translation decoding, we implemented decoders for phrase-and syntax-based models.",
        "In this section we compare the speed and optimality of these",
        "decoders to several baseline methods."
      ]
    },
    {
      "heading": "7.1 Setup and Implementation",
      "text": [
        "For phrase-based translation we used a German-to-English data set taken from Europarl (Koehn, 2005).",
        "We tested on 1,824 sentences of length at most 50 words.",
        "For experiments the phrase-based systems uses a trigram language model and includes standard distortion penalties.",
        "Additionally the unconstrained hypergraph includes further derivation information similar to the graph described in Chang and Collins (2011).",
        "For syntax-based translation we used a Chinese-to-English data set.",
        "The model and hypergraphs come from the work of Huang and Mi (2010).",
        "We tested on 691 sentences from the newswire portion of the 2008 NIST MT evaluation test set.",
        "For experiments, the syntax-based model uses a trigram language model.",
        "The translation model is tree-to-string syntax-based model with a standard context-free translation forest.",
        "The constraint matrix A is based on the constraints described by Rush and Collins (2011).",
        "Our decoders use a two-pass architecture.",
        "The first pass sets up the hypergraph in memory, and the second pass runs search.",
        "When possible the baselines share optimized construction and search code.",
        "The performance of optimal beam search is dependent on the sequences ?",
        "and ?.",
        "For the step-size ?",
        "we used a variant of Polyak's rule (Polyak, 1987; Boyd and Mutapcic, 2007), substituting the unknown optimal score for the last computed lower bound: ?k ?",
        "ub (k)?lb(k)"
      ]
    },
    {
      "heading": "||Ax(k)?b||22",
      "text": [
        ".",
        "We adjust the order of the pruning parameter ?",
        "based on a function ?",
        "of the current gap: ?k ?",
        "10?",
        "(ub (k)?lb(k)).",
        "Previous work on these data sets has shown that exact algorithms do not result in a significant increase in translation accuracy.",
        "We focus on the efficiency and model score of the algorithms."
      ]
    },
    {
      "heading": "7.2 Baseline Methods",
      "text": [
        "The experiments compare optimal beam search (OPTBEAM) to several different decoding methods.",
        "For both systems we compare to: BEAM, the beam search decoder from Figure 3 using the original weights ?",
        "and ?",
        ", and ?",
        "?",
        "{100, 1000}; LRTIGHT, Lagrangian relaxation followed by incre",
        "Graph (a) shows the duality gap distribution for 1,824 sentences after 0, 5, and 10 rounds of LR.",
        "Graph (b) shows the % of certificates found for sentences with differing gap sizes and beam search parameters ?.",
        "Duality gap is defined as, ub - (?>x?",
        "+ ?",
        ").",
        "mental tightening constraints, which is a reimplementation of Chang and Collins (2011) and Rush and Collins (2011).",
        "For phrase-based translation we compare with: MOSES-GC, the standard Moses beam search decoder with ?",
        "?",
        "{100, 1000} (Koehn et al., 2007); MOSES, a version of Moses without gap constraints more similar to BEAM (see Chang and Collins (2011)); ASTAR, an implementation of A?",
        "search using original outside scores, i.e.",
        "OUTSIDE(?, ?",
        "), and capped at 20,000,000 queue pops.",
        "For syntax-based translation we compare with: ILP, a general-purpose integer linear programming solver (Gurobi Optimization, 2013) and CUBEPRUNING, an approximate decoding method similar to beam search (Chiang, 2007), tested with ?",
        "?",
        "{100, 1000}."
      ]
    },
    {
      "heading": "7.3 Experiments",
      "text": [
        "Table 1 shows the main results.",
        "For phrase-based translation, OPTBEAM decodes the optimal translation with certificate in 99% of sentences with an average time of 17.27 seconds per sentence.",
        "This",
        "cert is the percentage of sentences solved with a certificate of optimality, exact is the percentage of sentences solved exactly, i.e. ?>x+ ?",
        "= ?>x?",
        "+ ?",
        ".",
        "Results are grouped by sentence length (group 1-10 is omitted for space).",
        "is seven times faster than the decoder of Chang and Collins (2011) and 3.5 times faster then our reimplementation, LR-TIGHT.",
        "ASTAR performs poorly, taking lots of time on difficult sentences.",
        "BEAM runs quickly, but rarely finds an exact solution.",
        "MOSES without gap constraints is also fast, but less exact than OPTBEAM and unable to produce certificates.",
        "For syntax-based translation.",
        "OPTBEAM finds a certificate on 98.8% of solutions with an average time of 1.75 seconds per sentence, and is four times faster than LR-TIGHT.",
        "CUBE (100) is an order of magnitude faster, but is rarely exact on longer sentences.",
        "CUBE (1000) finds more exact solutions, but is comparable in speed to optimal beam search.",
        "BEAM performs better than in the phrase-based model, but is not much faster than OPTBEAM.",
        "Figure 7.2 shows the relationship between beam search optimality and duality gap.",
        "Graph (a) shows how a handful of LR rounds can significantly tighten the upper bound score of many sentences.",
        "Graph (b) shows how beam search is more likely to find optimal solutions with tighter bounds.",
        "BEAM effectively uses 0 rounds of LR, which may explain why it finds so few optimal solutions compared to OPTBEAM.",
        "Table 2 breaks down the time spent in each part of the algorithm.",
        "For both methods, beam search has the most time variance and uses more time on longer sentences.",
        "For phrase-based sentences, Lagrangian relaxation is fast, and hypergraph construction dom",
        "including: hypergraph construction, Lagrangian relaxation, and beam search.",
        "Mean is the percentage of total time.",
        "Median is the distribution over the median values for each row.",
        "inates.",
        "If not for this cost, OPTBEAM might be comparable in speed to MOSES (1000)."
      ]
    },
    {
      "heading": "8 Conclusion",
      "text": [
        "In this work we develop an optimal variant of beam search and apply it to machine translation decoding.",
        "The algorithm uses beam search to produce constrained solutions and bounds from Lagrangian relaxation to eliminate non-optimal solutions.",
        "Results show that this method can efficiently find exact solutions for two important styles of machine translation."
      ]
    },
    {
      "heading": "Acknowledgments Alexander Rush, Yin-Wen",
      "text": [
        "Chang and Michael Collins were all supported by NSF grant IIS-1161814.",
        "Alexander Rush was partially supported by an NSF Graduate Research Fellowship."
      ]
    }
  ]
}
