{
  "info": {
    "authors": [
      "Emmanuel Lassalle",
      "Pascal Denis"
    ],
    "book": "ACL",
    "id": "acl-P13-1049",
    "title": "Improving pairwise coreference models through feature space hierarchy learning",
    "url": "https://aclweb.org/anthology/P13-1049",
    "year": 2013
  },
  "references": [
    "acl-C08-1121",
    "acl-C10-1017",
    "acl-D08-1031",
    "acl-D08-1069",
    "acl-H05-1004",
    "acl-J01-4004",
    "acl-M95-1005",
    "acl-N04-1037",
    "acl-N06-1025",
    "acl-P00-1023",
    "acl-P02-1014",
    "acl-P12-1041",
    "acl-W06-1633",
    "acl-W12-4501"
  ],
  "sections": [
    {
      "text": [
        "Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 497?506, Sofia, Bulgaria, August 4-9 2013. c?2013 Association for Computational Linguistics Improving pairwise coreference models through feature space hierarchy learning"
      ]
    },
    {
      "heading": "Abstract",
      "text": [
        "This paper proposes a new method for significantly improving the performance of pairwise coreference models.",
        "Given a set of indicators, our method learns how to best separate types of mention pairs into equivalence classes for which we construct distinct classification models.",
        "In effect, our approach finds an optimal feature space (derived from a base feature set and indicator set) for discriminating coref-erential mention pairs.",
        "Although our approach explores a very large space of possible feature spaces, it remains tractable by exploiting the structure of the hierarchies built from the indicators.",
        "Our experiments on the CoNLL-2012 Shared Task English datasets (gold mentions) indicate that our method is robust relative to different clustering strategies and evaluation metrics, showing large and consistent improvements over a single pairwise model using the same base features.",
        "Our best system obtains a competitive 67.2 of average F1 over MUC, B3, and CEAF which, despite its simplicity, places it above the mean score of other systems on these datasets."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Coreference resolution is the problem of partitioning a sequence of noun phrases (or mentions), as they occur in a natural language text, into a set of referential entities.",
        "A common approach to this problem is to separate it into two modules: on the one hand, one defines a model for evaluating coreference links, in general a discriminative classifier that detects coreferential mention pairs.",
        "On the other hand, one designs a method for grouping the detected links into a coherent global output (i.e. a partition over the set of entity mentions).",
        "This second step is typically achieved using greedy heuristics (McCarthy and Lehnert, 1995; Soon et al., 2001; Ng and Cardie, 2002; Bengston and Roth, 2008), although more sophisticated clustering approaches have been used, too, such as cutting graph methods (Nicolae and Nicolae, 2006; Cai and Strube, 2010) and Integer Linear Programming (ILP) formulations (Klenner, 2007; Denis and Baldridge, 2009).",
        "Despite its simplicity, this two-step strategy remains competitive even when compared to more complex models utilizing a global loss (Bengston and Roth, 2008).",
        "In this kind of architecture, the performance of the entire coreference system strongly depends on the quality of the local pairwise classifier.1 Consequently, a lot of research effort on coreference resolution has focused on trying to boost the performance of the pairwise classifier.",
        "Numerous studies are concerned with feature extraction, typically trying to enrich the classifier with more linguistic knowledge and/or more world knowledge (Ng and Cardie, 2002; Kehler et al., 2004; Ponzetto and Strube, 2006; Bengston and Roth, 2008; Versley et al., 2008; Uryupina et al., 2011).",
        "A second line of work explores the use of distinct local models for different types of mentions, specifically for different types of anaphoric mentions based on their grammatical categories (such as pronouns, proper names, definite descriptions) (Morton, 2000; Ng, 2005; Denis and Baldridge,",
        "cialized models is (psycho-)linguistic and comes from theoretical findings based on salience or accessibility (Ariel, 1988).",
        "It is worth noting that, from a machine learning point of view, this is related to feature extraction in that both approaches in effect recast the pairwise classification problem in higher dimensional feature spaces.",
        "In this paper, we claim that mention pairs should not be processed by a single classifier, and instead should be handled through specific models.",
        "But we are furthermore interested in learning how to construct and select such differential models.",
        "Our argument is therefore based on statistical considerations, rather than on purely linguistic ones3.",
        "The main question we raise is, given a set of indicators (such as grammatical types, distance between two mentions, or named entity types), how to best partition the pool of mention pair examples in order to best discriminate coref-erential pairs from non coreferential ones.",
        "In effect, we want to learn the ?best?",
        "subspaces for our different models: that is, subspaces that are neither too coarse (i.e., unlikely to separate the data well) nor too specific (i.e., prone to data sparseness and noise).",
        "We will see that this is also equivalent to selecting a single large adequate feature space by using the data.",
        "Our approach generalizes earlier approaches in important ways.",
        "For one thing, the definition of the different models is no longer restricted to grammatical typing (our model allows for various other types of indicators) or to the sole typing of the anaphoric mention (our models can also be specific to a particular type antecedent or to the two types of the mention pair).",
        "More importantly, we propose an original method for learning the best set of models that can be built from a given set of indicators and a training set.",
        "These models are organized in a hierarchy, wherein each leaf corresponds to a mutually disjoint subset of mention pair examples and the classifier that can be trained from it.",
        "Our models are trained using the Online Passive-Aggressive algorithm or PA (Crammer et al., 2006), a large margin version of the percep-tron.",
        "Our method is exact in that it explores the full space of hierarchies (of size at least 22n) definable on an indicator sequence, while remaining scalable by exploiting the particular structure of these during the training of the distinct local models (Ng and Cardie, 2002; Uryupina, 2004).",
        "3However it should be underlined that the statistical viewpoint is complementary to the linguistic work.",
        "hierarchies with dynamic programming.",
        "This approach also performs well, and it largely outperforms the single model.",
        "As will be shown based on a variety of experiments on the CoNLL-2012 Shared Task English datasets, these improvements are consistent across different evaluation metrics and for the most part independent of the clustering decoder that was used.",
        "The rest of this paper is organized as follows.",
        "Section 2 discusses the underlying statistical hypotheses of the standard pairwise model and defines a simple alternative framework that uses a simple separation of mention pairs based on grammatical types.",
        "Next, in section 3, we generalize the method by introducing indicator hierarchies and explain how to learn the best models associated with them.",
        "Section 4 provides a brief system description and Section 5 evaluates the various models on CoNLL-2012 English datasets."
      ]
    },
    {
      "heading": "2 Modeling pairs",
      "text": [
        "Pairwise models basically employ one local classifier to decide whether two mentions are coreferential or not.",
        "When using machine learning techniques, this involves certain assumptions about the statistical behavior of mention pairs."
      ]
    },
    {
      "heading": "2.1 Statistical assumptions",
      "text": [
        "Let us adopt a probabilistic point of view to describe the prototype of pairwise models.",
        "Given a document, the number of mentions is fixed and each pair of mentions follows a certain distribution (that we partly observe in a feature space).",
        "The basic idea of pairwise models is to consider mention pairs independently from each other (that is why a decoder is necessary to enforce transitivity).",
        "If we use a single classifier to process all pairs, then they are supposed to be identically distributed.",
        "We claim that pairs should not be processed by a single classifier because they are not identically distributed (or a least the distribution is too complex for the classifier); rather, we should separate different ?types?",
        "on pairs and create a specific model for each of them.",
        "Separating different kinds of pairs and handling them with different specific models can lead to more accurate global models.",
        "For instance, some coreference resolution systems process different kinds of anaphors separately, which suggests for example that pairs containing an anaphoric pronoun behave differently from pairs with non",
        "pronominal anaphors.",
        "One could rely on a rich set of features to capture complex distributions, but here we actually have a rather limited set of elementary features (see section 4) and, for instance, using products of features must be done carefully to avoid introducing noise in the model.",
        "Instead of imposing heuristic product of features, we will show that a clever separation of instances leads to significant improvements of the pairwise model."
      ]
    },
    {
      "heading": "2.2 Feature spaces 2.2.1 Definitions",
      "text": [
        "We first introduce the problem more formally.",
        "Every pair of mentions mi and mj is modeled by a",
        "where ?",
        "classically represents randomness, X is the space of objects (?mention pairs?)",
        "that is not directly observable and yij(?)",
        "?",
        "Y = {+1,?1} are the labels indicating whether mi and mj are coreferential or not.",
        "To lighten the notations, we will not always write the index ij.",
        "Now we define a mapping:",
        "that casts pairs into a feature space F through which we observe them.",
        "For us, F is simply a vector space over R (in our case many features are Boolean; they are cast into R as 0 and 1).",
        "For technical coherence, we assume that ?F1(x(?))",
        "and ?F2(x(?))",
        "have the same values when projected on the feature space F1 ?",
        "F2: it means that common features from two feature spaces have the same values.",
        "From this formal point of view, the task of coreference resolution consists in fixing ?F , observing labeled samples {(?F (x), y)t}t?TrainSet and, given partially observed new variables {(?F (x))t}t?TestSet, recovering the corresponding values of y.",
        "We claimed before that all mention pairs seemed not to be identically distributed since, for example, pronouns do not behave like nominals.",
        "We can formulate this more rigorously: since the object space X is not directly observable, we do not know its complexity.",
        "In particular, when using a mapping to a too small feature space, the classifier cannot capture the distribution very well: the data is too noisy.",
        "Now if we say that pronominal anaphora do not behave like other anaphora, we distinguish two kinds of pair i.e. we state that the distribution of pairs in X is a mixture of two distributions, and we deterministically separate pairs to their specific distribution part.",
        "In this way, we may separate positive and negative pairs more easily if we cast each kind of pair into a specific feature space.",
        "Let us call these feature spaces F1 and F2.",
        "We can either create two independent classifiers on F1 and F2 to process each kind of pair or define a single model on a larger feature space F = F1 ?",
        "F2.",
        "If the model is linear (which is our case), these approaches happen to be equivalent.",
        "So we can actually assume that the random variables Pij are identically distributed, but drawn from a complex mixture.",
        "A new issue arises: we need to find a mapping ?F that renders the best view on the distribution of the data.",
        "From a theoretical viewpoint, the higher the dimension of the feature space (imagine taking the direct sum of all feature spaces), the more we get details on the distribution of mention pairs and the more we can expect to separate positives and negatives accurately.",
        "In practice, we have to cope with data sparsity: there will not be enough data to properly train a linear model on such a space.",
        "Finally, we seek a feature space situated between the two extremes of a space that is too big (sparseness) or too small (noisy data).",
        "The core of this work is to define a general method for choosing the most adequate space F among a huge number of possibilities when we do not know a priori which is the best.",
        "In this work, we try to linearly separate positive and negative instances in the large space F with the Online Passive-Aggressive (PA) algorithm (Crammer et al., 2006): the model learns a parameter vector w that defines a hyperplane that cuts the space into two parts.",
        "The predicted class of a pair x with feature vector ?F (x) is given by:",
        "Linearity implies an equivalence between: (i) separating instances of two types, t1 and t2, in two",
        "independent models with respective feature spaces F1 and F2 and parameters w1 and w2, and (ii) a single model on F1?F2.",
        "To see why, let us define the map:",
        "and the parameter vector w =",
        "Now we check that the same property applies when the PA fits its parameter w. For each new instance of the training set, the weight is updated according to the following rule4:",
        "where the wit+1 correspond to the updates in space Fi independently from the rest.",
        "This result can be extended easily to the case of n feature spaces.",
        "Thus, with a deterministic separation of the data, a large model can be learned using smaller independent models."
      ]
    },
    {
      "heading": "2.3 An example: separation by gramtype",
      "text": [
        "To motivate our approach, we first introduce a simple separation of mention pairs which creates 9 models obtained by considering all possible pairs of grammatical types {nominal, name, pronoun} for both mentions in the pair (a similar fine-grained separation can be found in (Chen et al., 2011)).",
        "This is equivalent to using 9 different feature spacesF1, .",
        ".",
        ".",
        ",F9 to capture the global distribution of pairs.",
        "With the PA, this is also a single model with feature space F = F1 ?",
        "?",
        "?",
        "?",
        "?",
        "F9.",
        "We will call it the GRAMTYPE model.",
        "As we will see in Section 5, these separated models significantly outperform a single model",
        "It does not change if the instance is already correctly classified with such margin.",
        "that uses the same base feature set.",
        "But we would like to define a method that adapts a feature space to the data by choosing the most adequate separation of pairs."
      ]
    },
    {
      "heading": "3 Hierarchizing feature spaces",
      "text": [
        "In this section, we have to keep in mind that separating the pairs in different models is the same as building a large feature space in which the parameter w can be learned by parts in independent subspaces."
      ]
    },
    {
      "heading": "3.1 Indicators on pairs",
      "text": [
        "For establishing a structure on feature spaces, we use indicators which are deterministic functions on mention pairs with a small number of outputs.",
        "Indicators classify pairs in predefined categories in one-to-one correspondence with independent feature spaces.",
        "We can reuse some features of the system as indicators, e.g. the grammatical or named entity types.",
        "We can also employ functions that are not used as features, e.g. the approximate position of one of the mentions in the text.",
        "The small number of outputs of an indicator is required for practical reasons: if a category of pairs is too refined, the associated feature space will suffer from data sparsity.",
        "Accordingly, distance-based indicators must be approximated by coarse histograms.",
        "In our experiments the outputs never exceeded a dozen values.",
        "One way to reduce the output span of an indicator is to binarize it like binarizing a tree (many possible binarizations).",
        "This operation produces a hierarchy of indicators which is exactly the structure we exploit in what follows."
      ]
    },
    {
      "heading": "3.2 Hierarchies for separating pairs",
      "text": [
        "We define hierarchies as combinations of indicators creating finer categories of mention pairs: given a finite sequence of indicators, a mention pair is classified by applying the indicators successively, each time refining a category into subcategories, just like in a decision tree (each node having the same number of children as the number of outputs of its indicator).",
        "We allow the classification to stop before applying the last indicator, but the behavior must be the same for all the instances.",
        "So a hierarchy is basically a sub-tree of the complete decision tree that contains copies of the same indicator at each level.",
        "If all the leaves of the decision tree have the",
        "same depth, this corresponds to taking the Cartesian product of outputs of all indicators for indexing the categories.",
        "In that case, we refer to product-hierarchies.",
        "The GRAMTYPE model can be seen as a two level product-hierarchy (figure 1).",
        "Product-hierarchies will be the starting point of our method to find a feature space that fits the data.",
        "Now choosing a relevant sequence of indicators should be achieved through linguistic intuitions and theoretical work (gramtype separation is one of them).",
        "The system will find by itself the best usage of the indicators when optimizing the hierarchy.",
        "The sequence is a parameter of the model."
      ]
    },
    {
      "heading": "3.3 Relation with feature spaces",
      "text": [
        "Like we did for the GRAMTYPE model, we associate a feature space Fi to each leaf of a hierarchy.",
        "Likewise, the sum F = ?iFi defines a large feature space.",
        "The corresponding parameter w of the model can be obtained by learning the wi in Fi.",
        "Given a sequence of indicators, the number of different hierarchies we can define is equal to the number of sub-trees of the complete decision tree (each non-leaf node having all its children).",
        "The minimal case is when all indicators are Boolean.",
        "The number of full binary trees of height at most n can be computed by the following recursion:",
        "number of different hierarchies (or large feature spaces) definable with a sequence of indicators is gigantic (e.g. T (10) ?",
        "3.8.1090).",
        "Among all the possibilities for a large feature space, many are irrelevant because for them the data is too sparse or too noisy in some subspaces.",
        "We need a general method for finding an adequate space without enumerating and testing each of them."
      ]
    },
    {
      "heading": "3.4 Optimizing hierarchies",
      "text": [
        "Let us assume now that the sequence of indicators is fixed, and let n be its length.",
        "To find the best feature space among a very high number of possibilities, we need a criterion we can apply without too much additional computation.",
        "For that we only evaluate the feature space locally on pairs, i.e. without applying a decoder on the output.",
        "We employ 3 measures on pairwise classification results: precision, recall and F1-score.",
        "Now selecting the best space for one of these measures can be achieved by using dynamic programming techniques.",
        "In the rest of the paper, we will optimize the F1-score.",
        "Training the hierarchy Starting from the product-hierarchy, we associate a classifier and its proper feature space to each node of the tree5.",
        "The classifiers are then trained as follows: for each instance there is a unique path from the root to a leaf of the complete tree.",
        "Each classifier situated on the path is updated with this instance.",
        "The number of iterations of the Passive-Aggressive is fixed.",
        "Computing scores After training, we test all the classifiers on another set of pairs6.",
        "Again, a classifier is tested on an instance only if it is situated on the path from the root to the leaf associated with the instance.",
        "We obtain TP/FP/FN numbers7 on pair classifications that are sufficient to compute the F1-score.",
        "As for training, the data on which a classifier at a given node is evaluated is the same as the union of all data used to evaluate the classifiers corresponding to the children of this node.",
        "Thus we are able to compare the scores obtained at a node to the ?union of the scores?",
        "obtained at its children.",
        "Cutting down the hierarchy For the moment we have a complete tree with a classifier at each node.",
        "We use a dynamic programming technique to compute the best hierarchy by cutting this tree and only keeping classifiers situated at the leaf.",
        "The algorithm assembles the best local models (or feature spaces) together to create larger models.",
        "It goes from the leaves to the root and cuts the sub-tree starting at a node whenever it does not pro",
        "vide a better score than the node itself, or on the contrary propagates the score of the sub-tree when there is an improvement.",
        "The details are given in algorithm 1. list?",
        "list of nodes given by a breadth-first1 search for node in reversed list do if node.children 6= ?",
        "then2",
        "Let us briefly discuss the correctness and complexity of the algorithm.",
        "Each node is seen two times so the time complexity is linear in the number of nodes which is at least O(2n).",
        "However, only nodes that have encountered at least one training instance are useful and there are O(n ?",
        "k) such nodes (where k the size of the training set).",
        "So we can optimize the algorithm to run in time O(n ?",
        "k)8.",
        "If we scan the list obtained by breadth-first search backwards, we are ensured that every node will be processed after its children.",
        "(node.children) is the set of children of node, and (node.score) its score.",
        "sum-num provides TP/FP/FN by simply adding those of the children and sum-score computes the score based on these new TP/FP/FN numbers.",
        "(line 6) cuts the children of a node when they are not used in the best score.",
        "The algorithm thus propagates the best scores from the leaves to the root which finally gives a single score corresponding to the best hierarchy.",
        "Only the leaves used to compute the best score are kept, and they define the best hierarchy.",
        "Relation between cutting and the global feature space We can see the operation of cutting as replacing a group of subspaces by a single subspace in the sum (see figure 2).",
        "So cutting down the product-hierarchy amounts to reducing the global initial feature space in an optimal way.",
        "feature space To sum up, the whole procedure is equivalent to training more than O(2n) perceptrons simultaneously and selecting the best performing."
      ]
    },
    {
      "heading": "4 System description",
      "text": [
        "Our system consists in the pairwise model obtained by cutting a hierarchy (the PA with selected feature space) and using a greedy decoder to create clusters from the output.",
        "It is parametrized by the choice of the initial sequence of indicators."
      ]
    },
    {
      "heading": "4.1 The base features",
      "text": [
        "We used classical features that can be found in details in (Bengston and Roth, 2008) and (Rah-man and Ng, 2011): grammatical type and subtype of mentions, string match and substring, apposition and copula, distance (number of separating mentions/sentences/words), gender/number match, synonymy/hypernym and animacy (using WordNet), family name (based on lists), named entity types, syntactic features (gold parse) and anaphoricity detection."
      ]
    },
    {
      "heading": "4.2 Indicators",
      "text": [
        "As indicators we used: left and right grammatical types and subtypes, entity types, a boolean indicating if the mentions are in the same sentence, and a very coarse histogram of distance in terms of sentences.",
        "We systematically included right gramtype and left gramtype in the sequences and added other indicators, producing sequences of different lengths.",
        "The parameter was optimized by document categories using a development set after decoding the output of the pairwise model."
      ]
    },
    {
      "heading": "4.3 Decoders",
      "text": [
        "We tested 3 classical greedy link selection strategies that form clusters from the classifier decision: Closest-First (merge mentions with their closest coreferent mention on the left) (Soon et al., 2001),",
        "Best-first (merge mentions with the mention on the left having the highest positive score) (Ng and Cardie, 2002; Bengston and Roth, 2008), and Aggressive-Merge (transitive closure on positive pairs) (McCarthy and Lehnert, 1995).",
        "Each of these decoders is typically (although not always) used in tandem with a specific sampling selection at training.",
        "Thus, Closest-First for instance is used in combination with a sample selection that generates training instances only for the mentions that occur between the closest antecedent and the"
      ]
    },
    {
      "heading": "5 Experiments",
      "text": []
    },
    {
      "heading": "5.1 Data",
      "text": [
        "We evaluated the system on the English part of the corpus provided in the CoNLL-2012 Shared Task (Pradhan et al., 2012), referred to as CoNLL-2012 here.",
        "The corpus contains 7 categories of documents (over 2K documents, 1.3M words).",
        "We used the official train/dev/test data sets.",
        "We evaluated our system in the closed mode which requires that only provided data is used."
      ]
    },
    {
      "heading": "5.2 Settings",
      "text": [
        "Our baselines are a SINGLE MODEL, the GRAMTYPE model (section 2) and a RIGHT-TYPE model, defined as the first level of the gramtype product hierarchy (i.e. grammatical type of the anaphora (Morton, 2000)), with each greedy decoder and also the original sampling with a single model associated with those decoders.",
        "The hierarchies were trained with 10-fold cross-validation on the training set (the hierarchies are cut after cumulating the scores obtained by cross-validation) and their parameters are optimized by document category on the development set: the sequence of indicators obtaining the best average score after decoding was selected as parameter for the category.",
        "The obtained hierarchy is referred to as the BEST HIERARCHY in the results.",
        "We fixed the number of iterations for the PA for all models.",
        "In our experiments, we consider only the gold mentions.",
        "This is a rather idealized setting but our focus is on comparing various pairwise local models rather than on building a full coreference resolution system.",
        "Also, we wanted to avoid having to consider too many parameters in our experiments."
      ]
    },
    {
      "heading": "5.3 Evaluation metrics",
      "text": [
        "We use the three metrics that are most commonly used9, namely: MUC (Vilain et al., 1995) computes for each true entity cluster the number of system clusters that are needed to cover it.",
        "Precision is this quantity divided by the true cluster size minus one.",
        "Recall is obtained by reversing true and predicated clusters.",
        "F1 is the harmonic mean.",
        "B3 (Bagga and Baldwin, 1998) computes recall and precision scores for each mention, based on the intersection between the system/true clusters for that mention.",
        "Precision is the ratio of the intersection and the true cluster sizes, while recall is the ratio of the intersection to the system cluster sizes.",
        "Global recall, precision, and F1 scores are obtained by averaging over the mention scores.",
        "CEAF (Luo, 2005) scores are obtained by computing the best one-to-one mapping between the system/true partitions, which is equivalent to finding the best optimal alignment in the bipartite graph formed out of these partitions.",
        "We use the ?4 similarity function from (Luo, 2005).",
        "These metrics were recently used in the CoNLL2011 and -2012 Shared Tasks.",
        "In addition, these campaigns use an unweighted average over the F1 scores given by the three metrics.",
        "Following common practice, we use micro-averaging when reporting our scores for entire datasets."
      ]
    },
    {
      "heading": "5.4 Results",
      "text": [
        "The results obtained by the system are reported in table 2.",
        "The original sampling for the single model associated to Closest-First and Best-First decoder are referred to as SOON and NGCARDIE.",
        "The P/R/F1 pairwise scores before decoding are given in table 1.",
        "BEST HIERARCHY obtains a strong improvement in F1 (+15), a better precision and a less significant diminution of recall compared to GRAMTYPE and RIGHT-TYPE.",
        "9BLANC metric (Recasens and Hovy, 2011) results are not reported since they are not used to compute the CoNLL2012 global score.",
        "However we can mention that in our experiments, using hierarchies had a positive effect similar to what was observed on B3 and CEAF.",
        "Despite the use of greedy decoders, we observe a large positive effect of pair separation in the pairwise models on the outputs.",
        "On the mean score, the use of distinct models versus a single model yields F1 increases from 6.4 up to 8.3 depending on the decoder.",
        "Irrespective of the decoder being used, GRAMTYPE always outperforms RIGHT-TYPE and single model and is always outperformed by BEST HIERARCHY model.",
        "Interestingly, we see that the increment in pairwise and global score are not proportional: for instance, the strong improvement of F1 between RIGHT-TYPE and GRAMTYPE results in a small amelioration of the global score.",
        "Depending on the document category, we found some variations as to which hierarchy was learned in each setting, but we noticed that parameters starting with right and left gramtypes often produced quite good hierarchies: for instance right gramtype ?",
        "left gramtype ?",
        "same sentence ?",
        "right named entity type.",
        "We observed that product-hierarchies did not performed well without cutting (especially when using longer sequences of indicators, because of data sparsity) and could obtain scores lower than the single model.",
        "Hopefully, after cutting them the results always became better as the resulting hierarchy was more balanced.",
        "Looking at the different metrics, we notice that overall, pair separation improves B3 and CEAF (but not always MUC) after decoding the output: GRAMTYPE provides a better mean score than the single model, and BEST HIERARCHY gives the highest B3, CEAF and mean score.",
        "The best classifier-decoder combination reaches a score of 67.19, which would place it above the mean score (66.41) of the systems that took part in the CoNLL-2012 Shared Task (gold mentions track).",
        "Except for the first at 77.22, the best performing systems have a score around 68-69.",
        "Considering the simple decoding strategy we employed, our current system sets up a strong baseline."
      ]
    },
    {
      "heading": "6 Conclusion and perspectives",
      "text": [
        "In this paper, we described a method for selecting a feature space among a very large number of choices by using linearity and by combining indicators to separate the instances.",
        "We employed dynamic programming on hierarchies of indicators to compute the feature space providing the best pairwise classifications efficiently.",
        "We applied this",
        "method to optimize the pairwise model of a coreference resolution system.",
        "Using different kinds of greedy decoders, we showed a significant improvement of the system.",
        "Our approach is flexible in that we can use a variety of indicators.",
        "In the future we will apply the hierarchies on finer feature spaces to make more accurate optimizations.",
        "Observing that the general method of cutting down hierarchies is not restricted to modeling mention pairs, but can be applied to problems having Boolean aspects, we aim at employing hierarchies to address other tasks in computational linguistics (e.g. anaphoricity detection or discourse and temporal relation classification wherein position information may help separating the data).",
        "In this work, we have only considered standard, heuristic linking strategies like Closest-First.",
        "So, a natural extension of this work is to combine our method for learning pairwise models with more sophisticated decoding strategies (like Bestcut or using ILP).",
        "Then we can test the impact of hierarchies with more realistic settings.",
        "Finally, the method for cutting hierarchies should be compared to more general but similar methods, for instance polynomial kernels for SVM and tree-based methods (Hastie et al., 2001).",
        "We also plan to extend our method by breaking the symmetry of our hierarchies.",
        "Instead of cutting product-hierarchies, we will employ usual techniques to build decision trees10 and apply our cutting method on their structure.",
        "The objective is twofold: first, we will get rid of the sequence of indicators as parameter.",
        "Second, we will avoid fragmentation or overfitting (which can arise with classification trees) by deriving an optimal large margin linear model from the tree structure."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We thank the ACL 2013 anonymous reviewers for their valuable comments."
      ]
    }
  ]
}
