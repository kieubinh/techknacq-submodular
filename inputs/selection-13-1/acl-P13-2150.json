{
  "info": {
    "authors": [
      "Matt Post",
      "Shane Bergsma"
    ],
    "book": "ACL",
    "id": "acl-P13-2150",
    "title": "Explicit and Implicit Syntactic Features for Text Classification",
    "url": "https://aclweb.org/anthology/P13-2150",
    "year": 2013
  },
  "references": [
    "acl-C02-1150",
    "acl-D09-1012",
    "acl-D11-1148",
    "acl-E06-1015",
    "acl-E93-1006",
    "acl-J93-2004",
    "acl-N01-1031",
    "acl-N12-1033",
    "acl-P02-1034",
    "acl-P04-1016",
    "acl-P04-1043",
    "acl-P04-1054",
    "acl-P05-1022",
    "acl-P06-1006",
    "acl-P06-1055",
    "acl-P07-1010",
    "acl-P07-1098",
    "acl-P09-2012",
    "acl-P11-2038",
    "acl-P12-2038",
    "acl-W03-0402",
    "acl-W05-0904",
    "acl-W09-2112"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Syntactic features are useful for many text classification tasks.",
        "Among these, tree kernels (Collins and Duffy, 2001) have been perhaps the most robust and effective syntactic tool, appealing for their empirical success, but also because they do not require an answer to the difficult question of which tree features to use for a given task.",
        "We compare tree kernels to different explicit sets of tree features on five diverse tasks, and find that explicit features often perform as well as tree kernels on accuracy and always in orders of magnitude less time, and with smaller models.",
        "Since explicit features are easy to generate and use (with publicly available tools), we suggest they should always be included as baseline comparisons in tree kernel method evaluations."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Features computed over parse trees are useful for a range of discriminative tasks, including authorship attribution (Baayen et al., 1996), parse reranking (Collins and Duffy, 2002), language modeling (Cherry and Quirk, 2008), and native-language detection (Wong and Dras, 2011).",
        "A major distinction among these uses of syntax is how the features are represented.",
        "The implicit approach uses tree kernels (Collins and Duffy, 2001), which make predictions with inner products between tree pairs.",
        "These products can be computed efficiently with a dynamic program that produces weighted counts of all the shared tree fragments between a pair of trees, essentially incorporating all fragments without representing any of them explicitly.",
        "Tree kernel approaches have been applied successfully in many areas of NLP (Collins and Duffy, 2002; Moschitti, 2004; Pighin and Moschitti, 2009).",
        "Tree kernels were inspired in part by ideas from Data-Oriented Parsing (Scha, 1990; Bod, 1993), which was in turn motivated by uncertainty about which fragments to include in a grammar.",
        "However, manual and automatic approaches to inducing tree fragments have recently been found to be useful in an explicit approach to text classification, which employs specific tree fragments as features in standard classifiers (Post, 2011; Wong and Dras, 2011; Swanson and Charniak, 2012).",
        "These feature sets necessarily represent only a small subset of all possible tree patterns, leaving open the question of what further gains might be had from the unusued fragments.",
        "Somewhat surprisingly, explicit and implicit syntactic features have been explored largely independently.",
        "Here, we compare them on a range of classification tasks: (1,2) grammatical classification (is a sentence written by a human?",
        "), (3) question classification (what type of answer is sought by this question?",
        "), and (4,5) native language prediction (what is the native language of a text's author?).",
        "Our main contribution is to show that an explicit syntactic feature set performs as well or better than tree kernels on each tested task, and in orders of magnitude less time.",
        "Since explicit features are simple to generate (with publicly available tools) and flexible to use, we recommend they be included as baseline comparisons in tree kernel method evaluations."
      ]
    },
    {
      "heading": "2 Experimental setup",
      "text": [
        "We used the following feature sets:",
        "CFG rules Counts of depth-one context-free grammar (CFG) productions obtained from the Berkeley parser (Petrov et al., 2006).",
        "C&J features The parse-tree reranking feature set of Charniak and Johnson (2005), extracted from the Berkeley parse trees.",
        "TSG features We also parsed with a Bayesian tree substitution grammar (Post and Gildea, 2009, TSG)2 and extracted fragment counts from Viterbi derivations.",
        "We build classifiers with Liblinear3 (Fan et al., 2008).",
        "We divided each dataset into training, dev, and test sets.",
        "We then trained an L2-regularized L1-loss support vector machine (-s 3) with a bias parameter of 1 (-B 1), optimizing the regularization parameter (-c) on the dev set over the range {0.0001 .",
        ".",
        ".",
        "100} by multiples of 10.",
        "The best model was then used to classify the test set.",
        "A sentence length feature was included for every sentence.",
        "For tree kernels, we used SVM-light-TK4 (Moschitti, 2004; Moschitti, 2006) with the default settings (-t 5 D 1 L 0.4),5 which also solves an L2-regularized L1-loss SVM optimization problem.",
        "We tuned the regularization parameter (-c) on the dev set in the same manner as described above, providing 4 GB of memory to the kernel cache (-m 4000).6 We used subset tree kernels, which compute the similarity between two trees by implicitly enumerating all possible fragments of the trees (in contrast with subtree kernels, where all fragments fully extend to the leaves)."
      ]
    },
    {
      "heading": "3 Tasks",
      "text": [
        "Table 1 summarizes our datasets."
      ]
    },
    {
      "heading": "3.1 Coarse grammatical classification",
      "text": [
        "Our first comparison is coarse grammatical classification, where the goal is to distinguish between human-written sentences and ?pseudo-negative?",
        "sentences sampled from a trigram language model constructed from in-provement.",
        "for classifier setup, training, and testing.",
        "domain data (Okanohara and Tsujii, 2007).",
        "Cherry and Quirk (2008) first applied syntax to this task, learning weighted parameters for a CFG with a latent SVM.",
        "Post (2011) found further improvements with fragment-based representations (TSGs and C&J) with a regular SVM.",
        "Here, we compare their results to kernel methods.",
        "We repeat Post's experiments on the BLLIP dataset,7 using his exact data splits (Table 2).",
        "To our knowledge, tree kernels have not been applied to this task."
      ]
    },
    {
      "heading": "3.2 Fine grammatical classification",
      "text": [
        "Real-world grammaticality judgments require much finer-grained distinctions than the coarse ones of the previous section (for example, marking dropped determiners or wrong verb inflections).",
        "For this task, we too positive examples from all sentences of sections 2?21 of the WSJ portion of the Penn Treebank (Marcus et al., 1993).",
        "Negative examples were created by inserting one or two errors",
        "into the parse trees from the positive data using GenERRate (Foster and Andersen, 2009).",
        "An example sentence pair is But the ballplayers disagree[ing], where the negative example incorrectly inflects the verb.",
        "Wong and Dras (2010) reported good results with parsers trained separately on the positive and negative sides of the training data and classifiers built from comparisons between the CFG productions of those parsers.",
        "We obtained their data splits (described as NoisyWSJ in their paper) and repeat their experiments here (Table 3)."
      ]
    },
    {
      "heading": "3.3 Question Classification",
      "text": [
        "We look next at question classification (QC).",
        "Li and Roth (2002) introduced the TREC-10 dataset,8 a set of questions paired with labels that categorize the question by the type of answer it seeks.",
        "The labels are organized hierarchically into six (coarse) top-level labels and fifty (fine) refinements.",
        "An example question from the ENTY/animal category is What was the first domesticated bird?.",
        "Table 4 contains results predicting just the coarse labels.",
        "We compare to Pighin and Moschitti (2009), and also repeat their experiments, finding a slightly better result for them.",
        "8cogcomp.cs.illinois.edu/Data/QA/QC/ system sent.",
        "voting whole",
        "and ACL (five, bottom) datasets at the sentence and document levels.",
        "All documents were signature-stylized (?3.4).",
        "We also experimented with the refined version of the task, where we directly predict one of the fifty refined categories, and found nearly identical relative results, with the best explicit feature set (CFG) returning an accuracy of 83.6% (in seconds), and the tree kernel system 69.8% (in an hour).",
        "For reference, Zhang and Lee (2003) report 80.2% accuracy when training on the full training set (5,500 examples) with an SVM and bag-of-words features.9"
      ]
    },
    {
      "heading": "3.4 Native language identification",
      "text": [
        "Native language identification (NLI) is the task of determining a text's author's native language.",
        "This is usually cast as a document-level task, since there are often not enough cues to identify native languages at smaller granularities.",
        "As such, this task presents a challenge to tree kernels, which are defined at the level of a single parse tree and have no obvious document-level extension.",
        "Table 5 therefore presents three evaluations: (a) sentence-level accuracy, and document-level accuracy from (b) sentence-level voting and (c) direct, whole-document classification.",
        "We perform these experiments on two datasets.",
        "In order to mitigate topic bias10 and other problems that have been reported with",
        "the ICLE dataset (Tetreault et al., 2012),11 we preprocessed each dataset into two signature-stylized versions by replacing all words not in a stopword list.12 The first version replaces non-stopwords with word classes computed from surface-form signatures,13 and the second with POS tags.14 N-gram features are then taken from both stylized versions of the corpus.",
        "Restricting the feature representation to be topic-independent is standard-practice in sty-lometric tasks like authorship attribution, gender identification, and native-language identification (Mosteller and Wallace, 1984; Koppel et al., 2003; Tomokiyo and Jones, 2001).",
        "The first dataset is a seven-language subset of the International Corpus of Learner English, Version 2 (ICLE) (Granger et al., 2009), which contains 3.7 million words of English documents written by people with sixteen different native languages.",
        "Table 1 contains scores, including one reported by Wong and Dras (2011), who used the CFG and C&J features, and whose data splits we mirror.15",
        "We also experimented with native language classification on scientific documents using a version of the ACL Anthology Network (Radev et al., 2009, AAN) annotated for experiments in stylemetric tasks, including a native/non-native author judgment (Bergsma et al., 2012).",
        "For NLI, we further annotated this dataset in a semi-automatic fashion for the five most-common native languages of ACL authors in our training era: English, Japanese, German, Chinese, and French.",
        "The annotation heuristics, designed to favor pre",
        "test accuracy for coarse grammaticality, plotting test scores from models trained on 100, 300, 1k, 3k, 10k, 30k, and 100k instances."
      ]
    },
    {
      "heading": "4 Discussion",
      "text": [
        "Syntactic features improve upon the n-gram baseline for all tasks except whole-document classification for ICLE.",
        "Tree kernels are often among the best, but always trail (by orders of magnitude) when runtime is considered.",
        "Constructing the multi-class SVM-TK models for the NLI tasks in particular was computationally burdensome, requiring cpu-months of time.",
        "The C&J features are similarly often the best, but incur a runtime cost due to the large models.",
        "CFG and TSG features balance performance, model size, and runtime.",
        "We now compare these approaches in more depth."
      ]
    },
    {
      "heading": "4.1 Training time versus accuracy",
      "text": [
        "Tree kernel training is quadratic in the size of the training data, and its empirical slowness is known.",
        "It is informative to examine learning curves to see how the time-accuracy trade-offs extrapolate.",
        "We compared models trained on the first 100, 300, 1k, 3k, 10k, 30k, and 100k data points of the coarse grammaticality dataset, split evenly between positive and negative examples (Figure 1).",
        "SVM-TK improves over the TSG and CFG models in the limit, but at an extraordinary cost in training time: 100k training examples is already pushing the bounds of practicality for tree kernel learning, and generating curve's next point would require several months of time.",
        "Kernel methods also produce large models that result in slow test-time performance, a problem dubbed the ?curse of kernelization?",
        "(Wang et al., 2010).",
        "Approximate kernel methods designed to scale to large datasets address this (Severyn",
        "and Moschitti, 2010).",
        "We investigated the uSVM-TK toolkit,17 which enables tuning the tradeoff between training time and accuracy.",
        "While faster than SVM-TK, its performance was never better than explicit methods along both dimensions (time and accuracy)."
      ]
    },
    {
      "heading": "4.2 Overfitting",
      "text": [
        "Overfitting is also a problem for kernel methods.",
        "The best models often had a huge number of support vectors, achieving near-perfect accuracy on the training set but making many errors on the dev.",
        "and test sets.",
        "On the ICLE task, close to 75% of all the training examples were used as support vectors.",
        "We found only half as many support vectors used for the explicit representations, implying less error (Vapnik, 1998), and saw much lower variance between training and testing performance."
      ]
    },
    {
      "heading": "4.3 Which fragments?",
      "text": [
        "Our findings support the observations of Cumby and Roth (2003), who point out that kernels introduce a large number of irrelevant features that may be especially harmful in small-data settings, and that, when possible, it is often better to have a set of explicit, relevant features.",
        "In other words, it is better to have the right features than all of them.",
        "Tree kernels provide a robust, efficiently-computable measure of comparison, but they also skirt the difficult question, Which fragments?",
        "So what are the ?right?",
        "features?",
        "Table 6) presents an intuitive list from the coarse grammaticality task: phenomena such as balanced parenthetical phrases and quotations are associated with grammaticality, while small, flat, abstract rules indicate samples from the n-gram model.",
        "Similar intuitive results hold for the other tasks.",
        "The immediate interpretabil-ity of the explicit formalisms is another advantage, although recent work has shown that weights on the implicit features can also be obtained after a kind of linearization of the tree kernel (Pighin and Moschitti, 2009).",
        "Ultimately, which features matter is task-dependent, and skirting the question is advantageous in many settings.",
        "But it is also encouraging that methods for selecting fragments and other tree features work so well,",
        "TSG features (coarse grammaticality).",
        "yielding quick, lightweight models that contrast with the heavy machinery of tree kernels."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "Tree kernels provide a robust measure of comparison between trees, effectively making use of all fragments.",
        "We have shown that for some tasks, it is sufficient (and advantageous) to instead use an explicitly-represented subset of them.",
        "In addition to their flexibility and interpetability, explicit syntactic features often outperformed tree kernels in accuracy, and even where they did not, the cost was multiple orders of magnitude increase in both training and testing time.",
        "These results were consistent across a range of task types, dataset sizes, and classification arities (binary and multiclass).",
        "There are a number of important caveats.",
        "We explored a range of data settings, but there are many others where tree kernels have been proven useful, such as parse tree reranking (Collins and Duffy, 2002; Shen and Joshi, 2003), sentence subjectivity (Suzuki et al., 2004), pronoun resolution (Yang et al., 2006), relation extraction (Culotta and Sorensen, 2004), machine translation evaluation (Liu and Gildea, 2005), predicate-argument recognition, and semantic role labeling (Pighin and Moschitti, 2009).",
        "There are also tree kernel variations such as dependency tree kernels (Culotta and Sorensen, 2004) and shallow semantic tree kernels (Moschitti et al., 2007).",
        "These variables provide a rich environment for future work; in the meantime, we take these results as compelling motivation for the continued development of explicit syntactic features (both manual and automatically induced), and suggest that such features should be part of the baseline systems on applicable discriminative NLP tasks."
      ]
    }
  ]
}
