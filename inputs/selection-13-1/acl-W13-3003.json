{
  "info": {
    "authors": [
      "Martin Berglund",
      "Henrik Bj√∂rklund",
      "Frank Drewes"
    ],
    "book": "MoL",
    "id": "acl-W13-3003",
    "title": "On the Parameterized Complexity of Linear Context-Free Rewriting Systems",
    "url": "https://aclweb.org/anthology/W13-3003",
    "year": 2013
  },
  "references": [
    "acl-N10-1035",
    "acl-P10-1054",
    "acl-P87-1015",
    "acl-P92-1012",
    "acl-W05-1502"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We study the complexity of uniform membership for Linear Context-Free Rewriting Systems, i.e., the problem where we are given a string w and a grammar G and are asked whether w ?",
        "L(G).",
        "In particular, we use parameterized complexity theory to investigate how the complexity depends on various parameters.",
        "While we focus primarily on rank and fan-out, derivation length is also considered."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": []
    },
    {
      "heading": "Linear Context-Free Rewriting Systems (LCFRS)",
      "text": [
        "were introduced by Vijay-Shanker et al. (1987) with the purpose of capturing the syntax of natural language.1 It is one of several suggested ways of capturing Joshi's concept of mildly context-sensitive languages (Joshi, 1985).",
        "As such, it strengthens the expressive power of context-free grammars, while avoiding the full computational complexity of context-sensitive grammars.",
        "One of the defining features of mildly context-sensitive languages is that they should be decidable in polynomial time.",
        "This is indeed true for every language that can be generated by an LCFRS.",
        "Unlike the case for context-free grammars, however, the universal or uniform membership problem for LCFRSs, where both the grammar and the string in question are considered as input, is known to be PSPACE-complete (Kaji et al., 1992), making a polynomial time solution very improbable.",
        "The best known algorithms for the problem have a running time of O(|G |?",
        "|w|f ?",
        "(r+1)), where G is the grammar, w is the string, f is the fanout and r is the rank of the grammar (Seki et al., 1991; Burden and Ljunglo?f, 2005; Boullier, 2004).",
        "(For 1Seki et al. (1991) independently suggested the nearly identical Multiple Context-Free Grammars.",
        "a definition of fanout and rank, see Section 2.)",
        "Unlike the rank of a context-free grammar, the fanout and rank of an LCFRS cannot in general be reduced to some fixed constant.",
        "Increasing the fanout always gives more generative power, as does increasing the rank while keeping the fanout fixed (Satta, 1998).",
        "The rank can be reduced to two, but at the price of an exponential increase in the fanout.",
        "Research into algorithms for LCFRS parsing that are efficient enough for practical use is quite active.",
        "For example, algorithms for restricted cases are being studied, e.g., by Go?mez-Rodr?",
        "?guez et al. (2010), as well as rank reduction, primarily in special cases, where the fanout is not affected; see, e.g., Sagot and Satta (2010).",
        "This article is a first step towards a finer computational complexity analysis of the membership problem for LCFRSs.",
        "Specifically it asks the question ?could there exist an algorithm for the uniform LCFRS membership problem whose running time is a fixed polynomial in |w |times an arbitrary function in f and r??",
        "By employing parameterized complexity theory, we show that such an algorithm is very unlikely to be found.",
        "Fixing the rank of the grammar to one, the membership problem, parameterized by the fan-out, is W[SAT]-hard.",
        "Fixing the fanout to two and taking the rank as the parameter, the problem is W[1]-hard.",
        "Finally, if the fan-out, rank, and derivation length are included in the parameter, the problem is W[1]-complete.",
        "These results help guide future work, suggesting other types of parameters and grammar restrictions that may yield more favor-able complexity results."
      ]
    },
    {
      "heading": "2 Preliminaries",
      "text": [
        "For n ?",
        "N, we write [n] for {1, .",
        ".",
        ".",
        ", n} and [n]0 for {0} ?",
        "[n].",
        "Given an alphabet ?",
        "we write ??",
        "for all strings over ?",
        "and ?+ for all non-empty strings.",
        "The empty string is denoted by ?."
      ]
    },
    {
      "heading": "2.1 Linear context-free rewriting systems",
      "text": [
        "Let ?",
        "be an alphabet, x1, .",
        ".",
        ".",
        ", xn variables, and w1, .",
        ".",
        ".",
        ", wk strings over ?",
        "such that w1 ?",
        "?",
        "?wk = ?0 ?",
        "xpi(1) ?",
        "?1 ?",
        "?",
        "?xpi(n) ?",
        "?n for some permutation pi and some strings ?0, .",
        ".",
        ".",
        ", ?n ?",
        "??.",
        "Then define f as a function over tuples of strings such that f((x1, .",
        ".",
        ".",
        "), .",
        ".",
        ".",
        ", (.",
        ".",
        ".",
        ", xn)) = (w1, .",
        ".",
        ".",
        ", wk).",
        "A function is linear regular if and only if it can be described in this way.",
        "For example",
        "System is a tupleG = (N,?, F,R, S), whereN is an alphabet of nonterminals, where each A ?",
        "N has an associated fanout #(A); S ?",
        "N is the initial nonterminal with #(S) = 1; ?",
        "is an alphabet of terminals; F is a set of linear regular functions; and R is a set of rules of the form A ?",
        "g(B1, .",
        ".",
        ".",
        ", Bn), where A,B1, .",
        ".",
        ".",
        ", Bn ?",
        "N and g is a function in F of type",
        "The rank of a rule is the number of nonterminals on the right-hand side.",
        "The rank of G is the maximal rank of any rule in R. The fanout of G is the maximal fanout of any nonterminal in N .",
        "The language generated by a nonterminal A is a set of n-tuples, where n = #(A).",
        "Definition 2.2.",
        "Let G = (N,?, F,R, S) be a linear context-free rewriting system.",
        "Let LA ?",
        "(??",
        ")#(A) denote the tuples that a nonterminal A ?",
        "N can generate.",
        "This is the smallest set such that if A ?",
        "f(B1, .",
        ".",
        ".",
        ", Bn) is in R then, for all bi ?",
        "LBi where i ?",
        "[n], f(b1, .",
        ".",
        ".",
        ", bn) ?",
        "LA.",
        "The language of G is L(G) = LS .",
        "For i ?",
        "N, we write i-LCFRS for the class of all LCFRSs of rank at most i and LCFRS(i) for the class of all LCFRSs of fanout at most i.",
        "We also write i-LCFRS(j) for i-LCFRS?LCFRS(j)."
      ]
    },
    {
      "heading": "2.2 Parameterized complexity theory",
      "text": [
        "We only reproduce the most central definitions of parameterized complexity theory.",
        "For a more thorough treatment, we refer the reader to (Downey and Fellows, 1999; Flum and Grohe, 2006).",
        "A parameterized problem is a language L ?",
        "??",
        "?",
        "N, where ?",
        "is a finite alphabet.",
        "The second component is called the parameter.",
        "An algorithm for L is fixed-parameter tractable if there is a computable function f and a polynomial p such that for every (x, k) ?",
        "??",
        "?N, the algorithm decides in time f(k) ?",
        "p(|x|) whether (x, k) ?",
        "L. The problem of deciding L is fixed-parameter tractable if there is such an algorithm.",
        "If so, L belongs to the class FPT.",
        "A parameterized problem L ?",
        "??",
        "?",
        "N is fpt-reducible to another parameterized prob",
        "lem K ?",
        "??",
        "?",
        "N if there is a mapping R : ??",
        "?",
        "N?",
        "??",
        "?",
        "N such that 1. for all (x, k) ?",
        "??",
        "?",
        "N, we have (x, k) ?",
        "L if and only if R(x, k) ?",
        "K, 2. there is a computable function f and a polynomial p such that R(x, k) can be computed in time f(k) ?",
        "p(|x|), and 3. there is a computable function g such that for every (x, k) ?",
        "??",
        "?",
        "N, if R(x, k) = (y, k?",
        "), then k?",
        "?",
        "g(k).",
        "Note that several parameters may be combined into one by taking their maximum (or sum).",
        "The most commonly used hierarchy of parameterized complexity classes is the following.",
        "The classes W[1],.",
        ".",
        ".",
        ",W[P] are defined using circuits or, alternatively, logic.",
        "None of the inclusions is known to be strict, except that FPT is a strict subclass of XP.",
        "It is widely believed, however, that each of them is strict.",
        "The class XP is the class of all parameterized problems for which there is a computable function f such that every instance (x, k) can be decided in time |x|f(k)."
      ]
    },
    {
      "heading": "2.3 Problems of interest",
      "text": [
        "We know from Kaji et al. (1992) that the universal membership problem for 1-LCFRSs is PSPACE-complete.",
        "Satta (1992) has further shown that LCFRS(2)-MEMBERSHIP is NP-hard.",
        "We study the following decision problems, where the symbol P is used to indicate what the parameter is: ?",
        "P-LCFRS(j)-MEMBERSHIP, where j ?",
        "N is the membership problem for LCFRS(j), parameterized by the rank.",
        "?",
        "i-LCFRS(P)-MEMBERSHIP, where i ?",
        "N is the membership problem for i-LCFRS, parameterized by the fan-out.",
        "?",
        "P-LCFRS(P)-MEMBERSHIP is the membership problem for LCFRS parameterized by the rank and the fan-out.",
        "?",
        "SHORT P-LCFRS(P)-DERIVATION is the",
        "membership problem for LCFRS parameterized by the rank, the fan-out, and the derivation length.",
        "Since there are algorithms that solve the membership problem for LCFRSs with rank r and fanout t and string w in time |w|(r+1)t (see, e.g., (Seki et al., 1991; Burden and Ljunglo?f, 2005; Boullier, 2004)), we can immediately conclude that P-LCFRS(P)-MEMBERSHIP, as well as every other parameterized membership problem mentioned above, belongs to XP."
      ]
    },
    {
      "heading": "3 Fixed rank grammars",
      "text": [
        "The following theorem establishes a lower bound for 1-LCFRSs parameterized by the fan-out.",
        "Theorem 3.1.",
        "1-LCFRS(P)-MEMBERSHIP is W[SAT]-hard.",
        "The proof of Theorem 3.1 is by reduction from WEIGHTED MONOTONE SATISFIABILITY.",
        "Before we get into the actual proof, we discuss some properties of this problem.",
        "Definition 3.1.",
        "A monotone Boolean formula is a Boolean formula that contains only conjunctions, disjunctions, and variables.",
        "In particular, there are no negations.",
        "An instance of WEIGHTED MONOTONE SATISFIABILITY is a pair (?, k), where ?",
        "is a monotone Boolean formula and k ?",
        "N. The question is whether ?",
        "has a satisfying assignment of weight k, i.e., an assignment that sets exactly k of the variables that occur in ?",
        "to true.",
        "The parameter is k. WEIGHTED MONOTONE SATISFIABILITY is W[SAT]-complete (Abrahamson et al., 1993; Abrahamson et al., 1995; Downey and Fellows, 1999).",
        "We can view a monotone Boolean formula ?",
        "as an unranked tree, where the root node corresponds to the top level clause and the leaves correspond to bottom level clauses, i.e., variable occurrences.",
        "The set pos(?)",
        "of positions of ?",
        "is defined as usual, consisting of strings of natural numbers that indicate how to navigate to the clauses in a tree representation of ?.",
        "We denote each subclause of ?",
        "by Cs, where s ?",
        "pos(?)",
        "is its position.",
        "Thus",
        "tion.",
        "Conjunctive clauses are round and disjunctive rectangular.",
        "For example, C111 is the leftmost occurrence of x1 and C13 the clause (x3 ?",
        "x4).",
        "C?",
        "denotes the whole of ?, while, e.g., Cijl is the lth clause of the jth clause of the ith clause of ?.",
        "See Figure 1 for an example.",
        "We use C for the set of all clauses of ?",
        "and C?, C?, and CVar for the sets of conjunctive, disjunctive, and bottom level clauses, respectively.",
        "For all c ?",
        "CVar let Var(c) denote the variable in c, and let Var(?)",
        "denote the set of all variables in ?.",
        "Given a monotone Boolean formula ?",
        "and a variable assignment ?",
        ": Var(?)",
        "?",
        "B, we define a verification tour for ?",
        "and ?.",
        "Such a tour moves through the tree representation of ?, starting at the root node, and verifies that ?",
        "satisfies ?.",
        "To this end, we first define the function Next : pos(?)",
        "?",
        "pos(?)",
        "?",
        "{True} as follows.",
        "For the root clause let Next(?)",
        "= True .",
        "For all si ?",
        "pos(?",
        "), where s ?",
        "N?",
        "and i ?",
        "N, if Cs ?",
        "C?",
        "A verification tour over ?, given a variable assignment ?",
        "is constructed by the following procedure.",
        "Set the initial position p = ?, then",
        "?",
        "If Cp ?",
        "C?",
        "set p ?",
        "p1 (i.e., go to the first subclause).",
        "?",
        "If Cp ?",
        "C?",
        "set p ?",
        "pi for any i (i.e. non-deterministically pick a subclause).",
        "?",
        "IfCp ?",
        "CVar verify that ?",
        "(Var(Cp)) = true .",
        "If so, set p ?",
        "Next(p) and repeat.",
        "Otherwise, the verification tour fails.",
        "A verification tour succeeds if it reaches True .",
        "The following lemma can be proved by straightforward induction on the structure of ?.",
        "Lemma 3.2.",
        "If a verification tour for ?",
        "and variable assignment ?",
        "succeeds, then ?",
        "satisfies ?.",
        "We are now ready to prove Theorem 3.1.",
        "Proof of Theorem 3.1.",
        "Let (?, k) be an instance of WEIGHTED MONOTONE SATISFIABILITY.",
        "Let {x1, .",
        ".",
        ".",
        ", xn} be the variables that appear in ?.",
        "In particular, n is the number of distinct variables.",
        "Let m be the number of bottom level clauses.",
        "Intuitively, the LCFRS we will construct will guess a weight k variable assignment ?",
        "and then simulate a verification tour for ?",
        "and ?.",
        "Basically, we will use one nonterminal per clause and use the structure of the grammar to simulate a verification tour.",
        "In order to verify that the necessary bottom level clauses can all be satisfied through the same k true variables, we will use the input string to be parsed.",
        "The string w will consist of bracketed sequences of m copies of each of the n variables, i.e., w = [xm1 ] ?",
        "?",
        "?",
        "[x m n ].",
        "To understand the construction of the grammar, please keep in mind that the only derivations that matter are those generating this particular input string.",
        "The grammar will guess which k variables should be set to true and disregard the other variables.",
        "Technically, this is done by first letting a nonterminal F generate a tuple of k + 1 strings s0, .",
        ".",
        ".",
        ", sk such that each si consists of zero or more of the bracketed sequences of variables to be disregarded.",
        "The rest of the grammar generates exactly k bracketed sequences that will be interleaved with s0, .",
        ".",
        ".",
        ", sk.",
        "During the generation of these k bracketed sequences it is nondeterministi-cally verified that the corresponding truth assignment satisfies ?.",
        "We use the following set of nonterminals: {S, F} ?",
        "{Cs |s ?",
        "pos(?)",
        "?",
        "{True}} For S, there is only one rule: S ?",
        "fS(F ).",
        "The function fS places brackets around the k variables that are guessed to be true, represented by the strings t1, .",
        ".",
        ".",
        ", tk, and interleaves them with the remaining variables, represented by the strings s0, .",
        ".",
        ".",
        ", sk: fS(s0, .",
        ".",
        ".",
        ", sk, t1, .",
        ".",
        ".",
        ", tk) = (s0[t1]s1 ?",
        "?",
        "?",
        "[tk]sk) The nonterminal F has rules F ?",
        "fF,i,j(F ) for all i ?",
        "[n] and j ?",
        "[k]0.",
        "These rules produce the bracketed sequences of copies of the variables xi to be disregarded, as can be seen from the corresponding function:",
        "The rules for the nonterminals that represent clauses differ according to the type of the clause, i.e., if the nonterminal represents a conjunctive clause, a disjunctive clause, or a variable.",
        "For each conjunctive clause Cs there is exactly one rule, representing a move to its first subclause.",
        "Here, fid is the identity function.",
        "Cs ?",
        "fid (Cs1) For every disjunctive clause Cs and every i such that Csi is a subclause of Cs there is one rule.",
        "Cs ?",
        "fid (Csi) For every bottom level clause, i.e., Cs ?",
        "CVar , every i ?",
        "[k] and every j ?",
        "[m] there is one rule.",
        "Cs ?",
        "fs,i,j(CNext(s)) Intuitively, such a rule corresponds to producing j copies of the variable of clause Cs in component i of the tuple and moving on to the next clause that should be visited in a verification tour.",
        "This can be seen from the corresponding function.",
        "fs,i,j(t1, .",
        ".",
        ".",
        ", tk) = (t1, .",
        ".",
        ".",
        ",Var(Cs) jti, .",
        ".",
        ".",
        ", tk) The reason that the function produces j copies of the variable, rather than just one, is that it is unknown beforehand how many times a bottom level clause that represents that particular variable will be visited.",
        "Thus the number of copies to be produced has to be guessed nondeterministically in order to make sure that a total of m copies of each variable set to true are eventually produced.",
        "If there is a weight k satisfying assignment, there will also be a verification tour that eventually reaches True when Next is called (by Lemma 3.2).",
        "The single rule forCTrue simply produces a k-tuple of empty strings.",
        "The reduction is polynomial and the fanout of the resulting grammar is 2k+1.",
        "Thus it is an FPT-reduction.",
        "It remains to argue that the grammar can produce w if and only if ?",
        "has a satisfying assignment of weight k. We first note that whatever tuple is derived from F , the first k + 1 entries in the tuple consist of bracketed sequences of the form [xml ].",
        "If the grammar can produce w, it follows that the tuple (t1, .",
        ".",
        ".",
        ", tk) produced from C?",
        "must be such that each ti equalsm copies of the same variable name.",
        "Any successful derivation of a string by the grammar corresponds to a verification tour of ?",
        "and the variable assignment that sets the variables that appear in (t1, .",
        ".",
        ".",
        ", tk) to true and all other variables to false.",
        "Thus ?",
        "has a satisfying assignment of weight k. For the other direction, assume that ?",
        "has a satisfying assignment of weight k. Then the grammar can guess this assignment and a corresponding successful verification tour, thus producingw.",
        "Note that Theorem 3.1 can easily be strengthened to grammars with a binary terminal alphabet.",
        "It is enough to represent each variable name by a bitstring of length dlog2(m)e in the above reduction.",
        "We also note that Theorem 3.1 immediately implies that P-LCFRS(P)-MEMBERSHIP is W[SAT]-hard."
      ]
    },
    {
      "heading": "4 Fixed fanout grammars",
      "text": [
        "We next turn to the case where the fanout is fixed to two, while the rank is treated as a parameter.",
        "Theorem 4.1.",
        "P-LCFRS(2)-MEMBERSHIP is W[1]-hard.",
        "Proof.",
        "We reduce from k-CLIQUE, the problem of deciding whether a given graph has a clique of size k, with k as the parameter.",
        "This problem is known to be W[1]-complete (Flum and Grohe, 2006).",
        "Let G = (V,E) be an undirected graph.",
        "We assume, without loss of generality, that V = {1, .",
        ".",
        ".",
        ", n} and that an edge connecting nodes i, j ?",
        "V is represented as the ordered pair (i, j) such that i < j, i.e., E ?",
        "{(i, j) ?",
        "V ?",
        "V |i < j}.",
        "To find out whether G has a clique of size k we construct an instance of the membership problem for LCFRSs.",
        "The input alphabet is ?",
        "= {0, 1}.",
        "Construct the input string as",
        "The nonterminals are N = {A,E,C, S}, with S being the initial nonterminal.",
        "The rules are the following.",
        "Then the unique rule for S is:",
        "Now we need to define f .",
        "Consider the following",
        "The substrings ?1 through ?k are left to be defined, and will contain all the c?",
        "and d?",
        "arguments in a careful configuration derived from the structure of a clique.",
        "Let (pi1, pi?1), .",
        ".",
        ".",
        ", (pi?, pi ?",
        "?)",
        "be the lexicographically sorted sequence of edges in a k-clique with nodes numbered 1 through k. For example, (pi1, pi?1) = (1, 2), (pi2, pi",
        "Then, for each l, find the longest subsequences",
        "This construction is simpler than it may at first appear.",
        "Basically, the clique is found by generating k(k?",
        "1)/2 copies of E, each of which will be placed so that it has no choice but to generate an edge in a k-clique.",
        "Looking at the first part of the string, each 1cleldl1 must generate a string of the form 10n10n1: el will generate some 0n?i10n?j , were (i, j) is an edge in G, which forces cl to generate 0i and dl to generate 0j .",
        "The trick is that cl and dl yield the first string in a pair generated by an instance of C. The other string in the pair describes the same number as the first, but in such a way that it can be carefully placed in the latter part of the derivation string, thus forcing other instances of the C nonterminal to pick the same",
        "node (number of zeros) to generate.",
        "These are then placed in such a way that the edges picked by the instances of E all belong to the same clique.",
        "For example, for k = 3 the result of f will be c1e1d11c2e2d21c3e3d31a1c1c2a21c3d11d2d3, where the latter part ensures that c1 and c2 have to pick the same node (lowest-numbered node in the clique), as do c3 and d1, and d2 and d3."
      ]
    },
    {
      "heading": "5 Short derivations",
      "text": [
        "In this section, we consider the length of derivations as an additional parameter.",
        "As usual, the length of a derivation is the number of derivation steps it consists of.",
        "(In a derivation of an LCFRS (N,?, F,R, S), this is the same as the number of applications of functions in F .)",
        "Let G = (N,?, F,R, S) be an LCFRS in the following.",
        "Consider the following problem: Definition 5.1.",
        "An instance of the SHORT P-LCFRS(P) DERIVATION problem consists of a LCFRS G, some w ?",
        "??",
        "and a constant d ?",
        "N. The question asked is: can w be derived by G in at most d steps?",
        "The parameter is k = d + r + f where r is the maximum rank and f the maximum fanout.",
        "Lemma 5.1.",
        "SHORT P-LCFRS(P) DERIVATION is W[1]-hard.",
        "Proof.",
        "The W[1]-hardness of the problem follows immediately from the reduction in the proof of Theorem 4.1, since k-Clique is reduced to an instance of LCFRS membership with O(k2) derivation steps, rank O(k2), and fixed fan-out.",
        "We next demonstrate that SHORT P-LCFRS(P) DERIVATION is in W[1] (and is therefore W[1]-complete) by reducing to SHORT CONTEXT-SENSITIVE DERIVATION, shown to be W[1]-complete by Downey et al. (1994).",
        "Let H = (NH ,?H , RH , SH) be an arbitrary context-sensitive grammar in the following.",
        "A context-sensitive grammar has nonterminals, terminals and a starting nonterminal just like a LCFRS, but the rules are of the form ?",
        "?",
        "?",
        "for strings ?, ?",
        "?",
        "(?H ?NH)?",
        "where 0 < |?",
        "|?",
        "|?|.",
        "A derivation starts with the string SH .",
        "A string w ?",
        "?",
        "?",
        "w?",
        "can be turned into w ?",
        "?",
        "?",
        "w?",
        "in one derivation step if (?, ?)",
        "?",
        "RH .",
        "Definition 5.2.",
        "An instance of the SHORT"
      ]
    },
    {
      "heading": "CONTEXT-SENSITIVE DERIVATION problem",
      "text": [
        "consists of a context-sensitive grammar H , a string w ?",
        "?",
        "?H , and a constant dH ?",
        "N. The question is: can w be derived by H in at most dH steps?",
        "The parameter is dH .",
        "We are now ready to prove membership in W[1] by a FPT-reduction from (G,w, d) to (H,w, dH).",
        "Lemma 5.2.",
        "The SHORT P-LCFRS(P) DERIVATION problem is in W[1].",
        "Proof.",
        "We can restrict ourselves to the case where no nonterminal appears twice in a right-hand side of any rule in G. This is because, e.g., a rule of the form A ?",
        "f(B,B) can be turned into A ?",
        "f(B,B?",
        "), using a fresh copy B?",
        "of B that has the same rules asB (except for having the left-hand side B?",
        "rather than B).",
        "Note that this modification does not affect the parameter, and increases the size of the grammar only polynomially.",
        "The complete reduction is somewhat lengthy, but the core intuition is very simple.",
        "The string is kept the same, and a context-sensitive grammar H is constructed such that L(H) = L(G).",
        "H simulates G by maintaining a string serialization of the current ?configuration?",
        "of G, walking through the whole string rewriting the appropriate non-terminal for every rule application in G. A configuration of G can be viewed in this way, aa ?",
        "b ?",
        "?",
        "?",
        "b ?",
        "ba A B A where the derivation has, so far, generated some terminal symbols (the lower-case letters), two instances of the non-terminal A and one instance of B.",
        "The configuration keeps track of where the symbols generated by the non-terminals should go in the string, so #(A) = 2, #(B) = 1, and if (c, d) ?",
        "LA and e ?",
        "LB this derivation can generate the final string aacbeddbcba.",
        "These intermediary configurations are in H serialized into strings of nonterminals, with a ?nonterminal marker?",
        "symbol in each position where a nonterminal is referred to (i.e., H generates a symbol stating ?the ith string generated by instance j of the nonterminal A goes here?).",
        "H then operates like a Turing machine.",
        "A special nonterminal, the rewriting head, picks a rule from G to apply, and walks through the string replacing the nonterminal markers that are affected by that rule.",
        "This procedure is then repeated d times.",
        "We start by illustrating the principles of the reduction by an example.",
        "Consider the grammar",
        "the application of the first rule, r1 = S ?",
        "f(A), are given, the rest is abbreviated.",
        "G = ({S,A,B}, {a, b}, F,R, S) where F is {f(x, y) = xy, ha() = (a, a), hb() = (b, b), g((x, y), (x?, y?))",
        "= (xx?, yy?",
        ")}, and R contains the following",
        "Notice that L(G) = {ww |w ?",
        "{a, b}+}.",
        "We now describe how H is constructed by the reduction, after which the more general description follows.",
        "A derivation in G starts with the nonterminal S and must then apply r1.",
        "H is constructed to start with the string Pr1,1?2XS,1,1 (all these symbols are nonterminals, H has the same terminal alphabet as G).",
        "The symbols and mark the beginning and end of the string.",
        "The nonterminal XS,1,1 is a ?nonterminal marker?",
        "and denotes the location where the first string generated by instance 1 of the nonterminal S is to be placed.",
        "Since #(S) = 1 the first string is the only string generated from S. The last subscript, the instance number, is there to differentiate markers belonging to different instances of the same nonterminal.",
        "The rewriting head non-deterministically picks an instance number for a round of rewriting (single rule application) from a pool sufficiently large to differentiate between the maximal number of nonterminals (since the rank of G is at most k, no more than k2 nonterminals can be generated in k rule applications).",
        "Pr1,1?2 is the ?rewriting head?, the anchor for rule applications.",
        "The subscripts on P determines that it will apply the rule r1, rewriting nonterminal markers corresponding to the left hand side nonterminal of r1 which have instance number 1.",
        "Applying the rule may create new nonterminal markers, all of which get the instance number 2, also determined by the subscript.",
        "That is, the rules for Pr1,i?j in H will be Pr1,i?jXS,1,i ?",
        "XA,1,jXA,2,jPr1,i?j , for i, j ?",
        "[2k2], and Pr1,i?jx ?",
        "xPr1,i?j for all other x 6= .",
        "Pr5,i?jXB,1,i ?",
        "aPr5,i?j is another example of a rule corresponding to rule r5 of G. When a rewriting head hits it is replaced by a nonterminal R which reverses through the string (with rules of the form xR ?",
        "Rx for all x 6= ), after which a new rewriting head is non-deterministically picked using one of the rules in {R ?",
        "Pr,i?j |r ?",
        "R, i, j ?",
        "[2k2]}, after which the string is rewritten once more.",
        "Finally, there are rules ?",
        "?, ?",
        "?",
        "and R ?",
        "?, to remove all nonterminals once rewriting has terminated.",
        "A derivation is demonstrated in Figure 2.",
        "By induction on the length of derivations, one can show that L(H) = L(G).",
        "Now we need to modify the construction slightly to ensure that H can simulate d steps of G in dH steps.",
        "Limiting steps in G. Construct a SHORT P-LCFRS(P) DERIVATION instance (G?, w, d) from (G,w, d) whereG?",
        "is such that it cannot perform more than d derivation steps.",
        "Let N ?",
        "= {Ai |A ?",
        "N, i ?",
        "[d]}, and let Ai ?",
        "f(Bj1 , Cj2 , .",
        ".",
        ".)",
        "?",
        "R ?",
        "for all A ?",
        "f(B,C, .",
        ".",
        ".)",
        "?",
        "R, i ?",
        "[d] and j1 + j2 + ?",
        "?",
        "?",
        "= i?",
        "1.",
        "Then G?",
        "= (N ?,?, R?, S1).",
        "This reduction is somewhat heavy-handed, but is in FPT since it leaves k unchanged and each rule is replaced by less than kk rules (since d and the rank of the grammar are part of the parameter k).",
        "Deferring terminals.",
        "A problem in completing the reduction from (G,w, d) to (H,w, dH) is that the number of terminal symbolsG generates is not in its parameter k. For example, G may contain a rule like A ?",
        "a ?",
        "?",
        "?",
        "a, for an arbitrary number of as.",
        "Applying this rule may make the intermediary string H is operating on too long for it to complete rewriting in dH steps.",
        "This can",
        "easily be fixed by a polynomial-time rewriting of H .",
        "For any rule w ?",
        "w?",
        "in H such that w?",
        "contains at least one terminal, replace every maximal substring ?",
        "?",
        "??",
        "by a new nonterminal T?, a ?terminal place-holder?.The rewriting head P and reversal nonterminal R just walk over the place-holders without changing them.",
        "Now add the rule T?",
        "?",
        "?",
        "for each T?.",
        "For example, where a rewriting head inH might have replacedXA,1,1 by abcXB,1,1baXB,2,1cc it will now instead replace it by TabcXB,1,1TbaXB,2,1Tcc, and can defer replacing the place-holder nonterminals until the end.",
        "Completing the reduction.",
        "Now we are ready to put all the pieces together.",
        "Given the SHORT P-LCFRS(P) DERIVATION instance (G,w, d), apply the limiting steps reduction to construct (G?, w, d?).",
        "Apply the rewriting construction to G to get the context-sensitive grammar H .",
        "Now L(H) equals the language G can generate in d steps.",
        "Apply the deferring terminals construction to H to get H ?.",
        "All that remains is to calculate dH , the number of steps that H ?",
        "may take.",
        "For an FPT-reduction this number may only depend on the parameter k of (G?, w, d?).",
        "Picking dH = k5+103 is sufficient.",
        "Each rule inG?",
        "generates less than k nonterminals (since the maximum rank is at most k), each of which will generate at most k markers in the derivation in H ?",
        "(since the fanout is at most k).",
        "The rule may in addition generate (k + 1)k terminal place-holders (the k2 nonterminal markers and string ends separating maximal terminal substrings).",
        "After k rule applications, without replacing terminal placeholders, the intermediary string in a derivation in H is less than k(k2+(k+1)k)+3 symbols long.",
        "Simulating a rule application in H ?",
        "entails walking the string twice (forward and then reversing), and k rules are applied, giving 2k(k(k2+(k+1)k)+3) steps.",
        "Another k(k+ 1) + 3 steps at the end replace the terminal place-holders and remove markers and the rewriting head.",
        "Adding things up we arrive at a polynomial of degree 4 that can be rounded up to k5 + 103.",
        "Theorem 5.3.",
        "SHORT P-LCFRS(P) DERIVATION is W[1]-hard.",
        "Proof.",
        "This combines Lemmas 5.1 and 5.2.",
        "The result of Theorem 5.3 also trivially applies to another natural choice of parameters, the depth of acyclic LCFRS, since they can naturally only take a limited number of derivation steps.",
        "Definition 5.3.",
        "A LCFRS is acyclic of depth d if d is the smallest integer such that there is a function ?",
        ": N ?",
        "[d] such that for all A?",
        "f(B1, .",
        ".",
        ".",
        ", Bn) in R and i ?",
        "[n] it holds that ?",
        "(A) < ?(Bi).",
        "Corollary.",
        "The membership problem for acyclic LCFRS where the rank, fan-out, and depth are taken as the parameter is W[1]-complete."
      ]
    },
    {
      "heading": "6 Discussion",
      "text": [
        "We have shown that the 1-LCFRS(P)MEMBERSHIP problem is W[SAT]-hard, but we have no upper bound, except for the trivial XP membership.",
        "A conjecture of Pietrzak (2003) may help explain the difficulty of finding such an upper bound.",
        "It states that any parameterized problem that has a property that Pietrzak calls additive is either in FPT or not in W[P].",
        "Basically, additivity says that any number of instances, sharing a parameter value, can in polynomial time be combined into one big instance, with the same parameter.",
        "While 1-LCFRS(P)-MEMBERSHIP is not additive, it has subproblems that are.",
        "This means that if Pietrzak's conjecture is true (and FPT 6= W[P]), then 1-LCFRS(P)-MEMBERSHIP cannot belong to W[P].",
        "While our results are mostly intractability results, we see them as a first step towards a more finely grained understanding of the complexity of LCFRS parsing.",
        "Ruling out simple parameteri-zation by fanout or rank as a road towards efficient algorithms lets us focus on other possibilities.",
        "Many possible parameterizations remain unexplored.",
        "In particular, we conjecture that parameterizing by string length yields FPT membership.",
        "In the search for features that can be used in algorithm development, it may also be useful to investigate other formalisms, such as e.g., hypergraph replacement and tree-walking transducers."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We acknowledge the support of the Swedish Research Council grant 621-2011-6080."
      ]
    }
  ]
}
