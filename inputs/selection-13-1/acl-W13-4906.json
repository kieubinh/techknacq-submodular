{
  "info": {
    "authors": [
      "Eric De La Clergerie"
    ],
    "book": "Workshop on Statistical Parsing of Morphologically-Rich Languages",
    "id": "acl-W13-4906",
    "title": "Exploring beam-based shift-reduce dependency parsing with DyALog: Results from the SPMRL 2013 shared task",
    "url": "https://aclweb.org/anthology/W13-4906",
    "year": 2013
  },
  "references": [
    "acl-E12-2012",
    "acl-N12-1015",
    "acl-P05-1013",
    "acl-P09-1040",
    "acl-P09-2056",
    "acl-P10-1110",
    "acl-P13-2103",
    "acl-P13-2111",
    "acl-W05-1522",
    "acl-W13-4917"
  ],
  "sections": [
    {
      "text": [
        "Proceedings of the Fourth Workshop on Statistical Parsing of Morphologically Rich Languages, pages 53?62, Seattle, Washington, USA, 18 October 2013. c?2013 Association for Computational Linguistics Exploring beam-based shift-reduce dependency parsing with DyALog: Results from the SPMRL 2013 shared task ?ric Villemonte de la Clergerie"
      ]
    },
    {
      "heading": "Abstract",
      "text": [
        "The SPMRL 2013 shared task was the opportunity to develop and test, with promising results, a simple beam-based shift-reduce dependency parser on top of the tabular logic programming system DYALOG.",
        "The parser was also extended to handle ambiguous word lattices, with almost no loss w.r.t.",
        "disambiguated input, thanks to specific training, use of oracle segmentation, and large beams.",
        "We believe that this result is an interesting new one for shift-reduce parsing."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "DYALOG is a tabular-based logic programming environment, including a language (variant of Prolog), a bootstrapped compiler, and C-based abstract machine.",
        "It is mostly used for chart-like parsing (de La Clergerie, 2005b), in particular for a wide coverage French Tree Adjoining Grammar (de La Clergerie, 2005a).",
        "However, DYALOG offers all the power of a programming language a la Prolog, with some specific advantages, and it was tempting to try it on statistical parsing paradigms.",
        "The SPMRL 2013 shared task (Seddah et al., 2013) was an interesting opportunity to develop a simple (non-deterministic) beam-based shift-reduce dependency parser, called DYALOG-SR, inspired by (Huang and Sagae, 2010).",
        "The main advantage of logic programming is the (almost) transparent handling of non-determinism, useful for instance to handle ambiguous word lattices.",
        "DYALOG allows an easy tabulation of items, and their fast retrieval (thanks to full term indexing), needed for the dynamic programming part of the algorithm.",
        "Thanks to structure sharing and term hashing, it also reduces the costs related to the tabulation of multiple items (sharing subparts) and to term unification.",
        "Logic programs tend to be very concise, with, in our case, around 1500 lines of DYALOG code.",
        "However, one of the disadvantages of (pure) logic programming, and of DYALOG in particular, is the handling of mutable structures, which motivated the development of a companion C module (around 850 lines) to handle statistical models (loading, querying, updating, and saving).",
        "We briefly present the implemented algorithm (Section 2) and list the preliminary adaptations done for the 9 languages of the shared task (Section 3).",
        "We analyze in Section 4 the official results for DYALOG-SR.",
        "Recent developments corrected some weaknesses of DYALOG-SR.",
        "In particular, we explain in Section 5 how we seriously improved the parsing of ambiguous lattices, an important new result for shift-reduce parsing.",
        "Finally, Section 6 provides some empirical data about the efficiency and complexity of the algorithm."
      ]
    },
    {
      "heading": "2 A Dynamic Programming Shift-Reduce",
      "text": [
        "parser We used (Huang and Sagae, 2010) as the starting point for this work, in particular using the same simple arc-standard strategy for building projective dependency trees, defined by the deductive system of Figure 1.",
        "In a configuration m:?j, S?",
        ":c, m denotes the number of transitions applied since the axiom configuration, j the current position in the input string, S the stack of partial dependency trees built so far, and c the cost.",
        "A shift transition pushes the next input symbol on top of the stack while the two reduce transitions combine the 2 topmost stack trees, add a new (labeled) leftmost or rightmost de",
        "pendency edge between their roots, and remove the newly governed subtree from the stack.",
        "The delta cost ?, ?, and ?",
        "denote the cost of each operation w.r.t.",
        "the input configuration.",
        "input: w0 .",
        ".",
        ".",
        "wn?1",
        "From the configurations, the deductive system, and the configuration elements used to determine the transition costs, it is relatively straightforward to design items denoting partial configurations standing for equivalence classes of configurations and allowing computation sharing, following the principle of Dynamic Programming.",
        "The deduction rules are adapted to work on items and beam search (with size b) is then achieved by keeping only the b best items for each step m1.",
        "By following backpointers from items to parents, it is possible to retrieve the best transition sequence and the best dependency tree.",
        "i t em { s t e p => M, r i g h t => J , s t a c k => S0 , % t o p m o s t t r e e s s t a c k 1 => S1 , %",
        "Instead of the items proposed in (Huang and Sagae, 2010), we switched to items closer to those proposed in (Goldberg et al., 2013), corresponding 1Because we use Dynamic Programming techniques, keeping the b-best items at step m actually corresponds to keep more than the b-best configurations at step m. to Tree Structured Stacks (TSS), where stack tails are shared among items, as defined by Listing 1.",
        "The prefix cost corresponds to the maximal cost attached to the item, starting from the initial item.",
        "The inside cost is the maximal cost for a derivation from some ancestor item where s0 was shifted on the stack, and is used to adjust the total cost for different ancestor items.",
        "The items are completed by backpointers (using asserted facts back/5) and links to the potential stack tails (using asserted facts tail/2) needed to retrieve the lower part of a stack when applying a reduce action.",
        "Figure 2 shows the adaptation for items of some of the deductive rules.",
        "The stack elements for configuration are dependency trees, but approximations can be used for the item fields stack and stack1, under the condition that sufficient information remains to apply the transitions and to compute the costs.",
        "In practice, we keep information about the root node, and, when present, the leftmost and rightmost dependency edges, the numbers of left and right dependencies (valency), and the label sets (domain) for the left and right dependencies.",
        "The training phase relies on sequences of actions provided by an oracle and uses a simple averaged structured perceptron algorithm (Daume, 2006).",
        "The underlying statistical model is updated positively for the actions of the oracle and negatively for the actions of the parser, whenever a point of divergence is found.",
        "Several updating strategies may be considered (Huang et al., 2012), and, in our case, we update as early (early update) and as often as possible: after completion of Step m+1, we update the model locally (i.e. for the last action) whenever",
        "?",
        "the best item BOm+1 derived from the oracle item Om at Step m differs from the expected oracle item Om+1; ?",
        "the oracle item Om+1 is not in the beam, for intermediary steps m < 2n?",
        "2; ?",
        "the oracle item Om+1 is not the best item, for the last step m = 2n?",
        "2.",
        "We use a relatively standard set of word features related to the CONLL fields such as lex (FORM), lemma, cat (CPOSTAG), fullcat (POSTAG), mstag (morphosyntactic features FEATS).",
        "They apply to the next unread word (*I, say lemmaI), the two next lookahead words (*I2 and *I3), and (when present) to the 2 stack root nodes (*0 and *1), their leftmost and rightmost child (before b*[01] and after a*[01]).",
        "We have dependency features such as the labels of the leftmost and rightmost edges ([ab]label[01]), the left and right valency and domains ([ab][vd][01]).",
        "Finally, we have 3 (discretized) distance features between the next word and the stack roots (delta[01]) and between the two stack roots (delta01).",
        "Most feature values are atomic (either numerical or symbolic), but they can also be (recursively) a list of values, for instance for the mstag and domain features.",
        "A tagset (for a given language and/or treebank) contains a set of feature templates, each template being a sequence of features (for instance fullcat0:fullcat1:blabel0).",
        "Model management is a key factor for the efficiency of the algorithm, both for querying or updating the costs attached to a configuration.",
        "Therefore, we developed a specialized C companion module.",
        "A model is represented by a hash trie to factor the prefixes of the templates.",
        "Costs are stored in the leaves (for selecting the labels) and their immediate parent (for selecting between the shift and reduce base actions), ensuring join learning with smoothing of an action and a label.",
        "Querying is done by providing a tree-structured argument representing the feature values for all templates2, with the possibil-2The tree structure of the argument mirrors the tree structure of the templates and getting the argument tree for a configuration is actually a fast and very low memory operation, thanks to unification and structure sharing.",
        "ity to leave underspecified the action and the label.",
        "By traversing in a synchronous way the model trie and the argument tree, and accumulating costs for all possible actions and labels, a single query returns in order the cost for the b best actions.",
        "Furthermore, when a feature value is a list, the traversal is run for all its components (with summation of all found costs)."
      ]
    },
    {
      "heading": "3 Preparing the shared task",
      "text": [
        "We trained the parser on the training and dev dependency treebanks kindly provided by the organizers for the 9 languages of the task, namely Arabic3, Basque (Aduriz et al., 2003), French (Abeill?",
        "et al, 2003), German (Brants et al., 2002; Seeker and Kuhn, 2012), Hebrew (Sima?an et al., 2001; Tsarfaty, 2013; Goldberg, 2011), Hungarian (Vincze et al., 2010; Csendes et al., 2005), Korean (Choi et al., 1994; Choi, 2013) , Polish (S?widzin?ski and Wolin?ski, 2010), Swedish (Nivre et al., 2006).",
        "Being very short in time, we essentially used the same set of around 110 templates for all languages.",
        "Nevertheless, minimal tuning was performed for some languages and for the pred data mode (when using predicted data), as summarized below.",
        "For French, the main problem was to retrieve MWEs (Multi Word Expression) in pred data mode.",
        "Predicted features mwehead and pred were added, thanks to a list of MWEs collected in the gold treebank and in the French lexicon LEFFF (Sagot et al., 2006).",
        "We also added the predicted feature is_number to help detecting numerical MWEs such as 120 000, and also a is_capitalized feature.",
        "For all data modes, we added a sub-categorization feature for verbs (with a list value), again extracted from LEFFF.",
        "For Arabic, Hebrew, and Swedish, the lemma feature is removed because of the absence of lemma in the treebanks.",
        "Similarly, for Polish and German, with identical CPOS and POS tagsets, we remove the cat feature.",
        "For Hungarian, the SubPOS morphosyntactic feature is appended to the fullcat feature, to get a",
        "richer set of POS.",
        "The set of dependency labels being large (450 labels), we split the labels into lists of more elementary ones for the label features.",
        "Similarly, the Korean POS tags are also split into lists, because of their large number (2743 tags) and of their compound structure.",
        "For French, Hebrew, and Korean, in order to compensate initially large differences in performance between the gold and pred modes, we added, for the pred mode, dict features filled by predicted information about the possible tags for a given form, thanks to the dict lexicons provided by the IMS_SZEGED team.",
        "Finally, we discovered very late that the dependency trees were not necessarily projective for a few languages.",
        "A last-second solution was to use the MALT projectivization / deprojectivization wrappers (Nivre and Nilsson, 2005) to be able to train on projectivized versions of the treebanks for German, Hungarian, and Swedish, while returning non projective trees."
      ]
    },
    {
      "heading": "4 First results",
      "text": [
        "Under the team label ALPAGE-DYALOG, we have returned parsed data for the 9 languages of the shared task, for the full and 5k training size modes, and for the gold and pred data modes.",
        "For each configuration, we provided 3 runs, for beam sizes 8, 6, and 4.",
        "The results are synthesized in Tables 2, with LAS4 on the test and dev files, contrasted with the LAS for the best system, the baseline, and the mean LAS of all systems.",
        "The tables show that DYALOG-SR cannot compete with the best system (like most other participants !",
        "), but performs reasonably well w.r.t.",
        "the baseline and the mean LAS of the participants, at least in the gold/full case.",
        "The system is proportionally less accurate on smaller training treebanks (5k case), lacking good smoothing mechanisms to deal with data sparseness.",
        "The pred case is also more difficult, possibly again because of data sparseness (less reliable information not compensated by bigger treebanks) but also because we exploited no extra information for some languages (such as Basque or Swedish).",
        "The big drop for German in pred/5k case 4Labeled Attachment Score, with punctuation being taking into account.",
        "comes from the fact we were unable to de-projectivize the parsed test file with Malt5 and returned data built using an old model not relying on Malt proj/deproj wrappers.",
        "For Hungarian, a possible reason is the high level of multiple roots in sentences, not compatible with our initial assumption of a single root per sentence.",
        "New experiments, after modifying slightly the algorithm to accept multiple roots6, confirm this hypothesis for Hungarian, and for other languages with multiple roots, as shown in Table 1. language #roots/sent single multiple",
        "Finally, the Korean case, where we are below the baseline, remains to be explained.",
        "For the pred case, it could come from the use of the KAIST tagset instead of the alternative Seijong tagset.",
        "For the gold case, the results for all participants are actually relatively close."
      ]
    },
    {
      "heading": "5 Handling ambiguous lattices",
      "text": [
        "One of the important and innovative subtasks of the SPMRL campaign was to parse ambiguous lattices using statistical methods.",
        "A word lattice is just a Directed Acyclic Graph (DAG) whose edges are decorated by words with their features and whose nodes denote positions in the sentence, as represented in Figure 3 for an Hebrew sentence.",
        "A valid analysis for a sentence should follow a path in the DAG from its root node at position 0 till its final node at position n. Each edge may be associated with an unique identifier to be able to refer it.",
        "Lattice parsing is rather standard in chart-parsing7 and since the beginning, thanks to DYALOG's support, DYALOG-SR was designed to parse ambigu",
        "ous sentences.",
        "However, the initial experiments with Hebrew lattices (Table 3, using TED metric) have shown an important drop of 11 points between non ambiguous lattices (similar to standard CONLL files) and ambiguous ones.",
        "The main reason for that situation is that multiple paths of various lengths are now possible when traversing a lattice.",
        "Final items are no longer associated with the same number of steps (2n?1) and final items with a large number of steps (corresponding to longest paths in the lattice) tend to be favored over those with a small number of steps (corresponding to shortest paths), because the transition costs tend to be positive in our models.",
        "A first attempt to compensate this bias was to ?normalize?",
        "path lengths by adding (incrementally) some extra cost to the shortest paths, proportional to the number of missing steps.",
        "Again using models trained on non-ambiguous segmentations, we gained around 3 points (TED accuracy around 79) using this approach, still largely below the non-ambiguous case.",
        "Finally, we opted for specific training on lattice, with the idea of introducing the new length word feature, whose value is defined, for a word, as the difference between its right and left position in the lattice.",
        "To exploit this feature, we added the following 9 templates: length[I,I2,0],",
        "fullcat[I,I2,0]:length[I,I2,0], lengthI:lengthI2, length0:lengthI, and length0:lengthI:lengthI2.",
        "Then, to ensure that we follow valid lattice paths, the configurations and items were completed with three extra lookahead fields la[123] to remember the edge identifiers of the lookahead words that were consulted.",
        "Obviously, adding this extra information increases the number of items, only differing on their lookahead sequences, but it is an important element for the coherence of the algorithm.",
        "The reduce actions are kept unchanged, modulo the propagation without change of the lookahead identifiers, as shown below:",
        "On the other hand, the shift action consumes its first lookahead identifier la1 (for a word between position j and k) and selects a new lookahead identifier la4 (which must be a valid choice for continuing the path la1, la2, la3):",
        "It should be noted that for a given position j in the lattice, we may have several items only differing by their lookahead sequences la1, la2, la3, and each of them will produce at least one new item by shifting la1, and possibly more than one because of multiple la4.",
        "However, several of these new shifted items are discarded because of the beam.",
        "Learning good estimations for the shift actions becomes a key point, more important than for usual shift-reduce algorithms.",
        "In order to do that, we modified the oracle to provide information about the oracle segmentation path in the lattice, essentially by mentioning which edge identifier should be used for each oracle shift action.",
        "It should be noted that this information is also sufficient to determine the lookahead sequence for each oracle item, and in particular, the new edge identifier la4 to be retrieved for the shift actions.",
        "An issue was however to align the predicted lattices with the gold sentences (implementing a standard dynamic programming algorithm) in order to find the oracle segmentation paths.",
        "Unfortunately, we found that the segmentation path was missing for 1,055 sentences in the provided Hebrew lattices (around 20% of all sentences).",
        "Rather than discarding these sentences from an already small training set, we decided to keep them with incomplete prefix segmentation paths and oracles.",
        "Figure 4 shows the strong impact of a specific training and of using large beams, with a TED accuracy climbing up to 86.75 (for beam size 16), close to the 87.34 reached on non-ambiguous lattices (for beam 6).",
        "Increasing beam size (around 3 times) seems necessary, probably for compensating the lattice ambiguities (2.76 transitions per token on average).",
        "However, even at beam=6, we get much better results (TED=83.47) than without specific training for the same beam size (TED=76.35).",
        "To test the pertinence of the length features, we did some training experiments without these features.",
        "Against our expectations, we observed only a very low drop in performance (TED 86.50, loss = 0.25).",
        "It is possible that the lex features are sufficient, because only a relatively restricted set of (frequent) words have segmentations with length > 1.",
        "In practice, for the Hebrew 5k training lattices, we have 4,141 words with length > 1 for 44,722 occurrences (22.21% of all forms, and 12.65% of all occurrences), with around 80% of these occurrences covered by only 1,000 words.",
        "It is also possible that we under-employ the length features in too few templates, and that larger gains could be obtained."
      ]
    },
    {
      "heading": "6 Empirical analysis",
      "text": [
        "The diversity and amount of data provided for the shared task was the opportunity to investigate more closely the properties of DYALOG-SR, to identify its weaknesses, and to try to improve it.",
        "The usefulness of beams has been already proved in the case of Hebrew ambiguous lattices, and Figure 5 confirms that, in general, we get serious improvements using a beam, but in practice, beam sizes above 8 are not worth it.",
        "However, we observe almost no gain for Korean, a situation to be investigated.",
        "Efficiency was not the main motivation for this work and for the shared task.",
        "However, it is worthwhile to examine the empirical complexity of the algorithm w.r.t.",
        "beam size and w.r.t.",
        "sentence length.",
        "As shown in Figure 6, the average speed at beam=1 is around 740 tokens by second.",
        "At best, we expect a linear decreasing of the speed w.r.t.",
        "to beam size, motivating the use of a normalized speed by multiplying by the size.",
        "Surprisingly, we observe a faster normalized speed than expected for small beam sizes, maybe arising from computation sharing.",
        "However, for larger beam sizes, we observe a strong decrease, maybe related to beam management through (longer) sorted DYALOG lists, but also to some limits of term indexing8.",
        "The same experience carried for large beam sizes on the Hebrew lattices does not exhibit the same degradation, a point to be investigated but which suggests some kind of 8Even with efficient term indexing, checking the presence of an item in DYALOG table is not a constant time operation.",
        "equivalence between beam=4 on non ambiguous input string and beam=12 on ambiguous lattices (also reflected in accuracy evolution).",
        "Collecting parsing times for the sentences under length 80 from all training files and for all training iterations, Figure 8 confirms that parsing time (divided by beam size) is linear w.r.t.",
        "sentence length both for beam=1 and beam=8.",
        "On the other hand, we observe, Figure 9, that the number of updates increases with beam size (confirming that larger beams offer more possibilities of updates), but also non linearly with sentence length."
      ]
    },
    {
      "heading": "7 Conclusion",
      "text": [
        "We have presented DYALOG-SR, a new implementation on top of DYALOG system of a beam-based",
        "shift-reduce parser with some preliminary support for training on ambiguous lattices.",
        "Although developed and tuned in less than a month, the participation of this very young system to the SPMRL 2013 shared task has shown its potential, even if far from the results of the best participants.",
        "As far as we know, DYALOG-SR is also the first system to show that shift-parsing techniques can be applied on ambiguous lattices, with almost no accuracy loss and with only minimal modifications (but large beams).",
        "Several options are currently under consideration for improving the performances of DYALOG-SR.",
        "The first one is the (relatively straightforward) evolution of the parsing strategy for handling directly non-projective dependency trees, through the addition of some kind of SWAP transition (Nivre, 2009).",
        "Our preliminary experiments have shown the importance of larger beam sizes to cover the increased level of ambiguity due to lattices.",
        "However, it seems possible to adjust locally the beam size in function of the topology of the lattice, for improved accuracy and faster parsing.",
        "It also seems necessary to explore feature filtering, possibly using a tool like MALTOPTIMIZER (Ballesteros and Nivre, 2012), to determine the most discriminating ones.",
        "The current implementation scales correctly w.r.t.",
        "sentence length and, to a lesser extent, beam size.",
        "Nevertheless, for efficiency reasons, we plan to implement a simple C module for beam management to avoid the manipulation in DYALOG of sorted lists.",
        "Interestingly, such a module, plus the already implemented model manager, should also be usable to speed up the disambiguation process of DYALOG-based TAG parser FRMG (de La Clergerie, 2005a).",
        "Actually, these components could be integrated in a slow but ongoing effort to add first-class probabilities (or weights) in DYALOG, following the ideas of (Eisner and Filardo, 2011) or (Sato, 2008).",
        "Clearly, DYALOG-SR is still at beta stage.",
        "However, for interested people, the sources are freely available9, to be packaged in a near future."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "We would like to thank the organizers of the SPMRL 2013 shared task and the providers of the datasets for the 9 languages of the task."
      ]
    }
  ]
}
