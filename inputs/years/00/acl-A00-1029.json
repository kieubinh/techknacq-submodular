{
  "info": {
    "authors": [
      "Nanda Kambhatla",
      "Wlodek Zadrozny"
    ],
    "book": "Applied Natural Language Processing Conference and Meeting of the North American Association for Computational Linguistics",
    "id": "acl-A00-1029",
    "title": "A Tool for Automated Revision of Grammars for NLP Systems",
    "url": "https://aclweb.org/anthology/A00-1029",
    "year": 2000
  },
  "references": [
    "acl-C90-3035",
    "acl-J92-1004"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We present an algorithm and a tool for automatically revising grammars for natural language processing (NLP) systems to disallow specifically identified sentences or sets of sentences.",
        "We also outline an approach for automatically revising attribute value grammars using counterexamples.",
        "Developing grammars for NLP systems that are both general enough to accept most sentences about a domain, but constrained enough to disallow other sentences is very tedious.",
        "Our approach of revising grammars automatically using counterexamples greatly simplifies the development and revision of tightly constrained grammars.",
        "We have successfully used our tool to constrain over-generalizing grammars of speech understanding systems and obtained higher recognition accuracy."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Natural language processing systems often constrain the set of \"utterances\" from a user (spoken, typed in, etc.)",
        "to narrow down the possible syntactic and semantic resolutions of the utterance and reduce the number of misrecognitions and/or misunderstandings by the system.",
        "Such constraints on the allowed syntax and the inferred semantics are often expressed in the form of a \"grammar\"1, a set of 1 Throughout this document, by using the word \"grammar\", we refer to a Context-Free Grammar that consists of a finite set of non-terminals, a finite set of terminals, a unique non-terminal called the start symbol, and a set of production rules of the form A-> a, where A is a non-terminal and a is a string of terminal or non-terminal symbols.",
        "The language' rules specifying the set of allowed utterances and possibly also specifying the semantics associated with these utterances.",
        "For instance, grammars are commonly used in speech understanding systems to specify both the set of allowed sentences and to specify \"tags\" to extract semantic entities (e.g. the \"amount\" of money).",
        "Constraining the number of sentences accepted by a grammar is essential for reducing misinterpretations of user queries by an NLP system.",
        "For instance, for speech understanding systems, if the grammar accepts a large number of sentences, then the likelihood of recognizing uttered sentences as random, irrelevant, or undesirable sentences is increased.",
        "For transaction processing systems, misrecognized words can lead to unintended transactions being processed.",
        "An effective constraining grammar can reduce transactional errors by limiting the number of sentence level errors.",
        "The problem of over-generalization of speech grammars and related issues is well discussed by Seneff (1992).",
        "Thus, speech grammars must often balance the conflicting requirements of",
        "• accepting a wide variety of sentences to increase flexibility, and • accepting a small number of sentences to increase system accuracy and robustness.",
        "Developing tight grammars which trade-off these conflicting constraints is a tedious and",
        "difficult process.",
        "Typically, grammars overgeneralize and accept too many sentences that are irrelevant or undesirable for a given application.",
        "We call such sentences \"counterexamples\".",
        "The problem is usually handled by revising the grammar manually to disallow such counterexamples.",
        "For instance, the sentence \"give me my last eighteen transactions\" may need to be excluded from a grammar for a speech understanding system, since the words \"eighteen\" and \"ATM\" are easily confused by the speech recognizer.",
        "However, \"five\" and \"ten\" should remain as possible modifiers of \"transactions\".",
        "Counterexamples can also be sets of sentences that need to be excluded from a grammar (specified by allowing the inclusion of non-terminals in counter-examples).",
        "For example, for a banking application that disallows money transfers to online accounts, we might wish to exclude the set of sentences \"transfer <AMOUNT> dollars to my online account\" from the grammar, where <AMOUNT> is a non-terminal in the grammar that maps to all possible ways of specifying amounts.",
        "In this paper, we are proposing techniques for automatically revising grammars using counterexamples.",
        "The grammar developer identifies counterexamples from among sentences (or sets of sentences) mis-recognized by the speech recognizer or from sentences randomly generated by a sentence generator using the original grammar.",
        "The grammar reviser modifies"
      ]
    },
    {
      "heading": "Grammar Reviser Parser counterexamples",
      "text": [
        "pars e tree"
      ]
    },
    {
      "heading": "V",
      "text": []
    },
    {
      "heading": "initial",
      "text": [
        "grammar"
      ]
    },
    {
      "heading": "revised grammar",
      "text": [
        "the original grammar to invalidate the counterexamples.",
        "The revised grammar can be fed back to the grammar reviser and whole process can be iterated several times until the resulting grammar is deemed satisfactory.",
        "In the next sections, we first describe our algorithm for revising grammars to disallow counterexamples.",
        "We also discuss algorithms to make the revised grammar compact using minimum description length (MDL) based grammar compaction techniques and extensions to our basic algorithm to handle grammars with recursion.",
        "We then present some results of applying our grammar reviser tool to constrain speech grammars of speech understanding systems.",
        "Finally, we present an approach for revising attribute value grammars using our technique and present our conclusions."
      ]
    },
    {
      "heading": "2 Automated Grammar Revision by rule modification",
      "text": [
        "In this section, we describe an algorithm (see Figure 1) for revising grammars that directly modifies the rules of the grammar to disallow counterexamples.",
        "For each counter-example2, we generate the parse tree (representation of all the grammar rules needed to generate the sentence or set of sentences) and the grammar modifier modifies the production rules of the grammar to invalidate the counterexample.",
        "This process is repeated for each counterexample using the revised grammar from the previous iteration for generating the parse tree for the current counterexample.",
        "If a counterexample generates multiple parse trees, the above algorithm is repeated for each parse tree in turn."
      ]
    },
    {
      "heading": "2.1 Grammar modification algorithm",
      "text": [
        "We present the grammar modification algorithm below.",
        "For, we assume that the parse-tree(s) of the counterexample contain no recursion (i.e. the same production rule does not occur twice in any of the parse trees).",
        "In section 2.4, we present an approach for using the algorithm even when the parse-trees contain recursion.",
        "Thus, the algorithm is applicable for any context-free grammar.",
        "The grammar modification algorithm 2 Note that a counterexample can be a sentence such as \"move to operator\" or a set of sentences such as \"transfer <AMOUNT> to online account\".",
        "The latter is specified using non-terminals interspersed with words.",
        "Grammar Modifier",
        "for modifying the rules of a grammar to disallow a counterexample c (identified by a grammar developer) using a parse-tree for c proceeds as follows :",
        "1.",
        "For each non-terminal <N> in the parse tree, except the <<START>> symbol, a.",
        "Add a rule to define a new nonterminal <N'> such that <N'> generates all phrases that <N> generates except for the phrase in the counterexample that <N> generates.",
        "b.",
        "Add a rule to define a new nonterminal <No> such that <No> generates only the phrase(s) in the counterexample that <N> generates.",
        "2.",
        "Modify the rule that contains the <<START>> symbol in the parse tree, such that the <<START>> symbol no longer generates the given counterexample.",
        "::= \"to\" <N> .",
        "\"operator\".",
        "We illustrate the algorithm with an example.",
        "Figure 2(a) shows a simple grammar.",
        "Suppose the sentence \"move to operator\" is a counterexample for an application.",
        "Figure 2(b) shows the parse-tree for \"move to operator\".",
        "Since the parse tree contains the rule: <V> ::= \"move\", new rules are added to define non-terminals <V'> and <Vo>, where <VI> does not generate \"move\" and <Vo> generates only \"move\".",
        "Similarly, since the parse tree contains the rule: <N>::= \"operator\", the new rules: <N'>::= \"checking\" I \"savings\" I \"money\"; and <No>::= \"operator\", are added.",
        "For the non-terminal <PP>, the new rules: <PP'>::= \"to\" <N'>; and <PPo>::= \"to\" <No>, are added.",
        "Note that since <No> only generates the phrase \"operator\" which is part of the counter-example, <PPo> only generates the phrase \"to operator\" which is part of the counterexample.",
        "Also, <PP'> generates all phrases that <PP> generates except for the phrase \"to operator\".",
        "Finally, the rule: <<START>>::= <V> <PP> is modified using the newly created non-terminals <V'>, <Vo>, <PP'> and <PPo> such that the only sentences which are accepted by the grammar and begin with the phrase \"move\" do not end with the phrase \"to operator\", and also, the only sentences which are accepted by the grammar and end with the phrase \"to operator\" do not begin with the phrase \"move\".",
        "Figure 3 shows the final modified grammar that accepts all the sentences that the grammar in Figure 2(a) accepts except for the sentence \"move to Figure 3 operator\".",
        "In Figure 3, all the grammar rules that are new or modified are shown in bold and italics.",
        "The above algorithm for grammar modification has a time complexity of 0(m*2k) rule creation (or modification) steps for removing a counterexample, where m is the number of production rules in the parse tree of the counterexample and k is the largest number of non-terminals on the right hand side of any of these production",
        "attribute 'account', which encodes information about the type of account specified, e.g. `account' might have the values, SAVINGS, CHECKING and UNSPECIFIED.",
        "Figure 5 shows an equivalent non-attributed grammar, where the value of the attribute 'account' has been encoded in the names of the non-terminals.",
        "Note that such an encoding can potentially create a very large number of non-terminals.",
        "Also, the specific coding used needs to be such",
        "that the attributes can be easily recovered from the non-terminal names later on.",
        "We can now use our modification algorithms (Section 2.1 and 2.2) to eliminate counterexamples from the non-attributed grammar.",
        "For instance, suppose we wish to eliminate 'move to operator' from the attributed grammar based on Figure 2(a), as discussed above.",
        "We apply our algorithm (Section 2.1) to the grammar in Figure 5 and obtain the grammar shown in Figure 6.",
        "Note that we name any new non-terminals created during the grammar modification in such a way as to leave the encoding of the attribute values in the non-terminal names intact.",
        "After applying the grammar revision algorithm, we can extract the attribute values from the encoding in the non-terminal names.",
        "For instance, in the example outlined above, we might systematically check for suffixes of a certain type and recover the attributes and their values.",
        "Also, as described earlier, we can use the algorithm described in section 2.2 to make the resulting grammar compact again by using MDL based grammar induction algorithms."
      ]
    },
    {
      "heading": "4 Conclusions",
      "text": [
        "We have presented a set of algorithms and an interactive tool for automatically revising grammars of NLP systems to disallow identified counterexamples (sentences or sets of sentences accepted by the current grammar but deemed to be irrelevant for a given application).",
        "We have successfully used the tool to constrain overgeneralizing grammars of speech understanding systems and obtained 20-30% higher recognition accuracy.",
        "However, we believe the primary benefit of using our tool is the tremendously reduced effort for the grammar developer.",
        "Our technique relieves the grammar developer from the burden of going through the tedious and time consuming task of revising grammars by manually modifying production rules one at a time.",
        "Instead, the grammar developer simply identifies counterexamples to an interactive tool that revises the grammar to invalidate the identified sentences.",
        "We also discussed an MDL based algorithm for grammar compaction to reduce the size of the revised grammar.",
        "Thus, using a combination of the algorithms presented in this paper, one can obtain a compact grammar that is guaranteed to disallow the counterexamples.",
        "Although our discussion here was focussed on speech understanding applications, the algorithms and the tool described here are applicable for any domain where grammars are used.",
        "We are currently implementing an extension of the grammar modifier to handle attribute-value grammars.",
        "We outlined an"
      ]
    }
  ]
}
