{
  "info": {
    "authors": [
      "Hideo Watanabe"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C00-2132",
    "title": "A Method for Accelerating CFG-Parsing by Using Dependency Information",
    "url": "https://aclweb.org/anthology/C00-2132",
    "year": 2000
  },
  "references": [
    "acl-C96-2211",
    "acl-P95-1037",
    "acl-P96-1020",
    "acl-P96-1025",
    "acl-P97-1003",
    "acl-P98-2223"
  ],
  "sections": [
    {
      "text": [
        "A.bstract 'This paper describes an algorithm for accelerating the CFG-parsing process by using dependency (or modifier-niodifiee relationship) information given by, for instance, dependency estimation programs such as stochastic parsers, user's indication in an interactive application, and linguistic annotations added in a source text.",
        "This is a method for enhancing existing grammar-based CFG-parsing system by using dependency information."
      ]
    },
    {
      "heading": "Introduction",
      "text": [
        "The parsing system is a key component for natural language implications such as machine translation, information retrieval, text summarization, and its performance (processing speed and accuracy) is very important to the success of these applications.",
        "The usual CFG-parsing algorithms [3, 6] keep all intermediate possibilities which may or may not be used in the final parse results.",
        "Therefore, we usually reduce these intermediate possibilities which are unlikely to be used as final results ill the middle of the process by using several pruning techniques.",
        "One good information source for pruning is dependency information between words.",
        "it, has not been so easy to get such dependency information until a few years ago, but, the situation has recently changed.",
        "Recent intensive studies on statistical approach [7, 1, 2] advanced statistical parsing systems, and we can get relatively correct dependency information using these systems.",
        "Further, if we suppose an interactive NLP system, then there are some types of user interactions which can be considered to determine the modifiee candidate.",
        "In addition, recent studies on the linguistic information annotation [10, 4, 12, 13] provide tools by which a user can easily annotate linguistic information (special XML markup tags) into source texts, and we can expect to see an increase of the number of texts with linguistic information.",
        "This linguistic information usually includes dependency information.",
        "For instance, the following example shows an annotation example by Linguistic Annotation Language described in [12, 13], and the id and mod attributes inside lal:w elements specify word dependencies.",
        "He (lal:w id – \" il,\")saw(ilal:w) a man (lal:w mod.=:\"1\")with(/lakw) a telescope.",
        "In this example, the word \"with\" modifies the word \"saw.\" As shown in the above examples, we can now get dependency information more easily than a few years ago.",
        "Tins paper describes an algorithm for accelerating CFG-parsing systems by using such dependency (or modifier-modifiee relationship) in-fOrmation.",
        "The proposed algorithm does not assume all words are given dependency information, rather it works in case such that some of words are partially given dependency information."
      ]
    },
    {
      "heading": "2 Optimizing A.I.goritlun Using Dependency Information",
      "text": [
        "We use a normal CFG parsing system with one extension that for each rule there must be one right-hand side (or BUS) tenni- marked as a head, and the information of a head term is transferred to the left-hand side (or LIIS) term.",
        "In this paper, a CFG rule is denoted as follows:",
        "in the above notation, X is the left-hand side (or LBS) term, and are right-hand side (or RES) terms, and a RHS term followed by an asterisk is a head term.",
        "The typical usage of the head is that the [MS term shares many features of the head term in the RHS.",
        "For instance, a matching word of the the LI-IS term becomes the same as the one of the head term in the RHS.",
        "For each rule, an arc is constructed over a word segment in an input sentence.",
        "An arc is denoted using terms of its base rule as follows:",
        "I A term expresses a non-terminal symbol in HIS, and a non-terminal or a terminal symbol in RM.",
        "The LHS term of an arc means the LHS term of the base rule of the arc, and RHS terms of an arc means RHS terms of the base rule of the arc.",
        "In the above notation, a single dot indicates that RHS terms located to the left of a dot are inactive, that is, they already match the LHS term of sonic other arcs.",
        "Three dots are used to represent zero or any number of terms.",
        "An arc whose RHS terms are all inactive is called an inactive arc, otherwise it is called an active arc.",
        "An arc covers a segment of input words; the start point of an arc is the index of the first word in the covering segment, and the end point of an arc is 1 plus the index of the last word in the covering segment.",
        "Basically, a standard CFG parsing algorithm such as [3, 6] consists of the following three operations.",
        "Initialization: For each word, arcs are generated from rules such that the leftmost RHS term matches it.",
        "Operation A: For each inactive arc A, an arc is generated from A and a rule R such that the leftmost RHS term of R matches the LHS term of A.",
        "Operation B: For each inactive arc A, an arc is generated from A and another active arc B such that the leftmost active RHS term of B matches the LIIS term of A and the end point of B is the same as the start, point of A.",
        "We assume that sonic dependency information between words are given, and such dependency information is denoted as follows: 147,, TV, WT�W, The first of the above examples represents that a word Wy modifies another word IC, and WW precedes 147y, while the second one represents that a word 147,„ modifies another word W, and HT, precedes W,.",
        "Given this kind of dependency information, the following conditions are imposed on Operation A and Operation B."
      ]
    },
    {
      "heading": "Conditions for Operation A:",
      "text": [
        "Condition Al (when the leftmost RHS term of a rule is a head term): Given an inactive arc Are' denoted by [A ...] and a rule which has two or more RHS terms and the leftmost RHS term is a head denoted by {X A *",
        "B Operation A is executed only if there is dependency information 147, Wb where Wa is a word matching the LHS term A of Arc' and WI, is a word located anywhere to the right of the end point of Are'.",
        "{( -> A* B ...} Wa Wb - .......... ...........",
        "Figure 1 shows the above condition.",
        "In this figure, a thick arc represents an inactive arc, a line represents a matching to be tried in this operation, a dotted line represents a matching between a term in an arc and a word, and a dotted arrow represents dependency information.",
        "In this case, this type of rule implies that a word matching the LHS term of the arc to be matched with the leftmost term of the rule must be modified by any word which is located after the end point of the arc, since the head term is the leftmost term of the rule.",
        "Therefore, if the Al condition does not hold, Operation A is not required to be executed.",
        "Condition A2 (when the leftmost RHS term of a rule is not a head term): Given an inactive arc Arc/ denoted by [A --+ ...] and a rule which has two or more RHS terms and the leftmost RHS term is not a head denoted by {X – > A D* ...}, Operation A is executed only if there is a dependency information Wa WW where Wa is a word matching the LHS term A of Arc' and 1.47b is a word located anywhere after the end point of Arc'.",
        "Figure 2 shows the above condition.",
        "In this case, this type of rule implies that a word matching the LHS term of the arc to be matched with the leftmost term of the rule must modify any word which is located after the end point of the arc, since the head term is not the leftmost term of the rule."
      ]
    },
    {
      "heading": "Conditions for Operation B:",
      "text": [
        "Condition Bl.",
        "(when the leftmost active RHS term of an active arc is the head term): Given an active arc ArcA denoted by",
        "active arc Arc' denoted by [B ...]",
        "A of ArcA, and 147b is a word matching the LHS term B of Arc/.",
        "Wa Nig such that the end point of AMA is the same as the start point of Arcs, Operation B is executed only if, for each Way (0 < i < it) which is a word matching the RHS term Ai of ArcA, there is dependency information Wai Wb, where I/7/, is a word matching the LIN term 13 of Arc'.",
        "Figure 3 shows the above condition.",
        "In this figure, a dotted thick arc represents an active arc.",
        "In this case, this type of active arc implies that words matching inactive terms before the head term of the active arc must modify a word matching the LHS term of the inactive arc.",
        "Condition 132 (when the head term is on the left side of the leftmost active RHS term of an active arc): Given an active arc Arc, denoted by [X ... A* ... .",
        "13 ...] and an inactive arc Arc/ denoted by [B ...] such that the end point of Arc, is the same as the start point of Arc', Operation 13 is executed only if there is dependency information W„ Wb where 147,, is a word matching the RES term",
        "Given an active arc AreA denoted by [X -+ A .",
        "B C* ...] and an inactive arc Arc/ denoted by [B 4 ...] such that the end point of ArcA is the same as the start point of Arc/ , Operation B is executed only if there is dependency information IF,, 147, where 117b is a word matching the MIS term B of Arc', and 147L is a word on the right side of the end point of Arc'.",
        "The dependency information is not necessarily given to all words.",
        "If there is any source word except for the root word of a sentence such that there",
        "is no dependency information originating from it, then a set of such dependency information is called partial, otherwise, it is called total.",
        "If the given dependency information is partial, the Al condition can not be used, since, even if there is no dependency information targeting TV„, we cannot know if such dependency information does not really exist, or if such dependency information is not supplied.",
        "For other conditions, we check them only when all source words for dependency checking have dependency information.",
        "On the other hand, if the given dependency information is total, all conditions are checked."
      ]
    },
    {
      "heading": "3 Experiment",
      "text": [
        "We have implemented the proposed algorithm into an existing English CFG-parser we have developed for a machine translation product [8, 9, 11] , and conducted an experiment to know the effectiveness of tins algorithm.",
        "We selected 280 test sentences randomly from a sentence set created by JEIDA3 for evaluating translation system, and made the correct dependency relation data for these selected test sentences.",
        "We collected the number of inactive arcs, the number of active arcs, and the processing time for cases such that C modifiee candidates (one of which is the correct modifiee) are given to a word.'",
        "If C=1 then it corresponds to the best case for a parser such that only one correct modifiee is given for each word, while if C is 3 or 4 then it corresponds to the approximation of using a statistical modifiee estimation program for getting candidate modifiees.",
        "The graphs in Figure 6 indicate the reduction ratios of active arcs, inactive arcs, and processing tune for using conditions for total dependency information and conditions for partial dependency information.",
        "The denominators for calculating these ratios are the numbers of arcs and the processing time (seconds) in case of the parser without this algorithm.",
        "In these graphs, C=X indicates that X is the maximum number of modifiee candidates given to a word.",
        "From these graphs, we can see that the more words in a sentence, the better the performance.",
        "In a real domain, most sentences consist of more than ten words..",
        "Therefore, looking at values for around 10 in the X axis, we can see that inactive arcs are reduced by about 40% and 25%, active arcs",
        "are reduced by about 65% and 35%, and processing time is reduced by about 45% and 15%, for the ideal case (C=1) and more practical cases (C=3 or 4), respectively, in the case of total dependency information.",
        "Please note that, since the parser in winch this algorithm is implemented has already several pruning mechanisms, we can expect more reduction (or performance gain) for generic CFG parsers."
      ]
    },
    {
      "heading": "4 Discussion",
      "text": [
        "As a study for accelerating the parsing process using dependency information, Imaichi[5] reported an algorithm for Japanese language.",
        "The conditions introduced by Imaichi are described by using the notation in this paper as follows: Condition Ml: Given an active arc Arch denoted by [X A .",
        "13*] and an inactive arc Arc] denoted by [13 such that the end point of Area is the same as the start point of Arcs, Operation 11 is executed only if there is dependency information T1 a WI, where Wa is a word matching the MIS term A of Area, and 1171, is a word matching the II'S term T3 of Arc,.",
        "Condition M2: Given an inactive arc Arc' denoted by [A 4 ...] and a rule denoted by {X 4 A.",
        "Operation A is executed only if there is no dependency information W„ where Ihais a word matching the MIS term A of A.rei and Wk is a word located before the start point of Arc] .",
        "The condition M1 corresponds to 131.",
        "Since Imaichi's algorithm considers only Japanese in which all words other than the last word modifies one of the succeeding words, it does not deal with cases usually seen in European languages where a word modifies one of the preceding words.",
        "Therefore, it is not applicable to any language other than Japanese in general.",
        "Further, since a CFG rule is restricted to be in Chomsky normal form, Imaichi's algorithm is limited in terms of applicability.",
        "Since the algorithm proposed in this paper does not have any restrictions on the dependency direction and the CFG rule format, it can be applicable to any CFG-parsers in any languages."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We developed an algorithm for accelerating the performance of the CFG parsing process if we are given dependency information.",
        "From an experiment, we can show the effectiveness of tins algorithm.",
        "By using tins algorithm, we can enhance existing grammar-based parsers using dependency information given by stochastic parsers, interactive systems, and texts created by linguistic annotation systems."
      ]
    }
  ]
}
