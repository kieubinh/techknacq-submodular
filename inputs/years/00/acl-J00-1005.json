{
  "info": {
    "authors": [
      "Gertjan van Noord"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J00-1005",
    "title": "Treatment of Epsilon Moves in Subset Construction",
    "url": "https://aclweb.org/anthology/J00-1005",
    "year": 2000
  },
  "references": [
    "acl-E99-1017",
    "acl-P91-1032",
    "acl-P97-1058",
    "acl-P98-1101",
    "acl-W98-1302",
    "acl-W98-1306"
  ],
  "sections": [
    {
      "text": [
        "The paper discusses the problem of determinizing finite-state automata containing large numbers of c-moves.",
        "Experiments with finite-state approximations of natural language grammars often give rise to very large automata with a very large number of c-moves.",
        "The paper identifies and compares a number of subset construction algorithms that treat c-moves.",
        "Experiments have been performed which indicate that the algorithms differ considerably in practice, both with respect to the size of the resulting deterministic automaton, and with respect to practical efficiency.",
        "Furthermore, the experiments suggest that the average number of c-moves per state can be used to predict which algorithm is likely to be the fastest for a given input automaton."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": []
    },
    {
      "heading": "1.1 Finite-State Language Processing",
      "text": [
        "An important problem in computational linguistics is posed by the fact that the grammars typically hypothesized by linguists are unattractive from the point of view of computation.",
        "For instance, the number of steps required to analyze a sentence of n words is n3 for context-free grammars.",
        "For certain linguistically more attractive grammatical formalisms it can be shown that no upper bound to the number of steps required to find an analysis can be given.",
        "The human language user, however, seems to process in linear time; humans understand longer sentences with no noticeable delay.",
        "This implies that neither context-free grammars nor more powerful grammatical formalisms are likely models for human language processing.",
        "An important issue therefore is how the linearity of processing by humans can be accounted for.",
        "A potential solution to this problem concerns the possibility of approximating an underlying general and abstract grammar by techniques of a much simpler sort.",
        "The idea that a competence grammar might be approximated by finite-state means goes back to early work by Chomsky (Chomsky 1963, 1964).",
        "There are essentially three observations that motivate the view that the processing of natural language is finite-state:"
      ]
    },
    {
      "heading": "1.2 Finite-State Approximation and e-Moves",
      "text": [
        "In experimenting with finite-state approximation techniques for context-free and more powerful grammatical formalisms (such as the techniques presented in Black [1989], Pereira and Wright [1991, 19971, Rood [1996], Grimley-Evans [1997], Nederhof [1997, 1998], and Johnson [1998]), we have found that the resulting automata often are extremely large.",
        "Moreover, the automata contain many e-moves (jumps).",
        "And finally, if such automata are determinized then the resulting automata are often smaller.",
        "It turns out that a straightforward implementation of the subset construction determinization algorithm performs badly for such inputs.",
        "In this paper we consider a number of variants of the subset construction algorithm that differ in their treatment of E-moves.",
        "Although we have observed that finite-state approximation techniques typically yield automata with large numbers of e-moves, this is obviously not a necessity.",
        "Instead of trying to improve upon determinization techniques for such automata, it might be more fruitful to try to improve these approximation techniques in such a way that more compact automata are produced.'",
        "However, because research into finite-state approximation is still of an exploratory and experimental nature, it can be argued that more robust determinization algorithms do still have a role to play: it can be expected that approximation techniques are much easier to define and implement if the resulting automaton is allowed to be nondeterministic and to contain f-moves.",
        "Note furthermore that even if our primary motivation is in finite-state approximation, the problem of determinizing finite-state automata with E-moves may be relevant in other areas of language research as well."
      ]
    },
    {
      "heading": "1.3 Subset Construction and c-Moves",
      "text": [
        "The experiments were performed using the FSA Utilities.",
        "The FSA Utilities toolbox (van Noord 1997, 1999; Gerdemann and van Noord 1999; van Noord and Gerdemann 1999) is a collection of tools to manipulate regular expressions, finite-state automata, and finite-state transducers.",
        "Manipulations include determinization, minimization, composition, complementation, intersection, Kleene closure, etc.",
        "Various visualization tools are available to browse finite-state automata.",
        "The toolbox is implemented in SICStus Prolog, and is available free of charge under Gnu General Public License via anonymous ftp at ftp:/ /ftpletsug.nl/pub/vannoord/Fsa/, and via the web at http: / /www.letsug.n1/-vannoord/Fsa/.",
        "At the time of our initial experiments with finite-state approximation, an old version of the toolbox was used, which ran into memory problems for some of these automata.",
        "For this reason, the subset construction algorithm has been reimplemented, paying special attention to the treatment of e-moves.",
        "Three variants of the subset construction algorithm are identified, which differ in the way &moves are treated: per graph The most obvious and straightforward approach is sequential in the following sense: Firstly, an equivalent automaton without &moves is constructed for the input.",
        "To do this, the transitive closure of the graph consisting of all E-moves is computed.",
        "Secondly, the resulting automaton is then treated by a subset construction algorithm for &free automata.",
        "Different variants of per graph can be identified, depending on the implementation of the E-removal step.",
        "van Noord Epsilon Moves in Subset Construction per state For each state that occurs in a subset produced during subset construction, compute the states that are reachable using c-moves.",
        "The results of this computation can be memorized, or computed for each state in a preprocessing step.",
        "This is the approach mentioned briefly in Johnson and Wood (1997).2 per subset For each subset Q of states that arises during subset construction, compute Q' D Q, which extends Q with all states that are reachable from any member of Q using c-moves.",
        "Such an algorithm is described in Aho, Sethi, and Ullman (1986).",
        "The motivation for this paper is the knowledge gleaned from experience, that the first approach turns out to be impractical for automata with very large numbers of c-moves.",
        "An integration of the subset construction algorithm with the computation of c-reachable states performs much better in practice for such automata.",
        "Section 2 presents a short statement of the problem (how to determinize a given finite-state automaton), and a subset construction algorithm that solves this problem in the absence of c-moves.",
        "Section 3 defines a number of subset construction algorithms that differ with respect to the treatment of c-moves.",
        "Most aspects of the algorithms are not new and have been described elsewhere, and/or were incorporated in previous implementations; a comparison of the different algorithms had not been performed previously.",
        "We provide a comparison with respect to the size of the resulting deterministic automaton (in Section 3) and practical efficiency (in Section 4).",
        "Section 4 provides experimental results both for randomly generated automata and for automata generated by approximation algorithms.",
        "Our implementations of the various algorithms are also compared with AT&T's FSM utilities (Mohri, Pereira, and Riley 1998), to establish that the experimental differences we find between the algorithms are truly caused by differences in the algorithm (as opposed to accidental implementation details)"
      ]
    },
    {
      "heading": "2. Subset Construction",
      "text": []
    },
    {
      "heading": "2.1 Problem Statement",
      "text": [
        "Let a finite-state machine M be specified by a tuple (Q, E, 6, 5,F) where Q is a finite set of states, E is a finite alphabet, and 6 is a function from Q x (E U {c}) 2.",
        "Furthermore, S C Q is a set of start states and F C Q is a set of final states.3 Let c-move be the relation {(q„ th)lqi E 6(q, c)} c-reachable is the reflexive and transitive closure of c-move.",
        "Let c-CLOSURE: 2Q – > 2Q be a function defined as: c-CLOSURE(2') = OW' E , (q', q) E c-reachable} Furthermore, we write c-CLOSURE-1(Q') for the set Oki' E Q', (q, q') E c-reachable}.",
        " funct subset _construction ((Q, E, 6,5, F))"
      ]
    },
    {
      "heading": "Subset construction algorithm.",
      "text": [
        "For any given finite-state automaton M = (Q, E, 6, S, F), there is an equivalent deterministic automaton M' = (2Q, E, 6', {Q0}, F').",
        "F' is the set of all states in 2Q containing a final state of M, i.e., the set of subsets {Qi E 2Q lq E Qi, q E F}.",
        "M' has a single start state Qo, which is the epsilon closure of the start states of M, i.e., Qo = c-CLOSURE(S).",
        "Finally,",
        "An algorithm that computes M' for a given M will only need to take into account states in 2Q that are reachable from the start state Q0.",
        "This is the reason that for many input automata the algorithm does not need to treat all subsets of states (but note that there are automata for which all subsets are relevant, and hence exponential behavior cannot be avoided in general).",
        "Consider the subset construction algorithm in Figure 1.",
        "The algorithm maintains a set of subsets States.",
        "Each subset can be either marked or unmarked (to indicate whether the subset has been treated by the algorithm); the set of unmarked subsets is sometimes referred to as the agenda.",
        "The algorithm takes such an unmarked subset T and computes all transitions leaving T. This computation is performed by the function instructions and is called instruction computation by Johnson and Wood (1997).",
        "van Noord Epsilon Moves in Subset Construction The function index _transitions constructs the function transitions: Q – > E x 2, which returns for a given state p the set of pairs (s, T) representing the transitions leaving p. Furthermore, the function merge takes such a set of pairs and merges all pairs with the same first element (by taking the union of the corresponding second elements).",
        "For example: mergeffla , {1,2,4}), (b, {2,4}), (a, {3,4}), (b, {5,6})1) = {(a, {1,2,3,4}), (b, {2,4,5,6})1 The procedure add is responsible for \"reachable-state-set maintenance,\" by ensuring that target subsets are added to the set of subsets if these subsets were not encountered before.",
        "Moreover, if such a new subset contains a final state, then this subset is added to the set of final states."
      ]
    },
    {
      "heading": "3. Variants for E-Moves",
      "text": [
        "The algorithm presented in the previous section does not treat E-moves.",
        "In this section, possible extensions of the algorithm are identified to treat &moves."
      ]
    },
    {
      "heading": "3.1 Per Graph",
      "text": [
        "In the per graph variant, two steps can be identified.",
        "In the first step, efree, an equivalent &free automaton is constructed.",
        "In the second step this &free automaton is determinized using the subset construction algorithm.",
        "The advantage of this approach is that the subset construction algorithm can remain simple because the input automaton is &free.",
        "An algorithm for efree is described for instance in Hoperoft and Ullman (1979, 26- 27).",
        "The main ingredient of efree is the construction of the function &CLOSURE, which can be computed using a standard transitive closure algorithm for directed graphs: this algorithm is applied to the directed graph consisting of all &moves of M. Such an algorithm can be found in several textbooks (see, for instance, Cormen, Leiserson, and Rivest [1990]).",
        "For a given finite-state automaton M = (Q, E, 5, S. F), efree computes M' = (Q,E, 6' , S' , F') , where S' = c-CLOSURE(S), F' = E-CLOSURE-1(F), and 6' (p, a) = {qlq' E 6(p' , a), p' E &CLOSURE-1 (p), q E E-CLOSURE(q/)}.",
        "Instead of using &CLOSURE on both the source and target side of a transition, efree can be optimized in two different ways by using &CLOSURE only on one side:",
        "• efreet: M' = (Q,E, 6' , S' ,F) , where S' =- c-CLOSURE(S), and 6' (p, a) = {qlq' E 6(p , a), q E E-CLOSURE(c01.",
        "• efrees : M' = (Q,E, 6' , S ,F'), where F' = c-CLOSURE-1(F), and 6' (p, a) = {gig E 6(p' , a), p' E c-CLOSURE-1(p)}.",
        "Although the variants appear very similar, there are some differences.",
        "Firstly, efreet might introduce states that are not coaccessible: states from which no path exists to a final state; in contrast, efrees might introduce states that are not accessible: states from which no path exists from the start state.",
        "A straightforward modification of both algorithms is possible to ensure that these states are not present in the output.",
        "Thus efreet'c",
        "Illustration of the difference in size between two variants of efree.",
        "(1) is the input automaton.",
        "The result of efreet is given in (2); (3) is the result of efTees .",
        "(4) and (5) are the result of applying the subset construction to the result of efreet and efrees, respectively.",
        "ensures that all states in the resulting automaton are co-accessible; efrees,a ensures that all states in the resulting automaton are accessible.",
        "As a consequence, the size of the determinized machine is in general smaller if efreet,' is employed, because states that were not co-accessible (in the input) are removed (this is therefore an additional benefit of efreet; the fact that efrees'a removes accessible states has no effect on the size of the determinized machine because the subset construction algorithm already ensures accessibility anyway).",
        "Secondly, it turns out that applying efreet in combination with the subset construction algorithm generally produces smaller automata than efrees (even if we ignore the benefit of ensuring co-accessibility).",
        "An example is presented in Figure 2.",
        "The differences can be quite significant, as illustrated in Figure 3.",
        "Below we will write per graphx to indicate the nonintegrated algorithm based on efreex"
      ]
    },
    {
      "heading": "3.2 Per Subset and Per State",
      "text": [
        "Next, we discuss two variants (per subset and per state) in which the treatment of E-moves is integrated with the subset construction algorithm.",
        "We will show later that such an integrated approach is in practice often more efficient than the per graph approach if there are many c-moves.",
        "The per subset and per state approaches are also more suitable for a lazy implementation of the subset construction algorithm (in such a lazy implementation, subsets are only computed with respect to a given input string).",
        "The per subset and the per state algorithms use a simplified variant of the transitive closure algorithm for graphs.",
        "Instead of computing the transitive closure of a given",
        "Difference in sizes of deterministic automata constructed with either efrees or efreet, for randomly generated input automata consisting of 100 states, 15 symbols, and various numbers of transitions and jumps (cf.",
        "Section 4).",
        "Note that all states in the input are co-accessible; the difference in size is due solely to the effect illustrated in Figure 2.",
        "foreach q e 6(t,€) do if q D then add q unmarked to D fi od od return D end Figure 4"
      ]
    },
    {
      "heading": "Epsilon closure algorithm.",
      "text": [
        "graph, this algorithm only computes the closure for a given set of states.",
        "Such an algorithm is given in Figure 4.",
        "In both of the two integrated approaches, the subset construction algorithm is initialized with an agenda containing a single subset that is the &CLOSURE of the set of start states of the input; furthermore, the way in which new transitions are computed also takes the effect of &moves into account.",
        "Both differences are accounted for by an alternative definition of the epsilon_closure function.",
        "The approach in which the transitive closure is computed for one state at a time is defined by the following definition of the epsilon_closure function.",
        "Note that we make sure that the transitive closure computation is only performed once for each",
        "input state, by memorizing the closure function; the full computation is memorized as well.'",
        "funct epsilon_closure(U) variant 2: per state",
        "In the case of the per subset approach, the closure algorithm is applied to each subset.",
        "We also memorize the closure function, in order to ensure that the closure computation is performed only once for each subset.",
        "This can be useful, since the same subset can be generated many times during subset construction.",
        "The definition simply is:",
        "The motivation for the per state variant is the insight that in this case the closure algorithm is called at most IQ' times.",
        "In contrast, in the per subset approach the transitive closure algorithm may need to be called 21Q1 times.",
        "On the other hand, in the per state approach some overhead must be accepted for computing the union of the results for each state.",
        "Moreover, in practice, the number of subsets is often much smaller than 21Q1.",
        "In some cases, the number of reachable subsets is smaller than the number of states encountered in those subsets."
      ]
    },
    {
      "heading": "3.3 Implementation",
      "text": [
        "In order to implement the algorithms efficiently in Prolog, it is important to use efficient data structures.",
        "In particular, we use an implementation of (non-updatable) arrays based on the N+K trees of O'Keefe (1990, 142-145) with N = 95 and K = 32.",
        "On top of this data structure, a hash array is implemented using the SICStus library predicate t erm_hash/4, which constructs a key for a given term.",
        "In such hashes, a value in the underlying array is a partial list of key-value pairs; thus collisions are resolved by chaining.",
        "This provides efficient access in practice, although such arrays are quite memory-intensive: care must be taken to ensure that the deterministic algorithms indeed are implemented without introducing choice-points during runtime."
      ]
    },
    {
      "heading": "4. Experiments",
      "text": [
        "Two sets of experiments have been performed.",
        "In the first set of experiments, random automata are generated according to a number of criteria based on Leslie (1995).",
        "In the second set of experiments, results are provided for a number of (much larger) automata that surfaced during actual development work on finite-state approximation techniques.'",
        "Random Automata.",
        "Here, we report on a number of experiments for randomly generated automata.",
        "Following Leslie (1995), the absolute transition density of an automaton",
        "van Noord Epsilon Moves in Subset Construction is defined as the number of transitions divided by the square of the number of states multiplied by the number of symbols (i.e., the number of transitions divided by the maximum number of \"possible\" transitions, or, in other words, the probability that a possible transition in fact exists).",
        "Deterministic transition density is the number of transitions divided by the number of states multiplied by the number of symbols (i.e., the ratio of the number of transitions and the maximum number of \"possible\" transitions in a deterministic machine).",
        "In both of these definitions, the number of transitions should be understood as the number of nonduplicate transitions that do not lead to a sink state.",
        "A sink state is a state from which there exists no sequence of transitions to a final state.",
        "In the randomly generated automata, states are accessible and co-accessible by construction; sink states and associated transitions are not represented.",
        "Leslie (1995) shows that deterministic transition density is a reliable measure for the difficulty of subset construction.",
        "Exponential blow-up can be expected for input automata with deterministic transition density of around 2.6 He concludes (page 66): randomly generated automata exhibit the maximum execution time, and the maximum number of states, at an approximate deterministic density of 2.",
        "Most of the area under the curve occurs within 0.5 and 2.5 deterministic density – this is the area in which subset construction is expensive.",
        "Conjecture.",
        "For a given NFA, we can compute the expected numbers of states and transitions in the corresponding DFA, produced by subset construction, from the deterministic density of the NFA.",
        "In addition, this functional relationship gives rise to a Poisson-like curve with its peak approximately at a deterministic density of 2.",
        "A number of automata were generated randomly, according to the number of states, symbols, and transitions.",
        "For the first experiment, automata were generated consisting of 15 symbols, 25 states, and various densities (and no c-moves).",
        "The results are summarized in Figure 5.",
        "CPU-time was measured on a HP 9000/785 machine running HP-UX 10.20.",
        "Note that our timings do not include the start-up of the Prolog engine, nor the time required for garbage collection.",
        "In order to establish that the differences we obtain later are genuinely due to differences in the underlying algorithm, and not due to \"accidental\" implementation details, we have compared our implementation with the determirtizer of AT&T's FSM utilities (Mohri, Pereira, and Riley 1998).",
        "For automata without &moves, we establish that FSM normally is faster: for automata with very small transition densities, FSM is up to four times as fast; for automata with larger densities, the results are similar.",
        "A new concept called absolute jump density is introduced to specify the number of c-moves.",
        "It is defined as the number of &moves divided by the square of the number of states (i.e., the probability that an c-move exists for a given pair of states).",
        "Furthermore, deterministic jump density is the number of c-moves divided by the number of states (i.e., the average number of c-moves that leave a given state).",
        "In order to measure the differences between the three implementations, a number of automata have been generated consisting of 15 states and 15 symbols, using various",
        "Deterministic transition density versus CPU-time in msec.",
        "The input automata have 25 states, 15 symbols, and no c-moves.",
        "fsa represents the CPU-time required by our FSA6 implementation; fsm represents the CPU-time required by AT&T's FSM library; states represents the sum of the number of states of the input and output automata.",
        "transition densities between 0.01 and 0.3 (for larger densities, the automata tend to collapse to an automaton for E*).",
        "For each of these transition densities, deterministic jump densities were chosen in the range 0 to 2.5 (again, for larger values, the automata tend to collapse).",
        "In Figures 6 to 9, the outcomes of these experiments are summarized by listing the average amount of CPU-time required per deterministic jump density (for each of the algorithms), using automata with 15, 20, 25, and 100 states, respectively.",
        "Thus, every dot represents the average for determinizing a number of different input automata with various absolute transition densities and the same deterministic jump density.",
        "The striking aspect of these experiments is that the integrated per subset and per state variants are much more efficient for larger deterministic jump densities.",
        "The per graph' is typically the fastest algorithm of the nonintegrated versions.",
        "However, in these experiments all states in the input are co-accessible by construction; and moreover, all states in the input are final states.",
        "Therefore, the advantages of the per graph'''.",
        "algorithm could not be observed here.",
        "The turning point is a deterministic jump density of around 0.8: for smaller densities the per graph' is typically slightly faster; for larger densities the per state algorithm is much faster.",
        "For densities beyond 1.5, the per subset algorithm tends to perform better than the per state algorithm.",
        "Interestingly, this generalization is supported by the experiments on automata generated by approximation techniques (although the results for randomly generated automata are more consistent than the results for \"real\" examples).",
        "van Noord Epsilon Moves in Subset Construction Comparison with the FSM Library.",
        "We also provide the results for AT&T's FSM library.",
        "FSM is designed to treat weighted automata for very general weight sets.",
        "The initial implementation of the library consisted of an on-the-fly computation of the epsilon closures combined with determinization.",
        "This was abandoned for two reasons: it could not be generalized to the case of general weight sets, and it was not outputting the intermediate epsilon-removed machine (which might be of interest in itself).",
        "In the current version, c-moves must be removed before determinization is possible.",
        "This mechanism thus is comparable to our per graph variant.",
        "Apparently, FSM employs an algorithm equivalent to our per graph.",
        "The resulting determinized machines are generally larger than the machines produced by our integrated variants and the variants that incorporate c-moves on the target side of transitions.",
        "The timings below are obtained for the pipe fsmrmepsilon I fsmdeterminize This is somewhat unfair, since this includes the time to write and read the intermediate machine.",
        "Even so, it is interesting to note that the FSM library is a constant factor faster than our per graph; for larger numbers of jumps the per state and per subset variants consistently beat the FSM library.",
        "Experiment: Automata Generated by Approximation Algorithms.",
        "The automata used in the previous experiments were randomly generated.",
        "However, it may well be that in practice the automata that are to be treated by the algorithm have typical properties not reflected in this test data.",
        "For this reason, results are presented for a number of automata that were generated using approximation techniques for context-free grammars; in particular, for automata created by Nederhof, using the technique described in Nederhof (1997), and a small number of automata created using the technique of Pereira and Wright (1997) (as implemented by Nederhof).",
        "We have restricted our attention to automata with at least 1,000 states in the input.",
        "The automata typically contain lots of jumps.",
        "Moreover, the number of states of the resulting automaton is often smaller than the number of states in the input automaton.",
        "Results are given in Tables 1 and 2.",
        "One of the most striking examples is the ygrim automaton consisting of 3,382 states and 9,124 jumps.",
        "For this example, the per graph implementations ran out of memory (after a long time), whereas the implementation of the per subset algorithm produced the determinized automaton (containing only 9 states) within a single CPU-second.",
        "The FSM implementation took much longer for this example (whereas for many of the other examples it is faster than our implementations).",
        "Note that this example has the highest ratio of number of jumps to number of states.",
        "This confirms the observation that the per subset algorithm performs better on inputs with a high deterministic jump density."
      ]
    },
    {
      "heading": "5. Conclusion",
      "text": [
        "We have discussed a number of variants of the subset construction algorithm for determinizing finite automata containing &moves.",
        "The experiments support the following conclusions: • The integrated variants per subset and per state work much better for automata containing a large number of c-moves.",
        "The per subset variant tends to improve upon the per state algorithm if the number of c-moves increases even further.",
        "The automata generated by approximation algorithms.",
        "The table lists the number of states, transitions, and jumps of the input automaton, and the number of states of the determinized machine using the efrees, efreef, and the efreet'' variants, respectively.",
        "• We have identified four different variants of the per graph algorithm.",
        "In our experiments, the per graph' is the algorithm of choice for automata containing few E-moves, because it is faster than the other algorithms, and because it produces smaller automata than the per graphs and per graphs'a variants.",
        "• The per grapht'e variant is an interesting alternative in that it produces the smallest results.",
        "This variant should be used if the input automaton is expected to contain many non-co-accessible states.",
        "van Noord Epsilon Moves in Subset Construction • Automata produced by finite-state approximation techniques tend to contain many &moves.",
        "We found that for these automata the differences in speed between the various algorithms can be enormous.",
        "The per subset and per state algorithms are good candidates for this application.",
        "We have attempted to characterize the expected efficiency of the various algorithms in terms of the number of jumps and the number of states in the input automaton.",
        "It is quite conceivable that other simple properties of the input automaton can be used even more effectively for this purpose.",
        "One reviewer suggests using the number of strongly &connected components (the strongly connected components of the graph of all &moves) for this purpose.",
        "We leave this and other possibilities to a future occasion."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "I am grateful to Mark-Jan Nederhof for support, and for providing me with lots of (often dreadful) automata generated by his finite-state approximation tools.",
        "The comments of the anonymous FSMNLP and CL reviewers were extremely useful."
      ]
    }
  ]
}
