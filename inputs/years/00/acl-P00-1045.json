{
  "info": {
    "authors": [
      "Marcel P. Van Lohuizen"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P00-1045",
    "title": "Memory-Efficient and Thread-Safe Quasi-Destructive Graph Unification",
    "url": "https://aclweb.org/anthology/P00-1045",
    "year": 2000
  },
  "references": [
    "acl-C92-2068",
    "acl-P85-1017",
    "acl-P91-1041"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "In terms of both speed and memory consumption, graph unification remains the most expensive component of unification-based grammar parsing.",
        "We present a technique to reduce the memory usage of unification algorithms considerably, without increasing execution times.",
        "Also, the proposed algorithm is thread-safe, providing an efficient algorithm for parallel processing as well."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Both in terms of speed and memory consumption, graph unification remains the most expensive component in unification-based grammar parsing.",
        "Unification is a well known algorithm.",
        "Prolog, for example, makes extensive use of term unification.",
        "Graph unification is slightly different.",
        "Two different graph notations and an example unification are shown in Figure 1 and 2, respectively.",
        "In typical unification-based grammar parsers, roughly 90% of the unifications fail.",
        "Any processing to create, or copy, the result graph before the point of failure is",
        "redundant.",
        "As copying is the most expensive part of unification, a great deal of research has gone in eliminating superfluous copying.",
        "Examples of these approaches are given in (Tomabechi, 1991) and (Wroblewski, 1987).",
        "In order to avoid superfluous copying, these algorithms incorporate control data in the graphs.",
        "This has several drawbacks, as we will discuss next.",
        "Memory Consumption To achieve the goal of eliminating superfluous copying, the aforementioned algorithms include administrative fields – which we will call scratch fields – in the node structure.",
        "These fields do not attribute to the definition of the graph, but are used to efficiently guide the unification and copying process.",
        "Before a graph is used in unification, or after a result graph has been copied, these fields just take up space.",
        "This is undesirable, because memory usage is of great concern in many unification-based grammar parsers.",
        "This problem is especially of concern in Tomabechi’s algorithm, as it increases the node size by at least 60% for typical implementations.",
        "In the ideal case, scratch fields would be stored in a separate buffer allowing them to be reused for each unification.",
        "The size of such a buffer would be proportional to the maximum number of nodes that are involved in a single unification.",
        "Although this technique reduces memory usage considerably, it does not reduce the amount of data involved in a single unification.",
        "Nevertheless, storing and loading nodes without scratch fields will be faster, because they are smaller.",
        "Because scratch fields are reused, there is a high probability that they will remain in cache.",
        "As the difference",
        "in speed between processor and memory continues to grow, caching is an important consideration (Ghosh et al., 1997).1 A straightforward approach to separate the scratch fields from the nodes would be to use a hash table to associate scratch structures with the addresses of nodes.",
        "The overhead of a hash table, however, may be significant.",
        "In general, any binding mechanism is bound to require some extra work.",
        "Nevertheless, considering the difference in speed between processors and memory, reducing the memory footprint may compensate for the loss of performance to some extent.",
        "Symmetric Multi Processing Small-scale desktop multiprocessor systems (e.g. dual or even quad Pentium machines) are becoming more commonplace and affordable.",
        "If we focus on graph unification, there are two ways to exploit their capabilities.",
        "First, it is possible to parallelize a single graph unification, as proposed by e.g. (Tomabechi, 1991).",
        "Suppose we are unifying graph a with graph b, then we could allow multiple processors to work on the unification of a and b simultaneously.",
        "We will call this parallel unification.",
        "Another approach is to allow multiple graph unifications to run concurrently.",
        "Suppose we are unifying graph a and b in addition to unifying graph a and c. By assigning a different processor to each operation we obtain what we will call concurrent unification.",
        "Parallel unification exploits parallelism inherent of graph unification itself, whereas concurrent unification exploits parallelism at the context-free grammar backbone.",
        "As long as the number of unification operations in 'Most of today’s computers load and store data in large chunks (called cache lines), causing even uninitialized fields to be transported.",
        "one parse is large, we believe it is preferable to choose concurrent unification.",
        "Especially when a large number of unifications terminates quickly (e.g. due to failure), the overhead of more finely grained parallelism can be considerable.",
        "In the example of concurrent unification, graph a was used in both unifications.",
        "This suggests that in order for concurrent unification to work, the input graphs need to be read only.",
        "With destructive unification algorithms this does not pose a problem, as the source graphs are copied before unification.",
        "However, including scratch fields in the node structure (as Tomabechi’s and Wrob-lewski’s algorithms do) thwarts the implementation of concurrent unification, as different processors will need to write different values in these fields.",
        "One way to solve this problem is to disallow a single graph to be used in multiple unification operations simultaneously.",
        "In (van Lohuizen, 2000) it is shown, however, that this will greatly impair the ability to achieve speedup.",
        "Another solution is to duplicate the scratch fields in the nodes for each processor.",
        "This, however, will enlarge the node size even further.",
        "In other words, Tomabechi’s and Wroblewski’s algorithms are not suited for concurrent unification."
      ]
    },
    {
      "heading": "2 Algorithm",
      "text": [
        "The key to the solution of all of the above-mentioned issues is to separate the scratch fields from the fields that actually make up the definition of the graph.",
        "The resulting data structures are shown in Figure 3.",
        "We have taken Tomabechi’s quasi-destructive graph unification algorithm as the starting point (Tomabechi, 1995), because it is often considered to be the fastest unification algo",
        "reusable scratch fields.",
        "In the permanent structures we use offsets.",
        "Scratch structures use index values (including arcs recorded in comp-arc list).",
        "Our implementation derives offsets from index values stored in nodes.",
        "rithm for unification-based grammar parsing (see e.g. (op den Akker et al., 1995)).",
        "We have separated the scratch fields needed for unification from the scratch fields needed for copying.2 We propose the following technique to associate scratch structures with nodes.",
        "We take an array of scratch structures.",
        "In addition, for each graph we assign each node a unique index number that corresponds to an element in the array.",
        "Different graphs typically share the same indexes.",
        "Since unification involves two graphs, we need to ensure that two nodes will not be assigned the same scratch structure.",
        "We solve this by interleaving the index positions of the two graphs.",
        "This mapping is shown in Figure 4.",
        "Obviously, the minimum number of elements in the table is two times the number of nodes of the largest graph.",
        "To reduce the table size, we allow certain nodes to be deprived of scratch structures.",
        "(For example, we do not forward atoms.)",
        "We denote this with a valuation function v, which returns 1 if the node is assigned an index and 0 otherwise.",
        "We can associate the index with a node by including it in the node structure.",
        "For structure sharing, however, we have to use offsets between nodes (see Figure 4), because otherwise different nodes in a graph may end up having the same index (see Section 3).",
        "Off",
        "sets can be easily derived from index values in nodes.",
        "As storing offsets in arcs consumes more memory than storing indexes in nodes (more arcs may point to the same node), we store index values and use them to compute the offsets.",
        "For ease of reading, we present our algorithm as if the offsets were stored instead of computed.",
        "Note that the small index values consume much less space than the scratch fields they replace.",
        "The resulting algorithm is shown in Figure 5.",
        "It is very similar to the algorithm in (Tomabechi, 1991), but incorporates our indexing technique.",
        "Each reference to a node now not only consists of the address of the node structure, but also its index in the table.",
        "This is required because we cannot derive its table index from its node structure alone.",
        "The second argument of COPY indicates the next free index number.",
        "Copy returns references with an offset, allowing them to be directly stored in arcs.",
        "These offsets will be negative when COPY exits at line 2.2, resembling a reentrancy.",
        "Note that only AbsArc explicitly defines operations on offsets.",
        "AbsArc computes a node’s index using its parent node’s index and an offset.",
        "aWe assign even and odd indexes to the nodes of dg1 and dg2, respectively.",
        "bTables only needs to be cleared up to point where unification failed.",
        "cCompare indexes to allow more powerful structure sharing.",
        "Note that indexes uniquely identify a node in the case that for all nodes n holds v(n) = 1. dNote that we are multiplying the offset by 2 to account for the interleaved offsets of the left and right graph.",
        "eWe assume it is known at this point whether the new node requires an index number.",
        "fNote that ref contains an index, whereas ref1 contains an offset.",
        "gIf the node was already copied (in which case it is < 0), we need not reserve indexes.",
        "Contrary to Tomabechi’s implementation, we invalidate scratch fields by simply resetting them after a unification completes.",
        "This simplifies the algorithm.",
        "We only reset the table up to the highest index in use.",
        "As table entries are roughly filled in increasing order, there is little overhead for clearing unused elements.",
        "A nice property of the algorithm is that indexes identify from which input graph a node originates (even=left, odd=right).",
        "This information can be used, for example, to selectively share nodes in a structure sharing scheme.",
        "We can also specify additional scratch fields or additional arrays at hardly any cost.",
        "Some of these abilities will be used in the enhancements of the algorithm we will discuss next."
      ]
    },
    {
      "heading": "3 Enhancements",
      "text": [
        "Structure Sharing Structure sharing is an important technique to reduce memory usage.",
        "We will adopt the same terminology as Tomabechi in (Tomabechi, 1992).",
        "That is, we will use the term feature-structure sharing when two arcs in one graph converge to the same node in that graph (also refered to as reentrancy) and data-structure sharing when arcs from two different graphs converge to the same node.",
        "The conditions for sharing mentioned in (Tomabechi, 1992) are: (1) bottom and atomic nodes can be shared; (2) complex nodes can be shared unless they are modified.",
        "We need to add the following condition: (3) all arcs in the shared subgraph must have the same offsets as the subgraph that would have resulted from copying.",
        "A possible violation of this constraint is shown in Figure 6.",
        "As long as arcs are processed in increasing order of index number,3 this condition can only be violated in case of reentrancy.",
        "Basically, the condition can be violated when a reentrancy points past a node that is bound to a larger subgraph.",
        "Contrary to many other structure sharing schemes (like (Malouf et al., 2000)), our algorithm allows sharing of nodes that are part of the grammar.",
        "As nodes from the different input graphs are never assigned the same table entry, they are always bound independently of each other.",
        "(See the footnote for line 3 of Unify1.)",
        "The sharing version of Copy is similar to the variant in (Tomabechi, 1992).",
        "The extra check can be implemented straightforwardly by comparing the old offset with the offset for the new nodes.",
        "Because we derive the offsets from index values associated with nodes, we need to compensate for a difference between the index of the shared node and the index it should have in the new graph.",
        "We store this information in a specialized share arc.",
        "We need to adjust Unify1 to handle share arcs accordingly.",
        "Deferred Copying Just as we use a table for unification and copying, we also use a table for subsumption checking.",
        "Tomabechi’s algorithm requires that the graph resulting",
        "from unification be copied before it can be used for further processing.",
        "This can result in superfluous copying when the graph is subsumed by an existing graph.",
        "Our technique allows subsumption to use the bindings generated by Unify1 in addition to its own table.",
        "This allows us to defer copying until we completed subsumption checking.",
        "Packed Nodes With a straightforward implementation of our algorithm, we obtain a node size of 8 bytes.4 By dropping the concept of a fixed node size, we can reduce the size of atom and bottom nodes to 4 bytes.",
        "Type information can be stored in two bits.",
        "We use the two least significant bits of pointers (which otherwise are 0) to store this type information.",
        "Instead of using a pointer for the value field, we store nodes in place.",
        "Only for reentrancies we still need pointers.",
        "Complex nodes require 8 bytes, as they include a pointer to the first node past its children (necessary for unification).",
        "This scheme requires some extra logic to decode nodes, but significantly reduces memory consumption."
      ]
    },
    {
      "heading": "4 Experiments",
      "text": [
        "We have tested our algorithm with a medium-sized grammar for Dutch.",
        "The system was implemented in Objective-C using a fixed ar-ity graph representation.",
        "We used a test set of 22 sentences of varying length.",
        "Usually, approximately 90% of the unifications fails.",
        "On average, graphs consist of 60 nodes.",
        "The experiments were run on a Pentium III 600EB (256 KB L2 cache) box, with 128 MB memory, running Linux.",
        "We tested both memory usage and execution time for various configurations.",
        "The results are shown in Figure 7 and 8.",
        "It includes a version of Tomabechi’s algorithm.",
        "The node size for this implementation is 20 bytes.",
        "For the proposed algorithm we have included several versions: a basic implementation, a packed version, a version with deferred copying, and a version with structure sharing.",
        "The basic implementation has a node size of 8 bytes, the others have a variable node size.",
        "Whenever applicable, we applied the same optimizations to all algorithms.",
        "We also tested the speedup on a dual Pentium II 266 Mhz.5 Each processor was assigned its own scratch tables.",
        "Apart from that, no changes to the",
        "algorithm were required.",
        "For more details on the multiprocessor implementation, see (van Lohuizen, 1999).",
        "The memory utilization results show significant improvements for our approach.6 Packing decreased memory utilization by almost 40%.",
        "Structure sharing roughly halved this once more.",
        "The third condition prohibited sharing in less than 2% of the cases where it would be possible in Tomabechi’s approach.",
        "Figure 7 shows that our algorithm does not increase execution times.",
        "Our algorithm even scrapes off roughly 7% of the total parsing time.",
        "This speedup can be attributed to improved cache utilization.",
        "We verified this by running the same tests with cache disabled.",
        "This made our algorithm actually run slower than Tomabechi’s algorithm.",
        "Deferred copying did not improve performance.",
        "The additional overhead of dereferencing during subsumption was not compensated by the savings on copying.",
        "Structure sharing did not significantly alter the performance as well.",
        "Although, this version uses less memory, it has to perform additional work.",
        "Running the same tests on machines with less memory showed a clear performance advantage for the algorithms using less memory, because paging could be avoided."
      ]
    },
    {
      "heading": "5 Related Work",
      "text": [
        "We reduce memory consumption of graph unification as presented in (Tomabechi, 1991) (or (Wroblewski, 1987)) by separating scratch fields from node structures.",
        "Pereira’s (Pereira, 1985) algorithm also stores changes to nodes separate from the graph.",
        "However, Pereira’s mechanism incurs a log(n) overhead for accessing the changes (where n is the number of nodes in a graph), resulting in an O(n log n) time algorithm.",
        "Our algorithm runs in O(n) time.",
        "size, structure sharing yielded less relative improvements than when applied to the basic version.",
        "In terms of number of nodes, though, the two results were identical.",
        "With respect to over and early copying (as defined in (Tomabechi, 1991)), our algorithm has the same characteristics as Tomabechi’s algorithm.",
        "In addition, our algorithm allows to postpone the copying of graphs until after subsumption checks complete.",
        "This would require additional fields in the node structure for Tomabechi’s algorithm.",
        "Our algorithm allows sharing of grammar nodes, which is usually impossible in other implementations (Malouf et al., 2000).",
        "A weak point of our structure sharing scheme is its extra condition.",
        "However, our experiments showed that this condition can have a minor impact on the amount of sharing.",
        "We showed that compressing node structures allowed us to reduce memory consumption by another 40% without sacrificing performance.",
        "Applying the same technique to Tomabechi’s algorithm would yield smaller relative improvements (max.",
        "20%), because the scratch fields cannot be compressed to the same extent.",
        "One of the design goals of Tomabechi’s algorithm was to come to an efficient implementation of parallel unification (Tomabechi, 1991).",
        "Although theoretically parallel unification is hard (Vitter and Simons, 1986), Tomabechi’s algorithm provides an elegant solution to achieve limited scale parallelism (Fujioka et al., 1990).",
        "Since our algorithm is based on the same principles, it allows parallel unification as well.",
        "Tomabechi’s algorithm, however, is not thread-safe, and hence cannot be used for concurrent unification."
      ]
    },
    {
      "heading": "6 Conclusions",
      "text": [
        "We have presented a technique to reduce memory usage by separating scratch fields from nodes.",
        "We showed that compressing node structures can further reduce the memory footprint.",
        "Although these techniques require extra computation, the algorithms still run faster.",
        "The main reason for this was the difference between cache and memory speed.",
        "As current developments indicate that this difference will only get larger, this effect is not just an artifact of the current architectures.",
        "We showed how to incoporate data-structure sharing.",
        "For our grammar, the additional constraint for sharing did not pose a problem.",
        "If it does pose a problem, there are several techniques to mitigate its effect.",
        "For example, one could reserve additional indexes at critical positions in a subgraph (e.g. based on type information).",
        "These can then be assigned to nodes in later unifications without introducing conflicts elsewhere.",
        "Another technique is to include a tiny table with repair information in each share arc to allow a small number of conflicts to be resolved.",
        "For certain grammars, data-structure sharing can also significantly reduce execution times, because the equality check (see line 3 of Unify1) can intercept shared nodes with the same address more frequently.",
        "We did not exploit this benefit, but rather included an offset check to allow grammar nodes to be shared as well.",
        "One could still choose, however, not to share grammar nodes.",
        "Finally, we introduced deferred copying.",
        "Although this technique did not improve performance, we suspect that it might be beneficial for systems that use more expensive memory allocation and deallocation models (like garbage collection).",
        "Since memory consumption is a major concern with many of the current unification-based grammar parsers, our approach provides a fast and memory-efficient alternative to Tomabechi’s algorithm.",
        "In addition, we showed that our algorithm is well suited for concurrent unification, allowing to reduce execution times as well."
      ]
    }
  ]
}
