{
  "info": {
    "authors": [
      "Marcel P. Van Lohuizen"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P01-1065",
    "title": "A Generic Approach to Parallel Chart Parsing With an Application to LinGO",
    "url": "https://aclweb.org/anthology/P01-1065",
    "year": 2001
  },
  "references": [
    "acl-C96-1082",
    "acl-P00-1045",
    "acl-P91-1041",
    "acl-P94-1040"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Multiprocessor systems are becoming more commonplace and affordable.",
        "Based on analyses of actual parsings, we argue that to exploit the capabilities of such machines, unification-based grammar parsers should distribute work at the level of individual unification operations.",
        "We present a generic approach to parallel chart parsing that meets this requirement, and show that an implementation of this technique for LinGO achieves considerable speedups."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The increasing demand for accuracy and robustness for todays unification-based grammar parsers brings on an increasing demand for computing power.",
        "In addition, as these systems are increasingly used in applications that require direct user interaction, e.g. web-based applications, responsiveness is of major concern.",
        "In the mean time, small-scale desktop multiprocessor systems (e.g. dual or even quad Pentium machines) are becoming more commonplace and affordable.",
        "In this paper we will show that exploiting the capabilities of these machines can speed up parsers considerably, and can be of major importance in achieving the required performance.",
        "There are certain requirements the design of a parallel parser should meet.",
        "Over the past years, many improvements to existing parsing techniques have boosted the performance of parsers by many factors (Oepen and Callmeier, 2000).",
        "If a design of a parallel parser is tied too much to a particular approach to parsing, it may be hard to incorporate such improvements as they become available.",
        "For this reason, a solution to parallel parsing should be as general as possible.",
        "One obvious way to ensure that optimizations for sequential parsers can be used in a parallel parser as well is to let a parallel parser mimic a sequential parser as much as possible.",
        "This is basically the approach we will take.",
        "The parser that we will present in this paper uses the LinGO grammar.",
        "LinGO is an HPSG-based grammar which was developed at Stanford (Copestake, 2000).",
        "It is currently used by many research institutions.",
        "This allows our results to be compared with that of other research groups.",
        "In Section 2, we explore the possibilities for parallelism in natural language parsing by analyzing the computational structure of parsings.",
        "Section 3 and 4 discuss respectively the design and the performance of our system.",
        "Finally, we compare our work with other research on parallel parsing."
      ]
    },
    {
      "heading": "2 Analysis of Parsings",
      "text": [
        "To analyze the possibilities for parallelism in computations they are often represented as task graphs.",
        "A task graph is a directed acyclic graph, where the nodes represent some unit of computation, called a task, and the arcs represent the execution dependencies between the tasks.",
        "Task graphs can be used to analyze the critical path, which is the minimal time required to complete a computation, given an infinite amount of processors.",
        "From Brent (1974) and Graham (1969) we know that there exist P-processor schedulings where the execution time Tp is bound as follows: Tp G T1/P+T.,(1) where T1 is the total work, or the execution time for the one processor case, and T,,,, is the critical path.",
        "Furthermore, to effectively use P processors, the average parallelism P = T1 /T,,,, should be larger than P. The first step of the analysis is to find an appropriate graph representation for parsing computations.",
        "According to Caroll (1994), performing a complexity analysis solely at the level of grammars and parsing schemata can give a distorted image of the parsing process in practice.",
        "For this reason, we based our analysis on actual parsings.",
        "The experiments were based on the fuse test suite, which is a balanced extract from four appointment scheduling (spoken) dialogue corpora (incl.",
        "VerbMobil).",
        "Fuse contains over 2000 sentences with an average length of 11.6.",
        "We define a task graph for a single parsing computation as follows.",
        "First, we distinguish two types of tasks: unification tasks and match tasks.",
        "A unification task executes a single unification operation.",
        "A match task is responsible for all the actions that are taken when a unification succeeds: matching the resulting edge with other edges in the chart and putting resulting unification tasks on the agenda.",
        "The match task is also responsible for applying filtering techniques like the quick check (Malouf et al., 2000).",
        "The tasks are connected by directed arcs that indicate the execution dependencies.",
        "We define the cost of each unification task as the number of nodes visited during the unification and successive copying operation.",
        "Unification operations are typically responsible for over 90% of the total work.",
        "In addition, the cost of the match tasks are spread out over succeeding unification tasks.",
        "We therefore simply neglect the cost for match operations, and assume that this does not have a significant impact on our measurements.",
        "The length of a path in the graph can now be defined as the sum of the costs of all nodes on",
        "type 2 task graphs (average and worst case).",
        "the path.",
        "The critical path length T,,,, can be defined as the longest path between any two nodes in the graph.",
        "The presented model resembles a very fine-grained scheme for distributing work, where each single unification tasks to be scheduled independently.",
        "In a straightforward implementation of such a scheme, the scheduling overhead can become significant.",
        "Limiting the scheduling overhead is crucial in obtaining considerable speedup.",
        "It might therefore be tempting to group related tasks into a single unit of execution to mitigate this overhead.",
        "For this reason we also analyzed a task graph representation where only match tasks spawn a new unit of execution.",
        "The top graph in Figure 1 shows an example of a task graph for the first approach.",
        "The bottom graph of Figure 1 shows the corresponding task graph for the second approach.",
        "Note that because a unification task may depend on more than one match task, a choice has to be made in which unit of execution the unification task is put.",
        "Table 1 shows the results of the critical path analysis of both approaches.",
        "For the first approach, the critical path is uniquely defined.",
        "For the second approach we show both the worst case, considering all possible schedulings, and an average case.",
        "The results for T1, Tom, and P are averaged over all sentences.",
        "The results show that, using the first approach, there is a considerable amount of parallelism in the parsing computations.",
        "The results also show that a small change in the design of a parallel parser can have a significant impact on the value for P. To obtain a speedup of P, in practice, there should be a safety margin between P and P. This suggests that the first approach is a considerably saver choice, especially when one is considering using more than a dozen of processors."
      ]
    },
    {
      "heading": "3 Design and Implementation",
      "text": [
        "Based on the discussion in the preceding sections, we can derive two requirements for the design of a parallel parser: it should be close in design to a sequential parser and it should allow each single unification operation to be scheduled dynamically.",
        "The parallel parser we will present in this section meets both requirements.",
        "Let us first focus on how to meet the first requirement.",
        "Basically, we let each processor, run a regular sequential parser augmented with a mechanism to combine the results of the different parsers.",
        "Each sequential parser component is contained in a different thread.",
        "By using threads, we allow each parser to share the same memory space.",
        "Initially, each thread is assigned a different set of work, for example, resembling a different part of the input string.",
        "A thread will process the unification tasks on the agenda and, on success, will perform the resulting match task to match the new edge with the edges on its chart.",
        "After completing the work on its agenda, a thread will match the edges on its chart with the edges derived so far by the other threads.",
        "This may produce new unification tasks, which the thread puts on its agenda.",
        "After the communication phase is completed, it returns to normal parsing mode to execute the work on its agenda.",
        "This process continues until all edges 1 Note that since E T1 / E T. =# E T1 /T., the results for P turn out slightly lower than might have been expected from the values of T1 and T..",
        "of all threads have been matched against each other and all work has been completed."
      ]
    },
    {
      "heading": "3.1 Data Structures",
      "text": [
        "Figure 2 shows an outline of our approach in terms of data structures.",
        "Each thread contains an agenda, which can be seen as a queue of unification tasks, a chart, which stores the derived edges, and a heap, which is used to store the typed-feature structures that are referenced by the edges.",
        "Each thread has full access to its own agenda, chart, and heap, and has read-only access to the respective structures of all other threads.",
        "Grammars are read-only and can be read by all threads.",
        "In the communication phase, threads need read-only access to the edges derived by other threads.",
        "This is especially problematic for the feature structures.",
        "Many unification algorithms need write access to scratch fields in the graph structures.",
        "Such algorithms are therefore not thread-safe.2 For this reason we use the thread-safe unification algorithm presented by Van Lohuizen (2000), which is comparable in performance to Tomabechis algorithm (Tomabechi, 1991).",
        "Note that each thread also has its own agenda.",
        "Some parsing systems require strict control over the order of evaluation of tasks.",
        "The distributed agendas that we use in our approach may make it hard to implement such a strict control.",
        "One solution to the problem would be to use a centralized agenda.",
        "The disadvantage of such a solution is that it might increase the synchronization overhead.",
        "Techniques to reduce the synchronization overhead 2I n this context, thread safe means that the same data structure can be involved in more than one operation, of more than one thread, simultaneously.",
        "global shared NrThreadsIdle, Generation, IdleGen Sched() var threadGen, newWork, isIdle",
        "thread Gen +Generation +Generation +1 while NrThreadsIdle =# P do 1. newWork + not IsEmpty(agenda).",
        "2.",
        "Process the agenda as in the sequential case.",
        "In addition, stamp each newly derived I edge by setting I.generation to the current value for threadGen and add I to this threads edge list.",
        "3.",
        "Examine all the other threads for newly derived edges.",
        "For each new edge I and for each edge J on the chart for which holds I.generation > J.generation, add the corresponding task to the agenda if it passes the filter.",
        "If any edge was processed, set newWork to true.",
        "4. if not newWork then newWork +Steal() 5. lock GlobalLock 6. if newWork then",
        "in such a setup can be found in (Markatos and LeBlanc, 1992)."
      ]
    },
    {
      "heading": "3.2 Scheduling Algorithm",
      "text": [
        "At startup, each thread calls the scheduling algorithm shown in Figure 3.",
        "This algorithm can be seen as a wrapper around an existing sequential parser that takes care of combining the results of the individual threads.",
        "The functionality of the sequential parser is embedded in step 2.",
        "After this step, the agenda will be empty.",
        "The communication between threads takes place in step 3.",
        "Each time a thread executes this step, it will proceed over all the newly derived edges of other threads (foreign edges) and match them with the edges on its own chart (local edges).",
        "Checking the newly derived edges of other threads can simply be done by proceeding over a linked list of derived edges maintained by the respective threads.",
        "Threads record the last visited edge of the list of each other thread.",
        "This ensures that each newly derived item needs to be visited only once by each thread.",
        "As a result of step 3, the agenda may become non-empty.",
        "In this case, newWork will be set and step 2 is executed again.",
        "This cycle continues until all work is completed.",
        "The remaining steps serve several purposes: load balancing, preventing double work, and detecting termination.",
        "We will explain each of these aspects in the following sections.",
        "Note that step 6 and 7 are protected by a lock.",
        "This ensures that no two threads can execute this code simultaneously.",
        "This is necessary because Step 6 and 7 write to variables that are shared amongst threads.",
        "The overhead incurred by this synchronization is minimal, as a thread typically iterates over this part only a small number of times.",
        "This is because the depth of the derivation graph of any edge is limited (average 14, maximum 37 for the fuse test set)."
      ]
    },
    {
      "heading": "3.3 Work Stealing",
      "text": [
        "In the design as presented so far, each thread exclusively executes the unification tasks on its agenda.",
        "Obviously, this violates the requirement that each unification task should be scheduled dynamically.",
        "In (Blumofe and Leiserson, 1993), it is shown that for any multi-threaded computation with work Ti and task graph depth Tom, and for any number P of processors, a scheduling will achieve Tp G Ti /P + Tc,,, if for the scheduling holds that whenever there are more than P tasks ready, all P threads are executing work.",
        "In other words, as long as there is work on any queue, no thread should be idle.",
        "An effective technique to ensure the above requirement is met is work stealing (Frigo et al., 1998).",
        "With this technique, a thread will first attempt to steal work from the queue of another thread before denouncing itself to be idle.",
        "If it succeeds, it will resume normal execution as if the stolen tasks were its own.",
        "Work stealing incurs less synchronization overhead than, for example, a centralized work queue.",
        "In our implementation, a thread becomes a thief by calling Steal, at step 4 of Sched.",
        "STEAL allows stealing from two types of queues: the agendas, which contain outstanding unification tasks, and the unchecked foreign edges, which resemble outstanding match tasks between threads.",
        "A thief first picks a random victim to steal from.",
        "It first attempts to steal the victims match tasks.",
        "If it succeeds, it will perform the matches and put any resulting unification tasks on its own agenda.",
        "If it cannot gain exclusive access to the lists of unchecked foreign edges, or if there were no matches to be performed, it will attempt to steal work from the victims agenda.",
        "A thief will steal half of the work on the agenda.",
        "This balances the load between the two threads and minimizes the chance that either thread will have to call the expensive steal operation soon thereafter.",
        "Note that idle threads will keep calling STEAL until they either obtain new work or all other threads become idle.",
        "Obviously, stealing eliminates the exclusive ownership of the agenda and unchecked foreign edge lists of the respective threads.",
        "As a consequence, a thread needs to lock its agenda and edge lists each time it needs to access it.",
        "We use an asymmetric mutual exclusion scheme, as presented in (Frigo et al., 1998), to minimize the cost of locking for normal processing and move more of the overhead to the side of the thief."
      ]
    },
    {
      "heading": "3.4 Preventing Duplicate Matches",
      "text": [
        "When two matching edges are stored on the charts of two different threads, it should be prevented that both threads will perform the corresponding match.",
        "Failing to do so can cause the derivation of duplicate edges and eventually a combinatorial explosion of work.",
        "Our solution is based on a generation scheme.",
        "Each newly derived edge is stamped with the current generation of the respective thread, thread Gen (see step 2).",
        "In addition, a thread will only perform the match for two edges if the edge on its chart has a lower generation than the foreign edge (see step 3).",
        "Obviously, because the value of threadGen is unique for the thread (see step 6), this scheme prevents two edges from being matched twice.",
        "SCHED also ensures that two matching edges will always be matched by at least one thread.",
        "After a thread completes step 3, it will always raise its generation.",
        "The new generation will be greater than that of any foreign edge processed before.",
        "This ensures that when an edge is put on the chart, no foreign edge with a higher generation has been matched against the respective chart before."
      ]
    },
    {
      "heading": "3.5 Termination",
      "text": [
        "A thread may terminate when all work is completed, that is, if and only if the following conditions hold simultaneously: all agendas of all threads are empty, all possible matches between edges have been processed, and all threads are idle.",
        "Step 7 of SCHED enforces that these conditions hold before any thread leaves Sched.",
        "Basically, each thread determines for itself whether its queues are empty and raises the global counter NrThreadsIdle accordingly.",
        "When all threads are idle simultaneously, the parser is finished.",
        "A threads agenda is guaranteed to be empty whenever newWork is false at step 7.",
        "The same does not hold for the unchecked foreign edges.",
        "Whenever a thread derives a new edge, all other edges need to perform the corresponding matches.",
        "The following mechanism enforces this.",
        "The first thread to become idle raises the global generation and records it in IdleGen.",
        "Subsequent idle threads will adopt this as their idle generation.",
        "Whenever a thread derives a new edge, it will raise Generation and reset NrThreadsIdle (step 6).",
        "This invalidates IdleGen which implicitly removes the idle status from all threads.",
        "Note that step 7 lets each thread perform an additional iteration before raising NrThreadsIdle.",
        "This allows a thread to check for foreign edges that were derived after step 3 and before 7.",
        "Once all work is done, detecting termination",
        "suite for various number of processors.",
        "requires at most 2P synchronization steps.3"
      ]
    },
    {
      "heading": "3.6 Implementation",
      "text": [
        "The implementation of the system consists of two parts: MACAMBA and CaLi.",
        "MACAMBA stands for Multi-threading Architecture for Chart And Memoization-Based Applications.",
        "The MACAMBA framework provides a set of objects that implement the scheduling technique presented in the previous section.",
        "It also includes a set of support objects like charts and a thread-safe unification algorithm.",
        "CaLi is an instance of a MACAMBA application that implements a Chart parser for the LinGO grammar.",
        "The design of CaLi was based on PET (Callmeier, 2000), one of the fastest parsers for LinGO.",
        "It implements the quick check (Malouf et al., 2000), which, together with the rule check, takes care of filtering over 90% of the failing unification tasks before they are put on the agenda.",
        "MACAMBA and CaLi were both implemented in Objective-C and currently run on Windows NT, Linux, and Solaris."
      ]
    },
    {
      "heading": "4 Performance Results",
      "text": [
        "The performance of the sequential version of CaLi is comparable to that of PET .4 In addition, for the single-processor parallel version of CaLi the total overhead incurred by scheduling is less than 1%.",
        "The first set of experiments consisted of running the fuse test suite on a SUN Ultra Enterprise with 8 nodes, each with a 400 MHz 3N o locking is required once a thread is idle.",
        "4Respectively, 1231s and 1339s on a 500MHz P-III, where both parsers used the same parsing schema.",
        "UltraSparc processor, for a varying number of processors.",
        "Table 2 shows the results of these experiments.",
        "The execution times for each parse are measured in wall clock time.",
        "The time measurement of a parse is started before the first thread starts working and ends only when all threads have stopped.",
        "The fuse test suite contains a large number of small sentences that are hard to parallelize.",
        "These results indicate that deploying multiple processors on all input sentences unconditionally still gives a considerable overall speedup.",
        "The second set of experiments were run on a SUN Enterprise10000 with 64 250 MHz UltraSparc II processors.",
        "To limit the amount of data generated by the experiments, and to increase the accuracy of the measurements, we selected a subset of the sentences in the fuse suite.",
        "The parser is able to parse many sentences in the fuse suite in fewer than several milliseconds.",
        "Measuring speedup is inaccurate in these cases.",
        "We therefore eliminated such sentences from the test suite.",
        "From the remaining sentences we made a selection of 500 sentences of various lengths.",
        "The results are shown in Figure 4.",
        "The figure includes a graph for the maximum, minimum, and average speedup obtained over all sentences.",
        "The maximum speedup of 31.4 is obtained at 48 processors.",
        "The overall peak is reached at 32 processors where the average speedup is 17.3.",
        "One of the reasons for the decline in speedup after 32 processors is the overhead in the scheduling algorithm.",
        "Most notably, the total number of top-level iterations of Sched increases for larger P. The minimum speedups of around 1 are obtained for, often small, sentences that contain too little inherent parallelism to be parallelized effectively.",
        "Figure 4 shows a graph of the parallel efficiency, which is defined as speedup divided by the number of processors.",
        "The average efficiency remains close to 80% up till 16 processors.",
        "Note that super linear speedup is achieved with up to 12 processors, repeatedly for the same set of sentences.",
        "Super lin5Because the system was shared with other users, only 6 processors could be utilized.",
        "speedup and parallel efficiency based on wall clock time.",
        "ear speedup can occur because increasing the number of processors also reduces the amount of data handled by each node.",
        "This reduces the chance of cache misses."
      ]
    },
    {
      "heading": "5 Related Work",
      "text": [
        "Parallel parsing for NLP has been researched extensively.",
        "For example, Thompson (1994) presented some implementations of parallel chart parsers.",
        "Nijholt (1994) gives a more theoretical overview of parallel chart parsers.",
        "A survey of parallel processing in NLP is given by Adriaens and Hahn (1994).",
        "Nevertheless, many of the presented solutions either did not yield acceptable speedup or were very specific to one application.",
        "Recently, several NLP systems have been parallelized successfully.",
        "Pontelli et al.",
        "(1998) show how two existing NLP applications were successfully parallelized using the parallel Prolog environment ACE.",
        "The disadvantage of this approach, though, is that it can only be applied to parsers developed in Prolog.",
        "Manousopoulou et al.",
        "(1997) discuss a parallel parser generator based on the Eu-PAGE system.",
        "This solution exploits coarse-grained parallelism of the kind that is unusable for many parsing applications, including our own (see also Gorz et.",
        "al.",
        "(1996)).",
        "Nurkkala et al.",
        "(1994) presented a parallel parser for the UPenn TAG grammar, implemented on the nCUBE.",
        "Although their best results were obtained with random grammars, speedups for the English grammar were also considerable.",
        "Yoshida et.",
        "al.",
        "(Yoshida et al., 1999) presented a 2-phase parallel FB-LTAG parser, where the operations on feature structures are all performed in the second phase.",
        "The speedup ranged up to 8.8 for 20 processors, Parallelism is mainly thwarted by a lack of parallelism in the first phase.",
        "Finally, Ninomiya et al.",
        "(2001) developed an agent-based parallel parser that achieves speedups of up to 13.2.",
        "It is implemented in ABCL/ f and LiLFeS.",
        "They also provide a generic solution that could be applied to many parsers.",
        "The main difference with our system is the distribution of work.",
        "This system uses a tabular chart like distribution of matches and a randomized distribution of unification tasks.",
        "Experiments we conducted show that the choice of distribution scheme can have a significant influence on the cache utilization.",
        "It should be mentioned, though, that it is in general hard to compare the performance of systems when different grammars are used.",
        "On the scheduling side, our approach shows close resemblance to the Cilk-5 system (Frigo et al., 1998).",
        "It implements work stealing using similar techniques.",
        "An important difference, though, is that our scheduler was designed for chart parsers and tabular algorithms in general.",
        "These types of applications fall outside the class of applications that Cilk is capable of handling efficiently."
      ]
    },
    {
      "heading": "6 Conclusions",
      "text": [
        "We showed that there is sufficient parallelism in parsing computations and presented a parallel chart parser for LinGO that can effectively exploit this parallelism by achieving considerable speedups.",
        "Also, the presented techniques do not rely on a particular parsing schema or grammar formalism, and can therefore be useful for other parsing applications."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "Thanks to Makino Takaki and Takashi Ninomiya of the Department of Information Science, University of Tokyo, for running the 164 processor experiments at their departments computer."
      ]
    }
  ]
}
