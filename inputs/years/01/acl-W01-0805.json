{
  "info": {
    "authors": [
      "Emiel Krahmer",
      "Sebastiaan Van Erk",
      "Andre Verleg"
    ],
    "book": "Workshop on Natural Language Generation EWNLG",
    "id": "acl-W01-0805",
    "title": "A Meta-Algorithm for the Generation of Referring Expressions",
    "url": "https://aclweb.org/anthology/W01-0805",
    "year": 2001
  },
  "references": [
    "acl-E91-1028",
    "acl-J95-2003",
    "acl-P00-1012",
    "acl-P90-1013",
    "acl-P97-1027",
    "acl-W00-1424",
    "acl-W98-1419",
    "acl-W98-1426"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper describes a new approach to the generation of referring expressions.",
        "We propose to formalize a scene as a labeled directed graph and describe content selection as a subgraph construction problem.",
        "Cost functions are used to guide the search process and to give preference to some solutions over others.",
        "The resulting graph algorithm can be seen as a meta-algorithm in the sense that defining cost functions in different ways allows us to mimic – and even improve – a number of well-known algorithms."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The generation of referring expressions is one of the most common tasks in natural language generation, and has been addressed by many researchers in the past two decades (including Appelt 1985, Dale 1992, Reiter 1990, Dale & Haddock 1991, Dale & Reiter 1995, Horacek 1997, Stone & Webber 1998, Krahmer & Theune 1999 and van Deemter 2000).",
        "As a result, there are many different algorithms for the generation of referring expressions, each with its own objectives: some aim at producing the shortest possible description, others focus on efficiency or realistic output.",
        "The degree of detail in which the various algorithms are described differs considerably, and as a result it is often difficult to compare the various proposals.",
        "In addition, most of the algorithms are primarily concerned with the generation of descriptions only using properties of the target object.",
        "Consequently, the problem of generating relational descriptions (i.e., descriptions which incorporate references to other objects to single out the target object) has not received the attention it deserves.",
        "In this paper, we describe a general, graph-theoretic approach to the generation of referring expressions.",
        "We propose to formalize a scene (i.e., a domain of objects and their properties and relations) as a labeled directed graph and describe the content selection problem – which properties and relations to include in a description for an object? – as a subgraph construction problem.",
        "The graph perspective has three main advantages.",
        "The first one is that there are many attractive algorithms for dealing with graph structures.",
        "In this paper, we describe a branch and bound algorithm for finding the relevant subgraphs, where we use cost functions to guide the search process.",
        "Arguably, the proposed algorithm is a meta-algorithm, in the sense that by defining the cost function in different ways, we can mimic various well-known algorithms for the generation of referring expressions.",
        "A second advantage of the graph-theoretical framework is that it does not run into problems with relational descriptions, due to the fact that properties and relations are formalized in the same way, namely as edges in a graph.",
        "The third advantage is that the combined usage of graphs and cost-functions paves the way for a natural integration of traditional rule-based approaches to generation with more recent statistical approaches (e.g., Langkilde & Knight 1998,",
        "The outline of this paper is as follows.",
        "In section 2, we describe how scenes can be described as labeled directed graphs and show how content selection can be formalized as a subgraph construction problem.",
        "Section 3 contains a sketch of the branch and bound algorithm, which is illustrated with a worked example.",
        "In section 4 it is argued that by defining cost functions in different ways, we can mimic various well-known algorithms for the generation of referring expressions.",
        "We end with some concluding remarks in section 5."
      ]
    },
    {
      "heading": "2 Graphs",
      "text": [
        "Consider the following scene:",
        "In this scene, as in any other scene, we see a finite set of entities with properties and relations .",
        "In this particular scene, the set is the set of entities, dog, chihuahua, doghouse, small, large, white, brown is the set of properties and next to, left of, right of, contain, in is the set of relations.",
        "A scene can be represented in various ways.",
        "One common representation is to build a database, listing the properties of each element of : Here we take a different approach and represent a scene as a labeled directed graph.",
        "Let be the set of labels (with and disjoint, i.e., ).",
        "Then, a labeled directed graph , where is the set of vertices (or nodes) and is the set of labeled directed arcs (or edges).",
        "The scene given in Figure 1 can be represented by the graph in Figure 2.",
        "Keep in mind that the labels are only added to ease reference to nodes.",
        "Notice also that properties (such as being a dog) are always modelled as loops, i.e., edges which start and end in the same node, while relations may (but need not) have different start and end nodes.",
        "Now the content determination problem for referring expressions can be formulated as a graph construction task.",
        "In order to decide which information to include in a referring expression for an object , we construct a connected directed labeled graph over the set of labels and an arbitrary set of nodes, but including .",
        "This graph can be understood as the “meaning representation” from which a referring expression can be generated by a linguistic realizer.",
        "Informally, we say that a graph refers to a given entity iff the graph can be “placed over” the scene graph in such a way that the node being referred to is “placed over” the given entity and each edge can be “placed over” an edge labeled with the same label.",
        "Furthermore, a graph is distinguishing iff it refers to exactly one node in the scene graph.",
        "Consider the three graphs in Figure 3.",
        "Here and elsewhere circled nodes stand for the intended referent.",
        "Graph (i) refers to all nodes of the graph in Figure 2 (every object in the scene is next to some other object), graph (ii) can refer to both and , and graph (iii) is distinguishing in that it can only refer to .",
        "Notice that the three graphs might be realized as something next to something else, a chihuahua and the dog in the doghouse respectively.",
        "In this paper, we will concentrate on the generation of distinguishing graphs.",
        "Formally, the notion that a graph can be “placed over” another graph corresponds to the notion of a subgraph isomorphism.",
        "can be “placed over” iff there exists a subgraph of such that is isomorphic to .",
        "is isomorphic to iff there exists a bijection such that for all nodes and all In words: the bijective function maps all the nodes in to corresponding nodes in , in such a way that any edge with label between nodes",
        "and in is matched by an edge with the same label between the counterparts of and , i.e., and respectively.",
        "When is isomorphic to some subgraph of by an isomorphism , we write .",
        "Given a graph and a node in , and a graph and a node in , we define that the pair refers to the pair iff is connected and and .",
        "Furthermore, uniquely refers to (i.e., is distinguishing) iff refers to and there is no node in different from such that refers to .",
        "The problem considered in this paper can now be formalized as follows: given a graph and a node in , find a pair such that uniquely refers to .",
        "Consider, for instance, the task of finding a pair which uniquely refers to the node labeled in Figure 2.",
        "It is easily seen that there are a number of such pairs, three of which are depicted in Figure 4.",
        "We would like to have a mechanism which allows us to give certain solutions preference over other solutions.",
        "For this purpose we shall use cost -functions.",
        "In general, a cost function is a function which assigns to each subgraph of a scene graph a positive number.",
        "As we shall see, by defining cost functions in different ways, we can mimic various algorithms for the generation of referring expressions known from the literature.",
        "A note on problem complexity The basic decision problem for subgraph isomorphism (i.e., testing whether a graph is isomorphic to a subgraph of ) is known to be NP complete (see e.g., Garey & Johnson 1979).",
        "Here we are interested in connected , but unfortunately that chihuahua dog in doghouse in",
        "restriction does not reduce the theoretical complexity.",
        "However, as soon as we define an upper bound on the number of edges in a distinguishing graph, the problem loses its intractability and becomes solvable in polynomial time.",
        "Such a restriction is rather harmless for our current purposes, as it would only prohibit the generation of distinguishing descriptions with more than properties, for an arbitrary large .",
        "In general, there are various classes of graphs for which the subgraph isomorphism problem can be solved much more efficiently, without postulating upper bounds.",
        "For instance, if and are planar graphs the problem can be solved in time linear in the number of nodes of (Eppstein 1999).",
        "Basically, a planar graph is one which can be drawn on a plane in such a way that there are no crossing edges (thus, for instance, the graph in Figure 2 is planar).",
        "It is worth investigating to what extent planar graphs suffice for the generation of referring expressions."
      ]
    },
    {
      "heading": "3 Outline of the algorithm",
      "text": [
        "In this section we give a high-level sketch of the algorithm.",
        "The algorithm (called make-ReferringExpression) consists of two main components, a subgraph construction algorithm (called findGraph) and a subgraph isomorphism testing algorithm (called matchGraphs).",
        "We assume that a scene graph is given.",
        "The algorithm systematically tries all relevant subgraphs of the scene graph by starting with the subgraph containing only the node (the target object) and expanding it recursively by trying to add edges from which are adjacent to the subgraph constructed so far.",
        "In this way we know that the results will be a connected subgraph.",
        "We refer to this set of adjacent edges as the neighbors in (notation:.neighbors( )).",
        "The algorithm returns the cheapest distinguishing subgraph which refers to , if such a distinguishing graph exists, otherwise it returns the empty graph ."
      ]
    },
    {
      "heading": "3.1 Cost functions",
      "text": [
        "We use cost functions to guide the search process and to give preference to some solutions over others.",
        "If is a subgraph of , then the costs of , notation , are given by summing over the costs associated with the nodes and edges of H. Formally: We require the cost function to be monotonic.",
        "That is, adding an edge to a (non-empty) graph can never result in a cheaper graph.",
        "Formally: edges: cost cost This assumption helps reducing the search space substantially, since extensions of subgraphs with a cost greater than the best subgraph found so far can safely be ignored.",
        "The costs of the empty, undefined graph are infinite, i.e. ."
      ]
    },
    {
      "heading": "3.2 Worked example",
      "text": [
        "We now illustrate the algorithm with an example.",
        "Suppose the scene graph is as given in Figure 2, and that we want to generate a referring expression for object in this graph.",
        "Let us assume for the sake of illustration that the cost function is defined in such a way that adding a node or an edge always costs 1 point.",
        "Thus: for each and for each : .",
        "Here and elsewhere, we use the following notation.",
        "Let be a graph and an edge, then is the graph",
        "process for .",
        "(In the next section we describe a number of more interesting cost functions and discuss the impact these have on the output of the algorithm.)",
        "We call the function makeReferringExpression (given in Figure 5) with as parameter.",
        "In this function the variable bestGraph (for the best solution found so far) is initialized as the empty graph and the variable (for the distinguishing subgraph under construction) is initialized as the graph containing only node ((i) in Figure 6).",
        "Then the function findGraph (see also Figure 5) is called, with parameters , bestGraph and .",
        "In this function, first it is checked whether the costs of (the graph under construction) are higher than the costs of the bestGraph found so far.",
        "If that is the case, it is not worth extending since, due to the monotonicity constraint, it will never end up being cheaper than the current bestGraph.",
        "The initial value of bestGraph is the empty, undefined graph, and since its costs are astronomically high, we continue.",
        "Then the set of distractors (the objects from which the intended referent should be distinguished, Dale & Reiter 1995) is calculated.",
        "In terms of the graph perspective this is the set of nodes in the scene graph (other then the target node ) to which the graph refers.",
        "It is easily seen that the initial value of , i.e., (i) in Figure 6, refers to every node in .",
        "Hence, as one would expect, the initial set of distractors is nodes .",
        "Next we check whether the current set of distractors is empty.",
        "If so, we have managed to find a distinguishing graph, which is subsequently stored in the variable bestGraph.",
        "In this first iteration, this is obviously not the case and we continue, recursively trying to extend by adding adjacent (neighboring) edges until either a distinguishing graph has been constructed (all distract",
        "if matching then return true fi; if then return false fi; choose a fresh, unmatched from ; might be matched to ; for each do if is a valid extension of the mapping then if matchHelper(matching , , ) then return true fi;",
        "ors are ruled out) or the costs of exceed the costs of the bestGraph found so far.",
        "While bestGraph is still the empty set (i.e., no distinguishing graph has been found yet), the algorithm continues until is a distinguishing graph.",
        "Which is the first distinguishing graph to be found (if one or more exist) depends on the order in which the adjacent edges are tried.",
        "Suppose for the sake of argument that the first distinguishing graph to be found is (ii) in Figure 6.",
        "This graph is returned and stored in bestGraph.",
        "The costs associated with this graph are 5 points (two nodes and three edges).",
        "At this stage in the generation process only graphs with lower costs are worth investigating, which yields a drastic reduction of the search space.",
        "In fact, there are only a few distinguishing graphs which cost less.",
        "After a number of iterations the algorithm will find the cheapest solution (given this particular, simple definition of the cost function), which is (iii) in Figure 6."
      ]
    },
    {
      "heading": "3.3 Subgraph Isomorphism testing",
      "text": [
        "Figure 7 contains a sketch of the part of the algorithm which tests for subgraph isomorphism, matchGraphs.",
        "This function is called each time the distractor set is calculated.",
        "It tests whether the pair can refer to , or put differently, it checks whether there exists an isomorphism such that with .",
        "The function matchGraphs first determines whether the looping edges starting from node (i.e., the properties of ) match those of .",
        "If not (e.g., is a dog and is a doghouse), we can immediately discard the matching.",
        "Otherwise we start with the matching , and expand it recursively.",
        "Each recursion step afresh and as yet unmatched node from is selected which is adjacent to one of the nodes in the current matching.",
        "For each we calculate the set of possible nodes in to which can be matched.",
        "This set consist of all the nodes in which have the same looping edges as and the same edges to and from other nodes in the domain of the current matching function :",
        "The matching can now be extended with , for .",
        "The algorithm then branches over all these possibilities.",
        "Once a mapping has been found which has exactly as much elements as has nodes, we have found a subgraph isomorphism.",
        "If there are still unmatched nodes in or if all possible extensions with a node have been checked and no matching could be found, the test for subgraph isomorphism has failed."
      ]
    },
    {
      "heading": "3.4 A note on the implementation",
      "text": [
        "The basic algorithm outlined in Figures 5 and 7 has been implemented in Java.",
        "Various optimizations increase the efficiency of the algorithm, as certain calculations need not be repeated each iteration (e.g., the set.neighbors( )).",
        "In addition, the user has the possibility of specifying the cost function in a way which he or she sees fit."
      ]
    },
    {
      "heading": "4 Search methods and cost functions",
      "text": [
        "Arguably, the algorithm outlined above is a meta-algorithm, since by formulating the cost function in certain ways we can simulate various algorithms known from the generation literature."
      ]
    },
    {
      "heading": "4.1 Full (relational) Brevity Algorithm",
      "text": [
        "The algorithm described in the previous section can be seen as a generalization of Dale’s (1992) Full Brevity algorithm, in the sense that there is a guarantee that the algorithm will output the shortest possible description, if one exists.",
        "It is also an extension of the Full Brevity algorithm, since it allows for relational descriptions, as does the Dale & Haddock (1991) algorithm.",
        "The latter algorithm has a problem with infinite recursions; in principle their algorithm could output descriptions like “the dog in the doghouse which contains a dog which is in a doghouse which ... etc.” Dale & Haddock propose to solve this problem by stipulating that a property or relation may only be included once.",
        "In the graph-based model described above the possibility of such infinite recursions does not arise, since a particular edge is either present in a graph or not."
      ]
    },
    {
      "heading": "4.2 Incremental Algorithm",
      "text": [
        "Dale & Reiter’s (1995) Incremental Algorithm, generally considered the state of the art in this field, has the following characteristic properties.",
        "(1) It defines a list of preferred attributes, listing the attributes which human speakers prefer for a certain domain.",
        "For example, when discussing domestic animals, speakers usually first describe the “type” of animal (dog, cat), before absolute properties such as “color” are used.",
        "If that still is not sufficient to produce a distinguishing description, relative properties such as “size” can be included.",
        "Thus, the list of preferred attributes for this particular domain could be type, color, size .",
        "The Incremental Algorithm now simply iterates through this list, adding a property if it rules out any distractors not previously ruled out.",
        "(2) The algorithm always includes the “type” attribute, even if it is not distinguishing.",
        "And (3) the algorithm allows subsumption hierarchies on certain attributes (most notably for the “type” attribute) stating things like a fox terrier is a dog, and a dog is an animal.",
        "In such a hierarchy we can specify what the basic level value is (in this case it is dog).",
        "Dale & Reiter claim that there is a general preference for basic level values, and hence their algorithm includes the basic level value of an attribute, unless values subsumed by the basic level value rule out more distractors.",
        "These properties can be incorporated in the graph framework in the following way.",
        "(1) The list of preferred attributes can easily be modelled using the cost function.",
        "All “type” edges should be cheaper than all other edges (in fact, they could be for free), and moreover, the edges corresponding to absolute properties should cost less than those corresponding to relative ones.",
        "This gives us exactly the effect of having preferred attributes.",
        "(2) It also implies that the “type” of an object is always included if it is in any way distinguishing.",
        "That by itself does not guarantee that type is always is included.",
        "The most principled and efficient way to achieve that would be to reformulate the findGraph algorithm in such a way that the “type” loop is always included.",
        "(Given such a minor modification, the algorithm described in the previous section would output (iii) from Figure 3 instead of (iii) from Figure 6 when applied to .)",
        "Such a general modification might be undesirable from an empirical point of view however, since in various domains it is very common to not include type information, for instance when the domain contains only objects of the same type (see van der Sluis & Krahmer 2001).",
        "(3) The subsumption hierarchy can be modelled in the same way as preferred attributes are: for a given attribute, the basic level value should have the lowest costs and the values farthest away from the basic level value should have the highest costs.",
        "This implies that adding an edge labeled dog is cheaper than adding an edge labeled chihuahua, unless more (or more expensive) edges are needed to build a distinguishing graph including dog than are required for the graph including chihuahua.",
        "Assuming that the scene representation is well-defined, the algorithm never outputs a graph which contains both dog and chihuahua, since there will always be a cheaper distinguishing graph omitting one of the two edges.",
        "So, we can recast the Incremental Algorithm quite easily in terms of graphs.",
        "Note that the original Incremental Algorithm only operates on properties, looped edges in graph terminology.",
        "It is worth stressing that when all edges in the scene graph are of the looping variety, testing for subgraph isomorphism becomes trivial and we regain polynomial complexity.",
        "However, the above graph-theoretical formalization of the Incremental Algorithm does not fully exploit the possibilities offered by the graph framework and the use of cost functions.",
        "First, from the graph-theoretical perspective the generation of relational descriptions poses no problems whatsoever, while the incremental generation of relational descriptions is by no means trivial (see e.g., Theune 2000, Krahmer & Theune 1999).",
        "In fact, while it could be argued to some extent that incremental selection of properties is psychologically plausible, this somehow seems less plausible for incremental generation of relational extensions.",
        "Notice that the use of a As Dale & Reiter (1995:248) point out, redundant properties are not uncommon.",
        "That is: in certain situations people may describe an object as “the white bird” even though the simpler “the bird” would have been sufficient (cf. Pech-mann 1989, see also Krahmer & Theune 1999 for discussion).",
        "However, a similar argument seems somewhat far-fetched when applied to relations.",
        "It is unlikely that someone would describe an object as “the dog next to the tree in front of the garage” in a situation where “the dog in front of the garage” would suffice.",
        "cost function to simulate subsumption hierarchies for properties carries over directly to relations; for instance, the costs of adding a edge labeled next to should be less than those of adding one labeled left of or right of.",
        "Hence, next to will be preferred, unless using left of or right of has more discriminative power.",
        "Another advantage of the way the graph-based algorithm models the list of preferred attributes is that more fine-grained distinctions can be made than can be done in the Incremental Algorithm.",
        "In particular, we are not forced to say that values of the attribute “type” are always preferred over values of the attribute “color”.",
        "Instead we have the freedom to assign edges labeled with a common type value (e.g., dog) a lower cost than edges labeled with uncommon colors (such as Vandyke-brown), while at the same time edges labeled with obscure type values, such as polish owczarek nizinny sheepdog, can be given a higher cost than edges labeled with common colors such as brown."
      ]
    },
    {
      "heading": "4.3 Stochastic cost functions",
      "text": [
        "One of the important open questions in natural language generation is how the common, rule-based approaches to generation can be combined with recent insights from statistical NLP (see e.g., Langkilde & Knight 1998, Malouf 2000 for partial answers).",
        "Indeed, when looking at the Incremental Algorithm, for instance, it is not directly obvious how statistical information can be integrated in the algorithm.",
        "Arguably, this is different when we have cost functions.",
        "One can easily imagine deriving a stochastic cost function from a sufficiently large corpus and using it in the graph-theoretical framework (the result looks like but is not quite a Markov Model).",
        "As a first approximation, we could define the costs of adding an edge in terms of the probability that occurs in a distinguishing description (estimated by counting occurrences): log Thus, properties which occur frequently are cheap, properties which are relatively rare are expensive.",
        "In this way, we would probably derive that dog is indeed less expensive than Vandyke brown and that brown is less expensive than polish owczarek nizinny sheepdog."
      ]
    },
    {
      "heading": "5 Concluding remarks",
      "text": [
        "In this paper, we have presented a general graph-theoretical approach to content-determination for referring expressions.",
        "The basic algorithm has clear computational properties: it is NP complete, but there exist various modifications (a ban on non-looping edges, planar graphs, upper bound to the number of edges in a distinguishing graph) which make the algorithm polynomial.",
        "The algorithm is fully implemented.",
        "The graph perspective has a number of attractive properties.",
        "The generation of relational descriptions is straightforward; the problems which plague some other algorithms for the generation of relational descriptions do not arise.",
        "The use of cost functions allows us to model different search methods, each restricting the search space in its own way.",
        "By defining cost functions in different ways, we can model and extend various well-known algorithms from the literature such as the Full Brevity Algorithm and the Incremental Algorithm.",
        "In addition, the use of cost functions paves the way for integrating statistical information directly in the generation process.",
        "Various important ingredients of other generation algorithms can be captured in the algorithm proposed here as well.",
        "For instance, Horacek (1997) points out that an algorithm should not collect a set of properties which cannot be realized given the constraints of the grammar.",
        "This problem can be solved, following Horacek’s suggestion, by slightly modifying the algorithm in such a way that for each potential edge it is immediately investigated whether it can expressed by the realizer.",
        "Van Deemter’s (2000) proposal to generate (distributional) distinguishing plural descrip-A final advantage of the graph model certainly deserves further investigation is the following.",
        "We can look at a graph such as that in Figure 2 as a Kripke model.",
        "The advantage of this way of looking at it, is that we can use tools from modal logic to reason about these structures.",
        "For example, we can reformulate the problem of determining the content of a distinguishing description in terms of hybrid logic (see e.g., Blackburn 2000) as follows: A In words: when we want to refer to node , we are looking for that distinguishing formula which is true of (“at”) but not of any different from .",
        "One advantage of this perspective is that logical properties which are usually considered problematic from a generation perspective (such as not having a certain property), fit in very well with the logical perspective.",
        "tions (such as the dogs) can also be modelled quite easily.",
        "Van Deemter’s algorithm takes as input a set of objects, which in our case, translates into a set of nodes from the scene graph.",
        "The algorithm should be reformulated in such a way that it tries to generate a subgraph which can refer to each of the nodes in the set, but not to any of the nodes in the scene graph outside this set.",
        "Krahmer & Theune (1999) present an extension of the Incremental Algorithm which takes context into account.",
        "They argue that an object which has been mentioned in the recent context is somehow salient, and hence can be referred to using fewer properties.",
        "This is modelled by assigning salience weights to objects (basically using a version of Centering Theory (Grosz et al.",
        "1995) augmented with a recency effect), and by defining the set of distractors as the set of objects with a salience weight higher or equal than that of the target object.",
        "In terms of the graph-theoretical framework, one can easily imagine assigning salience weights to the nodes in the scene graph, and restricting the distractor set essentially as Krahmer & Theune do.",
        "In this way, distinguishing graphs for salient objects will generally be smaller than those of non-salient objects."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "Thanks are due to Alexander Koller, Kees van Deemter, Paul Piwek, Mari¨et Theune and two anonymous referees for discussions and comments on an earlier version of this paper."
      ]
    }
  ]
}
