{
  "info": {
    "authors": [
      "Takashi Ninomiya",
      "Yusuke Miyao",
      "Jun'ichi Tsujii"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C02-1100",
    "title": "Lenient Default Unification for Robust Processing Within Unification Based Grammar Formalisms",
    "url": "https://aclweb.org/anthology/C02-1100",
    "year": 2002
  },
  "references": [
    "acl-C92-2072",
    "acl-E93-1027",
    "acl-J93-2004",
    "acl-J99-1002",
    "acl-P00-1058",
    "acl-P90-1021",
    "acl-P91-1028"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper describes new default unification, lenient default unification.",
        "It works efficiently, and gives more informative results because it maximizes the amount of information in the result, while other default unification maximizes it in the default.",
        "We also describe robust processing within the framework of HPSG.",
        "We extract grammar rules from the results of robust parsing using lenient default unification.",
        "The results of a series of experiments show that parsing with the extracted rules works robustly, and the coverage of a manually-developed HPSG grammar for Penn Treebank was greatly increased with a little overgeneration."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Parsing has often been considered to be crucial for natural language processing, thus, efficient and wide coverage parsing has been extensively pursued in natural language literature.",
        "This study aims at robust processing within the Head-driven Phrase Structure Grammar (HPSG) to extend the coverage of manually-developed HPSG grammars.",
        "The meaning of ‘robust processing’ is not limited to robust processing for ill-formed sentences found in a spoken language, but includes robust processing for sentences which are well-formed but beyond the grammar writer’s expectation.",
        "Studies of robust parsing within unification-based grammars have been explored by many researchers (Douglas and Dale, 1992; Imaichi and Matsumoto, 1995).",
        "They classified the errors found in analyzing ill-formed sentences into several categories to make them tractable, e.g., constraint violation, missing or extra elements, etc.",
        "In this paper, we focus on recovery from the constraint violation errors, which is a violation of feature values.",
        "All errors in agreement fall into this category.",
        "Since many of the grammatical components in HPSG are written as constraints represented by feature structures, many of the errors are expected to be recovered by the recovery of constraint violation errors.",
        "This paper proposes two new types of default unification and describes their application to robust processing.",
        "Default unification was originally studied to develop a system of lexical semantics to deal with the default inheritance in a lexicon, but it is also desirable for the recovery of such constraint violation errors due to the following merits: i) default unification is always well-defined, and ii) a feature structure is relaxed such that the amount of information is maximized.",
        "From the viewpoint of robust processing, an amount of lost information can be regarded as a cost (i.e., penalty) of robust processing.",
        "In other words, default unification tries to minimize the cost.",
        "Given a strict feature structure F and a default feature structure G, default unification is defined as unification that satisfies the following (written as F u G): 1) It is always defined.",
        "2) All strict information is preserved.",
        "That is, F C (F u G).",
        "3) It reduces to standard unification in the case of F and G being consistent.",
        "That is, (F u G) = (F U G) if F U G is defined.",
        "With these definitions, Douglas’ relaxation technique can be regarded as a sort of default unification.",
        "They classify constraints into necessary constraints and optional constraints, which can be regarded as strict information and default information in the definition of default unification.",
        "Carpenter (1993) gave concise and comprehensive definitions of default unification.",
        "However, the problem in Carpenter’s default unification is that it tries to maximize the amount of information in a default feature structure, not the result of default unification.",
        "Consider the case where a grammar rule is the default feature structure and the daughters are the strict feature structure.",
        "The head feature principle can be described as the structure-sharing between the values of the head feature in a mother and in a head daughter.",
        "The set of constraints that represent the head feature principle consists of only one element.",
        "When we lose just one element in the head feature principle, a large amount of information in the daughter’s substructure is not propagated to its mother.",
        "As Copestake (1993) mentioned, another problem in Carpenter’s default unification is that the time complexity for finding the optimal answer of default unification is exponential because we have to verify the unifiability of the power set of constraints in a default feature structure.",
        "Here, we propose ideal lenient default unification, which tries to maximize the amount of information of a result, not the amount of default information.",
        "Thus, the problem of losing a large amount of information in structure-sharing never arises.",
        "We also propose lenient default unification whose algorithm is much more efficient than the ideal one.",
        "Its time complexity is linear to the size of the strict feature structure and the default feature structure.",
        "Instead, the amount of information of a result derived by lenient default unification is equal to or less than that of the ideal one.",
        "We apply lenient default unification to robust processing.",
        "Given an HPSG grammar, our approach takes two steps; i) extraction of grammar rules from the results of robust parsing using lenient default unification for applying the HPSG grammar rules (offline parsing), and ii) runtime parsing using the HPSG grammar with the extracted rules.",
        "The extracted rules work robustly since they reflect the effects of recovery rules applied during offline robust parsing and the conditions in which they are applied.",
        "Sections 3 and 4 describe our default unification.",
        "Our robust parsing is explained in Section 5.",
        "Section 6 shows a series of experiments of robust parsing with default unification."
      ]
    },
    {
      "heading": "2 Background",
      "text": [
        "Default unification has been investigated by many researchers (Bouma, 1990; Russell et al., 1991; Copestake, 1993; Carpenter, 1993; Lascarides and Copestake, 1999) in the context of developing lexical semantics.",
        "Here, we first explain the definition given by Carpenter (1993) because his definition is both concise and comprehensive."
      ]
    },
    {
      "heading": "2.1 Carpenter’s Default Unification",
      "text": [
        "Carpenter proposed two types of default unification, credulous default unification and skeptical default unification.",
        "F is called a strict feature structure, whose information must not be lost, and G is called a default feature structure, whose information might be lost but as little as possible so that F and G can be unified.",
        "A credulous default unification operation is greedy in that it tries to maximize the amount of information it retains from the default feature structure.",
        "This definition returns a set of feature structures rather than a unique feature structure.",
        "Skeptical default unification simply generalizes the set of feature structures which results from credulous default unification.",
        "The definition of skeptical default unification leads to a unique result.",
        "The default information which can be found in every result of credulous default unification remains.",
        "Following is an example of skeptical default unification."
      ]
    },
    {
      "heading": "2.2 Forced Unification",
      "text": [
        "Forced unification is another way to unify inconsistent feature structures.",
        "Forced unification always succeeds by supposing the existence of the top type (the most specific type) in a type hierarchy.",
        "Unification of any pair of types is defined in the type hierarchy, and therefore unification of any pair of feature structures is defined.",
        "One example is described by Imaichi and Matsumoto (1995) (they call it cost-based unification).",
        "Their unification always succeeds by supposing the top type, and it also keeps the information about inconsistent types.",
        "Forced unification can be regarded as one of the toughest robust processing because it always succeeds and never loses the information embedded in feature structures.",
        "The drawback of forced unification is the postprocessing of parsing, i.e., feature structures with top types are not tractable.",
        "We write FUfG for the forced unification of F and G."
      ]
    },
    {
      "heading": "3 Ideal Lenient Default Unification",
      "text": [
        "In this section, we explain our default unification, ideal lenient default unification.",
        "Ideal lenient default unification tries to maximize the amount of information of the result, subsuming the result of forced unification.",
        "In other words, ideal lenient default unification tries to generate a result as similar as possible to the result of forced unification such that the result is defined in the type hierarchy without the top type.",
        "Formally, we have:",
        "where Cf is a subsumption relation where the top type is defined.",
        "From the definition of skeptical default unification, ideal lenient default unification is equivalent to F <us (FUfG) assuming that skeptical default unification does not add the default information that includes the to pp ttyyppe to the strict information.",
        "Consider the-following feature structures.",
        "In the case of Carpenter’s default unification, the results of skeptical and credulous default unification become as follows: F <us G = F,F <uc G = {F}.",
        "This is because G is generalized to the bottom feature structure, and hence the result is equivalent to the strict feature structure.",
        "With ideal lenient default unification, the result becomes as follows.",
        "Figure 1 shows F, G and H in the graph notation.",
        "This figure also shows the nodes that correspond to topnode(H), fpnode(H) and fpchild(H).",
        "F U H fails because some of the path value in H conflict with F, or some of the path equivalence in H cause inconsistencies.",
        "The basic ideas are that i) the inconsistency caused by path value specifications can be removed by generalizing the types assigned to the fail points in H, and that ii) the inconsistency caused by path equivalence specifications can be removed by unfolding the structure-sharing of fail path nodes in H. Let H be (QH, ¯qH, θH, δH), where Q is a set of a feature structure’s nodes, q¯ is the root node, θ (q) is a total node typing function, and δ (π, q) is a partial function that returns a node reached by following path π from q.",
        "We first give several definitions to define a generalized feature structure.",
        "c ideas are that i) the inconsistency caused by path value specifications can be removed by generalizing the types assigned to the fail points in H, and that ii) the inconsistency caused by path equivalence specifications can be removed by unfolding the structure-sharing of fail path nodes in H. Let H be (QH, ¯qH, θH, δH), where Q is a set of a feature structure’s nodes, q¯ is the root node, θ (q) is a total node typing function, and δ (π, q) is a partial function that returns a node reached by following path π from q.",
        "We first give several definitions to define a generalized feature structure.",
        "the leastfeature structures where path value of π is σ",
        "the leastfeature structures where path value of π is σ I(=QI,¯qI, θI, δI)) be I\"(H).",
        "The definition of the generalized feature structure is given as follows: Let q,θ,δ) eI() h eiiino h eeaie etr tutr sgvna o-os",
        "Finally, lenient default unification F <u G is defined as follows:",
        "For F and G depicted in Figure 1, F<u G becomes as follows: information is preserved.",
        "That is, F C (F :21"
      ]
    },
    {
      "heading": "Algorithm",
      "text": [
        "Our algorithm for lenient default unification proceeds in the following steps.",
        "1) Calculate forced unification of F and G (let H be FUfG).",
        "2) Find fail points and fail path nodes in H. 3) Generalize H so that F Li H can be unified.",
        "Figure 2 describes the algorithm that generalizes the result of forced unification.",
        "The time complexity of the algorithm for finding F <U G is linear to",
        "the size of feature structures F and G because the time complexity of each algorithm (the algorithm for finding fail points, finding fail path nodes, and generalization) is linear to their size."
      ]
    },
    {
      "heading": "Comparison",
      "text": [
        "The difference between ideal lenient default unification and lenient default unification can be exemplified by the following example.",
        "Suppose also that the type head has PHON:, CASE:, INV: and TENSE: as its features, and the type sign has HEAD: and VAL:.",
        "The result of skeptical default uni-DTR us R becomes DTR.",
        "This is because fication Both ideal and non-ideal lenient default unification satisfy the following desiderata: 1) It is always defined (and produces a unique result).",
        "2) All strict",
        "DTR = [DTRS: [ �.SPR HEAD:CA�E: nom]] Suppose also that the type head has PHON:, CASE:, INV: and TENSE: as its features, and the type sign has HEAD: and VAL:.",
        "The result of skeptical default uni",
        "all structure-sharings embedded in R are relevant to unification failure.",
        "However, the result of lenient default unification is more informative."
      ]
    },
    {
      "heading": "Robust Parsing and Grammar Extraction",
      "text": [
        "This section describes a new approach to robust parsing using default unification.",
        "Given an HPSG grammar, our approach takes two steps; i) extraction of grammar rules from the result of offline robust parsing using default unification for applying the HPSG grammar rules, and ii) runtime parsing using the HPSG grammar with the extracted rules.",
        "Offlin parsing is a training phase to extract grammar rules, and runtime parsing is a phase where we apply the extracted rules to practice.",
        "The extracted rules work robustly over corpora other than the training corpus because the extracted rules reflect the effects of default unification that are applied during offlin parsing.",
        "Given an annotated corpus, our algorithm extracts grammar rules that make the coverage of the HPSG grammar wider.",
        "In the offlin parsing, constituents are generated by default unification of daughters and grammar rules of the HPSG grammar2, where a head daughter and a grammar rule are strict feature structures and anon-head daughter is a default feature structure.",
        "With this construction, the information in a grammar rule and a head daughter is strictly preserved and the information in a non-head daughter is partially lost (but, as lit le as possible).",
        "The ideas",
        "behind this construction are that (i) we had better construct a mother node without the information of the non-head daughter rather than construct nothing (i.e., we had better construct a mother node by unifying only ahead-daughter and a grammar rule), (ii) we had better construct a mother node with the maximal information of a non-head daughter rather than have no information of the non-head daughter added.",
        "Parse trees can be derived even if a parse tree cannot be derived by normal unification.",
        "Offline robust parsing is based on A* algorithm, but we generate only parse trees which meet the following conditions, 1) a generated parse tree must be consistent with an existing bracketed corpus, and 2) the parsing cost of a generated parse tree must be minimum.",
        "This means that i) we can limit a search space, and that ii) the parsing result is valid in the sense that it is consistent with the existing corpus.",
        "The cost of a parse tree can be calculated by adding the cost of lenient default unification, which is the amount of information that is lost by lenient default unification.",
        "We regard it as the difference between the number of path values and structure-sharing in the results of a lenient default unification and a forced unification.",
        "Grammar extraction is very concise.",
        "When we find a mother M in the result of offline parsing that cannot be derived by using unification but can be derived by default unification, we regard M --+ L, R as a new rule, where L and R are the daughters of the mother.",
        "The rules extracted in such a way can reconstruct the mothers as does default unification, and they reflect the condition of triggering default unification, i.e., the extracted rules are not frequently triggered because they can be applied to feature structures that are exactly equivalent to their daughter’s part.",
        "By collecting a number of such rules,3 a grammar becomes wide-coverage with some overgeneration.",
        "They can be regarded as exceptions in a grammar, which are difficult to be captured only by propagating information from daughters to a mother.",
        "This approach can be regarded as a kind of explanation-based learning (Samuelsson and Rayner, 1991).",
        "The explanation-based learning method is recently attracting researcher’s attention (Xia, 1999; Chiang, 2000) because their parsers are comparative to the state-of-the-art parsers in terms of precision and recall.",
        "In the context of unification-based grammars, Neumann (1994) has developed a parser running with an HPSG grammar learned by explanation-based learning.",
        "It should be also noted that Kiyono and Tsujii (1993) exemplified the grammar extraction approach using offline parsing in the",
        "The information of structure-sharing is preserved as much as possible.",
        "In the example above, the structure-sharing tagged as 2 in the original grammar rule R is decomposed into the structure-sharings [3l, 4J,5, 6.",
        "That is, the structure-sharing tagged as 2is preserved except HEAD:CASE:.",
        "context of explanation-based learning.",
        "Finally, we need to remove some values in the extracted rules because they contain too specific information.",
        "For instance, a value of PHONOLOGY: represents a list of phoneme strings of a phrasal structure.",
        "Without removing them, extracted rules cannot be triggered until when completely the same strings appear in a text.",
        "4"
      ]
    },
    {
      "heading": "6 Performance Evaluation",
      "text": [
        "We measured the performance of our robust parsing algorithm by measuring coverage and degree of overgeneration for the Wall Street Journal in the Penn Treebank (Marcus et al., 1993).",
        "The training corpus consists of 5,903 sentences selected from the Wall Street Journal (Wall Street Journal 00 – 02), and we prepared two sets of test corpora, TestSetA and TestSetB.",
        "TestSetA consists of 1,480 sentences (Wall Street Journal 03) and is used for measuring coverage.5 TestSetB consists of 100 sentences and is used for measuring the degree of overgeneration.",
        "The sentences of TestSetB are the shortest 100 sentences in TestSetA.",
        "Table 1 shows the average sentence length of each corpus.",
        "Here, ‘coverage’ means the ratio of ‘the number of sentences that are covered by a grammar’ to ‘the number of all sentences’.",
        "Here, we say ‘a sentence is covered’ when a sentence can be analyzed by a parser and the result includes trees that are consistent with brackets and POS tags annotated in the Penn Treebank.",
        "Grammar rules were extracted by offline parsing with the XHPSG grammar (Tateisi et al., 1998),",
        "which is a translation into HPSG of the manually-developed XTAG English grammar (The XTAG Research Group , 1995).",
        "The growth of the number of extracted rules is shown in the left of Figure 3.",
        "The average cost per sentence in offline parsing was 8.11.",
        "This means the total number of nodes and structure-sharing that are removed was less than 9 for each sentence.",
        "The coverage for the training corpus by offline parsing was 95.4%.",
        "The coverage was measured by using the XHPSG grammar with the extracted rules.",
        "The coverage for TestSetA and TestSetB is illustrated in the middle and right of Figure 3, respectively.",
        "As seen in the figure, the coverage for the Wall Street Journal grew from 24.7% to 65.3% for TestSetA and from 64% to 88% for TestSetB.",
        "We measured the degree of overgeneration by measuring the number of edges, using a parser based on A* algorithm.",
        "Figure 4 shows the average number of edges when TestSetB was parsed.",
        "From this figure and Figure 3, we can observe that the coverage grew from 64% to 88% by generating just 87.99 more edges (the number of edges grew from 240.68 to 328.67 in average).",
        "From the experiments, we can say that our approach is effective in extending coverage with a little overgeneration.",
        "We have analyzed the phenomena that cannot be analyzed by the original XHPSG grammar but can be analyzed by the extracted rules in the first 200 sentences in Wall Street Journal 03 of the test set.",
        "Among the 200 sentences, the original XHPSG grammar can cover 38 sentences (19% of the sentences) and the XHPSG grammar with the extracted rules can analyze 131 sentences (65.5% of the sentences).",
        "Table 2 shows the number of each",
        "phenomenon that the original grammar fails to analyze ((A) in the table), and also shows the number of each phenomenon that the XHPSG grammar with the extracted rules still fails to analyze ((B) in the table).",
        "As seen in the table, more than 70% of phenomena that the original grammar cannot analyze were analyzed by our method.",
        "Note that most of the phenomena that cannot be analyzed with the extracted rules were lack of lexical entry, inconsistency between the grammar and the treebank, and complicated phenomena that are currently open problems in the field of linguistics.",
        "Most of the lack of lexical entries failures were caused by the lack of ‘apostrophe s.’ This means that just by adding lexical entries for ‘apostrophe s’, we can cover almost half of this type of error.",
        "Among the words listed in the table, the XHPSG grammar has no lexical entry for ‘itself’ and ‘as (Adv)’.",
        "As our method is only concerned with grammar rules, our method cannot recover words that have no lexical entry.",
        "This means that if a sentence includes the word ‘itself’, the sentence cannot be recovered by our method."
      ]
    },
    {
      "heading": "7 Conclusion",
      "text": [
        "We proposed two new types of default unification, ideal and non-ideal lenient default unification.",
        "Ideal lenient default unification is desirable in that it maximizes the amount of information in the result, while other existing types of default unification maximize the amount of information in the default.",
        "Although non-ideal lenient default unification gives a less informative result than the ideal one, it works efficiently and retains the desiderata the ideal one satisfies.",
        "We also proposed a new approach to extend the coverage of a grammar.",
        "We extracted grammar rules from the results of robust parsing using lenient default unification.",
        "A series of experiments showed that the extracted rules work robustly, and the coverage of the XHPSG grammar for Penn Treebank greatly increased with a little overgeneration."
      ]
    }
  ]
}
