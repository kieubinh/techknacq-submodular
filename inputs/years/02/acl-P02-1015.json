{
  "info": {
    "authors": [
      "Mark-Jan Nederhof",
      "Giorgio Satta"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P02-1015",
    "title": "Parsing Non-Recursive CFGs",
    "url": "https://aclweb.org/anthology/P02-1015",
    "year": 2002
  },
  "references": [
    "acl-A00-2023"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We consider the problem of parsing non-recursive context-free grammars, i.e., context-free grammars that generate finite languages.",
        "In natural language processing, this problem arises in several areas of application, including natural language generation, speech recognition and machine translation.",
        "We present two tabular algorithms for parsing of non-recursive context-free grammars, and show that they perform well in practical settings, despite the fact that this problem is PSPACE-complete."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Several applications in natural language processing require “parsing” of a large but finite set of candidate strings.",
        "Here parsing means some computation that selects those strings out of the finite set that are well-formed according to some grammar, or that are most likely according to some language model.",
        "In these applications, the finite set is typically encoded in a compact way as a context-free grammar (CFG) that is non-recursive.",
        "This is motivated by the fact that non-recursive CFGs allow very compact representations for finite languages, since the strings derivable from single nonterminals may be substrings of many different strings in the language.",
        "Unfolding such a grammar and parsing the generated strings",
        "one by one then leads to an unnecessary duplication of subcomputations, since each occurrence of a repeated substring has to be independently parsed.",
        "As this approach may be prohibitively expensive, it is preferable to find a parsing algorithm that shares subcomputations among different strings by working directly on the nonterminals and the rules of the non-recursive CFG.",
        "In this way, “parsing” a nonterminal of the grammar amounts to shared parsing of all the substrings encoded by that nonterminal.",
        "To give a few examples, in some natural language generation systems (Langkilde, 2000) non-recursive CFGs are used to encode very large sets of candidate sentences realizing some input conceptual representation (Langkilde calls such grammars forests).",
        "Each CFG is later “parsed” using a language model, in order to rank the sentences in the set according to their likelyhood.",
        "Similarly, in some approaches to automatic speech understanding (Corazza and Lavelli, 1994) the N-best sentences obtained from the speech recognition module are “compressed” into a non-recursive CFG grammar, which is later provided as input to a parser.",
        "Finally, in some machine translation applications related techniques are exploited to obtain sentences that simultaneously realize two different conceptual representations (Knight and Langkilde, 2000).",
        "This is done in order to produce translations that preserve syntactic or semantic ambiguity in cases where the ambiguity could not be resolved when processing the source sentence.",
        "To be able to describe the above applications in an abstract way, let us first fix some terminology.",
        "The term “recognition” refers to the process of deciding Proceedings of the 40th Annual Meeting of the Association for Computational Linguistics (ACL), Philadelphia, July 2002, pp.",
        "112-119. whether an input string is in the language described by a grammar, the parsing grammar Gp.",
        "We will generalize this notion in a natural way to input representing a set of strings, and here the goal of recognition is to decide whether at least one of the strings in the set is in the language described by Gp.",
        "If the input is itself given in the form of a grammar, the input grammar Gi, then recognition amounts to determining whether the intersection of the languages described by Gi and Gp is non-empty.",
        "In this paper we use the term parsing as synonymous to recognition, since the recognition algorithms we present can be easily extended to yield parse trees (with associated probabilities if either Gi or Gp or both are probabilistic).",
        "In what follows we consider the case where both Gp and Gi are CFGs.",
        "General CFGs have unfavourable computational properties with respect to intersection.",
        "In particular, the problem of deciding whether the intersection of two CFGs is non-empty is undecidable (Harrison, 1978).",
        "Following the terminology adopted above, this means that parsing a context-free input grammar Gi on the basis of a context-free parsing grammar Gp is not possible in general.",
        "One way to make the parsing problem decidable is to place some additional restrictions on Gi or Gp.",
        "This direction is taken by Langkilde (2000), where Gi is a non-recursive CFG and Gp represents a regular language, more precisely an N-gram model.",
        "In this way the problem can be solved using a stochastic variant of an algorithm presented by Bar-Hillel et al.",
        "(1964), where it is shown that the intersection of a general context-free language and a regular language is still context-free.",
        "In the present paper we leave the theoretical framework of Bar-Hillel et al.",
        "(1964), and consider parsing grammars Gp that are unrestricted CFGs, and input grammars Gi that are non-recursive context-free grammars.",
        "In this case the parsing (intersection) problem becomes PSPACE-complete.1 Despite of this unfavourable theoretical result, algorithms for the problem at hand have been proposed in the literature and are currently used in practical applications.",
        "In (Knight and Langkilde, 2000) Gi is",
        "unfolded into a lattice (acyclic finite automaton) and later parsed with Gp using an algorithm close to the one by Bar-Hillel et al.",
        "(1964).",
        "The algorithm proposed by Corazza and Lavelli (1994) involves copying of charts, and this makes it very similar in behaviour to the former approach.",
        "Thus in both algorithms parts of the input grammar Gi are copied where a nonterminal occurs more than once, which destroys the compactness of the representation.",
        "In this paper we propose two alternative tabular algorithms that exploit the compactness of Gi as much as possible.",
        "Although a limited amount of copying is also done by our algorithms, this never happens in cases where the resulting structure is ungrammatical with respect to the parsing grammar Gp.",
        "The structure of this paper is as follows.",
        "In Section 2 we introduce some preliminary definitions, followed in Section 3 by a first algorithm based on CKY parsing.",
        "A more sophisticated algorithm, satisfying the equivalent of the correct-prefix property and based on Earley’s algorithm, is presented in Section 4.",
        "Section 5 presents our experimental results and Section 6 closes with some discussion."
      ]
    },
    {
      "heading": "2 Preliminaries",
      "text": [
        "In this section we briefly recall some standard notions from formal language theory.",
        "For more details we refer the reader to textbooks such as (Harrison, 1978).",
        "A context-free grammar is a 4-tuple (Z, N, S, R), where Z is a finite set of terminals, called the alphabet, N is a finite set of nonterminals, including the start symbol S, and R is a finite set of rules having the form A – > � with A E N and � E (Z U N) * ."
      ]
    },
    {
      "heading": "Throughout the paper we assume the following con",
      "text": [
        "ventions: A, B.... denote nonterminals, a, b.... denote terminals, y, v, � are strings in (Z U .N) * and v, w are strings in Z*.",
        "We also assume that each CFG is reduced, i.e., no CFG contains nonterminals that do not occur in any derivation of a string in the language.",
        "Furthermore, we assume that the input grammars do not contain epsilon rules and that there is only one rule S – > � defining the start symbol S.2 Finally, in Section 3 we will consider parsing gram2 Strictly speaking, the assumption about the absence of epsilon rules is not without loss of generality, since without epsilon rules the language cannot contain the empty string.",
        "However, this has no practical consequence.",
        "mars in Chomsky normal form (CNF), i.e., grammars with rules of the form A – > B C or A – > a.",
        "Instead of working with non-recursive CFGs, it will be more convenient in the specification of our algorithms to encode Gi as a push-down automaton (PDA) with stack size bounded by some constant.",
        "Unlike many text-books, we assume PDAs do not have states; this is without loss of generality, since states can be encoded in the symbols that occur topmost on the stack.",
        "Thus, a PDA is a 5-tuple (Z, S,",
        "stack symbol Xinit and the final stack symbol X final, and a is the set of transitions, having one of the following three forms: X H XY (a push transition), XY H Z (a pop transition), or X > Y (a scan transition, scanning symbol a).",
        "Throughout this paper we use the following conventions: Q, X, Y, Z denote stack symbols and a,,3, y are strings in S* representing stacks.",
        "We remark that in our notation stacks grow from left to right, i.e., the topmost stack symbol will be found at the right end.",
        "Configurations of the PDA have the form (a, w), where a E S* is a stack and w E Z* is the remaining input.",
        "We let the binary relation �- be defined by: (ya, vw) �- (y/3, w) if and only if there is a transition in Q of the form a H 3, where v = e, or of the form a I> 3, where v = a.",
        "The relation �- * denotes the reflexive and transitive closure of �-.",
        "An input string w is recognized by the PDA if and only if (Xinit, w) �_* (X finals 6) ."
      ]
    },
    {
      "heading": "3 The CKY algorithm",
      "text": [
        "In this section we present our first parsing algorithm, based on the so-called CKY algorithm (Harrison, 1978) and exploiting a decomposition of computations of PDAs cast in a specific form.",
        "We start with a construction that translates the non-recursive input CFG Gi into a PDA accepting the same language.",
        "Let Gi = (Z, N, S, R).",
        "The PDA associated",
        "where S consists of symbols of the form [A – > y •",
        "v] for (A – > µv) E R, and a contains the following transitions: • For each pair of rules A pBv and B",
        "• For each rule A pav, a contains:",
        "Observe that for all PDAs constructed as above, no push transition can be immediately followed by a pop transition, i.e., there are no stack symbols X, Y and Z such that X H XY and XY H Z.",
        "As a consequence of this, a computation (Xinit, w) �-* (X finah E) of the PDA can always and uniquely be decomposed into consecutive subcomputations, which we call segments, each starting with zero or more push transitions, followed by a single scan transition and by zero or more pop transitions.",
        "In what follows, we will formalize this basic idea and exploit it within our parsing algorithm.",
        "We write a a > 3 to indicate that there is a computation (a, a) �-* (/3, e) of the PDA such that all of the following three conditions hold:",
        "(i) either I a I = 1 or 1/31 = 1; (ii) the computation starts with zero or more push transitions, followed by one scan transition reading a and by zero or more pop transitions; (iii) if I a I > 1 then the topmost symbol of a must",
        "be in the right-hand side of a pop or scan transition (i.e., topmost in the stack at the end of a previous segment) and if 1/31 > 1, then the topmost symbol of 3 must be the left-hand side of a push or scan transition (i.e., topmost in the stack at the beginning of a following segment).",
        "Let Begin = f Xinit I U {Z I ]X,Y[XY H Z]} U",
        "formal definition of relation =:�.",
        "above is provided in Figure 1 by means of a deduction system.",
        "We assign a procedural interpretation to such a system following Shieber et al.",
        "(1995), resulting in an algorithm for the computation of the relation.",
        "We now turn to an important property of segments.",
        "Any computation (Xinit, al • • • an) �_*",
        "a2 ai >'3i.",
        "n segments represented by ai a2 > /3i, 1 < i < n, N with of = Xinit, n = Xfcnal, and for 1 < i < n, /3i is a suffix of ai+1 or ai+1 is a suffix of /3i.",
        "This is done by the deduction system given in Figure 2, which defines the relation >+.",
        "The second side-condition of inference rule (5) checks whether a segment aX a > 3Y may border on other segments, or may be the first or last segment in a computation.",
        "Figure 3 illustrates a computation of a PDA recognizing a string ala2a3a4.",
        "A horizontal line segment in the curve represents a scan transition, an upward line segment represents a push transition, and a downward line segment a pop transition.",
        "The shaded areas represent segments ai a2 > 3i.",
        "As an example, the area labelled I represents Xinit al> XinitXlX2, for certain stack symbols Xl and X2, where the left edge of the shaded area represents Xinit and the right edge represents X initX 1 X 2 .",
        "Note that segments ai a2 > 3i abstract away from the stack symbols that are pushed and then popped again.",
        "Furthermore, in the context of the whole computation, segments abstract away from stack symbols that are not accessed during a subcomputation.",
        "As an example, the shaded area labelled III represents segment YlY2 a3> Z, for certain stack symbols Yl, Y2 and Z, and this abstracts away from the stack symbols that may occur below Yl and Z.",
        "Figure 4 illustrates how two adjacent segments are combined.",
        "The dashed box in the left-hand side of the picture represents stack symbols from the right edge of segment II that need not be explicitly represented by segment III, as discussed above.",
        "We may assume that these symbols exist, so that II and III can be combined into the larger computation in the right-hand side of the picture.",
        "Note that if a computation a w >+ 3 is obtained as the combination of two segments as in Figure 4, then some internal details of these segments are abstracted away, i.e., stack elements that were pushed and again popped in the combined computation are no longer recorded.",
        "This abstraction is a key feature of the parsing algorithm to be presented next, in that it considerably reduces the time complexity as compared with that of an algorithm that investigates all computations of the PDA in isolation.",
        "We are now ready to present our parsing algorithm, which is the main result of this section.",
        "The algorithm combines the deduction system in Figure 2, as applied to the PDA encoding the input grammar Gi, with the CKY algorithm as applied to the parsing grammar Gp.",
        "(We assume that Gp is in CNF.)",
        "The parsing algorithm may rule out many combinations of segments from Figure 2 that are inconsistent with the language generated by Gp.",
        "Also ruled out are structural compositions of segments that are inconsistent with the structure that Gp assigns to the corresponding substrings.",
        "The parsing algorithm is again specified as a deduction system, presented in Figure 5.",
        "The algorithm manipulates items of the form [A, a,,3], where A is a nonterminal of Gp and a, 3 are stacks of the PDA encoding Gi.",
        "Such an item indicates that there",
        "encoding Gz.",
        "is some terminal string w that is derivable from A in Gp, and such that (a, w) �-* (/3, e).",
        "If the item [S, Xi .2t, Xfi .al] can be derived by the algorithm, then the intersection of the language generated by Gp and the language accepted by the PDA (generated by Gz) is non-empty."
      ]
    },
    {
      "heading": "4 Earley’s algorithm",
      "text": [
        "The CKY algorithm from Figure 5 can be seen to filter out a selection of the computations that may be derived by the deduction system from Figure 2.",
        "One may however be even more selective in determining which computations of the PDA to consider.",
        "The basis for the algorithm in this section is Earley’s algorithm (Earley, 1970).",
        "This algorithm differs from the CKY algorithm in that it satisfies the correct-prefix property (Harrison, 1978).",
        "The new algorithm is presented by Figure 6.",
        "There are now two types of item involved.",
        "The first item has the form [A – > y • v I y * a, y * 3], where A – > y • v has the same role as the dotted rules in Earley’s original algorithm.",
        "The second and third components are stacks of the PDA as before, but these stacks now contain a distinguished position, indicated by *.",
        "The existence of an item [A – > y • v I y * a, y * 3] implies that (ya, v) �-* (y/3, e), where v is now a string derivable from fie.",
        "This is quite similar to the meaning we assigned to the items of the CKY algorithm, but here not all stack symbols in ya and y/3 are involved in this computation: only the symbols in a and /3 are now accessed, while all symbols in y remain unaffected.",
        "The portion of the stack represented by y is needed to ensure the correct-prefix property in subsequent computations following from this item, in case all of the symbols in /3 are popped.",
        "The correct-prefix property is ensured in the following sense.",
        "The existence of an item [A – > y • v I y * a, y * 3] implies that (i) there is a string wv that is both a prefix of a string accepted by the PDA and of a string generated by the CFG such that after",
        "processing w, A is expanded in a leftmost derivation and some stack can be obtained of which ya represent the topmost elements, and (ii) y is rewritten to v and while processing v the PDA replaces the stack elements a by /3.3 The second type of item has the form [A • v I y * a, y * /3 1 Q?].",
        "The first three components are the same as before, and Q indicates that we wish to know whether a stack with topmost symbols Qya may arise after reading a prefix of a string that may also lead to expansion of nonterminal A in a leftmost derivation.",
        "Such an item results if it is detected that the existence of Q below ya needs to be ensured in order to continue the computation under the constraint of the correct-prefix property.",
        "Our algorithm also makes use of segments, as computed by the algorithm from Figure 1.",
        "Consistently with rule (5) from Figure 2, we write aX a >+ 3Y to represent a segment aX a > 3Y such that X E Begin A Y E End.",
        "The use of segments that were computed bottom-up is a departure from pure left-to-right processing in the spirit of Ear-ley’s original algorithm.",
        "The motivation is that we have found empirically that the use of rule (2) was essential for avoiding a large part of the exponential behaviour; note that that rule considers at most a number of stacks that is quadratic in the size of the PDA.",
        "The first inference rule (11) can be easily justified: we want to investigate strings that are both generated by the grammar and recognized by the PDA, so we begin by combining the start symbol and a matching right-hand side from the grammar with the initial stack for the PDA.",
        "Segments are incorporated into the left-to-right computation by rules (12) and (13).",
        "These two rules are the equivalents of (9) and (10) from Figure 5.",
        "Note that in the case of (13) we require the presence of y below the marker in the antecedent.",
        "This indicates that a stack with topmost symbols ya and a dotted rule A – > y • av can be obtained by simultaneously processing a string from left to right by the grammar and the PDA.",
        "Thereby, we may continue the derivation with the item in the consequent without violating the correct-prefix property.",
        "Rule (14) states that if a segment presupposes the existence of stack elements that are not yet available, we produce an item that starts a backward computation.",
        "We do this one symbol at a time, starting with",
        "the symbol Q just beneath the part of the stack that is already available.",
        "This will be discussed more carefully below.",
        "The predictor step of Earley’s algorithm is represented by (15), and the completer step by rules (16) and (17).",
        "These latter two are very similar to (12) and (13) in that they incorporate a smaller derivation in a larger derivation.",
        "Rules (18) and (19) repeat computations that have been done before, but in a backward manner, in order to propagate the information that deeper stack symbols are needed than those currently available, in particular that we want to know whether a certain stack symbol Q may occur below the currently available parts of the stack.",
        "In (18) this query is passed on to the beginning of the context-free rule, and in (19) this query is passed on backwards through a predictor step.",
        "In the antecedent of rule (18) the position of the marker is irrelevant, and is not indicated explicitly.",
        "Similarly, for rule (19) we assume the position of the marker is copied unaltered from the first antecedent to the consequent.",
        "If we find the required stack symbol Q, we propagate the information forward that this symbol may indeed occur at the specified position in the stack.",
        "This is implemented by rules (20) and (21).",
        "Rule (20) corresponds to the predictor step (15), but (20) passes on a larger portion of the stack than (20).",
        "Rule (15) only transfers the topmost symbol X to the consequent, in order to keep the stacks as shallow as possible and to achieve a high degree of sharing of computation."
      ]
    },
    {
      "heading": "5 Empirical results",
      "text": [
        "We have implemented the two algorithms and tested them on non-recursive input CFGs and a parsing CFG.",
        "We have had access to six input CFGs of the form described by Langkilde (2000).",
        "As parsing CFG we have taken a small handwritten grammar of about 100 rules.",
        "While this small size is not at all typical of practical grammars, it suffices to demonstrate the applicability of our algorithms.",
        "The results of the experiments are reported in Figure 1.",
        "We have ordered the input grammars by size, according to the number of nonterminals (or the number of nodes in the forest, following the terminology by Langkilde (2000)).",
        "The second column presents the number of strings generated by the input CFG, or more accurately, the number of derivations, as the grammars contain some ambiguity.",
        "The high numbers show that without a doubt the naive solution of processing the input grammars by enumerating individual strings (derivations) is not a viable option.",
        "The third column shows the size, expressed as number of states, of a lattice (acyclic finite automaton) that would result by unfolding the grammar (Knight and Langkilde, 2000).",
        "Although this approach could be of more practical interest than the naive approach of enumerating all strings, it still leads to large intermediate results.",
        "In fact, practical context-free parsing algorithms for finite automata have cubic time complexity in the number of states, and derive a number of items that is quadratic in the number of states.",
        "The next column presents the number of segments a a > 3.",
        "These apply to both algorithm.",
        "We only compute segments a a > 3 for terminals a that also occur in the parsing grammar.",
        "(Further obvious optimizations in the case of Earley’s algorithm were found to lead to no more than a slight reduction of produced segments.)",
        "The last two columns present the number of items specific to the two algorithms in Figures 5 and 6, respectively.",
        "Although our two algorithms are exponential in the number of stack symbols in the worst case, just as approaches that enumerate all strings or that unfold Gz into a lattice, we see that the numbers of items are relatively moderate if we compare them to the number of strings generated by the input grammars.",
        "Earley’s algorithm generally produces more items than the CKY algorithm.",
        "An exception is the last input CFG; it seems that the number of items that Ear-ley’s algorithm needs to consider in order to maintain the correct-prefix property is very sensitive to qualities of the particular input CFG.",
        "The present implementations use a trie to store stacks; the arcs in the trie closest to the root represent stack symbols closest to the top of the stacks.",
        "For example, for storing a 't 3, the algorithm represents a and /3 by their corresponding nodes in the trie, and it indexes a 't 3 twice, once through each associated node.",
        "Since the trie is doubly linked (i.e. we may traverse the trie upwards as well as downwards), we can always reconstruct the stacks",
        "from the corresponding nodes.",
        "This structure is also convenient for finding pairs of matching stacks, one of which may be deeper than the other, as required by the inference rules from e.g.",
        "Figure 5, since given the first stack in such a pair, the second can be found by traversing the trie either upwards or downwards."
      ]
    },
    {
      "heading": "6 Discussion",
      "text": [
        "It is straightforward to give an algorithm for parsing a finite language: we may trivially parse each string in the language in isolation.",
        "However, this is not a practical solution when the number of strings in the language exceeds all reasonable bounds.",
        "Some algorithms have been described in the existing literature that parse sets of strings of exponential size in the length of the input description.",
        "These solutions have not considered context-free parsing of finite languages encoded by non-recursive CFGs, in a way that takes full advantage of the compactness of the representation.",
        "Our algorithms make this possible, relying on the compactness of the input grammars for efficiency in practical cases, and on the absence of recursion for guaranteeing termination.",
        "Our experiments also show that these algorithms are of practical interest."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "We are indebted to Irene Langkilde for putting to our disposal the non-recursive CFGs on which we have based our empirical evaluation."
      ]
    }
  ]
}
