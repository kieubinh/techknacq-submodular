{
  "info": {
    "authors": [
      "Stuart Geman",
      "Mark Johnson"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P02-1036",
    "title": "Dynamic Programming for Parsing and Estimation of Stochastic Unification-Based Grammars",
    "url": "https://aclweb.org/anthology/P02-1036",
    "year": 2002
  },
  "references": [
    "acl-J97-4005",
    "acl-P99-1069"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Stochastic unification-based grammars (SUBGs) define exponential distributions over the parses generated by a unification-based grammar (UBG).",
        "Existing algorithms for parsing and estimation require the enumeration of all of the parses of a string in order to determine the most likely one, or in order to calculate the statistics needed to estimate a grammar from a training corpus.",
        "This paper describes a graph-based dynamic programming algorithm for calculating these statistics from the packed UBG parse representations of Maxwell and Kaplan (1995) which does not require enumerating all parses.",
        "Like many graphical algorithms, the dynamic programming algorithm’s complexity is worst-case exponential, but is often polynomial.",
        "The key observation is that by using Maxwell and Kaplan packed representations, the required statistics can be rewritten as either the max or the sum of a product of functions.",
        "This is exactly the kind of problem which can be solved by dynamic programming over graphical models.",
        "We would like to thank Eugene Charniak, Miyao Yusuke, Mark Steedman as well as Stefan Riezler and the team at PARC; naturally all errors remain our own.",
        "This research was supported by NSF awards DMS 0074276 and ITR IIS 0085940."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Stochastic Unification-Based Grammars (SUBGs) use log-linear models (also known as exponential or MaxEnt models and Markov Random Fields) to define probability distributions over the parses of a unification grammar.",
        "These grammars can incorporate virtually all kinds of linguistically important constraints (including non-local and non-context-free constraints), and are equipped with a statistically sound framework for estimation and learning.",
        "Abney (1997) pointed out that the non-context-free dependencies of a unification grammar require stochastic models more general than Probabilistic Context-Free Grammars (PCFGs) and Markov Branching Processes, and proposed the use of log-linear models for defining probability distributions over the parses of a unification grammar.",
        "Unfortunately, the maximum likelihood estimator Abney proposed for SUBGs seems computationally intractable since it requires statistics that depend on the set of all parses of all strings generated by the grammar.",
        "This set is infinite (so exhaustive enumeration is impossible) and presumably has a very complex structure (so sampling estimates might take an extremely long time to converge).",
        "Johnson et al.",
        "(1999) observed that parsing and related tasks only require conditional distributions over parses given strings, and that such conditional distributions are considerably easier to estimate than joint distributions of strings and their parses.",
        "The conditional maximum likelihood estimator proposed by Johnson et al.",
        "requires statistics that depend on the set of all parses of the strings in the training corpus.",
        "For most linguistically realistic grammars this set is finite, and for moderate sized grammars and training corpora this estimation procedure is quite feasible.",
        "However, our recent experiments involve training from the Wall Street Journal Penn Treebank, and repeatedly enumerating the parses of its 50,000 sentences is quite time-consuming.",
        "Matters are only made worse because we have moved some of the constraints in the grammar from the unification component to the stochastic component.",
        "This broadens the coverage of the grammar, but at the expense of massively expanding the number of possible parses of each sentence.",
        "In the mid-1990s unification-based parsers were developed that do not enumerate all parses of a string but instead manipulate and return a “packed” representation of the set of parses.",
        "This paper describes how to find the most probable parse and the statistics required for estimating a SUBG from the packed parse set representations proposed by Maxwell III and Kaplan (1995).",
        "This makes it possible to avoid explicitly enumerating the parses of the strings in the training corpus.",
        "The methods proposed here are analogues of the well-known dynamic programming algorithms for Probabilistic Context-Free Grammars (PCFGs); specifically the Viterbi algorithm for finding the most probable parse of a string, and the Inside-Outside algorithm for estimating a PCFG from unparsed training data.' In fact, because Maxwell and Kaplan packed representations are just Truth Maintenance System (TMS) representations (Forbus and de Kleer, 1993), the statistical techniques described here should extend to non-linguistic applications of TMSs as well.",
        "Dynamic programming techniques have been applied to log-linear models before.",
        "Lafferty et al.",
        "(2001) mention that dynamic programming can be used to compute the statistics required for conditional estimation of log-linear models based on context-free grammars where the properties can include arbitrary functions of the input string.",
        "Miyao and Tsujii (2002) (which 'However, because we use conditional estimation, also known as discriminative training, we require at least some discriminating information about the correct parse of a string in order to estimate a stochastic unification grammar.",
        "appeared after this paper was accepted) is the closest related work we know of.",
        "They describe a technique for calculating the statistics required to estimate a log-linear parsing model with non-local properties from packed feature forests.",
        "The rest of this paper is structured as follows.",
        "The next section describes unification grammars and Maxwell and Kaplan packed representation.",
        "The following section reviews stochastic unification grammars (Abney, 1997) and the statistical quantities required for efficiently estimating such grammars from parsed training data (Johnson et al., 1999).",
        "The final substantive section of this paper shows how these quantities can be defined directly in terms of the Maxwell and Kaplan packed representations.",
        "The notation used in this paper is as follows.",
        "Variables are written in upper case italic, e.g., X, Y, etc., the sets they range over are written in script, e.g., X, Y, etc., while specific values are written in lower case italic, e.g., x, y, etc.",
        "In the case of vector-valued entities, subscripts indicate particular components."
      ]
    },
    {
      "heading": "2 Maxwell and Kaplan packed representations",
      "text": [
        "This section characterises the properties of unification grammars and the Maxwell and Kaplan packed parse representations that will be important for what follows.",
        "This characterisation omits many details about unification grammars and the algorithm by which the packed representations are actually constructed; see Maxwell III and Kaplan (1995) for details.",
        "A parse generated by a unification grammar is a finite subset of a set F of features.",
        "Features are parse fragments, e.g., chart edges or arcs from attribute-value structures, out of which the packed representations are constructed.",
        "For this paper it does not matter exactly what features are, but they are intended to be the atomic entities manipulated by a dynamic programming parsing algorithm.",
        "A grammar defines a set Q of well-formed or grammatical parses.",
        "Each parse w E Q is associated with a string of words Y(w) called its yield.",
        "Note that except for trivial grammars F and Q are infinite.",
        "the set of parses of a string y and F(y) is the set of features appearing in the parses of y.",
        "In the grammars of interest here Q(y) and hence also F(y) are finite.",
        "Maxwell and Kaplan’s packed representations often provide a more compact representation of the set of parses of a sentence than would be obtained by merely listing each parse separately.",
        "The intuition behind these packed representations is that for most strings y, many of the features in F(y) occur in many of the parses Q(y).",
        "This is often the case in natural language, since the same substructure can appear as a component of many different parses.",
        "Packed feature representations are defined in terms of conditions on the values assigned to a vector of variables X.",
        "These variables have no direct linguistic interpretation; rather, each different assignment of values to these variables identifies a set of features which constitutes one of the parses in the packed representation.",
        "A condition a on X is a function from X to {0, 1}.",
        "While for uniformity we write conditions as functions on the entire vector X, in practice Maxwell and Kaplan’s approach produces conditions whose value depends only on a few of the variables in X, and the efficiency of the algorithms described here depends on this.",
        "A packed representation of a finite set of parses is a quadruple R = (FP, X, N, a), where:",
        "• FP D F(y) is a finite set of features, • X is a finite vector of variables, where each variable Xt ranges over the finite set Xt, • N is a finite set of conditions on X called the no-goods,2 and • a is a function that maps each feature f E F' to a condition a f on X.",
        "A vector of values x satisfies the no-goods N iff N(x) = 1, where N(x) = H,CN q(x).",
        "Each x that satisfies the no-goods identifies a parse w(x) = {f E FP|a f(x) = 1}, i.e., w is the set of features whose conditions are satisfied by x.",
        "We require that each parse be identified by a unique value satisfying 2 The name “no-good” comes from the TMS literature, and was used by Maxwell and Kaplan.",
        "However, here the no-goods actually identify the good variable assignments.",
        "the no-goods.",
        "That is, we require that:",
        "Finally, a packed representation R represents the set of parses Q(R) that are identified by values that satisfy the no-goods, i.e., Q(R) = {w(x)|x E X, N(x) = 1}.",
        "Maxwell III and Kaplan (1995) describes a parsing algorithm for unification-based grammars that takes as input a string y and returns a packed representation R such that Q(R) = Q(y), i.e., R represents the set of parses of the string y.",
        "The SUBG parsing and estimation algorithms described in this paper use Maxwell and Kaplan’s parsing algorithm as a subroutine."
      ]
    },
    {
      "heading": "3 Stochastic Unification-Based Grammars",
      "text": [
        "This section reviews the probabilistic framework used in SUBGs, and describes the statistics that must be calculated in order to estimate the parameters of a SUBG from parsed training data.",
        "For a more detailed exposition and descriptions of regularization and other important details, see Johnson et al.",
        "(1999).",
        "The probability distribution over parses is defined in terms of a finite vector g = (gi, ... , gm) of properties.",
        "A property is a real-valued function of parses Q. Johnson et al.",
        "(1999) placed no restrictions on what functions could be properties, permitting properties to encode arbitrary global information about a parse.",
        "However, the dynamic programming algorithms presented here require the information encoded in properties to be local with respect to the features F used in the packed parse representation.",
        "Specifically, we require that properties be defined on features rather than parses, i.e., each feature f E F is associated with a finite vector of real values (gi (f ), ... , gm (f )) which define the property functions for parses as follows: gk (w) = E gk (f) , for k = 1... m. (2) fEw That is, the property values of a parse are the sum of the property values of its features.",
        "In the usual case, some features will be associated with a single property (i.e., gk(f ) is equal to 1 for a specific value of k and 0 otherwise), and other features will be associated with no properties at all (i.e., g(f) = 0).",
        "This requires properties be very local with respect to features, which means that we give up the ability to define properties arbitrarily.",
        "Note however that we can still encode essentially arbitrary linguistic information in properties by adding specialised features to the underlying unification grammar.",
        "For example, suppose we want a property that indicates whether the parse contains a reduced relative clauses headed by a past participle (such “garden path” constructions are grammatical but often almost incomprehensible, and alternative parses not including such constructions would probably be preferred).",
        "Under the current definition of properties, we can introduce such a property by modifying the underlying unification grammar to produce a certain “diacritic” feature in a parse just in case the parse actually contains the appropriate reduced relative construction.",
        "Thus, while properties are required to be local relative to features, we can use the ability of the underlying unification grammar to encode essentially arbitrary non-local information in features to introduce properties that also encode non-local information.",
        "A Stochastic Unification-Based Grammar is a triple (U, g, 0), where U is a unification grammar that defines a set Q of parses as described above, g = (g1, ... , gm) is a vector of property functions as just described, and 0 = (01, ... , Bm) is a vector of non-negative real-valued parameters called property weights.",
        "The probability PO (w) of a parse w E Q is:",
        "Intuitively, if gj (w) is the number of times that property j occurs in w then Bj is the ‘weight’ or ‘cost’ of each occurrence of property j and ZB is a normalising constant that ensures that the probability of all parses sums to 1.",
        "Now we discuss the calculation of several important quantities for SUBGs.",
        "In each case we show that the quantity can be expressed as the value that maximises a product of functions or else as the sum of a product of functions, each of which depends on a small subset of the variables X.",
        "These are the kinds of quantities for which dynamic programming graphical model algorithms have been developed."
      ]
    },
    {
      "heading": "3.1 The most probable parse",
      "text": [
        "In parsing applications it is important to be able to extract the most probable (or MAP) parse ˆw(y) of string y with respect to a SUBG.",
        "This parse is:",
        "Given a packed representation (P, X, N, a) for the parses Q(y), let ˆx(y) be the x that identifies ˆw(y).",
        "Since WB(ˆc�;(y)) > 0, it can be shown that:",
        "where he, f (x) = Hm j=1 B�j (f ) if of (x) = 1 and he, f(x) = 1 if a f(x) = 0.",
        "Note that he, f(x) depends on exactly the same variables in X as a f does.",
        "As (3) makes clear, finding ˆx(y) involves maximising a product of functions where each function depends on a subset of the variables X.",
        "As explained below, this is exactly the kind of maximisation that can be solved using graphical model techniques."
      ]
    },
    {
      "heading": "3.2 Conditional likelihood",
      "text": [
        "We now turn to the estimation of the property weights 0 from a training corpus of parsed data D = (w1, ... , wn).",
        "As explained in Johnson et al.",
        "(1999), one way to do this is to find the 0 that maximises the",
        "conditional likelihood of the training corpus parses given their yields.",
        "(Johnson et al.",
        "actually maximise conditional likelihood regularized with a Gaussian prior, but for simplicity we ignore this here).",
        "If yi is the yield of the parse wi, the conditional likelihood of the parses given their yields is:",
        "Then the maximum conditional likelihood estimate Bˆ of 0 is Bˆ = argmaxg LD(0).",
        "Now calculating WO(wi) poses no computational problems, but since Q(yi) (the set of parses for yi) can be large, calculating Zg(Q(yi)) by enumerating each W E Q(yi) can be computationally expensive.",
        "However, there is an alternative method for calculating Zg(Q(yi)) that does not involve this enumeration.",
        "As noted above, for each yield yi, i = 1, ... , n, Maxwell’s parsing algorithm returns a packed feature structure Ri that represents the parses of yi, i.e., Q(yi) = Q(Ri).",
        "A derivation parallel to the one for (3) shows that for R = (FP, X, N, a):",
        "(This derivation relies on the isomorphism between parses and variable assignments in (1)).",
        "It turns out that this type of sum can also be calculated using graphical model techniques."
      ]
    },
    {
      "heading": "3.3 Conditional Expectations",
      "text": [
        "In general, iterative numerical procedures are required to find the property weights 0 that maximise the conditional likelihood LD(0).",
        "While there are a number of different techniques that can be used, all of the efficient techniques require the calculation of conditional expectations EB [gk |yi] for each property gk and each sentence yi in the training corpus, where:",
        "For example, the Conjugate Gradient algorithm, which was used by Johnson et al., requires the calculation not just of LD(B) but also its derivatives aLD(0)/a0k.",
        "It is straightforward to show:",
        "We have just described the calculation of LD(B), so if we can calculate EB [gk |yi] then we can calculate the partial derivatives required by the Conjugate Gradient algorithm as well.",
        "Again, let R = (FP, X, N, a) be a packed representation such that Q(R) = Q(yi).",
        "First, note that (2) implies that:",
        "Note that P ({W : f E W } |yi) involves the sum of weights over all x E X subject to the conditions that N(x) = 1 and a f(x) = 1.",
        "Thus P({W : f E W}|yi) can also be expressed in a form that is easy to evaluate using graphical techniques."
      ]
    },
    {
      "heading": "4 Graphical model calculations",
      "text": [
        "In this section we briefly review graphical model algorithms for maximising and summing products of functions of the kind presented above.",
        "It turns out that the algorithm for maximisation is a generalisation of the Viterbi algorithm for HMMs, and the algorithm for computing the summation in (5) is a generalisation of the forward-backward algorithm for HMMs (Smyth et al., 1997).",
        "Viewed abstractly, these algorithms simplify these expressions by moving common factors over the max or sum operators respectively.",
        "These techniques are now relatively standard; the most well-known approach involves junction trees (Pearl, 1988; Cow-ell, 1999).",
        "We adopt the approach approach described by Geman and Kochanek (2000), which is a straightforward generalization of HMM dynamic programming with minimal assumptions and programming overhead.",
        "However, in principle any of",
        "the graphical model computational algorithms can be used.",
        "The quantities (3), (4) and (5) involve maximisation or summation over a product of functions, each of which depends only on the values of a subset of the variables X.",
        "There are dynamic programming algorithms for calculating all of these quantities, but for reasons of space we only describe an algorithm for finding the maximum value of a product of functions.",
        "These graph algorithms are rather involved.",
        "It may be easier to follow if one reads Example 1 before or in parallel with the definitions below.",
        "To explain the algorithm we use the following notation.",
        "If x and x' are both vectors of length m then x =j x' iff x and x' disagree on at most their jth components, i.e., xk = xk for k = 1,... , j − 1, j + 1,... m. If f is a function whose domain is X, we say that f depends on the set of variables d(f) = {Xj |Ix, x' E X, x= j x', f(x) =7� f(x')}.",
        "That is, Xj E d(f ) iff changing the value of Xj can change the value of f .",
        "The algorithm relies on the fact that the variables in X = (X1 , ... , Xn) are ordered (e.g., X1 precedes X2, etc.",
        "), and while the algorithm is correct for any variable ordering, its efficiency may vary dramatically depending on the ordering as described below.",
        "Let H be any set of functions whose domains are X.",
        "We partition H into disjoint subsets H1, ... , Hn+1, where Hj is the subset of H that depend on Xj but do not depend on any variables ordered before Xj, and Hn+1 is the subset of H that do not depend on any variables at all (i.e., they are constants).3 That is,Hj = {H E H|Xj E d(H), Vi < j Xi V d(H)} and Hn+1 = {H EH|d(H) = 0}.",
        "As explained in section 3.",
        "1, there is a set of functions A such that the quantities we need to calculate have the general form:",
        "Mmax is the maximum value of the product expression while xˆ is the value of the variables at which the maximum occurs.",
        "In a SUBG parsing application xˆ identifies the MAP parse.",
        "The procedure depends on two sequences of functions Mi,i = 1,...,n + 1 and Vi,i = 1,...,n. Informally, Mi is the maximum value attained by the subset of the functions A that depend on one of the variables X1, ... , Xi, and Vi gives information about the value of Xi at which this maximum is attained.",
        "To simplify notation we write these functions as functions of the entire set of variables X, but usually depend on a much smaller set of variables.",
        "The Mi are real valued, while each Vi ranges over Xi.",
        "Let M = {M1, ... , Mn}.",
        "Recall that the sets of functions A and M can be both be partitioned into disjoint subsets A1, ... , An+1 and M1, ... , Mn+1 respectively on the basis of the variables each Ai and Mi depend on.",
        "The definition of the Mi and Vi, i = 1, ... , n is as follows:",
        "The definition of Mi in (8) may look circular (since M appears in the right-hand side), but in fact it is not.",
        "First, note that Mi depends only on variables ordered after Xi, so if Mj E Mi then j < i.",
        "More specifically,",
        "Thus we can compute the Mi in the order M1, ... , Mn+1, inserting Mi into the appropriate set Mk, where k > i, when Mi is computed.",
        "We claim that Mmax = Mn+1.",
        "(Note that Mn+1 and Mn are constants, since there are no variables ordered after Xn).",
        "To see this, consider the tree T whose nodes are the Mi, and which has a directed edge from Mi to Mj iff Mi E Mj (i.e., Mi appears in the right hand side of the definition (8) of Mj ).",
        "T has a unique root Mn+1, so there is a path from",
        "every Mi to Mn+1 .",
        "Let i � jiff there is a path from Mi to Mj in this tree.",
        "Then a simple induction shows that Mj is a function from d(Mj) to a maximisation over each of the variables Xi where i � j of Fi�j,AEA, A.",
        "Further, it is straightforward to show that Vi(ˆx) = ˆxi (the value xˆ assigns to Xi).",
        "By the same arguments as above, d(Vi) only contains variables ordered after Xi, so Vn = ˆxn.",
        "Thus we can evaluate the Vi in the order Vn, ... , V1 to find the maximising assignment ˆx.",
        "Example 1 Let X = { X1, X2, X3, X4, X5, X6, X7} and set A = {a(X1, X3), b(X2, X4), c(X3, X4, X5), d(X4, X5), e(X6, X7)}.",
        "We can represent the sharing of variables in A by means of a undirected graph GA, where the nodes of GA are the variables X and there is an edge in GA connecting Xi to Xj iff ]A E A such that both Xi, Xj E d(A).",
        "GA is depicted below.",
        "Starting with the variable X1, we compute M1 and V1:",
        "Since M1 belongs to M3, it appears in the definition of M3.",
        "Note that M5 is a constant, reflecting the fact that in GA the node X5 is not connected to any node ordered after it.",
        "The maximum value for the product M8 = Mmax is defined in terms of M5 and M7.",
        "Finally, we evaluate V7, ... , V1 to find the maximising assignment ˆx.",
        "We now briefly consider the computational complexity of this process.",
        "Clearly, the number of steps required to compute each Mi is a polynomial of order |d(Mi) |+ 1, since we need to enumerate all possible values for the argument variables d(Mi) and for each of these, maximise over the set Xi.",
        "Further, it is easy to show that in terms of the graph GA, d(Mj) consists of those variables Xk, k > j reachable by a path starting at Xj and all of whose nodes except the last are variables that precede Xj.",
        "Since computational effort is bounded above by a polynomial of order |d(Mi) |+ 1, we seek a variable ordering that bounds the maximum value of |d(Mi)|.",
        "Unfortunately, finding the ordering that minimises the maximum value of |d(Mi) |is an NP-complete",
        "problem.",
        "However, there are several efficient heuristics that are reputed in graphical models community to produce good visitation schedules.",
        "It may be that they will perform well in the SUBG parsing applications as well."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "This paper shows how to apply dynamic programming methods developed for graphical models to SUBGs to find the most probable parse and to obtain the statistics needed for estimation directly from Maxwell and Kaplan packed parse representations.",
        "i.e., without expanding these into individual parses.",
        "The algorithm rests on the observation that so long as features are local to the parse fragments used in the packed representations, the statistics required for parsing and estimation are the kinds of quantities that dynamic programming algorithms for graphical models can perform.",
        "Since neither Maxwell and Ka-plan’s packed parsing algorithm nor the procedures described here depend on the details of the underlying linguistic theory, the approach should apply to virtually any kind of underlying grammar.",
        "Obviously, an empirical evaluation of the algorithms described here would be extremely useful.",
        "The algorithms described here are exact, but because we are working with unification grammars and apparently arbitrary graphical models we cannot polynomially bound their computational complexity.",
        "However, it seems reasonable to expect that if the linguistic dependencies in a sentence typically factorize into largely non-interacting cliques then the dynamic programming methods may offer dramatic computational savings compared to current methods that enumerate all possible parses.",
        "It might be interesting to compare these dynamic programming algorithms with a standard unification-based parser using a best-first search heuristic.",
        "(To our knowledge such an approach has not yet been explored, but it seems straightforward: the figure of merit could simply be the sum of the weights of the properties of each partial parse’s fragments).",
        "Because such parsers prune the search space they cannot guarantee correct results, unlike the algorithms proposed here.",
        "Such a best-first parser might be accurate when parsing with a trained grammar, but its results may be poor at the beginning of parameter weight estimation when the parameter weight estimates are themselves inaccurate.",
        "Finally, it would be extremely interesting to compare these dynamic programming algorithms to the ones described by Miyao and Tsujii (2002).",
        "It seems that the Maxwell and Kaplan packed representation may permit more compact representations than the disjunctive representations used by Miyao et al., but this does not imply that the algorithms proposed here are more efficient.",
        "Further theoretical and empirical investigation is required."
      ]
    }
  ]
}
