{
  "info": {
    "authors": [
      "Jason M. Eisner"
    ],
    "book": "Human Language Technology Conference and Meeting of the North American Association for Computational Linguistics",
    "id": "acl-N03-1009",
    "title": "Simpler and More General Minimization for Weighted Finite-State Automata",
    "url": "https://aclweb.org/anthology/N03-1009",
    "year": 2003
  },
  "references": [
    "acl-J97-2003",
    "acl-P02-1001"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Previous work on minimizing weighted finite-state automata (including transducers) is limited to particular types of weights.",
        "We present efficient new minimization algorithms that apply much more generally, while being simpler and about as fast.",
        "We also point out theoretical limits on minimization algorithms.",
        "We characterize the kind of “well-behaved” weight semirings where our methods work.",
        "Outside these semirings, minimization is not well-defined (in the sense of producing a unique minimal automaton), and even finding the minimum number of states is in general NP-complete and inapproximable."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "It is well known how to efficiently minimize a deterministic finite-state automaton (DFA), in the sense of constructing another DFA that recognizes the same language as the original but with as few states as possible (Aho et al., 1974).",
        "This DFA also has as few arcs as possible.",
        "Minimization is useful for saving memory, as when building very large automata or deploying NLP systems on small hand-held devices.",
        "When automata are built up through complex regular expressions, the savings from minimization can be considerable, especially when applied at intermediate stages of the construction, since (for example) smaller automata can be intersected faster.",
        "Recently the computational linguistics community has turned its attention to weighted automata that compute interesting functions of their input strings.",
        "A traditional automaton only returns an boolean from the set K = {true, f alsel, which indicates whether it has accepted the input.",
        "But a probabilistic automaton returns a probability in K = [0, 1], or equivalently, a negated log-probability in K = [0, oo] .",
        "A transducer returns an output string from K = A* (for some alphabet A).",
        "Celebrated algorithms by Mohri (1997; 2000) have recently made it possible to minimize deterministic automata whose weights (outputs) are log-probabilities or strings.",
        "These cases are of central interest in language and speech processing.",
        "However, automata with other kinds of weights can also be defined.",
        "The general formulation of weighted automata (Berstel and Reutenauer, 1988) permits any weight set K, if appropriate operations ® and (9 are provided for combining weights from the different arcs of the automaton.",
        "The triple (K, ®, (9) is called a weight semiring and will be explained below.",
        "K-valued functions that can be computed by finite-state automata are called rational functions.",
        "How does minimization generalize to arbitrary weight semirings?",
        "The question is of practical as well as theoretical interest.",
        "Some NLP automata use the real semiring (R, +, x), or its log equivalent, to compute unnormalized probabilities or other scores outside the range [0, 1] (Laf-ferty et al., 2001; Cortes et al., 2002).",
        "Expectation semirings (Eisner, 2002) are used to handle bookkeeping when training the parameters of a probabilistic transducer.",
        "A byproduct of this paper is a minimization algorithm that works fully with those semirings, a new result permitting more efficient automaton processing in those situations.",
        "Surprisingly, we will see that minimization is not even well-defined for all weight semirings!",
        "We will then (nearly) characterize the semirings where it is well-defined, and give a recipe for constructing minimization algorithms similar to Mohri’s in such semirings.",
        "Finally, we follow this recipe to obtain a specific, simple and practical algorithm that works for all division semirings.",
        "All the cases above either fall within this framework or can be forced into it by adding multiplicative inverses to the semiring.",
        "The new algorithm provides arguably simpler minimization for the cases that Mohri has already treated, and also handles additional cases."
      ]
    },
    {
      "heading": "2 Weights and Minimization",
      "text": [
        "We introduce weighted automata by example.",
        "The transducer below describes a partial function from strings to strings.",
        "It maps aab �--> xyz and bab �--> wwyz.",
        "Why?",
        "Since the transducer is deterministic, each input (such as aab) is accepted along at most one path; the corresponding output (such as xyz) is found by concatenating the output strings found along the path.",
        "E denotes the empty string.",
        "δ and σ standardly denote the automaton’s transition and output functions: δ(3, a) = 2 is the state reached by the",
        "a:wwy a:y b:zz b:z b:e a arc from state 3, and Q(3, a) = wwy is that arc’s output.",
        "In an automaton whose outputs (weights) were numbers rather than strings like wwy, concatenating them would not be sensible; instead we would want to add or multiply the weights along the path.",
        "In general ® denotes the chosen operation for combining weights along a path.",
        "The ® operation need not be commutative – indeed concatenation is not – but it must be associative.",
        "K must contain (necessarily unique) weights, denoted 1 and 0, such that 1®k=k®1=kand 0®k=k®0=0for all k E K. An unaccepted input (e.g., aba) is assigned the output 0.",
        "When ® is string concatenation, 1 = e, and 0 is a special object ∅ defined to satisfy the axioms.",
        "If an input such as aa were accepted along multiple paths, we would have to use another operation ⊕ to combine those paths’ weights into a single output for aa.",
        "But that cannot happen with the deterministic automata treated by this paper.",
        "So we omit discussion of the properties that ⊕ should have, and do not trouble to spell out its definition for the semirings (K, ⊕, ®) discussed in this paper.1 We are only concerned with the monoid (K, ®).",
        "The following automaton is equivalent to the previous one since it computes the same function: a:yz However, it distributes weights differently along the arcs, and states 1 and 3 can now obviously be merged (as can 2 and 4, yielding the minimal equivalent automaton).",
        "Formally we know that states 1 and 3 are equivalent because F1 = F3, where F9 denotes the suffix function of state q – the function defined by the automaton if the start state is taken to be q rather than 0.",
        "(Thus, F3 (ab) = yz.)",
        "Equivalent states can safely be merged, by deleting one and rerouting its incoming arcs to the other.",
        "We will follow Mohri’s minimization strategy:",
        "1.",
        "Turn the first automaton above into the second.",
        "This operation is called pushing (or quasi-determinization).",
        "Here, for instance, it “pushed ww back” through state 3.",
        "2.",
        "Merge equivalent states of the second automaton, by applying ordinary unweighted DFA minimization (Aho et al., 1974, section 4.13) as if each weighted arc label such as a:yz were simply a letter in a large alphabet.",
        "3.",
        "Trim the result, removing useless states and arcs that are not on any accepting path (defined as a path whose weight is non-0 because it has no missing arcs and its last state is final).",
        "Mohri (2000) proves that this technique finds the minimal automaton, which he shows to be unique up to placement of weights along paths.2 We will only have to modify step 1, generalizing pushing to other semirings.",
        "Pushing makes heavy use of left quotients: we adopt the notation k\\m for an element of K such that k ® (k\\m) = m. This differs from the notation k-1® m (in which k-1 denotes an actual element of K) because k\\m need not exist nor be unique.",
        "For example, ww\\wwzzz = zzz (a fact used above) but wwy\\wwzzz does not exist since wwzzz does not begin with wwy.",
        "If F is a function, a is a string, and k is a weight, we use some natural notation for functions related to F:",
        "In effect, k\\F and a-1F drop output and input prefixes."
      ]
    },
    {
      "heading": "3 Pushing and Its Limitations",
      "text": [
        "The intuition behind pushing is to canonicalize states’ suffix functions.",
        "This increases the chance that two states will have the same suffix function.",
        "In the example of the previous section, we were able to replace F3 with ww\\F3 (pushing the ww backwards onto state 3’s incoming arc), making it equal to F1 so f1, 3l could merge.",
        "Since canonicalization was also performed at states 2 and 4, F1 and F3 ended up with identical representations: arc weights were distributed identically along corresponding paths from 1 and 3.",
        "Hence unweighted minimization could discover that F1 = F3 and merge f1, 3l.",
        "Mohri’s pushing strategy – we will see others – is always to extract some sort of “maximum left factor” from each suffix function F9 and push it backwards.",
        "That is, he expresses F9 = k ® G for as “large” a k E K as possible – a maximal common prefix – then pushes factor k back out of the suffix function so that it is counted earlier on paths through q (i.e., before reaching q).",
        "q’s suffix function now has canonical form G (i.e., k\\F9).",
        "How does Mohri’s strategy reduce to practice?",
        "For transducers, where (K, ®) = (A*, concat), the maximum left factor of F9 is the longest common prefix of the strings in range(F9).3 Thus we had range(F3) = f wwyz, wwzzzl above with longest common prefix ww.",
        "For the tropical semiring (R>0 U fool, min, +), where k\\m = m − k is defined only if k ≤ m, the maximum left factor k is the minimum of range(F9).",
        "But “maximum left factor” is not an obvious notion for all semirings.",
        "If we extended the tropical semir",
        "ing with negative numbers, or substituted the semiring (R>0, +, x), keeping the usual definition of “maximum,” then any function would have arbitrarily large left factors.",
        "A more fundamentally problematic example is the semiring Z[v/-5].",
        "It is defined as (1m+nv/-5 : m, n E Z}, +, x) where Z denotes the integers.",
        "It is a standard example of a commutative algebra in which factorization is not unique.",
        "For example, 6 = 2 ® 3 =",
        "What is the best left factor to extract from F2?",
        "We could left-divide F2 by either 2 or 1 + v/-5.",
        "The former action allows us to merge 11, 2} and the latter to merge 12,3}; but we cannot have it both ways.",
        "So this automaton has no unique minimization!",
        "The minimum of 4 states is achieved by two distinct answers (contrast footnote 2).",
        "It follows that known minimization techniques will not work in general semirings, as they assume state merge-ability to be transitive .4 In general the result of minimization is not even well-defined (i.e., unique).",
        "Of course, given a deterministic automaton M, one may still seek an equivalent M¯ with as few states as possible.",
        "But we will now see that even finding the minimum number of states is NP-complete, and inapproximable.",
        "The NP-hardness proof [which may be skipped on a first reading] is by reduction from Minimum Clique Partition.",
        "Given a graph with vertex set V = 11, 2,... n} and edge set E, we wish to partition V into as few cliques as possible.",
        "(S C_ V is a clique of the graph iff ij E E for all pairs i, j E S.) Determining the minimum number of cliques is NP-complete and inapproximable: that is, unless P=NP, we cannot even find it within a factor of 2 or 3 or any other constant factor in polynomial time.5 Given such a graph, we reduce the clique problem to our problem.",
        "Consider the “bitwise boolean” semiring (10,1}n, OR, AND).",
        "Each weight k is a string of n bits,",
        "denoted k1,... kn.",
        "For each i E V, define f i, ki, mi E K as follows:fij = 0 iff ij E E; kij = 1 iff i = j; mi j = 0 iff either ij E E or i = j.",
        "Now consider the following automaton M over the alphabet E = 1 a, b, c 1, ... cn }.",
        "The states are 10, 1,... n, n + 1}; 0 is the initial state and n + 1 is the only final state.",
        "For each i E V, there is an arc 0ci:1n --→i and arcs ia:ki--→(n + 1) and i b:mi --→(n + 1).",
        "A minimum-state automaton equivalent to M must have a topology obtained by merging some states of V. Other topologies that could accept the same language (c1 l c2l · · · l cn) (alb) are clearly not minimal (they can be improved by merging final states or by trimming).",
        "We claim that for S C_ 11, 2,... n}, it is possible to merge all states in S into a single state (in the automaton) if and only if S is a clique (in the graph):",
        "• If S is a clique, then define k, m E K by ki = 1 iff i E S, and mi = 1 iff i E� S. Observe that for every i E S, we have ki = fi ® k, mi = fi ® m. So by pushing back a factor of fiat each i E S, one can make all i E S share a suffix function and then merge them.",
        "• If S is not a clique, then choose i, j E S so that ij E� E. Considering only bit i, there exists no bit",
        "pair (ki, mi) E 10,1}2 of which (kii, mii) = (1, 0) and (ki, mi) = (0, 1) are both left-multiples.",
        "So there can exist no weight pair (k, m) of which (ki, mi) and (kj, mj) are both left-multiples.",
        "It is therefore not possible to equalize the suffix functions Fi and Fj by left-dividing each of them.6 i and j cannot be merged.",
        "Thus, the partitions of V into cliques are identical to the partitions of V into sets ofmergeable states, which are in 1-1 correspondence with the topologies of automata equivalent to M and derived from it by merging.",
        "There is an N-clique partition of V iff there is an (N+2)-state automaton.",
        "It follows that finding the minimum number of states is as hard, and as hard to approximate within a constant factor, as finding the minimum number of cliques."
      ]
    },
    {
      "heading": "4 When Is Minimization Unique?",
      "text": [
        "The previous section demonstrated the existence of pathological weight semirings.",
        "We now partially characterize the “well-behaved” semirings (K, ⊕, ®) in which all automata do have unique minimizations.",
        "Except when otherwise stated, lowercase variables are weights E K and uppercase ones are K-valued rational functions.",
        "[This section may be skipped, except the last paragraph.]",
        "A crucial necessary condition is that (K, ®) allow what we will call greedy factorization, meaning that given f ® F = g ® G =� 0, it is always possible to express 6 This argument only shows that pushing backward cannot give them the same suffix function.",
        "But pushing forward cannot help either, despite footnote 4, since 1' on the arc to i has no right factors other than itself (the identity) to push forward.",
        "many practically useful semirings, commutative or otherwise.",
        "It says, roughly, that the order in which left factors are removed from a suffix function does not matter.",
        "We can reach the same canonical H regardless of whether we left-divide first by f or g. Given a counterexample to this condition, one can construct an automaton with no unique minimization.",
        "Simply follow the plan of the Z[.",
        "/−5] example, putting F1 = F, F2 = f ® F = g ® G, F3 = G.7 For example, in sefm/iring (K/, ®) = ({xn : n f#/ 1}, concat), put",
        "Some useful semirings do fail the condition.",
        "One is the “bitwise boolean” semiring that checks a string’s membership in two languages at once: (K, ⊕, ®) = ({00, 01,10,11}, OR, AND).",
        "(Let F2 = 01 ® {(a,11), (b, 00)} = 01 ® {(a, 01), (b,10)}.)",
        "R2 under pointwise x (which computes a string’s probability under two models) fails similarly.",
        "So does (sets, fl, U) (which collects features found along the accepting path).",
        "We call H a residue of F iff F = f' ® H for some f'.",
        "Write F ^ G iff F, G have a common residue.",
        "In these terms, (K, ®) allows greedy factorization iff F ^ G when F, G are residues of the same nonzero function.",
        "More perspicuously, one can show that this holds iff ^ is an equivalence relation on nonzero, K-valued functions.",
        "So in semirings where minimization is uniquely defined, ^ is necessarily an equivalence relation.",
        "Given an automaton M for function F, we may regard ^ as an equivalence relation on the states of a trimmed version of M:8 q ^ riff Fq ^ F,.",
        "Let [r] = {r1 , ... , rm} be the (finite) equivalence class of r: we can inductively find at least one function F[,] that is a common residue of F,1, ... , F,m.",
        "The idea behind minimization is to construct a machine M¯ whose states correspond to these equivalence classes, and where each [r] has suffix function F[,].",
        "The Appendix shows that M¯ is then minimal.",
        "If M has an arc qa:k− – >r, M¯ needs anarc [q] �[r], where k' is such that a-1F[q] = k'® F[,].",
        "The main difficulty in completing the construction of M¯ is to ensure each weight k' exists.",
        "That is, F[,] must be carefully chosen to be a residue not only of F,1, ... , F,m (which ultimately does not matter, as long as F[0] is a residue of F0, where 0 is the start state) but also of a-1F[q].",
        "If M is cyclic, this imposes cyclic dependencies on the choices of the various F[q] and F[,] functions.",
        "We have found no simple necessary and sufficient condition on (K, ®) that guarantees a globally consistent set of choices to exist.",
        "However, we have given a useful nec",
        "essary condition (greedy factorization), and we now give a useful sufficient condition.",
        "Say that H is a minimum residue of G =� 0 if it is a residue of every residue of G. (If G has several minimum residues, they are all residues of one another.)",
        "If (K, ®) is such that every G has a minimum residue – a strictly stronger condition than greedy factorization – then it can be shown that G has the same minimum residues as any H ^ G. In such a (K, ®), M¯ can be constructed by choosing the suffix functions F[,] independently.",
        "Just let F[,] = F{,1,...,,mI be a minimum residue of F,1.",
        "Now consider again M’s arc qa:k− – >r: since a-1F[q] ^a-1Fq ^ F, ^ F,1, we see F[,] is a (minimum) residue of a-1F[q], so that a weight k' canbe chosen for [q]a:k� − – >[r].",
        "A final step ensures that describe it, we must augment the formalism to allow an initial weight t(0) E K, and a final weight 0(r) E K for each final state r. The weight of an accepting path from the start state 0 to a final state r is now defined to be t(0) ® (weights of arcs along the path) ® 0(r).",
        "In ¯M, we set t([0]) to some k such that F0 = k ® F[0], and set 0([r]) = F[,] (e).",
        "The mathematical construction is done."
      ]
    },
    {
      "heading": "5 A Simple Minimization Recipe",
      "text": [
        "We now give an effective algorithm for minimization in the semiring (K, ®).",
        "The algorithmic recipe has one ingredient: along with (K, ®), the user must give us a left-factor functional A that can choose a left factor A(F) of any function F. Formally, if E is the input alphabet, then we require A : (E* – > K) – > K to have the following properties for any rational F : E* – > K and any k E K:",
        "• Shifting: A(k ® F) = k ® A(F).",
        "• Quotient: A(F)\\A(a-1F) exists in K for any a E E. • Final-quotient: A(F)\\F(e) exists in K.9",
        "The algorithm generalizes Mohri’s strategy as outlined in section 2.",
        "We just use A to pick the left factors during pushing.",
        "The A’s used by Mohri for two semirings were mentioned in section 3.",
        "We will define another A in section 6.",
        "Naturally, it can be shown that no A can exist in a semiring that lacks greedy factorization, such as Z[.",
        "/−5].",
        "The 3 properties above are needed for the strategy to work.",
        "The strategy also requires (K, ®) to be left can-cellative, i.e., k ® m = k ® m' implies m = m' (if k =� 0).",
        "In other words, left quotients by k are unique when they exist (except for 0\\0).",
        "This relieves us from having to make arbitrary choices of weight during pushing.",
        "Incompatible choices might prevent arc labels from matching as desired during the merging step of section 2.",
        "9To show the final-quotient property given the other two, it suffices to show that A(G) E K has a right inverse in K, where G is the function mapping a to 1 and everything else to 0.",
        "M defines the function F. To Given an input DFA.",
        "At each state q, simultaneously, we will push back A(Fq).",
        "This pushing construction is trivial once the A(Fq) values are computed.",
        "An arc qa:k−→r should have its weight changed from k to A(Fq)\\A(a−1Fq) = A(Fq)\\A(k (9 FT), which is well-defined (by the quotient property and left cancellativity)10 and can be computed as A(Fq)\\(k (9 A(FT)) (by the shifting property).",
        "Thus a subpath qa:k−→r−W →s, with weight",
        "way the factor A(FT) is removed from the start of all paths from r, and is pushed backwards through r onto the end of all paths to r. It is possible for this factor (or part of it) to travel back through multiple arcs and around cycles, since k' is found by removing a A(Fq) factor from all of k (9 A(FT) and not merely from k. As it replaces the arc weights, pushing also replaces the initial weight ι(0) with ι(0) (9 A(F0), and replaces each final weight O(r) with A(FT)\\O(r) (which is well-defined, by the final-quotient property).",
        "Altogether, pushing leaves path weights unchanged (by easy induction).11 After pushing, we finish with merging and trimming as in section 2.",
        "While merging via unweighted DFA minimization treats arc weights as part of the input symbols, what should it do with any initial and final weights?",
        "The start state’s initial weight should be preserved.",
        "The merging algorithm can and should be initialized with a multi-way partition of states by final weight, instead of just a 2-way partition into final vs. non-final.",
        "12 The Appendix shows that this strategy indeed finds the unique minimal automaton.",
        "It is worth clarifying how this section’s effective algorithm implements the mathematical construction from the end of section 4.",
        "At each state q, pushing replaces the suffix function Fq with A(Fq)\\Fq.",
        "The quotient properties of A are designed to guarantee that this quotient is defined, 13 and the shifting property is designed to ensure 10Except in the case 0\\0, which is not uniquely defined.",
        "This arises only if F9 = 0, i.e., q is a dead state that will be trimmed later, so any value will do for 0\\0: arcs from q are irrelevant.",
        "11 One may prefer a formalism without initial or final weights.",
        "If the original automaton is free of final weights (other than 1), so is the pushed automaton – provided that A(F) = 1 whenever F(E) = 1, as is true for all A’s in this paper.",
        "Initial weights can be eliminated at the cost of duplicating state 0 (details omitted).",
        "12 Alternatively, Mohri (2000, §4.5) explains how to temporarily eliminate final weights before the merging step.",
        "13 That is, A(F9)\\F9(-y) exists for each y E E*.",
        "One may show by induction on 1-y1 that the left quotients A(F)\\F(-y) exist for all F. When 1-y1 = 0 this is the final-quotient property.",
        "For 1-y1 > 0 we can write y as a-y', and then A(F)\\F(-y) =",
        "(A(a-1F)\\(a-1F)(-y')), where the first factor exists by the quotient property and the second factor exists by inductive hypothesis.",
        "that it is a minimum residue of Fq.14 In short, if the conditions of this section are satisfied, so are the conditions of section 4, and the construction is the same.",
        "The converse is true as well, at least for right cancella-tive semirings.",
        "If such a semiring satisfies the conditions of section 4 (every function has a minimum residue), then the requirements of this section can be met to obtain an effective algorithm: there exists a A satisfying our three properties,15 and the semiring is left cancellative.",
        "16"
      ]
    },
    {
      "heading": "6 Minimization in Division Semirings",
      "text": [
        "For the most important idea of this paper, we turn to a common special case.",
        "Suppose the semiring (K, ⊕, (9) defines k\\m for all m, k =� 0 E K. Equivalently,17 suppose every k =� 0 E K has a unique two-sided inverse k−1 E K. Useful cases of such division semirings include the real semiring (R, +, x), the tropical semiring extended with negative numbers (R U Ioo}, min, +), and expectation semirings (Eisner, 2002).",
        "Minimization has not previously been available in these.",
        "We propose a new left-factor functional that is fast to compute and works in arbitrary division semirings.",
        "We avoid the temptation to define A(F) as ® range(F): this definition has the right properties, but in some semirings including (R≥0, +, x) the infinite summation is quite expensive to compute and may even diverge.",
        "Instead (unlike Mohri) we will permit our A(F) to depend on more than just range(F).",
        "Order the space of input strings E∗ by length, breaking ties lexicographically.",
        "For example, E < bb < aab < aba < abb.",
        "Now define 14 Suppose X is any residue of F9, i.e., we can write F9 = x ® X.",
        "Then we can rewrite the identity F9 = A(F9) ® (A(F9)\\F9), using the shifting property, as x ® X = x ® A(X) ® (A(F9)\\F9).",
        "As we have separately required the semiring to be left cancellative, this implies that X = A(X) ® (A(F9)\\F9).",
        "So (A(F9)\\F9) is a residue of any residue X of F9, as claimed.",
        "15Define A(0) = 0.",
        "From each equivalence class of nonzero functions under�, pick a single minimum residue (axiom of choice).",
        "Given F, let [F] denote the minimum residue from its class.",
        "Observe that F = f ® [F] for some f ; right cancellativity implies f is unique.",
        "So define A(F) = f. Shifting property: A(k®F)=A(k®f ®[F])=k®f =k®A(f ®[F])= k ® A(F).",
        "Quotientproperty: A(a-1F) ® [a-1F] = a-1F =",
        "quotientproperty: Quotient exists since F(E) = A(F) ® [F] (E).",
        "16Let (x, y) denote the function mapping a to x, b to y, and everything else to 0.",
        "Given km = km', we have k ® (m, 1) = k® (m', 1).",
        "Since the minimum residue property implies greedy factorization, we can write (m, 1) = f ® (a, b), (m', 1) = g ® (a, b).",
        "Then f ® b = g ® b, so by right cancellativity f =g,whence m= f ®a=g®a=m'.",
        "where support(F) denotes the set of input strings to which F assigns a non-0 weight.",
        "This A clearly has the shifting property needed by section 5.",
        "The quotient and final-quotient properties come for free because we are in a division semiring and because A(F) = 0 iff F = 0.",
        "Under this definition, what is A(Fq) for a suffix function Fq?",
        "Consider all paths of nonzero weight 18 from state q to a final state.",
        "If none exist, A(Fq) = 0.",
        "Otherwise, min support(Fq)is the input string on the shortest such path, breaking ties lexicographically.19 A(Fq) is simply the weight of that shortest path.",
        "To push, we must compute A(Fq) for each state q.",
        "This is easy because A(Fq) is the weight of a single, minimum-length and hence acyclic path from q.",
        "(Previous methods combined the weights of all paths from q, even if infinitely many.)",
        "It also helps that the left factors at different states are related: if the minimum path from q begins with a weight-k arc to r, then it continues along the minimum path from r, so A(Fq) = k ® A(FT).",
        "Below is a trivial linear-time algorithm for computing A(Fq) at every q.",
        "Each state and arc is considered once in a breadth-first search back from the final states.",
        "len(q) andfirst(q) store the string length and first letter of a running minimum of support(Fq) E E*.",
        "1. foreach state q 2. if q is final then 3. len(q) := 0 (* min support(Fq) is a for final q *) 4.",
        "A(Fq):= φ(q) (*Fq(a)isjust the final weight,φ(q)*) 5. enqueue q on a FIFO queue 6. else 7. len(q) := oo (* not yet discovered *) 8.",
        "A(Fq) := 0 (* assumeFq = 0 until we discoverq *) 9. until the FIFO queue is empty 10. dequeue a state r 11. foreach arc q�r entering r such that k =� 0 12. if len(q) = oo then enqueue q (* breadth-first search *) 13. if len(q) = oo or (len(q) = len(r) + 1 and a < first(q)) then 14. first(q) := a (* reduce min support(Fq) *) 15. len(q) := len(r) + 1 16.",
        "A(Fq) := k ® A(Fr)",
        "The runtime is O (j statesj+t •jarcs j) if ® has runtime t. If ® is slow, this can be reduced to O(t • jstatesj + jarcsj) by removing line 16 and waiting until the end, when the minimum path from each non-final state q is fully known, to compute the weight A(Fq) of that path.",
        "Simply finish up by calling FIND-A on each state q:",
        "FIND-A(state q): 1. if A(Fq) = 0 and len(q) < oo then 2.",
        "A(Fq) := v(q,first(q)) ® FIND-A(δ(q,first(q))) 3. return A(Fq)",
        "After thus computing A(Fq), we simply proceed with pushing, merging, and trimming as in section 5 .20 Pushing runs in time O(t •jarcs j) and trimming in O (j statesj+ jarcs j) .",
        "Merging is worse, with time O(jarcsj logjstates j) ."
      ]
    },
    {
      "heading": "7 A Bonus: Non-Division Semirings",
      "text": [
        "The trouble with Z[.",
        "/-5] was that it “lacked” needed quotients.",
        "The example on p. 3 can easily be minimized (down to 3 states) if we regard it instead as defined over (C, +, x) – letting us use any weights in C. Simply use section 6’s algorithm.",
        "This new change-of-semiring trick can be used for other non-division semirings as well.",
        "One can extend the original weight semiring (K, ®, ®) to a division semiring by adding ®-inverses.21 In this way, the tropical semiring (R≥0 U fool, min, +) can be augmented with the negative reals to obtain (R U fool, min, +).",
        "And the transducer semiring (A* U f�l, min, concat)22 can be augmented by extending the alphabet A = f x, y ,... l with inverse letters fx-1, y-1, ...l. The minimized DFA we obtain may have “weird” arc weights drawn from the extended semiring.",
        "But the arc weights combine along paths to produce the original automaton’s outputs, which fall in the original semiring.",
        "Let us apply this trick to the example of section 2, yielding the following pushed automaton in which F1 = F3 as desired.",
        "(x-1, y-1,... are written as X, Y, ..., and A(Fq) is displayed at each q.)",
        "For example, the z-1y-1zzz output on the 3 – > 4 arc was computed as A(F3)-1 ® wwzzz ® A(F4) = (wwyz)-1 ® wwzzz ® E = z-1y-1w-1w-1wwzzz.",
        "This trick yields new algorithms for the tropical semiring and sequential transducers, which is interesting and perhaps worthwhile.",
        "How do they compare with previous work?",
        "Over the tropical semiring, our linear-time pushing algorithm is simpler than (Mohri, 1997), and faster by a",
        "log factor, because it does not require a priority queue.",
        "(Though this does not help the overall complexity of minimization, which is dominated by the merging step.)",
        "We also have no need to implement faster algorithms for special cases, as Mohri proposes, because our basic algorithm is already linear.",
        "Finally, our algorithm generalizes better, as it can handle negative weight cycles in the input.",
        "These are useful in (e.g.) conditional random fields.",
        "On the other hand, Mohri’s algorithm guarantees a potentially useful property that we do not: that the weight of the prefix path reading α E E* is the minimum weight of all paths with prefix α.",
        "Commonly this approximates − log(p(most probable string with prefix α)), perhaps a useful value to look up for pruning.",
        "As for transducers, how does our minimization algorithm (above) compare with previous ones?",
        "Following earlier work by Choffrut and others, Mohri (2000) defines A(Fq) as the longest common prefix of range(Fq).",
        "He constrains these values with a set of simultaneous equations, and solves them by repeated changes of variable using a complex relaxation algorithm.",
        "His implementation uses various techniques (including a trie and a graph decomposition) to make pushing run in time O(IstatesI + IarcsI • maxq IA(Fq)I).23 Breslauer(1996) gives a different computation of the same result.",
        "To implement our simpler algorithm, we represent strings in A* as pointers into a global trie that extends upon lookup.",
        "The strings are actually stored reversed in the trie so that it is fast to add and remove short prefixes.",
        "Over the extended alphabet, we use the pointer pair (k, m) to represent the string k-1m where k, m E A* have no common prefix.",
        "Such pointer pairs can be equality-tested in O(1) time during merging.",
        "For k, m E A*, k ⊗ m is computed in time O(IkI), and k\\m in time O(ILCP(k, m)I) or more loosely O(IkI) (where LCP = longest common prefix).",
        "The total time to compute our A(Fq) values is therefore O (I states I + t • I arcsI), where t is the maximum length of any arc’s weight.",
        "For each arc we then compute a new weight as a left-quotient by a A value.",
        "So our total runtime for pushing is O(I states I + I arcs I • maxq IA(Fq)I).",
        "This may appear identical to Mohri’s runtime, but in fact our IA(Fq)I ≥ Mohri’s, though the two definitions share a worst case of t • I states I.24 Inverse letters must be eliminated from the minimized transducer if one wishes to pass it to any specialized algorithms (composition, inversion) that assume weights",
        "in A*.",
        "Fortunately this is not hard.",
        "If state q of the result was formed by merging states q1,... qj, define ρ(q) = LCS {A(Fq,) : i = 1,... j} E A* (where LCS = longest common suffix).",
        "Now push the minimized transducer using ρ(q)-1 in place of A(Fq) for all q.",
        "This corrects for “overpushing”: any letters ρ(q) that were unnecessarily pushed back before minimization are pushed forward again, cancelling the inverse letters.",
        "In our running example, state 0 will push (xyz)-1 back and the merged state {1,3} will push (yz)-1 back.",
        "This is equivalent to pushing ρ(0) = xyz forward through state 0 and the yz part of it forward through {1,3 }, canceling the z-1y-1 at the start of one of the next arcs.",
        "We must show that the resulting labels really are free of inverse letters.",
        "Their values are as if the original pushing had pushed back not A(Fq,) E A* but only its shorter def prefix A(qi) = A(Fq,)/ ρ(qi) E A* (note the right quotient).",
        "In other words, an arc from qi to ri, with weight k E A* was reweighted as ˆA(qi)\\(k ⊗ ˆA(ri,)).",
        "Any inverse letters in such new weights clearly fall at the left.",
        "So suppose the new weight on the arc from q to r begins with an inverse letter z-1.",
        "Then ˆA(qi) must have ended with z for each i = 1,... j.",
        "But then ρ(qi) was not the longest common suffix: zρ(qi) is a longer one, a contradiction (Q.E.D.).",
        "Negative weights can be similarly eliminated after minimization over the tropical semiring, if desired, by substituting min for LCS.",
        "The optional elimination of inverse letters or negative weights does not affect the asymptotic runtime.",
        "A caveat here is that the resulting automaton no longer has a canonical form.",
        "Consider a straight-line automaton: pushing yields a canonical form as always, but inverse-letter elimination completely undoes pushing (ˆA(qi) = E).",
        "This is not an issue in Mohri’s approach."
      ]
    },
    {
      "heading": "8 Conclusion and Final Remarks",
      "text": [
        "We have characterized the semirings over which weighted deterministic automata can be minimized (section 4), and shown how to perform such minimization in both general and specific cases (sections 5, 6, 7).",
        "Our technique for division semirings and their subsemirings pushes back, at each state q, the output of a single, easily found, shortest accepting path from q.",
        "This is simpler and more general than previous approaches that aggregate all accepting paths from q.",
        "Our new algorithm (section 6) is most important for previously unminimizable, practically needed division semirings: real (e.g., for probabilities), expectation (for learning (Eisner, 2002)), and additive with negative weights (for conditional random fields (Lafferty et al., 2001)).",
        "It can also be used in non-division semirings, as for transducers.",
        "It is unpatented, easy to implement, comparable or faster in asymptotic runtime, and perhaps faster in practice (especially for the tropical semiring, where it seems preferable in most respects).",
        "Our approach applies also to R-weighted sequential transducers as in (Cortes et al., 2002).",
        "Such automata can be regarded as weighted by the product semiring",
        "push the numeric and string components independently.",
        "Our new pushing algorithm enables not only minimization but also equivalence-testing in more weight semirings.",
        "Equivalence is efficiently tested by pushing the (deterministic) automata to canonicalize their arc labels and then testing unweighted equivalence (Mohri, 1997)."
      ]
    },
    {
      "heading": "References",
      "text": []
    },
    {
      "heading": "Appendix: Remaining Proofs",
      "text": [
        "Let M be an automaton to minimize and F : E* → K be the function it defines.",
        "We assume (K, ®) allows greedy factorization, so -_ is an equivalence relation on nonzero functions.",
        "We first prove that M¯ with the properties of section 4 is the minimal automaton computing F. We will then show, following Mohri, that the algorithm of section 5 finds such an ¯M.",
        "(Section 6 is a special case of section 5.)",
        "We chose in advance a desired suffix function F[r] for each state [r] of ¯M, and used these to determine the weights of ¯M.",
        "To show that the weights were determined correctly, let ˜F[r] be the actual suffix function of [r].",
        "Claim that for all α and r, ˜F[r](α) = F[r](α).",
        "This is easily proved by induction on |α|.",
        "Our choice of initial weight then ensures that M¯ computes F. We must now prove minimality.",
        "For α,Q E E*, say α F Q iff α-1F -_ Q-1F.",
        "Note that F is an equivalence relation on",
        "Uniqueness: If M' has the same number of states as ¯M, then the two partitions must be equal.",
        "So two prefixes reach the same state in M' iff they do so in ¯M.",
        "This gives a 6-preserving isomorphism between M' and ¯M.",
        "It follows that the minimal machine is unique, except for the distribution of output labels along paths (which may depend on arbitrary choices of residues F[r ] ).",
        "Now we turn to section 5’s effective construction, using λ, of a pushed machine Mˆ and a merged version ¯M.",
        "The proof of minimality is essentially the same as in (Mohri, 2000).",
        "We know that M¯ computes the same function as M (since pushing, merging, and trimming preserve this).",
        "So it suffices to show α F Q =:>.α m Q.",
        "The above proof of minimality will then go through as before.",
        "M and Mˆ have the same states and transition function 6; denote their emission functions by v and ˆv.",
        "F9 refers to suffix functions in M. Given α Z Q (so α,Q E D), use the definition of F to write α-1 F = k« ® F' and Q-1F = kβ ® F'.",
        "Let q = 6(0, α), r = 6(0, Q), k = v(0, α).",
        "For any a E E, write ˆv(q, a) = λ(F9)\\λ(a-1F9) = (k ® λ(F9))\\(k ® λ4a-1F9)) = λ(k ® F9)\\λ(k® a-1F) λ(α-1F)\\λka (α-1F)) = λ(k«®F')\\λ(a-1(k«®P λ(F')\\λ(a- F').",
        "By symmetry, ˆv(r, a) = λ(F')\\λ(a-1F') as well.",
        "Thanks to left cancellativity, left quotients are unique, so ˆv(q, a) = ˆv(r, a).26 So α Z Q =:>.",
        "corresponding arcs from q and r in M output identical weights.",
        "Since αa F Qa as well, the same holds at 6(q, a) and 6(r, a).",
        "So by induction, regarding Mˆ as an unweighted automaton, exactly the same strings in (E x K)* are accepted from q and from r. So merging will merge q and r, and α m¯-Qas claimed.",
        "This corresponds to the fact that a dead state can be made to merge with any state by pushing 0 back from it, so that the arcs to it have weight 0 and the arcs from it have arbitrary weights.",
        "Our construction of",
        "sinceotherwiseλ(ry-F9)=0andλ(ry-1F9)\\(ry- F9)(e) is undefined, contradicting the final-quotient property.)"
      ]
    }
  ]
}
