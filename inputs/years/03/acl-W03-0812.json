{
  "info": {
    "authors": [
      "Hans-Ulrich Krieger"
    ],
    "book": "Workshop on Software Engineering and Architecture of Language Technology Systems SEALTS",
    "id": "acl-W03-0812",
    "title": "SDL - A Description Language for Building NLP Systems",
    "url": "https://aclweb.org/anthology/W03-0812",
    "year": 2003
  },
  "references": [
    "acl-P02-1056",
    "acl-W03-0802"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We present the system description language SDG that offers a declarative way of specifying new complex NLP systems from already existing modules with the help of three operators: sequence, parallelism, and unrestricted iteration.",
        "Given a system description and modules that implement a minimal interface, the SDG compiler returns a running Java program which realizes exactly the desired behavior of the original speci£cation.",
        "The execution semantics of SDG is complemented by a precise formal semantics, de£ned in terms of concepts of function theory.",
        "The SDG compiler is part of the SProUT shallow language platform, a system for the development and processing of multilingual resources."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "In this paper, we focus on a general system description language, called SDG, which allows the declarative spec-i£cation of NLP systems from a set of already existing base modules.",
        "Assuming that each initial module implements a minimal interface of methods, a new complex system is composed with the help of three operators, realizing a sequence of two modules, a (quasi-)parallel execution of several modules, and a potentially unrestricted self-application of a single module.",
        "Communication between independent modules is decoupled by a mediator which is sensitive to the operators connecting the modules and to the modules themselves.",
        "To put it in another way: new systems can be de£ned by simply putting together existing independent modules, sharing a common interface.",
        "The interface assumes functionality which modules usually already provide, such as set input, clear internal state, start computation, etc.",
        "It is clear that such an approach permits ¤exible experimentation with different software architectures during the set up of a new (NLP) system.",
        "The use of mediators furthermore guarantees that an independently developed module will stay independent when integrated into a new system.",
        "In the worst case, only the mediator needs to be modi£ed or upgraded, resp.",
        "In many cases, not even a modi£cation of the mediator is necessary.",
        "The execution semantics of SDG is complemented by an abstract semantics, de£ned in terms of concepts of function theory, such as Cartesian product, functional composition & application, Lambda abstraction, and unbounded minimization.",
        "Contrary to an interpreted approach to system speci£cation, our approach compiles a syntactically well-formed SDG expression into a Java program.",
        "This code might then be incorporated into a larger system or might be directly compiled by the Java compiler, resulting in an executable £le.",
        "This strategy has two advantages: £rstly, the compiled Java code is faster than an interpretation of the corresponding SDG expression, and secondly, the generated Java code can be modi£ed or even extended by additional software.",
        "The structure of this paper is as follows.",
        "In the next section, we motivate the development of SDG and give a ¤avor of how base expressions can be compiled.",
        "We then come up with an EBNF speci£cation of the concrete syntax for SDG in section 3 and explain SDG with the help of an example.",
        "Since modules can be seen as functions in the mathematical sense, we argue in section 4 that a system speci£cation can be given a precise formal semantics.",
        "We also clarify the formal status of the mediators and show how they are incorporated in the de£-nition of the abstract semantics.",
        "Section 5 then de£nes the programming interfaces and their default implementation, both for modules and for mediators.",
        "In the £nal section, we present some details of the compilation process."
      ]
    },
    {
      "heading": "2 Motivation & Idea",
      "text": [
        "The shallow text processing system SProUT (Becker et al., 2002) developed at DFKI is a complex platform for the development and processing of multilingual resources.",
        "SProITT arranges processing components (e.g., tokenizer, gazetteer, named entity recognition) in a strictly sequential fashion, as is known from standard cascaded £nite-state devices (Abney, 1996).",
        "In order to connect such (independently developed) NL components, one must look at the application programmer interface (API) of each module, hoping that there are API methods which allow, e.g., to call a module with a speci£c input, to obtain the result value, etc.",
        "In the best case, API methods from different modules can be used directly without much programming overhead.",
        "In the worst case, however, there is no API available, meaning that we have to inspect the programming code of a module and have to write additional code to realize interfaces between modules (e.g., data transformation).",
        "Even more demanding, recent hybrid NLP systems such as W�ITEBOa�n (Crysmann et al., 2002) implement more complex interactions and loops, instead of using a simple pipeline of modules.",
        "We have overcome this in¤exible behavior by implementing the following idea.",
        "Since we use typed feature structures (Carpenter, 1992) in SProITT as the sole data interchange format between processing modules, the construction of a new system can be reduced to the interpretation of a regular expression of modules.",
        "Because the o sign for concatenation can not be found on a keyboard, we have given the three characters +, I, and * the following meaning:"
      ]
    },
    {
      "heading": "• sequence or concatenation",
      "text": [
        "m1 +m2 expresses the fact that (1) the input to m1 + m2 is the input given to m1, (2) the output of module m1 serves as the input to m2, and (3) that the £nal output of m1 + m2 is equal to the output of m2.",
        "This is the usual ¤ow of information in a sequential cascaded shallow NL architecture.",
        "• concurrency or parallelism",
        "Idenotes a quasi-parallel computation of independent modules, where the £nal output of each module serves as the input to a subsequent module (perhaps grouped in a structured object, as we do by default).",
        "This operator has far reaching potential.",
        "We envisage, e.g., the parallel computation of several morphological analyzers with different coverage or the parallel execution of a shallow topological parser and a deep HPSG parser (as in W�ITEBOa�n).",
        "In a programming language such as Java, the execution of modules can even be realized by independently running threads.",
        "• unrestricted iteration or £xpoint computation m* has the following interpretation.",
        "Module m feeds its output back into itself, until no more changes occur, thus implementing a kind of a £x",
        "point computation (Davey and Priestley, 1990).",
        "It is clear that such a £xpoint might not be reached in £- nite time, i.e., the computation must not stop.",
        "A possible application was envisaged in (Braun, 1999), where an iterative application of a base clause module was necessary to model recursive embedding of subordinate clauses in a system for parsing German clause sentential structures.",
        "Notice that unrestricted iteration would even allow us to simulate an all-paths context-free parsing behavior, since such a feedback loop can in principle simulate an unbounded number of cascade stages in a £nite-state device (each level of a CF parse tree has been constructed by a single cascade stage).",
        "We have de£ned a Java interface of methods which each module must ful£ll that will be incorporated in the construction of a new system.",
        "Implementing such an interface means that a module must provide an implementation for all methods speci£ed in the interface with exactly the same method name and method signature, e.g., set-Input(), clear(), or run () .",
        "To ease this implementation, we have also implemented an abstract Java class that provides a default implementation for all these methods with the exception of run () , the method which starts the computation of the module and which delivers the £nal result.",
        "The interesting point now is that a new system, declaratively speci£ed by means of the above apparatus, can be automatically compiled into a single Java class.",
        "Even the newly generated Java class implements the above interface of methods.",
        "This Java code can then be compiled by the Java compiler into a running program, realizing exactly the intended behavior of the original system speci-£cation.",
        "The execution semantics for an arbitrary module m is de£ned to be always the execution of the run ( ) method of m, written in Java as m. run ( ) Due to space limitations, we can only outline the basic idea and present a simpli£ed version of the compiled code for a sequence of two module instances m 1 + m2, for the independent concurrent computation m1 I m2, and for the unbounded iteration of a single module instance m*.",
        "Note that we use the typewriter font when referring to the concrete syntax or the implementation, but use italics to denote the abstract syntax.",
        "The pseudo code above contains three methods, seq () , par () , and fix () , methods which mediate between the output of one module and the input of a succeeding module.",
        "Clearly, such functionality should not be squeezed into independently developed modules, since otherwise a module m must have a notion of a £xpoint during the execution of m* or must be sensitive to the output of every other module, e.g., during the processing of (m1 |m2) + m. Note that the mediators take modules as input, and so having access to their internal information via the public methods speci£ed in the module interface (the API).",
        "The default implementation for seq is of course the identity function (speaking in terms of functional composition).",
        "par wraps the two results in a structured object (default implementation: a Java array).",
        "fix () implements a £xpoint computation (see section 5.3 for the Java code).",
        "These mediators can be made speci£c to special module-module combinations and are an implementation of the mediator design pattern, which loosely couples independent modules by encapsulating their interaction in a new object (Gamma et al., 1995, pp.",
        "273).",
        "I.e., the mediators do not modify the original modules and only have read access to input and output via getInput ( ) and getOutput () .",
        "In the following, we present a graphical representation for displaying module combination.",
        "Given such pictures, it is easy to see where the mediators come into play.",
        "Depicting a sequence of two modules is, at £rst sight, not hard.",
        "G connects two modules.",
        "This fact is re¤ected by making seq a binary method which takes m1 and m2 as input parameters (see example code).",
        "Let us now move to the parallel execution of several modules (not necessarily two, as in the above example).",
        "There is one problem here.",
        "What happens to the output of each module when the lines come together, meeting in the outgoing arrow?",
        "The next section has a few words on this and presents a solution.",
        "We only note here that there exists a mediator method par, which, by default, groups the output in a structured object.",
        "Since par does not know the number of modules in advance, it takes as its parameter an array of modules.",
        "Note further that the input arrows are £ne – every module gets the same data.",
        "Hence, we have the following modi£ed picture.",
        "Now comes the * operator.",
        "As we already said, the module feeds itself with its own output, until a £xpoint has been reached, i.e., until input equals output.",
        "Instead of writing we make the mediator method for * explicit, since it embodies the knowledge about £xpoints (and not the module):",
        "Now, if the input format of m2 is not compatible with the output of m1, must we change the programming code for m2?",
        "Even more serious, if we would have another expression m3 + m2, must m2 also be sensitive to the output format of m3?",
        "In order to avoid these and other cases, we decouple module interaction and introduce a special mediator method for the sequence operator (seq in the above code), depicted by G."
      ]
    },
    {
      "heading": "3 Syntax",
      "text": [
        "A new system is built from an initial set of already existing modules M with the help of the three operators +, |, and *.",
        "The set of all syntactically well-formed module descriptions D in SDL is inductively de£ned as follows:",
        "• mEM=:�mED • m1,m2ED�m1+m2ED",
        "• m1, ... , mk E D =:� (I m1 ... mk) E D • mED=:�m*ED",
        "Examples in the concrete syntax are written using the typewriter font, e.g., module.",
        "All operators have the same priority.",
        "Succeeding modules are written from left to right, using in£x notation, e.g., m1 + m2.",
        "Parallel executed modules must be put in parentheses with the I operator £rst, for instance ( I m1 m2) .",
        "Note that we use the pre£x notation for the concurrency operator I to allow for an arbitrary number of arguments, e.g., ( I m1 m2 m3) .",
        "This technique furthermore circumvents notorious grouping ambiguities which might lead to different results when executing the modules.",
        "Notice that since I must neither be commutative nor must it be associative, the result of ( I m1 m2 m3) might be different to ( I m1 (I m2 m3) ) , to ( I ( I m1 m2) m3) , or even to ( I m2 (I m1 m3) ) , etc.",
        "Whether I is commutative or associative is determined by the implementation of concurrency mediator par.",
        "Let us give an example.",
        "Assume, for instance, that m1, m2, and m3 would return typed feature structures and that par () would join the results by using uni£cation.",
        "In this case, I is clearly commutative and associative, since uni£cation is commutative and associative (and idempotent).",
        "Finally, the unrestricted self-application of a module should be expressed in the concrete syntax by using the module name, pre£xed by the asterisk sign, and grouped using parentheses, e.g., (* module).",
        "module here might represent a single module or a complex expression (which itself must be put in parentheses).",
        "Making I and * pre£x operators (in contrast to +) ease the work of the syntactical analysis of an SDL expression.",
        "The EBNF for a complete system description system is given by £gure 1.",
        "A concrete running example is shown in £gure 2.",
        "The example system from £gure 2 should be read as de£ne a new module de.",
        "dfki .",
        "lt .",
        "test.",
        "System as (I rnd1 rnd2 rnd3) + inc1 + ..., variables rnd1, rnd2, and rnd3 refer to instances of module de.dfki.lt.sdl.test.Randomize, module Randomize belongs to package de.dfki.lt.sdl.test, the value of rnd1 should be initialized with (\"foo\", \"bar\", \"baz\"), etc.",
        "Every single line must be separated by the newline character.",
        "The use of variables (instead of using directly module names, i.e., Java classes) has one important advantage: variables can be reused (viz., rnd2 and rnd3 in the example), meaning that the same instances are used at several places throughout the system description, instead of using several instances of the same module (which, of course, can also be achieved; cf. rnd1, rnd2, and rnd3 which are instances of module Randomize).",
        "Notice that the value of a variable can not be rede£ned during the course of a system description."
      ]
    },
    {
      "heading": "4 Modules as Functions",
      "text": [
        "Before we start the description of the implementation in the next section, we will argue that a system description can be given a precise formal semantics, assuming that the initial modules, which we call base modules are well de£ned.",
        "First of all, we only need some basic mathematical knowledge from secondary school, viz., the concept of a function.",
        "A function f (sometimes called a mapping) from S to T, written as f : S – > T, can be seen as a special kind of relation, where the domain of f is S (written as DOM (f) = S), and for each element in the domain of f, there is at most one element in the range (or codomain) RNG(f ).",
        "If there always exists an element in the range, we say that f is a total function (or well de£ned) and write f t. Otherwise, f is said to be a partial function, and for an s E S for which f is not de£ned, we then write f (s) T. Since S itself might consist of ordered n-tuples and thus is the Cartesian product of S1, ... , Sn, depicted as xn i=1 Si, we use the vector notation and write f(�s) instead of f (s).",
        "The n-fold functional composition of f : S – > T (n > 0) is written as fn and has the following inductive de£nition: f 0 (�s) : = s�and f i+1(�s) : = f (f i ( �s) ).",
        "s E S is said to be a £xpoint of f : S – > S iff f (f (s)) =S f (s) (we use =S to denote the equality relation in S).",
        "Assuming that m is a module for which a proper run ( ) method has been de£ned, we will, from now on, refer to the function m as abbreviating m. run () , the execution of method run () from module m. Hence, we de£ne the execution semantics of m to be equivalent to m. run () ."
      ]
    },
    {
      "heading": "4.1 Sequence",
      "text": [
        "Let us start with the sequence m1 + m2 of two modules, regarded as two function m1 : S1 – > T1 and"
      ]
    },
    {
      "heading": "4.2 Parallelism",
      "text": [
        "We now come to the parallel execution of k modules mi : Si – > Ti (1 < i < k), operating on the same input.",
        "As already said, the default mediator for I returns an ordered system – >de£nition {command}* variables de£nition – > module \"=\" regexpr newline module – > a fully quali£ed Java class name",
        "sequence of the results of m1, ... , mk, hence is similar to the Cartesian product x:",
        "de£ned and the domain of each module is a superset of the domain of the new composite module:"
      ]
    },
    {
      "heading": "4.3 Iteration",
      "text": [
        "A proper de£nition of unrestricted iteration, however, deserves more attention and a bit more work.",
        "Since a module m feeds its output back into itself, it is clear that the iteration (m*) (�s) must not terminate.",
        "I.e., the question whether m*1 holds, is undecidable in general.",
        "Obviously, a necessary condition for m* 1 is that S D T, and so if m : S – – > T and m 1 holds, we have m* : S – – > S. Since m is usually not a monotonic function, it must not be the case that m has a least and a greatest £xpoint.",
        "Of course, m might not possess any £xpoint at all.",
        "Within our very practical context, we are interested in £nitely-reachable £xpoints.",
        "From the above remarks, it is clear that givens� E S, (m*)(�s) terminates in £nite time iff no more changes occur during the iteration process, i.e., Eln E N. mn(�s) =S mn-1(�s) We can formalize the meaning of * with the help of Kleene’s µ operator, known from recursive function theory (Hermes, 1978).",
        "µ is a functional and so, given a function f as its input, returns a new function µ(f), the unbounded minimization of f. Originally employed to precisely de£ne (partial) recursive functions of natural numbers, we need a slight generalization, so that we can apply µ to functions, not necessarily operating on natural numbers.",
        "Letf :Nk+1 – – >N(kEN).µ(f):Nk – – >Nis given by n if f (�x, n) = 0 and f (�x, i) > 0, for all 0<i<n – 1 T otherwise I.e., µ(f) (�x) returns the least n for which f (�x, n) = 0.",
        "Such an n, of course, must not exist.",
        "We now move from the natural numbers N to an arbitrary (structured) set S with equality relation =S.",
        "The task of µ here is to return the number of iteration steps µ(f)(�x):= is the case in the default implementation for +.",
        "This view, in fact, precisely corresponds to the implementation.",
        "Let us quickly make the two other de£nitions re¤ect this new view and let P and T be the functionals for j and *, resp.",
        "For j, we now have n for which a self-application of module m no longer changes the output, when applied to the original input u� E S. And so, we have the following de£nitional equation for the meaning of m*:",
        "Obviously, the number of iteration steps needed to obtain a £xpoint is given by µ(m)(�u), where µ : (S – >",
        "Compare this de£nition with the original µ(f ) (�x) on natural numbers above.",
        "Testing for zero is replaced here by testing for equality in S. This last de£nition completes the semantics for m*."
      ]
    },
    {
      "heading": "4.4 Incorporating Mediators",
      "text": [
        "The above formalization does not include the use of mediators.",
        "The effects the mediators have on the input/output of modules are an integral part of the de£nition for the meaning of m1 + m2, (j m1 ... mk), and m*.",
        "In case we explicitly want to represent (the default implementation of) the mediators in the above de£nitions, we must, £rst of all, clarify their status.",
        "Let us focus, for instance, on the mediator for the sequence operator +.",
        "We already said that the mediator for + uses the output of m1 to feed m2, thus can be seen as the identity function id, speaking in terms of functional composition.",
        "Hence, we might rede£ne Q(m1 + m2)](�u) as",
        "If so, mediators were functions and would have the same status as modules.",
        "Clearly, they pragmatically differ from modules in that they coordinate the interaction between independent modules (remember the mediator metaphor).",
        "However, we have also said that the mediator methods take modules as input.",
        "When adopting this view, a mediator is different from a module: it is a functional (as is µ), taking functions as arguments (the modules) and returning a function.",
        "Now, let S be the mediator for the + operator.",
        "We then obtain a different semantics",
        "The adaption of m* is also not hard:T is exactly the µ(m) (�x)-fold composition of m, given value �x.",
        "Since x� are free variables, we use Church’s Lambda abstraction (Barendregt, 1984), make them bound, and write",
        "It is clear that the above set of de£nitions is still not complete, since it does not cover the cases where a module m consists of several submodules, as does the syntax of SDL clearly admit.",
        "This leads us to the £nal four inductive de£nitions which conclude this section:",
        "• Qm] (�u) := m(�u) iff m is a base module • Q(m1 + m2)](�u) := (Qm2] oS(Qm1], Qm2]) o Qm1])(�u) • Q(j m1 ... mk)](�u) := (P(Qm1],... ,Qmk]) o (xki= 1Qmi] ))(�uk) • Qm*](�u) := (T(Qm]))(�u), whereasT(Qm]) := a�x.",
        "Qm]µ([[m])(�x)(�x)",
        "Recall that the execution semantics of m(�u) has not changed after all and is still m. run (s) , whereas s abbreviates the Java notation for the k-tuple �u."
      ]
    },
    {
      "heading": "5 Interfaces",
      "text": [
        "This section gives a short scetch of the API methods which every module must implement and presents the default implementation of the mediator methods."
      ]
    },
    {
      "heading": "5.1 Module Interface IModule",
      "text": [
        "The following seven methods must be implemented by a module which should contribute to a new system.",
        "The next subsection provides a default implementation for six of them.",
        "The exception is the one-argument method run () which is assumed to execute a module.",
        "• clear() clears the internal state of the module it is applied to.",
        "clear() is useful when a module instance is reused during the execution of a system.",
        "clear() might throw a ModuleClearError in case something goes wrong during the clearing phase.",
        "• init () initializes a given module by providing an array of init strings.",
        "init () might throw a ModuleInitError.",
        "• run () starts the execution of the module to which it belongs and returns the result of this computation.",
        "An implementation of run () might throw a ModuleRunError.",
        "Note that run () should not store the input nor the output of the computation.",
        "This is supposed to be done independently by using setInput () and setOutput () (see below).",
        "• setInput () stores the value of parameter input and returns this value.",
        "• getInput () returns the input originally given to setInput().",
        "• setOutput () stores the value of parameter output and returns this value.",
        "• getOutput () returns the output originally given to setOutput () ."
      ]
    },
    {
      "heading": "5.2 Module Methods",
      "text": [
        "Six of the seven module methods are provided by a default implementation in class Modules which implements interface IModule (see above).",
        "New modules are advised to inherit from Modules, so that only run () must actually be speci£ed.",
        "Input and output of a module is memorized by introducing the two additional private instance £elds input and output."
      ]
    },
    {
      "heading": "5.3 Mediator Methods",
      "text": [
        "The public class Mediators provides a default implementation for the three mediator methods, speci£ed in interface IMediator.",
        "It is worth noting that although fix () returns the £xpoint, it relocates its computation into an auxiliary method fixpoint () (see below), due to the fact that mediators are not allowed to change the internal state of a module.",
        "And thus, the input £eld still contains the original input, whereas the output £eld refers to the £xpoint, at last."
      ]
    },
    {
      "heading": "6 Compiler",
      "text": [
        "In section 2, we have already seen how basic expressions are compiled into a sequence of instructions, consisting of API methods from the module and mediator interface.",
        "Here, we like to glance at the compilation of more complex SDL expressions.",
        "First of all, we note that complex expressions are decomposed into ¤at basic expressions which are not further structured.",
        "Each subexpression is associated with a new module variable and these variables are inserted into the original system description which will also then become ¤at.",
        "In case of the example from £gure 2, we have private Object fixpoint(IModule module, Object input) { Object output = module.run(input); if (output.equals(input)) return output; else return fixpoint(module, output); } the following subexpressions together with their variables (we pre£x every variable by the dollar sign): $1 =( |$rnd1 $rnd2 $rnd3),$2 = (* $i5ut42),$3 = ($rnd3 + $rnd2), and $4 = (* $3).",
        "As a result, the original system description reduces to $1 + $ inc 1 + $inc2 + $2 + $4 and thus is normalized as $1, ..., $ 4 are.",
        "The SM compiler then introduces so-called local or inner Java classes for such subexpressions and locates them in the same package to which the newly de£ned system belongs.",
        "Clearly, each new inner class must also ful£ll the module interface IModule (see section 5) and the SM compiler produces the corresponding Java code, similar to the default implementation in class Modules (section 5), together with the right constructors for the inner classes.",
        "For each base module and each newly introduced inner class, the compiler generates a private instance £eld (e.g., private Randomize $rnd1) and anew instance (e.g., this .",
        "$rnd1 = new Randomize()) to which the API methods can be applied.",
        "Each occurence of the operators +, |, and * corresponds to the execution of the mediator methods seq, par, and fix (see below).",
        "Local variables (pre£xed by the low line character) are also introduced for the individual run () methods ( 15, ..",
        "., 23 below).",
        "These variables are introduced by the SM compiler to serve as handles (or anchors) to already evaluated subexpression, helping to establish a proper ¤ow of control during the recursive compilation process.",
        "We £nish this paper by presenting the generated code for the run () method for system System from £gure 2.",
        "this.$4.setOutput(_23); return this.setOutput(_23); } We always generate a new mediator object ( med) for each local class in order to make the parallel execution of modules thread-safe.",
        "Note that in the above code, the mediator method seq () is applied four times due to the fact that + occurs four times in the original speci£cation.",
        "The full code generated by the SM compiler for the example from £gure 2 can be found under http://www.dfki.de/ – krieger/public/.",
        "The directory also contains the Java code of the involved modules, plus the default implementation of the mediator and module methods.",
        "In the workshop, we hope to further report on the combination of WHAT (Sch¨afer, 2003), an XSLT-based annotation transformer, with SM."
      ]
    },
    {
      "heading": "Acknowledgement",
      "text": [
        "I am grateful to my colleagues Bernd Kiefer, Markus Pilzecker, and Ulrich Sch¨afer, helping me to make things clear.",
        "Thanks to the anonymous reviewers who have iden-ti£ed weak points.",
        "This work was supported by the German Federal Ministry for Education, Science, Research, and Technology under grant no.",
        "01 IW C02 (QUETAL) and by an EU grant under no.",
        "IST 12179 (Airforce)."
      ]
    }
  ]
}
