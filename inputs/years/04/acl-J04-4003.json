{
  "info": {
    "authors": [
      "Stoyan Mihov",
      "Klaus U. Schulz"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J04-4003",
    "title": "Fast Approximate Search in Large Dictionaries",
    "url": "https://aclweb.org/anthology/J04-4003",
    "year": 2004
  },
  "references": [
    "acl-J00-1002",
    "acl-J96-1003"
  ],
  "sections": [
    {
      "text": [
        "The need to correct garbled strings arises in many areas of natural language processing.",
        "If a dictionary is available that covers all possible input tokens, a natural set ofcandidatesfor correcting an erroneous input P is the set ofall words in the dictionaryfor which the Levenshtein distance to P does not exceed a given (small) bound k. In this article we describe methodsfor efficiently selecting such candidate sets.",
        "After introducing as a starting point a basic correction method based on the concept of a “universal Levenshtein automaton,” we show how two filtering methods known from the field of approximate text search can be used to improve the basic procedure in a significant way.",
        "The first method, which uses standard dictionaries plus dictionaries with reversed words, leads to very short correction times for most classes of input strings.",
        "Our evaluation results demonstrate that correction times for fixed-distance bounds depend on the expected number of correction candidates, which decreases for longer input words.",
        "Similarly the choice of an optimal filtering method depends on the length of the input words."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "In this article, we face a situation in which we receive some input in the form of strings that may be garbled.",
        "A dictionary that is assumed to contain all possible correct input strings is at our disposal.",
        "The dictionary is used to check whether a given input is correct.",
        "If it is not, we would like to select the most plausible correction candidates from the dictionary.",
        "We are primarily interested in applications in the area of natural language processing in which the background dictionary is very large and fast selection of an appropriate set of correction candidates is important.",
        "By a “dictionary,” we mean any regular (finite or infinite) set of strings.",
        "Some possible concrete application scenarios are the following:",
        "• The dictionary describes the set of words of a highly inflectional or agglutinating language (e.g., Russian, German, Turkish, Finnish, Hungarian) or a language with compound nouns (German).",
        "The dictionary is used by an automated or interactive spelling checker.",
        "• The dictionary is multilingual and describes the set of all words of a family of languages.",
        "It is used in a system for postcorrection of results of OCR in which scanned texts have a multilingual vocabulary.",
        "• The dictionary describes the set of all indexed words and phrases of an Internet search engine.",
        "It is used to determine the plausibility that a new query is correct and to suggest “repaired” queries when the answer set returned is empty.",
        "• The input is a query to some bibliographic search engine.",
        "The dictionary contains titles of articles, books, etc.",
        "The selection of an appropriate set of correction candidates for a garbled input P is often based on two steps.",
        "First, all entries W of the dictionary are selected for which the distance between P and W does not exceed a given bound k. Popular distance measures are the Levenshtein distance (Levenshtein 1966; Wagner and Fischer 1974; Owolabi and McGregor 1988; Weigel, Baumann, and Rohrschneider 1995; Seni, Kripasundar, and Srihari 1996; Oommen and Loke 1997) or n-gram distances (Angell, Freund, and Willett 1983; Owolabi and McGregor 1988; Ukkonen 1992; Kim and Shawe-Taylor 1992, 1994) Second, statistical data, such as frequency information, may be used to compute a ranking of the correction candidates.",
        "In this article, we ignore the ranking problem and concentrate on the first step.",
        "For selection of correction candidates we use the standard Levenshtein distance (Levenshtein 1966).",
        "In most of the above-mentioned applications, the number of correction candidates becomes huge for large values of k. Hence small bounds are more realistic.",
        "In light of this background, the algorithmic problem discussed in the article can be described as follows: Given a pattern P, a dictionary D, and a small bound k, efficiently compute the set of all entries W in D such that the Levenshtein distance between P and W does not exceed k. We describe a basic method and two refinements for solving this problem.",
        "The basic method depends on the new concept of a universal deterministic Levenshtein automaton of fixed degree k. The automaton of degree k may be used to decide, for arbitrary words U and V, whether the Levenshtein distance between U and V does not exceed k. The automaton is “universal” in the sense that it does not depend on U and V. The input of the automaton is a sequence of bitvectors computed from U and V. Though universal Levenshtein automata have not been discussed previously in the literature, determining Levenshtein neighborhood using universal Levenshtein automata is closely related to a more complex table-based method described by the authors Schulz and Mihov (2002).",
        "Hence the main advantage of the new notion is its conceptual simplicity.",
        "In order to use the automaton for solving the above problem, we assume that the dictionary is given as a determininistic finite-state automaton.",
        "The basic method may then be described as a parallel backtracking traversal of the universal Levenshtein automaton and the dictionary automaton.",
        "Backtracking procedures of this form are well-known and have been used previously: for example, by Oflazer (1996) and the authors Schulz and Mihov (2002).",
        "For the first refinement of the basic method, a filtering method used in the field of approximate text search is adapted to the problem of approximate search in a dictionary.",
        "In this approach, an additional “backwards” dictionary DR (representing the set of all reverses of the words of a given dictionary D) is used to reduce approximate search in D with a given bound k ≥ 1 to related search problems for smaller bounds k' < k in D and DR. As for the basic method, universal Levenshtein automata are used to control the search.",
        "Ignoring very short input words and correction bound k = 1,",
        "this approach leads to a drastic increase in speed.",
        "Hence the “backwards dictionary method” can be considered the central contribution of this article.",
        "The second refinement, which is only interesting for bound k = 1 and short input words, also uses a filtering method from the field of approximate text search (Muth and Manber 1996; Mor and Fraenkel 1981).",
        "In this approach, “dictionaries with single deletions” are used to reduce approximate search in a dictionary D with bound k = 1 to a conventional lookup technique for finite-state transducers.",
        "Dictionaries with single deletions are constructed by deleting the symbol at a fixed position n in all words of a given dictionary.",
        "For the basic method and the two refinements, detailed evaluation results are given for three dictionaries that differ in terms of the number and average length of entries: a dictionary of the Bulgarian language with 965,339 entries (average length 10.23 symbols), a dictionary of German with 3,871,605 entries (dominated by compound nouns, average length 18.74 symbols), and a dictionary representing a collection of 1,200,073 book titles (average length 47.64 symbols).",
        "Tests were restricted to distance bounds k = 1, 2, 3.",
        "For the approach based on backwards dictionaries, the average correction time for a given input word – including the displaying of all correction suggestions – is between a few microseconds and a few milliseconds, depending on the dictionary, the length of the input word, and the bound k. Correction times over one millisecond occur only in a few cases for bound k = 3 and short input words.",
        "For bound k = 1, which is important for practical applications, average correction times did not exceed 40 microseconds.",
        "As a matter of fact, correction times are a joint result of hardware improvements and algorithmic solutions.",
        "In order to judge the quality of the correction procedure in absolute terms, we introduce an “idealized” correction algorithm in which any kind of blind search and superfluous backtracking is eliminated.",
        "Based on an analysis of this algorithm, we believe that using purely algorithmic improvements, our correction times can be improved only by a factor of 50–250, depending on the kind of dictionary used.",
        "This factor represents a theoretical limit in the sense that the idealized algorithm probably cannot be realized in practice.",
        "This article is structured as follows.",
        "In Section 2, we collect some formal preliminaries.",
        "In Section 3, we briefly summarize some known techniques from approximate string search in a text.",
        "In Section 4, we introduce universal deterministic Levenshtein automata of degree k and describe how the problem of deciding whether the Levenshtein distance between two strings P and W does not exceed k can be efficiently solved using this automaton.",
        "Since the method is closely related to a table-based approach introduced by the authors (Schulz and Mihov 2002), most of the formal details have been omitted.",
        "Sections 5, 6, and 7 describe, respectively, the basic method, the refined approach based on backwards dictionaries, and the approach based on dictionaries with single deletions.",
        "Evaluation results are given for the three dictionaries mentioned above.",
        "In Section 8 we briefly comment on the difficulties that we encountered when trying to combine dictionary automata and similarity keys (Davidson 1962; Angell, Freund, and Willett 1983; Owolabi and McGregor 1988; Sinha 1990; Kukich 1992; Anigbogu and Belaid 1995; Zobel and Dart 1995; de Bertrand de Beuvron and Trigano 1995).",
        "Theoretical bounds for correction times are discussed in Section 9.",
        "The problem considered in this article is well-studied.",
        "Since the number of contributions is enormous, a complete review of related work cannot be given here.",
        "Relevant references with an emphasis on spell-checking and OCR correction are Blair (1960), Riseman and Ehrich (1971), Ullman (1977), Angell, Freund, and Willett (1983), Srihari, Hull, and Choudhari (1983), Srihari (1985), Takahashi et al.",
        "(1990), Kukich (1992), Zobel"
      ]
    },
    {
      "heading": "2. Formal Preliminaries",
      "text": [
        "We assume that the reader is familiar with the basic notions of formal language theory as described, for example, by Hopcroft and Ullman (1979) or Kozen (1997).",
        "As usual, finite-state automata (FSA) are treated as tuples of the form A = (Σ, Q, q0, F, ∆), where Σ is the input alphabet, Q is the set of states, q0 ∈ Q is the initial state, F is the set of final states, and ∆ ⊆ Q × Σε × Q is the transition relation.",
        "Here E denotes the empty string and Σε := Σ ∪ {E}.",
        "The generalized transition relation ∆ˆ is defined as the smallest subset of Q × Σ∗ × Q with the following closure properties:",
        "• For all q ∈ Q we have (q, E, q) ∈ ˆ∆.",
        "• For all q1, q2, q3 ∈ Q and W1, W2 ∈ Σ∗, if (q1, W1, q2) ∈ ∆ˆ and",
        "A finite-state automaton A is deterministic if the transition relation is a function 6: Q × Σ → Q.",
        "Let A = (Σ, Q, q0, F, 6) be a deterministic FSA, and let 6∗: Q × Σ∗ → Q denote the generalized transition function, which is defined in the usual way.",
        "For q ∈ Q, we write LA (q) := {U ∈ Σ∗ |6∗(q,U) ∈ F} for the language of all words that lead from q to a final state.",
        "The length of a word W is denoted by |W|.",
        "Regular languages over Σ are defined in the usual way.",
        "With L1 · L2 we denote the concatenation of the languages L1 and L2.",
        "It is well-known that for any regular language L, there exists a deterministic FSA AL such that L(A) = L and AL is minimal (with respect to number of states) among all deterministic FSA accepting L. AL is unique up to renaming of states.",
        "A p-subsequential transducer is a tuple T = (Σ, Π, Q, q0, F, 6, A, Ψ), where",
        "• (Σ, Q, q0, F, 6) is a deterministic finite-state automaton; • Π is a finite output alphabet; • A: Q × Σ → Π∗ is a function called the transition output function; • the final function Ψ : F → 211* assigns to each f ∈ F a set of strings over Π, where |Ψ(f ) |≤ p.",
        "The function A is extended to the domain Q × Σ∗ by the following definition of A∗:",
        "The input language of the transducer is L(T) := {U ∈ Σ∗ |6∗(q0,U) ∈ F}.",
        "The subsequential transducer maps each word from the input language to a set of at most",
        "p output words.",
        "The output function OT: L(T) → 2n\" of the transducer is defined as follows: ∀U ∈ L(T) (OT (U) = λ∗(q0,U) · Ψ(δ∗(q0,U))) By a dictionary, we mean a regular (finite or infinite) set of strings over a given alphabet Σ.",
        "Using the algorithm described by Daciuk et al.",
        "(2000), the minimal deterministic FSA AD accepting a finite dictionary D can be effectively computed.",
        "By a dictionary with output sets, we mean a regular (finite or infinite) set of input strings over a given alphabet together with a function that maps each of the input strings to a finite set of output strings.",
        "Given a finite dictionary with output sets, we can effectively compute, using the algorithm described by Mihov and Maurel (2001), the minimal subsequential transducer that maps each input string to its set of output strings."
      ]
    },
    {
      "heading": "3. Background",
      "text": [
        "In this section, we describe some established work that is of help in understanding the remainder of the article from a nontechnical, conceptual point of view.",
        "After introducing the Levenshtein distance, we describe methods for computing the distance, for checking whether the distance between two words exceeds a given bound, and for approximate search for a pattern in a text.",
        "The similarities and differences described below between approximate search in a text, on the one hand, and approximate search in a dictionary, on the other hand, should help the reader understand the contents of the following sections from a broader perspective."
      ]
    },
    {
      "heading": "3.1 Computation of Levenshtein Distance",
      "text": [
        "The most prominent metric for comparing strings is the Levenshtein distance, which is based on the notion of a primitive edit operation.",
        "In this article, we consider the standard Levenshtein distance.",
        "Here the primitive operations are the substitution of one symbol for another symbol, the deletion of a symbol, and the insertion of a symbol.",
        "Obviously, given two words W and V in the alphabet Σ, it is always possible to rewrite W into V using primitive edit operations."
      ]
    },
    {
      "heading": "Definition 1",
      "text": [
        "Let P, W be words in the alphabet Σ.",
        "The (standard) Levenshtein distance between P and W, denoted dL (P, W), is the minimal number of primitive edit operations (substitutions, deletions, insertions) that are needed to transform P into W. The Levenshtein distance between two words P and W can be computed using the following simple dynamic programming scheme, described, for example, by Wagner and Fischer (1974):",
        "for P, W ∈ Σ∗ and a, b ∈ Σ.",
        "Given P = p1 ... pm and W = w1 ... wn (m, n ≥ 0), a standard way to apply the scheme is as follows: Proceeding top-down and from left to right, the cells of an (m + 1) × (n + 1) table TL(P,W) are filled, where entry (i, j) of T(P,W) is dL (p1 ... pi, w1 ... wj) (0 ≤ i ≤ m, 0 ≤ j ≤ n) (Wagner and Fischer 1974).",
        "The first two",
        "Computation of the Levenshtein distance using dynamic programming and filling table TL (chold, hchold).",
        "Shaded regions represent diagonals in Ukkonen’s approach (cf.",
        "Section 3.2).",
        "clauses above are used for initialization and yield, respectively, the first column and the first row.",
        "The third clause is used to compute the remaining entries.",
        "The table for the strings chold and hchold is shown in Figure 1."
      ]
    },
    {
      "heading": "3.2 Testing Levenshtein Neighborhood",
      "text": [
        "The algorithm of Wagner and Fischer, which has time complexity O(m • n), has been improved and generalized in many aspects.",
        "(See, for example, Stephen [1994] for a survey).",
        "We briefly sketch a more efficient variant that can be used for the restricted problem of deciding whether the Levenshtein distance between two words P and W exceeds a fixed bound, k. Ukkonen (1985a) shows that in this case only the values of 2k + 1 “diagonals” of TL (P, W) are essential for a test to make such a determination.",
        "Figure 1 illustrates the situation in which k = 2.",
        "Ukkonen obtained an algorithm with time complexity O(k • min(m,n)).",
        "He used the test for determining whether the Levenshtein distance between two words exceeds a given bound to derive an algorithm for computing the edit distance with complexity O(min(m,n) • dL(P,W))."
      ]
    },
    {
      "heading": "3.3 Approximate Search for a Pattern in a Text",
      "text": [
        "A problem closely related to approximate search in a dictionary is approximate search for a pattern in a text (AST): Given two strings P and T (called, respectively, the pattern and the text), find all occurrences T' of substrings of T that are within a given distance of P. Each occurrence T' is called a hit.",
        "In the following discussion, we consider the case in which a fixed bound k for the Levenshtein distance between P and potential hits is specified.",
        "Mihov and Schulz Fast Approximate Search in Large Dictionaries t h i s _ c h i l d 0 0 0 0 0 0 0 0 0 0 0 c 1 1 1 1 1 1 0 1 1 1 1 h 2 2 1 2 2 2 1 0 1 2 2 o 3 3 2 2 3 3 2 1 1 2 3 l 4 4 3 3 3 4 3 2 2 1 2 d 5 5 4 4 4 4 4 3 3 2 1"
      ]
    },
    {
      "heading": "Approximate search of pattern chold in a text using dynamic programming.",
      "text": [
        "distance < k to some word in Σ∗ •P (Ukkonen 1985b; Wu and Manber 1992; Baeza-Yates and Navarro 1999).",
        "The automaton for pattern chold and distance bound k = 2 is shown in Figure 3.",
        "States are numbered in the form be.",
        "The “base number” b determines the position of the state in the pattern.",
        "The “exponent” e indicates the error level, that is, the number of edit errors that have been observed.",
        "Horizontal transitions encode “normal” transitions in which the text symbol matches the expected next symbol of the pattern.",
        "Vertical transitions represent insertions, nonempty (respectively, empty) diagonal transitions represent substitutions (respectively, deletions).",
        "In the example shown in Figure 3, final states are 50, 51, and 52.",
        "It is obvious that when using a given text T as input, we reach a final state of AAST (P, 2) exactly at those positions where a substring T' of T ends such that dL(P,T') < 2.",
        "For other bounds k, we just have to vary the number of levels.",
        "Note that a string can be accepted in AAST (P, k) at several final states.",
        "In order to determine the optimal distance between P and a substring T' of T ending at a certain position, it is necessary to determine the final state that can be reached that has the smallest exponent.",
        "In the remainder of the article, the set of all states with base number i is called the ith column of AAST (P, k) ."
      ]
    },
    {
      "heading": "Remark 1",
      "text": [
        "There is a direct relationship between the entries in column j of the dynamic programming table TAST(P,T) and the set of active states of AAST (P,k) that are reached with input t1 • • • tj.",
        "Entry (i,j) of TAST(P,T) has the value h < k iff h is the exponent of the bottommost active state in the ith column of AAST (P, k).",
        "For example, in Figure 3, the set of active states of AAST (chold, k) reached after reading the two symbols t and h is highlighted.",
        "The bottommost elements 00, 11, 21, and 32 correspond to the entries 0,1,1, and 2 shaded in the upper part of the third column of Figure 2.",
        "Nondeterministic automaton AAST (chold, 2) for approximate search with pattern chold and distance bound k = 2.",
        "Active states after symbols t and h have been read are highlighted.",
        "k) might be difficult or impossible.",
        "In practice, simulation of determinism via bit-parallel computation of sets of active states gives rise to efficient and flexible algorithms.",
        "See Navarro (2001) and Navarro and Raffinot (2002) for surveys of algorithms along this li",
        "The direct use of the nondeterministic automaton AAST(P,k) for conducting approximate searches is inefficient.",
        "Furthermore, depending on the length m of the pattern and the error bound k, the explicit construction and storage of a deterministic version of"
      ]
    },
    {
      "heading": "4. Testing Levenshtein Neighborhood with Universal Deterministic",
      "text": []
    },
    {
      "heading": "Levenshtein Automata",
      "text": [
        "In our approach, approximate search of a pattern P in a dictionary D is traced back to the problem of deciding whether the Levenshtein distance between P and an entry W of D exceeds a given bound k. A well-known method for solving this problem is based on a nondeterministic automaton",
        "k. The automaton A(P, k) does not have the initial Σ loop that is needed in AAST(P,k) to traverse the text.",
        "The automaton for pattern chold and distance bound k = 2 is shown in Figure 4.",
        "Columns of",
        "... , m = IPI are defined as for AAST(P, k).",
        "In A(P, k), we use as final states all states q from which we can reach one of the states in column m using a (possibly empty) sequence of e-transitions.",
        "The reason for this modification – which obviously does not change the set of accepted words – will become apparent later.",
        "We now show that for fixed small error bounds k, the explicit computation of A(P, k), in a deterministic or nondeterministic variant, can be completely avoided.",
        "In our approach, pattern P and entry W ="
      ]
    },
    {
      "heading": "This sequence is used as input for a fixed automaton Ae(k).",
      "text": [
        "The automaton Ae(k) is deterministic and “universal” in the sense that it does not depend on a given pattern P. For each bound k, there is just one fixed automaton Ae (k), which is precomputed once and used for arbitrary patterns P and words W.",
        "recognition phase after the initial computation of the bitvectors �χ1, ... , �χ,,.",
        "It is worth mentioning that the possibility of using a fixed universal automaton Ae(k) instead of a specific automaton",
        "features of the automata A(P, k) (cf.",
        "Remark 2); a similar technique for AAST(P,k)",
        "Mihov and Schulz Fast Approximate Search in Large Dictionaries appears to be impossible.",
        "For defining states, input vectors and transitions of AV(k), the following two definitions are essential:"
      ]
    },
    {
      "heading": "Definition 2",
      "text": [
        "The characteristic vector �χ(w, V) of a symbol w E Σ in a word V = v1 • • • vn E Σ* is the bitvector of length n where the ith bit is set to 1 iff w = vi."
      ]
    },
    {
      "heading": "Definition 3",
      "text": [
        "Let P denote a pattern of length m. The triangular area of a state p of A (P, k) consists of all states q of A(P, k) that can be reached from p using a (potentially empty) sequence of u upward transitions and, in addition, h < u horizontal or reverse (i.e., leftward) horizontal transitions.",
        "Let 0 < i < m. By triangular area i, we mean the triangular area of state i0.",
        "For j = 1,. .",
        ".",
        ", k, by triangular area m+j, we mean the triangular area of the state mj.",
        "For example, in Figure 4, triangular areas 0,. .",
        ".",
        ", 7 of A (chold, 2) are shown.",
        "In Remark 1, we pointed to the relationship between the entries in column i of table TAST (P, T) and the set of active states of AAST(P, k) that are reached with input w1 • • • wi.",
        "A similar relationship holds between the entries in column i of table TL (P, T) and the set of active states of the automaton A(P, k) that are reached with input w1 • • • wi.",
        "Triangular area i corresponds to the ith column of the subregion of TL(P,T) given by the 2k + 1 diagonals used in Ukkonen’s (1985a) approach.",
        "The left-to-right orientation in A(P, k) corresponds to a top-down orientation in TL (P, T).",
        "As an illustration, the active states of A(chold,2) after symbols h and c have been consumed are marked in Figure 4.",
        "The exponents 2, 1, 2, and 2 of the bottommost active states in columns 1, 2, 3, and 4 are found in the shaded region of the third column of Figure 1."
      ]
    },
    {
      "heading": "Remark 2",
      "text": [
        "It is simple to see that for any input string W = w1 ... wn, the set of active states of A(P, k) reached after reading the ith symbol wi of W is a subset of triangular area i (0 < i < min f n, m + k}).",
        "For i > m + k, the set is empty.",
        "Furthermore, the set of active states that is reached after reading symbol wi depends only",
        "1. on the previous set of active states (the set reached after reading w1 ... wi_1, a subset of the triangular area i - 1); 2. on the characteristic vector �χ(wi, pl • • • pi • • • p,) where l= max f 1, i - k}",
        "and , = min f m, i + k}.",
        "The following description of AV (k) proceeds in three steps that introduce, in order, input vectors, states, and the transition function.",
        "States and transition function are described informally.",
        "1.",
        "Input vecto,s.",
        "Basically we want to use the vectors χ(wi,pl • • • pi • • • p,), which are of length < 2k + 1, as input for AV (k).",
        "For technical reasons, we introduce two modifications.",
        "First, in order to standardize the length of the characteristic vectors that",
        "are obtained for the initial symbols w1, w2, ..., we define p0 = p_1 = ... = p_k+1 := $.",
        "In other words, we attach to P a new prefix with k symbols $.",
        "Here $ is a new symbol that does not occur in W. Second imagine that we get to triangular area i after reading the ith letter wi (cf.",
        "Remark 2).",
        "As long as i < m - k - 1, we know that we cannot reach a triangular area containing final states after reading wi.",
        "In order to encode",
        " this information in the input vectors, we enlarge the relevant subword of P for input wi and consider one additional position i + k + 1 on the right-hand side (whenever i + k + 1 ≤ m).",
        "This means that we use the vectors �χi := �χ(wi,pi_k · · · pi · · · pr), where r = min{m, i+k+1}, as input for Ae(k), for 1 ≤ i ≤ min{n, m+k}.",
        "Consequently, for 0 ≤ i ≤ m−k−1, the length of�χi is 2k+2; for i = m−k (respectively, m−k+1, ... , m, ... , m+k), the length of �χi is 2k + 1 (respectively, 2k, ... , k + 1,... ,1)."
      ]
    },
    {
      "heading": "Example 1",
      "text": [
        "Consider Figure 4 where P is chold and k = 2.",
        "Input hchold is translated into the vectors",
        "The computation of the vectors �χi for input W = w1 ... wn is based on a preliminary step in which we compute for each σ ∈ Σ the vector �κ(σ) := �χ(σ, $... $p1 ... pm) (using k copies of $).",
        "The latter vectors are initialized in the form �κ(w) := 0k+m.",
        "We then compute for i = 1, ... , n the value �κ(wi) := �κ(wi) |0k+i_110m_i.",
        "Here the symbol |denotes bitwise OR.",
        "Once we have obtained the values �κ(wi), which are represented as arrays, the vectors �χi := �χ(wi,pi_k ... pi ... pr) can be accessed in constant time.",
        "2.",
        "States.",
        "Henceforth, states of automata A(P,k) will be called positions.",
        "Recall that a position is given by a base number and an exponent e, 0 ≤ e ≤ k represent",
        "ing the error count.",
        "By a symbolic triangular area, we mean a triangular area in which “explicit” base numbers (like 1,2,...) in positions are replaced by “symbolic” base numbers of a form described below.",
        "Two kinds of symbolic triangular areas are used.",
        "A unique “I-area” represents all triangular areas of automata A(P,k) that do not contain final positions.",
        "The “integer variable” I is used to abstract from possible base numbers i, 0 ≤ i ≤ m − k − 1.",
        "Furthermore, k + 1 “M-areas” are used to represent triangular areas of automata A(P,k) that contain final positions.",
        "Variable M is meant to abstract from concrete values of m, which differ for distinct P. Symbolic base numbers are expressions of the form I, I + 1, I − 1, I + 2, I − 2... (I-areas) or M, M − 1, M − 2,... (M-areas).",
        "The elements of the symbolic areas, which are called symbolic positions, are symbolic base numbers together with exponents indicating an error count.",
        "Details should become clear in Example 2.",
        "The use of expressions such as (I + 2)2 simply enables a convenient labeling of states of Ae(k) (cf.",
        "Figure 6).",
        "Using this kind of labeling, it is easy to formulate a correspondence between derivations in automata A(P, k) and in Ae (k) (cf. properties C1 and C2 discussed below)."
      ]
    },
    {
      "heading": "Example 2",
      "text": [
        "The symbolic triangular areas for bound k = 1 are"
      ]
    },
    {
      "heading": "Symbolic triangular areas and symbolic final positions for bound k = 2 (cf. Example 2).",
      "text": [
        "Symbolic final positions for k = 1 are M1, M0, and (M − 1)0.",
        "The symbolic triangular areas for k = 2 are indicated in Figure 5, in which the ellipses around symbolic final positions are rendered in boldface.",
        "States of Ae (k) are merely subsets of symbolic triangular areas.",
        "Subsets containing symbolic final positions are final states of Ae(k), and {I0} is the start state.",
        "A special technique is used to reduce the number of states.",
        "Returning to automata of the form A(P, k), it is simple to see that triangular areas often contain positions p = ge and q = hf where p “subsumes” q in the following sense: If, for some fixed input rest U, it is possible to reach a final position of A(P, k) starting from q and consuming U, then we may also reach a final position starting from p using U.",
        "A corresponding notion of subsumption can be defined for symbolic positions.",
        "States of Ae(k) are then defined as subsets of symbolic triangular areas that are free of subsumption in the sense that a symbolic position of a state is never subsumed by another position of the same state."
      ]
    },
    {
      "heading": "Example 3",
      "text": [
        "The states of automaton Ae(1) are shown in Figure 6.",
        "As a result of the above reduction technique, the only state containing the symbolic position I0 is {I0}, the start state.",
        "Each of the symbolic positions (I − 1)1,I1, (I + 1)1 is subsumed by I0.",
        "3.",
        "Transition function.",
        "It remains to define the transition function δe of Ae (k).",
        "We describe only the basic idea.",
        "Imagine an automaton A(P, k), where the pattern P has length m. Let W = w1 ... wn denote an input word.",
        "Let SPi denote the set of active positions of A(P, k) that are reached after reading the ith symbol wi (1 ≤ i ≤ n).",
        "For simplicity, we assume that in each set, all subsumed positions are erased.",
        "In Ae (k) we have a parallel acceptance procedure in which we reach, say, state Sei after reading �χi := �χ(wi, pi�k · · · pi · · · pr), where r = min{m, i + k + 1}, as above, for 1 ≤ i ≤ n. Transitions are defined in such a way that C1 and C2 hold:",
        "the set SPi is obtained from Sei by instantiating the letter I by i whenever Sei uses variable I and instantiating M by m in the other cases.",
        "C2.",
        "Whenever SPi contains a final position, then Sei is final.",
        "Given properties C1 and C2, it follows immediately that A(P,k) accepts w1 ... wn iff Ae (k) accepts �χ1, ... ,�χn.",
        "The universal deterministic Levenshtein automaton Ad(1).",
        "See Example 4 for notation."
      ]
    },
    {
      "heading": "Example 4",
      "text": [
        "The universal deterministic automaton At'(1) is shown in Figure 6.",
        "(Some redundant transitions departing from nonfinal states S =� {I0} and using vectors of length ≤ 3 have been omitted.)",
        "The symbol stands for either 1 or 0.",
        "Moreover, x( ) is shorthand for ; or ;C. In order to illustrate the use of A∀ (1), consider the pattern P of the form chold.",
        "Input child is translated into the sequence",
        "Starting from state {I0}, we successively reach {I0}, {I0}, {(I−1)1,I1}, {I1}, {M1}.",
        "Hence child is accepted.",
        "In a similar way the input word cold is translated into the sequence 0100–0010–0010–001.",
        "Starting from {I0}, we successively reach {I0}, {(I−1)1,I1, (I+1)1}, { (I + 1)1}, {M1}.",
        "Hence cold is also accepted.",
        "Third, input hchold is translated into the sequence 0010–1000–1000–100–10–1.",
        "We reach successively {(I − 1)1,I1, (I + 1)1}, {(I − 1)1}, {(I − 1)1}, {(I − 1)1}, {(I − 1)1}, {M1}.",
        "Hence hchold is accepted as well.",
        "For larger values of k, the number of states of A∀ (k) grows rapidly.",
        "A∀ (2) has 50 nonfinal states and 40 final states.",
        "The automaton A∀ (3) has 563 states.",
        "When we tried",
        "to minimize the automata A∀ (1), A∀ (2), and A∀ (3), we found that these three automata are already minimal.",
        "However, we do not have a general proof that our construction always leads to minimal automata."
      ]
    },
    {
      "heading": "5. Approximate Search in Dictionaries Using Universal Levenshtein Automata",
      "text": [
        "We now describe how to use the universal deterministic Levenshtein automaton A∀ (k) for approximate search for a pattern in a dictionary."
      ]
    },
    {
      "heading": "5.1 Basic Correction Algorithm",
      "text": [
        "Let D denote the background dictionary, and let P = p1 ... pm denote a given pattern.",
        "Recall that we want to compute for some fixed bound k the set of all entries W E D such that dL(P,W) < k. We assume that D is implemented in the form of a deterministic finite-state automaton AD = (Σ, QD, qD0 , FD, δD), the dictionary automaton.",
        "Hence L(AD) represents the set of all correct words.",
        "Let A∀ (k) = (Γ, Q∀, q∀0, F∀, δ∀) denote the universal deterministic Levenshtein automaton for bound k. We assume that we can access, for each symbol σ E Σ and each index 1 < i < m + k, the characteristic vector �χ(σ, pi−k • • • pi • • • pr), where r = min{m, i + k+ 11, in constant time (cf.",
        "Section 4).",
        "We traverse the two automata A∀ (k) and AD in parallel, using a standard backtracking procedure.",
        "At each step, a symbol σ read in AD representing the ith symbol of the current dictionary path is translated into the bitvector �χ(σ, pi−k • • • pi • • • pr), r = min{m, i + k + 11, which is used as input for A∀(k).",
        "Starting with the pair of initial states (qD0 , q∀0 ), position i = 0, and the empty word ε, each step of the traversal adds a new symbol σ E Σ to the actual word W and leads from a pair of states (qD,q∀) E QD x Q∀ to (δD(qD,σ),δ∀(q∀,�χ)).",
        "We proceed as long as both components are distinct from the empty failure state,1 NIL.",
        "Whenever a final state is reached in both automata, the actual word W is added to the output.",
        "It is trivial to show that the list of all output words represents exactly the set of all dictionary entries W such that dL (W, P) < k. The computational cost of the above algorithm is bounded by the size of the dictionary automaton AD and depends on the bound k used.",
        "If k reaches the length of",
        "the longest word in the dictionary, then in general (e.g., for the empty input word), the algorithm will result in a complete traversal of AD.",
        "In practice, small bounds are used, and only a small portion of AD will be visited.",
        "For bound 0, the algorithm validates in time O(IPI) if the input pattern P is in the dictionary."
      ]
    },
    {
      "heading": "5.2 Evaluation Results for Basic Correction Algorithm",
      "text": [
        "Experimental results were obtained using a Bulgarian lexicon (BL) with 965,339 word entries (average length 10.23 symbols), a German dictionary (GL) with 3,871,605 entries (dominated by compound nouns, average length 18.74 symbols), and a “lexicon” (TL) containing 1,200,073 bibliographic titles from the Bavarian National Library (average length 47.64 symbols).",
        "The German dictionary and the title dictionary are nonpublic.",
        "They were provided to us by Franz Guenthner and the Bavarian National Library, respectively, for the tests we conducted.",
        "The following table summarizes the dictionary automaton statistics for the three dictionaries:",
        "5.2.1 A Baseline.",
        "Before we present our evaluation results, we give a simplified baseline.",
        "Let a garbled word W be given.",
        "In order to find all words from the dictionary within Levenshtein distance k, we can use two simple methods: 1.",
        "For each dictionary word V, check whether dL (V, W) < k. 2.",
        "For each string V such that dL(V,W) < k, check whether V is in the",
        "dictionary.",
        "We consider input words W of length 10.",
        "Visiting a state in an automaton takes about 0.1 µs.",
        "Using Method 1, the time needed to check whether dL (V, W) < k for a dictionary word V using the universal Levenshtein automaton can be estimated as 1 µs (a crude approximation).",
        "When using Method 2, we need about 1 µs for the dictionary lookup of a word with 10 symbols.",
        "Assume that the alphabet has 30 symbols.",
        "Given the input W, we have 639 strings within Levenshtein distance 1, about 400,000 strings within distance 2, and about 260,000,000 strings within distance 3.",
        "Assuming that the dictionary has 1,000,000 words, we get the following table of correction times: Distance 1 Distance 2 Distance 3 Method 1 1,000 ms 1,000 ms 1,000 ms Method 2 0.639 ms 400 ms 260,000 ms",
        "lexicon, we used a Bulgarian word list containing randomly introduced errors.",
        "In each word, we introduced between zero and four randomly selected symbol substitutions,",
        "insertions, or deletions.",
        "The number of test words created for each length is shown in the following table:",
        "hence the column represents the total correction time.",
        "Column 3 (NC1) shows the average number of correction candidates (dictionary words within the given distance bound) per input word.",
        "(For k = 1, there are cases in which this number is below 1.",
        "This shows that for some of the test words, no candidates were returned: These words were too seriously corrupted for correction suggestions to be found within the given distance bound.)",
        "Similarly Columns 4 (CT2) and 6 (CT3) yield, respectively, the total correction times per word (averages) for distance bounds 2 and 3, and Columns 5 (NC2) and 7 (NC3) yield, respectively, the average number of correction candidates per word for distance bounds 2 and 3.",
        "Again, the time needed to output all corrections is included.",
        "5.2.3 Correction with GL.",
        "To test the correction times when using the German lexicon, we again created a word list with randomly introduced errors.",
        "The number of test words of each particular length is shown in the following table: Length 1–14 15–24 25–34 35–44 45–54 55–64 0 words 100,000 100,000 100,000 9,776 995 514 The average correction times and number of correction candidates for GL are summarized in Table 2, which has the same arrangement of columns (with corresponding interpretations) as Table 1.",
        "5.2.4 Correction with TL.",
        "To test the correction times when using the title “lexicon,” we again created a word list with randomly introduced errors.",
        "The number of test words of each length is presented in the following table: Length 1–14 15–24 25–34 35–44 45–54 55–64 0 words 91,767 244,449 215,094 163,425 121,665 80,765 Table 3 lists the results for correction with TL and standard Levenshtein distance with bounds k = 1, 2, 3.",
        "The arrangement of columns is the same as for Table 1, with corresponding interpretations.",
        "5.2.5 Summary.",
        "For each of the three dictionaries, evaluation times strongly depend on the tolerated number of edit operations.",
        "When fixing a distance bound, the length of the input word does not have a significant influence.",
        "In many cases, correction works faster for long input words, because the number of correction candidates decreases.",
        "The large number of entries in GL leads to increased correction times."
      ]
    },
    {
      "heading": "6. Using Backwards Dictionaries for Filtering",
      "text": [
        "In the related area of pattern matching in strings, various filtering methods have been introduced that help to find portions of a given text in which an approximate match of a given pattern P is not possible.",
        "(See Navarro [2001] and Navarro and Raffinot [2002] for surveys).",
        "In this section, we show how one general method of this form (Wu and Manber 1992; Myers 1994; Baeza-Yates and Navarro 1999; Navarro and Baeza-Yates 1999) can be adapted to approximate search in a dictionary, improving the basic correction algorithm.",
        "For approximate text search, the crucial observation is the following: If the Levenshtein distance between a pattern P and a portion of text T' does not exceed a given bound k, and if we cut P into k + 1 disjoint pieces P1,.",
        ".",
        ".",
        ", Pk+1, then T' must contain at least one piece.",
        "Hence the search in text T can be started with an exact multipat-tern search for {P1, ... , Pk+1 }, which is much faster than approximate search for P. When finding one of the pieces Pi in the text, the full pattern P is searched for (returning now to approximate search) within a small neighborhood around the occurrence.",
        "Generalizations of this idea rely on the following lemma (Myers 1994; Baeza-Yates and Navarro 1999; Navarro and Raffinot 2002):"
      ]
    },
    {
      "heading": "Lemma 1",
      "text": [
        "Let T' match P with ≤ k errors.",
        "Let P be represented as the concatenation of j words P1,.",
        ".",
        ".",
        ", Pj.",
        "Let a1,.",
        ".",
        ".",
        ", aj denote arbitrary integers, and define A = �ji=1 ai.",
        "Then, for some i ∈ {1, ... , j}, Pi matches a substring of T' with ≤ Laik/AJ errors.2 In our experiments, which were limited to distance bounds k = 1, 2, 3, we used the following three instances of the general idea.",
        "Let P denote an input pattern, and let W denote an entry of the dictionary D. Assume we cut P into two pieces, representing it in the form P = P1P2: 1.",
        "If dL (P, W) ≤ 3, then W can be represented in the form W = W1 W2, where we have the following mutually exclusive cases:",
        "(a) dL (P1, W1) = 0 and dL (P2, W2) ≤ 3 (b) 1 ≤ dL (P1, W1) ≤ 3 and dL (P2, W2) = 0 (c) dL (P1, W1) = 1 and 1 ≤ dL (P2, W2) ≤ 2 (d) dL (P1, W1) = 2 and dL (P2, W2) = 1 2.",
        "If dL (P, W) ≤ 2, then W can be represented in the form W = W1 W2,",
        "where we have the following mutually exclusive cases:",
        "(a) dL (P1, W1) = 0 and dL (P2, W2) ≤ 2 (b) dL (P2, W2) = 0 and 1 ≤ dL (P1, W1) ≤ 2 (c) dL (P1, W1) = 1 = dL (P2, W2) 3.",
        "If dL (P, W) ≤ 1, then W can be represented in the form W = W1 W2,",
        "where we have the following mutually exclusive cases:",
        "(a) dL (P1, W1) = 0 and dL (P2, W2) ≤ 1 (b) dL (P1, W1) = 1 and dL (P2, W2) = 0",
        "In order to make use of these observations, we compute, given dictionary D, the backwards dictionary D-R:= {W-R |W ∈ D}.3 Dictionary D and backwards dictionary DR are compiled into deterministic finite-state automata AD and AD-R, respectively.",
        "If the dictionary is infinite and directly given as a finite-state automaton AD, the automaton AD-R may be computed using standard techniques from formal language theory.",
        "Further steps depend on the bound k. We will describe only approximate search with bound k = 3; the methods for bounds k = 1, 2 are similar.",
        "Let P denote the given pattern.",
        "P is cut into two pieces P1, P2 of approximately the same length.",
        "We compute p R and Pi R. We then start four subsearches, corresponding to Cases (1a)–(1d) specified above.",
        "For subsearch (1a), we first traverse AD using input P1.",
        "Let q denote the state that is reached.",
        "Starting from q and the initial state {I° } of AV (3), we continue with a parallel traversal of AD and AV (3).",
        "Transition symbols in AD are translated into input bitvectors for AV(3) by matching them against appropriate subwords of $$$P2, as described in Section 5.",
        "The sequence of all transition labels of the actual paths in AD is stored as usual.",
        "Whenever we reach a pair of final states, the current sequence – which includes the prefix P1 – is passed to the output.",
        "Clearly, each output sequence has the form P1P2', where dL(P2,P'2) ≤ 3.",
        "Conversely, any dictionary word of this form is found using subsearch (1a).",
        "For subsearch (1b), we first traverse AD-R using p R. Let q denote the state that is reached.",
        "Starting from q and the initial state {I°} of AV(3), we continue with a parallel traversal of AD-R and AV(3).",
        "Transition symbols in AD-R are translated into input bitvectors for AV (3) by matching them against appropriate subwords of $$$Pi R .",
        "Whenever we reach a pair of final states, the inversed sequence is passed to the output.",
        "Clearly, each output sequence has the form P'1P2, where dL (P1, P'1) ≤ 3.",
        "Conversely, any dictionary word of this form is found using a search of this form.",
        "For a given output, a closer look at the final state S that is reached in AV (3) may be used to exclude cases in which P1 = P'1.",
        "(Simple details are omitted).",
        "For subsearch (1c), we start with a parallel traversal of AD and AV(1).",
        "Transition symbols in AD are translated into input bitvectors for AV (1) by matching them against appropriate subwords of $P1.",
        "For each pair of states (q,S) that are reached, where S represents a final state of AV (1), we start a parallel traversal of AD and AV (2), departing from q and the initial state {I°} of AV(2).",
        "Transition symbols in AD are translated into input bitvectors for AV(2) by matching them against appropriate subwords of $$P2.",
        "Whenever we reach a pair of final states, the current sequence is passed to the output.",
        "Clearly, each output sequence has the form P'1P'2, where dL (P1, P'1) ≤ 1 and dL (P2, P'2) ≤ 2.",
        "Conversely, any dictionary word of this form is found using a search of this form.",
        "A closer look at the final states that are respectively reached in AV(1) and AV (2) may be used to exclude cases in which P1 = P'1 or P2 = P'2.",
        "(Again, simple details are omitted).",
        "where dL (P1, P 1) < 2 and dL (P2, P 2) < 1.",
        "Conversely, any word in the dictionary of this form is found using a search of this form.",
        "A closer look at the final states that are reached in A∀(1) and A∀(2) may be used to exclude cases where P2 = P 2 or dL (P1, P 1) < 1, respectively.",
        "(Again, simple details are omitted).",
        "It should be noted that the output sets obtained from the four subsearches (1a)– (1d) are not necessarily disjoint, because a dictionary entry W may have more than one partition W = W1 W2 of the form described in cases (1a)–(1d)."
      ]
    },
    {
      "heading": "6.1 Evaluation Results",
      "text": [
        "The following table summarizes the statistics of the automata for the three backwards dictionaries:",
        "Note that the size of the backwards-dictionary automata is approximately the same as the size of the dictionary automata.",
        "Tables 4, 5, and 6 present the evaluation results for the backwards dictionary filtering method using dictionaries BL, GL, and TL, respectively.",
        "We have constructed additional automata for the backwards dictionaries.",
        "For the tests, we used the same lists of input words as in Section 5.2 in order to allow a direct comparison to the basic correction method.",
        "Dashes indicate that the correction times were too small to be measured with sufficient confidence in their level of precision.",
        "In columns 3, 5, and 7, we quantify the speedup factor, that is, the ratio of the time taken by the basic algorithm to that taken by the backwards-dictionary filtering method."
      ]
    },
    {
      "heading": "6.2 Backwards-Dictionary Method for Levenshtein Distance with Transpositions",
      "text": [
        "Universal Levenshtein automata can also be constructed for the modified Levenshtein distance, in which character transpositions count as a primitive edit operation, along with insertions, deletions, and substitutions.",
        "This kind of distance is preferable when correcting typing errors.",
        "A generalization of the techniques presented by the authors (Schulz and Mihov 2002) for modified Levenshtein distances – using either transpositions or merges and splits as additional edit operations – has been described in Schulz and Mihov (2001).",
        "It is assumed that all edit operations are applied in parallel, which implies, for example, that insertions between transposed letters are not possible.",
        "If we want to apply the filtering method using backwards dictionaries for the modified Levenshtein distance d L (P, W) with transpositions, we are faced with the following problem: Assume that the pattern P = a1a2 ... amam+1... an is split into P1 = a1a2 ... am and P2 = am+1am+2 .",
        ".",
        ".",
        "an.",
        "When we apply the above procedure, the case in which am and am+1 are transposed is not covered.",
        "In order to overcome this problem, we can draw on the following observation: If d L (P, W) < 3, then W can be represented in the form W = W1 W2, where there are seven alternatives, inlcuding the following four:",
        "1. d L (P1, W1) = 0 and d L (P2, W2) < 3 2.",
        "1 < d L(P1, W1) < 3 and d L(P2, W2) = 0",
        "3. d'L (P1, W1) = 1 and 1 < d'L (P2, W2) < 2 4. d'L (P1, W1) = 2 and d'L (P2, W2) = 1",
        "In the remaining three alternatives, W1 = W'1am+1 ends with the symbol am+1, and W2 = am W'2 starts with am.",
        "For P'1 := a1a2 ... am-1 and P'2 := am+2am+3 .",
        ".",
        ".",
        "an, we have the following three alternatives:",
        "5. d'L (P'1, W'1) = 0 and dL (P'2, W'2) < 2 6. d'L(P'1,W'1) = 1 and d'L(P'2,W'2) < 1 7. d'L (P'1, W'1) = 2 and d'L (P'2, W'2) = 0",
        "We have tested the new search procedure for the modified Levenshtein distance d' L. In Table 7 we present the experimental results with the German dictionary and the title “lexicon” for distance bound k = 3.",
        "6.2.1 Summary.",
        "The filtering method using backwards dictionaries drastically improves correction times.",
        "The increase in speed depends both on the length of the input word and on the error bound.",
        "The method works particularly well for long input words.",
        "For GL, a drastic improvement can be observed for all subclasses.",
        "In contrast, for very short words of BL, only a modest improvement is obtained.",
        "When using BL and the modified Levenshtein distance d' L with transpositions, the backwards-dictionary method improved the basic search method only for words of length > 9.",
        "For short words, a large number of repetitions of the same correction candidates was observed.",
        "The analysis of this problem is a point of future work.",
        "Variants of the backwards-dictionary method also can be used for the Levenshtein distance d''L, in which insertions, deletions, substitutions, merges, and splits are treated as primitive edit operations.",
        "Here, the idea is to split the pattern at two neighboring positions, which doubles the number of subsearches.",
        "We did not evaluate this variant.",
        "7.",
        "Using Dictionaries with Single Deletions for Filtering The final technique that we describe here is again an adaptation of a filtering method from pattern matching in strings (Muth and Manber 1996; Navarro and Raffinot 2002).",
        "When restricted to the error bound k = 1, this method is very efficient.",
        "It can be used only for finite dictionaries.",
        "Assume that the pattern P = p1 ... pm matches a portion of text, T', with one error.",
        "Then m - 1 letters of P are found in T' in the correct order.",
        "This fact can be used to compute m + 1 derivatives of P that are compared with similar derivatives of a window T' of length m that is slid over the text.",
        "A derivative of a word V can be V or a word that is obtained by deleting exactly one letter of V. Coincidence between derivatives of P and T' can be used to detect approximate matches of P of the above form.",
        "For details we refer to Navarro and Raffinot (2002).",
        "In what follows we describe an adaptation of the method to approximate search of a pattern P in a dictionary D. Let i be an integer.",
        "With V[i] we denote the word that is obtained from a word V by deleting the ith symbol of V. For |V |< i, we define V[i] = V. By a dictionary with output sets, we mean a list of strings W, each of which is associated with a set of output strings O(W).",
        "Each string W is called a key.",
        "Starting from the conventional dictionary D, we compute the following dictionaries with output sets Dall, D1, D2, ..., D„0, where „0 is the maximal length of an entry in D:",
        "• The set of keys of Dall is D ∪ {V |∃i ≥ 1, W ∈ D such that V = W[i] }.",
        "The output set for key V is Oall(V):={W∈D |W=V∨V=W[i] for some i≥1}.",
        "• The set of keys for Di is D ∪ {V |∃W ∈ D such that V = W [i] }.",
        "The output set for a key VisOi(V):={W∈D |W=V∨V=W[i]}."
      ]
    },
    {
      "heading": "Lemma 2",
      "text": [
        "Let P denote a pattern, and let W ∈ D. Then dL (P, W) ≤ 1 iff either W ∈ Oall (P) or there exists i, 1 ≤ i ≤ |P|, such that W ∈ Oi(P[i] ).",
        "The proof of the lemma is simple and has therefore been omitted.",
        "In our approach, the dictionaries with output sets Dall, D1, D2, ..., D„0 are compiled, respectively, into minimal subsequential transducers Aall, A1, A2, ...,A„0.",
        "Given a pattern P, we compute the union of the output sets Oall(P),O1 (P[1] ),...,O|P |(P[P|]) using these transducers.",
        "It follows from Lemma 2 that we obtain as result the set of all entries W of D such that dL (P, W) ≤ 1.",
        "It should be noted that the output sets are not necessarily disjoint.",
        "For example, if P itself is a dictionary entry, then P ∈ Oi (P[i]) for all 1 ≤ i ≤ |P|.",
        "After we implemented the above procedure for approximate search, we found that a similar approach based on hashing had been described as early as 1981 in a technical report by Mor and Fraenkel (1981)."
      ]
    },
    {
      "heading": "7.1 Evaluation Results",
      "text": [
        "Table 8 presents the evaluation results for edit distance 1 using dictionaries with single deletions obtained from BL.",
        "The total size of the constructed single-deletion dictionary automata is 34.691 megabytes.",
        "The word lists used for tests are those described in Section 5.2.",
        "GL and TL are not considered here, since the complete system of subdic-tionaries needed turned out to be too large.",
        "For a small range of input words of length 3–6, filtering using dictionaries with single deletions behaves better than filtering using the backwards-dictionary method."
      ]
    },
    {
      "heading": "8. Similarity Keys",
      "text": [
        "A well-known technique for improving lexical search not mentioned so far is the use of similarity keys.",
        "A similarity key is a mapping κ that assigns to each word W a simplified representation κ(W).",
        "Similarity keys are used to group dictionaries into classes",
        "of “similar” entries.",
        "Many concrete notions of “similarity” have been considered, depending on the application domain.",
        "Examples are phonetic similarity (e.g., SOUNDEX system; cf. Odell and Russell [1918, 1922] and Davidson [1962]), similarity in terms of word shape and geometric form (e.g., “envelope representation” [Sinha 1990; Anigbogu and Belaid 1995] ) or similarity under n-gram analysis (Angell, Freund, and Willett 1983; Owolabi and McGregor 1988).",
        "In order to search for a pattern P in the dictionary, the “code” r.(P) is computed.",
        "The dictionary is organized in such a way that we may efficiently retrieve all regions containing entries with code (similar to) r.(P).",
        "As a result, only small parts of the dictionary must be visited, which speeds up search.",
        "Many variants of this basic idea have been discussed in the literature (Kukich 1992; Zobel and Dart 1995; de Bertrand de Beuvron and Trigano 1995).",
        "In our own experiments we first considered the following simple idea.",
        "Given a similarity key r., each entry W of dictionary D is equipped with an additional prefix of the form r.(W)&.",
        "Here & is a special symbol that marks the border between codes and original words.",
        "The enhanced dictionary Dˆ with all entries of the form r.(W)&W is compiled into a deterministic finite-state automaton AˆD.",
        "Approximate search for pattern P in D is then reorganized in the following way.",
        "The enhanced pattern r.(P)&P is used for search in AˆD.",
        "We distinguish two phases in the backtracking process.",
        "In Phase 1, which ends when the special symbol & is read, we compute an initial path of AˆD in which the corresponding sequence of transition labels represents a code a such that dL(r.(P),a) ≤ k. All paths of this form are visited.",
        "Each label sequence a& of the above form defines a unique state q of the automaton AˆD such that LAˆD(q) = {W ∈ D |r.",
        "(W) = a}.",
        "In Phase 2, starting from q, we compute all entries W with code r.(W) = a such that dL(W,P) ≤ k. In both phases the automaton A∀ (k) is used to control the search, and transition labels of AˆD are translated into characteristic vectors.",
        "In order to guarantee completeness of the method, the distance between codes of a pair of words should not exceed the distance between the words themselves.",
        "It is simple to see that in this method, the backtracking search is automatically restricted to the subset of all dictionary entries V such that dL (r. (V), r. (P)) ≤ k. Unfortunately, despite this, the approach does not lead to reduced search times.",
        "A closer look at the structure of (conventional) dictionary automata AD for large dictionaries D shows that there exists an enormous number of distinct initial paths of AD of length 3–5.",
        "During the controlled traversal of AD, most of the search time is spent visiting paths of this initial “wall.” Clearly, most of these paths do not lead to any correction candidate.",
        "Unfortunately, however, these “blind” paths are recognized too late.",
        "Using the basic method described in Section 5, we have to overcome one single wall in AD for the whole dictionary.",
        "In contrast, when integrating similarity keys in the above form, we have to traverse a similar wall for the subdictionary D,.",
        "(W) := {V ∈ D |r.",
        "(V) = r.(W)} for each code r.(W) found in Phase 1.",
        "Even if the sets Dκ(W) are usually much smaller than D, the larger number of walls that are visited leads to increased traversal times.",
        "As an alternative, we tested a method in which we attached to each entry W of D all prefixes of the form a&, where a represents a possible code such that dL(r.(W), a) ≤ k. Using a procedure similar to the one described above, we have to traverse only one wall in Phase 2.",
        "With this method, we obtained a reduction in search time.",
        "However, with this approach, enhanced dictionaries Dˆ are typically much larger than original dictionaries D. Hence the method can be used only if both dictionary D and bound k are not too large and if the key is not too fine.",
        "Since the method is not more efficient than filtering using backwards dictionaries, evaluation results are not presented here."
      ]
    },
    {
      "heading": "9. Concluding Remarks",
      "text": [
        "In this article, we have shown how filtering methods can be used to improve finite-state techniques for approximate search in large dictionaries.",
        "As a central contribution we introduced a new correction method, filtering based on backwards dictionaries and partitioned input patterns.",
        "Though this method generally leads to very short correction times, we believe that correction times could possibly be improved further using refinements and variants of the method or introducing other filtering methods.",
        "There are, however, reasons to assume that we are not too far from a situation in which further algorithmic improvements become impossible for fundamental reasons.",
        "The following considerations show how an “optimal” correction time can be estimated that cannot be improved upon without altering the hardware or using faster access methods for automata.",
        "We used a simple backtracking procedure to realize a complete traversal of the dictionary automaton AD.",
        "During a first traversal, we counted the total number of visits to any state.",
        "Since AD is not a tree, states may be passed through several times during the complete traversal.",
        "Each such event counts as one visit to a state.",
        "The ratio of the number of visits to the total number of symbols in the list of words D gives the average number of visits per symbol, denoted v0.",
        "In practice, the value of v0 depends on the compression rate that is achieved when compiling D into the automaton AD.",
        "It is smaller than 1 because of numerous prefixes of dictionary words that are shared in AD.",
        "We then used a second traversal of AD – not counting visits to states – to compute the total traversal time.",
        "The ratio of the total traversal time to the number of visits yields the time t0 that is needed for a single visit.",
        "For the three dictionaries, the following values were obtained:",
        "Given an input V, we may consider the total number nV of symbols in the list of correction candidates.",
        "Then nV ·v0 · t0 can be used to estimate the optimal correction time for V. In fact, in order to achieve this correction time, we need an oracle that knows how to avoid any kind of useless backtracking.",
        "Each situation in which we proceeded on a dictionary path that does not lead to a correction candidate for V would require some extra time that is not included in the above calculation.",
        "From another point of view, the above idealized algorithm essentially just copies the correction candidates into a resulting destination.",
        "The time that is consumed is proportional to the sum of the length of the correction candidates.",
        "For each of the three dictionaries, we estimated the optimal correction time for one class of input words.",
        "For BL we looked at input words of length 10.",
        "The average number of correction candidates for Levenshtein distance 3 is 121.73 (cf. Table 1).",
        "Assuming that the average length of correction candidates is 10, we obtain a total of 1,217.3 symbols in the complete set of all correction candidates.",
        "Hence the optimal correction time is approximately 1217.3•0.0000918 ms • 0.1433 = 0.016 ms The actual correction time using filtering with the backwards-dictionary method is 0.827 ms, which is 52 times slower.",
        "For GL, we considered input words of length 15–24 and distance bound 3.",
        "We have on average 3.824 correction candidates of length 20, that is, 76.48 symbols.",
        "Hence the optimal correction time is approximately 76.48•0.0001078 ms • 0.3618 = 0.003 ms The actual correction time using filtering with the backwards-dictionary method is 0.601 ms, which is 200 times slower.",
        "For TL, we used input sequences of length 45–54 and again distance bound 3.",
        "We have on average 0.857 correction candidates of length 50, that is, 42.85 symbols.",
        "Hence the optimal correction time is approximately 42.85•0.0000865 ms • 0.7335 = 0.003 ms The actual correction time using filtering with the backwards-dictionary method is 0.759 ms, which is 253 times slower.",
        "These numbers coincide with our basic intuition that further algorithmic improvements are simpler for dictionaries with long entries.",
        "For example, variants of the backwards-dictionary method could be considered in which a finer subcase analysis is used to improve filtering."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "This work was funded by a grant from VolkswagenStiftung.",
        "The authors thank the anonymous referees for many suggestions that helped to improve the presentation."
      ]
    }
  ]
}
