{
  "info": {
    "authors": [
      "Daniel Feinstein",
      "Shuly Wintner"
    ],
    "book": "International Conference on Computational Linguistics and Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P06-1137",
    "title": "Highly Constrained Unification Grammars",
    "url": "https://aclweb.org/anthology/P06-1137",
    "year": 2006
  },
  "references": [
    "acl-J93-4002",
    "acl-P98-1101"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Unification grammars are widely accepted as an expressive means for describing the structure of natural languages.",
        "In general, the recognition problem is undecidable for unification grammars.",
        "Even with restricted variants of the formalism, off-line parsable grammars, the problem is computationally hard.",
        "We present two natural constraints on unification grammars which limit their expressivity.",
        "We first show that non-reentrant unification grammars generate exactly the class of context-free languages.",
        "We then relax the constraint and show that one-reentrant unification grammars generate exactly the class of tree-adjoining languages.",
        "We thus relate the commonly used and linguistically motivated formalism of unification grammars to more restricted, computationally tractable classes of languages."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Unification grammars (UG) (Shieber, 1986; Shieber, 1992; Carpenter, 1992) have originated as an extension of context-free grammars, the basic idea being to augment the context-free rules with non context-free annotations (feature structures) in order to express additional information.",
        "They can describe phonological, morphological, syntactic and semantic properties of languages simultaneously and are thus linguistically suitable for modeling natural languages.",
        "Several formulations of unification grammars have been proposed, and they are used extensively by computational linguists to describe the structure of a variety of natural languages.",
        "Unification grammars are Turing equivalent: determining whether a given string is generated by a given grammar is as hard as deciding whether a Turing machine halts on the empty input (Johnson, 1988).",
        "Therefore, the recognition problem for unification grammars is undecidable in the general case.",
        "To ensure its decidability, several constraints on unification grammars, commonly known as the off-line parsability (OLP) constraints, were suggested, such that the recognition problem is decidable for off-line parsable grammars (Jaeger et al., 2005).",
        "The idea behind all the OLP definitions is to rule out grammars which license trees in which unbounded amount of material is generated without expanding the frontier word.",
        "This can happen due to two kinds of rules: c-rules (whose bodies are empty) and unit rules (whose bodies consist of a single element).",
        "However, even for unification grammars with no such rules the recognition problem is NP-hard (Barton et al., 1987).",
        "In order for a grammar formalism to make predictions about the structure of natural language its generative capacity must be constrained.",
        "It is now generally accepted that Context-free Grammars (CFGs) lack the generative power needed for this purpose (Savitch et al., 1987), due to natural language constructions such as reduplication, multiple agreement and crossed agreement.",
        "Several linguistic formalisms have been proposed as capable of modeling these phenomena, including Linear Indexed Grammars (LIG) (Gazdar, 1988), Head Grammars (Pollard, 1984), Tree Adjoining Grammars (TAG) (Joshi, 2003) and Combinatory Categorial Grammars (Steedman, 2000).",
        "In a seminal work, Vijay-Shanker and Weir (1994) prove that all four formalisms are weakly equivalent.",
        "They all generate the class of mildly context-sensitive languages (MCSL), all members",
        "of which have recognition algorithms with time complexity O(n6) (Vijay-Shanker and Weir, 1993; Satta, 1994).1 As a result of the weak equivalence of four independently developed (and linguistically motivated) extensions of CFG, the class MCSL is considered to be linguistically meaningful, a natural class of languages for characterizing natural languages.",
        "Several authors tried to approximate unification grammars by means of context-free grammars (Rayner et al., 2001; Kiefer and Krieger, 2004) and even finite-state grammars (Pereira and Wright, 1997; Johnson, 1998), but we are not aware of any work which relates unification grammars with the class MCSL.",
        "The main objective of this work is to define constraints on UGs which naturally limit their generative capacity.",
        "We define two natural and easily testable syntactic constraints on UGs which ensure that grammars satisfying them generate the context-free and the mildly context-sensitive languages, respectively.",
        "The contribution of this result is twofold:",
        "• From a theoretical point of view, constraining unification grammars to generate exactly the class MCSL results in a grammatical formalism which is, on one hand, powerful enough for linguists to express linguistic generalizations in, and on the other hand cognitively adequate, in the sense that its generative capacity is constrained; • Practically, such a constraint can provide efficient recognition algorithms for the limited class of unification grammars.",
        "We define some preliminary notions in section 2 and then show a constrained version of UG which generates the class CFL of context-free languages in section 3.",
        "Section 4 presents the main result, namely a restricted version of UG and a mapping of its grammars to LIG, establishing the proposition that such grammars generate exactly the class MCSL.",
        "For lack of space, we favor intuitive explanation over rigorous proofs; the full details can be found in Feinstein (2004)."
      ]
    },
    {
      "heading": "2 Preliminary notions",
      "text": [
        "A CFG is a four-tuple GIf = (VN, V�, R�f , 5) where V� is a set of terminals, VN is a set of non",
        "terminals, including the start symbol 5, and Rif is a set of productions, assumed to be in a normal form where each rule has either (zero or more) non-terminals or a single terminal in its body, and where the start symbol never occurs in the right hand side of rules.",
        "The set of all such context-free grammars is denoted CFGS.",
        "In a linear indexed grammar (LIG),2 strings are derived from nonterminals with an associated stack denoted A[l1... ln], where A is a nonterminal, each li is a stack symbol, and l1 is the top of the stack.",
        "Since stacks can grow to be of unbounded size during a derivation, some way of partially specifying unbounded stacks in LIG productions is needed.",
        "We use A[l1... ln 00] to denote the nonterminal A associated with any stack �whose top n symbols are l1, l2 ..., ln.",
        "The set of all nonterminals in VN, associated with stacks whose symbols come from V3, is denoted VN [V3* ].",
        "Definition 1.",
        "A Linear Indexed Grammar is afive tuple Gli = (VN, V� , V3, Rli, 5) where V�, VN and 5 are as above, V3 is a finite set of indices (stack symbols) and Rli is a finite set of productions in one of the following two forms: • fixed stack: Ni [p1 .",
        ".",
        ".",
        "pn] – a • unbounded stack: Ni [p1 .",
        ".",
        ".",
        "pn 00] – a or Ni [p1 ... pn 00] – aNj [q1 ... qm 00] o",
        "where Ni, Nj E VN, p1 .",
        ".",
        ".",
        "pn, q1 .",
        ".",
        ".",
        "qm E V3, n, m > 0 and a, o E (V� U VN [V3* ]) *.",
        "A crucial characteristic of LIG is that only one copy of the stack can be copied to a single element in the body of a rule.",
        "If more than one copy were allowed, the expressive power would grow beyond MCSL.",
        "Definition 2.",
        "Given a LIG (VN, V� , V3, Rli, 5), the derivation relation ‘Ali’is defined as follows: for all 'F1,'F2 E (VN [V3*]UV�)*and�EV3*,",
        "• If Ni [p1 ... pn] 'F1Ni[p1 ... pn]'F2 Ali 'F1a'F2 • If Ni [p1 ... pn 00] – a E Rli then 'F1Ni[p1 .",
        ".",
        ".pn�]'F2 Ali 'F1a'F2 • If Ni [p1 ... pn 00] – aNj [q1 ... qm 00]o E Rli then 'F1Ni[p1 .",
        ".",
        ".",
        "pn�]'F2 Ali 'F1aNj [q1 ... qm�]o'F2",
        "The language generated by GLz is L(GLz) _ {w E Vt* I S[ ] *�Lz w}, where ‘*�Lz’ is the reflexive, transitive closure of ‘�Lz’.",
        "Unification grammars are defined over feature structures (FSs) which are directed, connected, rooted, labeled graphs, usually depicted as attribute-value matrices (AVM).",
        "A feature structure A can be characterized by its set of paths, HA, an assignment of atomic values to the ends of some paths, �A (•), and a reentrancy relation ‘*\"’ relating paths which lead to the same node.",
        "A sequence of feature structures, where some nodes may be shared by more than one element, is a multi-rooted structure (MRS).",
        "Informally, a rule is non-reentrant if (on an AVM view) no reentrancy tags occur in it.",
        "When the rule is viewed as a (multi-rooted) graph, it is non-reentrant if the in-degree of all nodes is at most 1.",
        "A rule is one-reentrant if (on an AVM view) at most one reentrancy tag occurs in it, exactly twice: once in the head of the rule and once in an element of its body.",
        "When the rule is viewed as a (multi-rooted) graph, it is one-reentrant if the in-degree of all nodes is at most 1, with the exception of one node whose in-degree can be 2, provided that the only two distinct paths that lead to this node leave from the roots of the head of the rule and an element of the body.",
        "FSs and MRSs are partially ordered by sub-sumption, denoted ‘C’.",
        "The least upper bound with respect to subsumption is unification, denoted ‘U’.",
        "Unification is partial; when A U B is undefined we say that the unification fails and denote it as AU B _ T. Unification is lifted to MRSs: given two MRSs Q and p, it is possible to unify the i-th element of Q with the j-th element of p. This operation, called unification in context and denoted (Q, i) U (p, j), yields two modified variants of Q and p: (Q', p').",
        "In unification grammars, forms are MRSs.",
        "A form QA _ (A1, ... , Ak) immediately derives another form QB _ (B1, ... , B,,t) (denoted by QA �u QB) iff there exists a rule ru E Ru of length n that licenses the derivation.",
        "The head of ru is matched against some element Az in QA using unification in context: (QA, i) U (ru, 0) _ (Q'A, r').",
        "If the unification does not fail, QB is obtained by replacing the i-th element of Q'A with the body of r'.",
        "The reflexive transitive closure of ‘1�u’ is denoted by ‘*�u’.",
        "1Gi<n."
      ]
    },
    {
      "heading": "3 Context-free unification grammars",
      "text": [
        "We define a constraint on unification grammars which ensures that grammars satisfying it generate the class CFL.",
        "The constraint disallows any reen-trancies in the rules of the grammar.",
        "When rules are non-reentrant, applying a rule implies that an exact copy of the body of the rule is inserted into the generated (sentential) form, not affecting neighboring elements of the form the rule is applied to.",
        "The only difference between rule application in UGnr and the analog operation in CFGS is that the former requires unification whereas the latter only calls for identity check.",
        "This small difference does not affect the generative power of the formalisms, since unification can be pre-compiled in this simple case.",
        "The trivial direction is to map a CFG to a non-reentrant unification grammar, since every CFG is, trivially, such a grammar (where terminal and non-terminal symbols are viewed as atomic feature structures).",
        "For the inverse direction, we define a mapping from UGnr to CFGS.",
        "The nonterminals of the CFG in the image of the mapping are the set of all feature structures defined in the source UG.",
        "Definition 6.",
        "Let ug2cfg : UGnr H CFGS be a mapping of UGnr to CFGS, such that",
        "• VN={Ai IA0 – *A1...AnERu,i�0}� {A I A E L(a), a E ATOMS} U {A3}.",
        "VN is the set of all the feature structures occurring in any of the rules or the lexicon of Gu.",
        "• 5cf = A3 • Vt = WORDS • Rcf consists of the following rules: 1.",
        "Let A0 – * A1 ... An E Ru and B E L(b).",
        "Iffor some i, 1 < i < n, Ai � B =� T, then Ai – * b E Rcf 2.",
        "If A0 – * A1 ... An E Ru and A3 t A0 =� T then 5cf – * A1 ... An E Rcf.",
        "then the rule Ai – * B1 ... Bm E Rcf The size of ug2cfg(Gu) is polynomial in the size of Gu.",
        "By inductions on the lengths of the derivation sequences, we prove the following theorem: Theorem 1.",
        "If Gu = (Ru, A3, L) is a non-reentrant unification grammar and Gcf = ug2cfg(Gu), then L(Gcf) = L(Gu).",
        "Corollary 2.",
        "Non-reentrant unification grammars are weakly equivalent to CFGS."
      ]
    },
    {
      "heading": "4 Mildly context-sensitive UG",
      "text": [
        "In this section we show that one-reentrant unification grammars generate exactly the class MCSL.",
        "In such grammars each rule can have at most one reentrancy, reflecting the LIG situation where stacks can be copied to exactly one daughter in each rule.",
        "4.1 Mapping LIG to UG1, In order to simulate a given LIG with a unification grammar, a dedicated signature is defined based on the parameters of the LIG.",
        "Definition 7.",
        "Given a LIG (VN, Vt, V3, RLi, 5), let T be (ATOMS, FEATS, WORDS), where ATOMS = VN U V3 U {elist}, FEATS = {HEAD, TAIL}, and WORDS = Vt. We use T throughout this section as the signature over which UGs are defined.",
        "We use FSs over the signature T to represent and simulate LIG symbols.",
        "In particular, FSs will encode lists in the natural way, hence the features HEAD and TAIL.",
        "For the sake of brevity, we use standard list notation when FSs encode lists.",
        "LIG symbols are mapped to FSs thus:",
        "1.",
        "If t E Vt then toFs(t) = (t)",
        "The mapping toFs is extended to sequences of symbols by setting toFs(ao) = toFs(�)toFs(o).",
        "Note that toFs is one to one.",
        "When FSs that are images of LIG symbols are concerned, unification is reduced to identity:",
        "When a feature structure which is represented as an unbounded list (a list that is not terminated by elist) is unifiable with an image of a LIG symbol, the former is a prefix of the latter.",
        "Lemma 4.",
        "Let C = (p1, ... , pn, i ) be a non-reentrant feature structure, where p1, ... , pn E V3, and letX E VN [V3* ] � Vt. Then C � toFs(X) =� Tiff toFs (X) = (p1, ... , pn, a), for some a E V3*.",
        "To simulate LIGs with UGs we represent each symbol in the LIG as a feature structure, encoding the stack of LIG non-terminals as lists.",
        "Rules that propagate stacks (from mother to daughter) are simulated by means of reentrancy in the UG.",
        "the signature T (definition 7), A3 = toFs (5[ ]), for all t E Vt, L(t) = {toFs(t)} and Ru is defined by: • A LIG rule of the form X0 – * a is mapped to the unification rule toFs(X0) – * toFs(a) • A LIG rule of the form Ni [p1, ... , pn oc] – * a Nj [q1, ... , qm oc] o is mapped to the unification rule (Ni, p1, .",
        ".",
        ".",
        ", pn, 1 toFs (�) (Nj, q1, ... , qm, 1 ) toFs(o)"
      ]
    },
    {
      "heading": "4.2 Mapping UG1, to LIG",
      "text": [
        "We are now interested in the reverse direction, namely mapping UGs to LIG.",
        "Of course, since UGs are more expressive than LIGs, only a subset of the former can be correctly simulated by the latter.",
        "The differences between the two formalisms can be summarized along three dimensions: The basic elements UG manipulates feature structures, and rules (and forms) are MRSs; whereas LIG manipulates terminals and non-terminals with stacks of elements, and rules (and forms) are sequences of such symbols.",
        "Rule application In UG a rule is applied by unification in context of the rule and a sentential form, both of which are MRSs, whereas in LIG, the head of a rule and the selected element of a sentential form must have the same non-terminal symbol and consistent stacks.",
        "Propagation of information in rules In UG information is shared through reentrancies, whereas In LIG, information is propagated by copying the stack from the head of the rule to one element of its body.",
        "We show that one-reentrant UGs can all be correctly mapped to LIG.",
        "For the rest of this section we fix a signature (ATOMS, FEATS, WORDS) over which UGs are defined.",
        "Let NRFSS be the set of all non-reentrant FSs over this signature.",
        "One-reentrant UGs induce highly constrained (sentential) forms: in such forms, there are no reentrancies whatsoever, neither between distinct elements nor within a single element.",
        "Hence all the FSs in forms induced by a one-reentrant UG are non-reentrant.",
        "Let Gu = (Ru, A3, L) E UG1, be a one-reentrant",
        "The following lemma indicates an important property of one-reentrant UGs.",
        "Informally, in any FS that is an element of a sentential form induced by such grammars, if two paths are long (specifically, longer than the maximum height of the grammar), they must have a long common prefix.",
        "Lemma 6.",
        "Let Gu = (Ru, A3, L) E UG1, be a one-reentrant unification grammar.",
        "Let A be an element of a sentential form induced by Gu.",
        "If 7r � (Fj)•7r1,7r•(Fk)•7r2 E HA, where Fj, Fk E FEATS, j =� k and I7r1I < I7r2 I, then I7r1I < maxHt(Gu).",
        "Lemma 6 facilitates a view of all the FSs induced by such a grammar as (unboundedly long) lists of elements drawn from a finite, predefined set.",
        "The set consists of all features in FEATS and all the non-reentrant feature structures whose height is limited by the maximal height of the unification grammar.",
        "Note that even with one-reentrant UGs, feature structures can be unbound-edly deep.",
        "What lemma 6 establishes is that if a feature structure induced by a one-reentrant unification grammar is deep, then it can be represented as a single “core” path which is long, and all the substructures which “hang” from this core are depth-bounded.",
        "We use this property to encode such feature structures as cords.",
        "for 1 < i < n + 1, Ai are non-reentrant FSs such that:",
        "• HAi = {(G) • 7r I (F1, .",
        ".",
        ".",
        ", Fi-1, G) • 7r E HA,i<n,G=�Fi}U{E} • �Ai (7r) = E)A((F1, ... , Fi-1) -7r) (if it is defined).",
        "We also define last(IF(A,7r)) = An+1.",
        "The height of a cord is defined as IIF(A,7r)I = maX1<i<n+1(IAiI).",
        "For each cord IF(A, 7r) we refer to A as the base feature structure and to 7r as the base path.",
        "The length of a cord is the length of the base path.",
        "The function IF is one to one: given IF(A, 7r), both A and 7r are uniquely determined.",
        "Lemma 7.",
        "Let Gu be a one-reentrant unification grammar and let A be an element of a sentential form induced by Gu.",
        "Then there is a path 7r E HA such that IIF(A, 7r)I < maxHt(Gu).",
        "Lemma 7 implies that every non-reentrant FS (i.e., FSs induced by one-reentrant grammars) can be represented as a height-limited cord.",
        "This mapping resolves the first difference between LIG and UG, by providing a representation of the basic elements.",
        "We use cords as the stack contents of LIG non-terminals: cords can be unboundedly long, but so can LIG stacks; the crucial point is that cords are height limited, implying that they can be represented using afinite number of elements.",
        "We now show how to simulate, in LIG, the unification in context of a rule and a sentential form.",
        "The first step is to have exactly one non-terminal symbol (in addition to the start symbol); when all non-terminal symbols are identical, only the content of the stack has to be taken into account.",
        "Recall that in order for a LIG rule to be applicable to a sentential form, the stack of the rule’s head must be a prefix of the stack of the selected element in the form.",
        "The only question is whether the two stacks are equal (fixed rule head) or not (unbounded rule head).",
        "Since the contents of stacks are cords, we need a property relating two cords, on one hand, with unifiability of their base feature structures, on the other.",
        "Lemma 8 establishes such a property.",
        "Informally, if the base path of one cord is a prefix of the base path of the other cord and all feature structures along the common path of both cords are unifiable, then the base feature structures of both cords are unifiable.",
        "The reverse direction also holds.",
        "Lemma 8.",
        "Let A, B E NRFSS be non-reentrant feature structures and 7r1, 7r2 E PATHS be paths such that 7r1 E HB, 7r1.7r2 E HA, T (A, 7r1.7r2) =",
        "The length of a cord of an element of a sentential form induced by the grammar cannot be bounded, but the length of any cord representation of a rule head is limited by the grammar height.",
        "By lemma 8, unifiability of two feature structures can be reduced to a comparison of two cords representing them and only the prefix of the longer cord (as long as the shorter cord) affects the result.",
        "Since the cord representation of any grammar rule’s head is limited by the height of the grammar we always choose it as the shorter cord in the comparison.",
        "We now define, for a feature structure C (which is a head of a rule) and some path 7r, the set that includes all feature structures that are both unifiable with C and can be represented as a cord whose height is limited by the grammar height and whose base path is 7r.",
        "We call this set the compatibility set of C and 7r and use it to define the set of all possible prefixes of cords whose base FSs are unifiable with C (see definition 13).",
        "Crucially, the compatibility set of C is finite for any feature structure C since the heights and the lengths of the cords are limited.",
        "Definition 12.",
        "Given a non-reentrant feature structure C, a path 7r = (F1, ... , Fn) E HC and a natural number h, the compatibility set,",
        "The compatibility set is defined for a feature structure and a given path (when h is taken to be the grammar height).",
        "We now define two similar sets, FH and UH, for a given FS, independently of a path.",
        "When rules of a one-reentrant unification grammar are mapped to LIG rules (definition 14), FH and UH are used to define heads of fixed and unbounded LIG rules, respectively.",
        "A single unification rule is mapped to a set of LIG rules, each with a different head.",
        "The stack of the head is some member of the sets FH and UH.",
        "Each such member is a prefix of the stack of potential elements of sentential forms that the LIG rule can be applied to.",
        "Definition 13.",
        "Let C be a non-reentrant feature structure and h be a natural number.",
        "Then: FH(C, h) = {xF(A, ir)I ir E 11c, A E r(C, ir, h)J UH(C, h) = {xF(A, ir) (F) I xF(A, ir) E FH(C, h),",
        "This accounts for the second difference between LIG and one-reentrant UG, namely rule application.",
        "We now briefly illustrate our account of the last difference, propagation of information in rules.",
        "In UG1, information is shared between the rule’s head and a single element in its body.",
        "Let r' = (C0, ... , C,,,) be a reentrant unification rule in which the path µe, leaving the e-th element of the body, is reentrant with the path µ0 leaving the head.",
        "This rule is mapped to a set of LIG rules, corresponding to the possible rule heads induced by the compatibility set of C0.",
        "Let r be a member of this set, and let X0 and Xe be the head and the e-th element of r, respectively.",
        "Reentrancy in r' is modeled in the LIG rule by copying the stack from X0 to Xe.",
        "The major complication is the contents",
        "of this stack, which varies according to the cord representations of C0 and Ce and to the reentrant paths.",
        "Summing up, in a LIG simulating a one-reentrant UG, FSs are represented as stacks of symbols.",
        "The set of stack symbols V3, therefore, is defined as a set of height bounded non-reentrant FSs.",
        "Also, all the features of the UG are stack symbols.",
        "V3 is finite due to the restriction on FSs (no reentrancies and height-boundedness).",
        "The set of terminals, Vt, is the words of the UG.",
        "There are exactly two non-terminal symbols, 5 (the start symbol) and N. The set of rules is divided to four.",
        "The start rule only applies once in a derivation, simulating the situation in UGs of a rule whose head is unifiable with the start symbol.",
        "Terminal rules are a straightforward implementation of the lexicon in terms of LIG.",
        "Non-reentrant rules are simulated in a similar way to how rules of a non-reentrant UG are simulated by CFG (section 3).",
        "The major difference is the head of the rule, X0, which is defined as explained above.",
        "One-reentrant rules are simulated similarly to non-reentrant ones, the only difference being the selected element of the rule body, Xe, which is defined as follows.",
        "Definition 14.",
        "Let ug2lig be a mapping of UG1r to LIGS, such that if Gu = (Ru, A3, L) E UG1r then ug2lig(Gu) = (VN, Vt, V3, RLz, 5), where VN = {N, 51 (fresh symbols), Vt = WORDS, V3 = FEATS U {A I A E NRFSS, IAI < maxHt(Gu)1, and RLz is defined as follows:3",
        "1.",
        "5[ ] – * N[IF(A3, E)] 2.",
        "For every w E WORDS such that L(w) = {C01 and for every 7r0 E Hco, the rule N[IF(C0, 7r0)] – * w is in RLz.",
        "3.",
        "If (C0, ... , Cn) E Ru is a non-reentrant rule, then for every X0 E LIGHEAD(C0) the rule X0 – * N [IF (C1, E)] ... N[IF(Cn, E)] is in RLz.",
        "4.",
        "Let ru = (C0, ... , Cn) E Ru and (0, µ0) ru (e, µe), where 1 < e < n. Then for every",
        "N[IF(Ce+1, E)] ... N [IF (Cn, E)]",
        "as {N[77] 1 77 E FH(C0,maxHt(Gu))I U {N[77 oo] 1 77 E UH(Co, maxHt(Gu))I is in RLz, where Xe is defined as follows.",
        "Let 7r0 be the base path of X0 and A be the base feature structure of X0.",
        "Applying the rule ru to A, define ((A), 0) t (ru, 0) = ((P0), (P0, ... , Pe, ... , Pn)).",
        "By inductions on the lengths of the derivations we prove that the mapping is correct: Theorem 9.",
        "If Gu E UG1r, then L(Gu) = L(ug2lig(Gu))."
      ]
    },
    {
      "heading": "5 Conclusions",
      "text": [
        "The main contribution of this work is the definition of two constraints on unification grammars which dramatically limit their expressivity.",
        "We prove that non-reentrant unification grammars generate exactly the class of context-free languages; and that one-reentrant unification grammars generate exactly the class of mildly context-sensitive languages.",
        "We thus obtain two linguistically plausible constrained formalisms whose computational processing is tractable.",
        "This main result is primarily a formal grammar result.",
        "However, we maintain that it can be easily adapted such that its consequences to (practical) computational linguistics are more evident.",
        "The motivation behind this observation is that reentrancy only adds to the expressivity of a grammar formalism when it is potentially unbounded, i.e., when infinitely many feature structures can be the possible values at the end of the reentrant paths.",
        "It is therefore possible to modestly extend the class of unification grammars which can be shown to generate exactly the class of mildly context-sensitive languages, by allowing also a limited form of multiple reentrancies among the elements in a rule (e.g., to handle agreement phenomena).",
        "This can be most useful for grammar writers, and at the same time adds nothing to the expressivity of the formalism.",
        "We leave the formal details of such an extension to future work.",
        "This work can also be extended in other directions.",
        "The mapping of one-reentrant UGs to LIG is highly verbose, resulting in LIGs with a huge",
        "number of rules.",
        "We believe that it should be possible to optimize the mapping such that much smaller grammars are generated.",
        "In particular, we are looking into mappings of one-reentrant UGs to other MCSL formalisms, notably TAG.",
        "The two constraints on unification grammars (non-reentrant and one-reentrant) are parallel to the first two classes of the Weir (1992) hierarchy of languages.",
        "A possible extension of this work could be a definition of constraints on unification grammars that would generate all the classes of the hierarchy.",
        "Another direction is an extension of one-reentrant unification grammars, where the reentrancy does not have to be between the head and one element of the body.",
        "Also of interest are two-reentrant unification grammars, possibly with limited kinds of reentrancies."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "This research was supported by The Israel Science Foundation (grant no.",
        "136/01).",
        "We are grateful to Yael Cohen-Sygal, Nissim Francez and James Rogers for their comments and help."
      ]
    }
  ]
}
