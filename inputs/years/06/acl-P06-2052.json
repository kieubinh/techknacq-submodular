{
  "info": {
    "authors": [
      "Hiroshi Ichikawa",
      "Keita Hakoda",
      "Taiichi Hashimoto",
      "Takenobu Tokunaga"
    ],
    "book": "International Conference on Computational Linguistics and Annual Meeting of the Association for Computational Linguistics – Poster Sessions",
    "id": "acl-P06-2052",
    "title": "Efficient Sentence Retrieval Based on Syntactic Structure",
    "url": "https://aclweb.org/anthology/P06-2052",
    "year": 2006
  },
  "references": [
    "acl-C00-1004",
    "acl-I05-4002"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper proposes an efficient method of sentence retrieval based on syntactic structure.",
        "Collins proposed Tree Kernel to calculate structural similarity.",
        "However, structual retrieval based on Tree Kernel is not practicable because the size of the index table by Tree Kernel becomes impractical.",
        "We propose more efficient algorithms approximating Tree Kernel: Tree Overlapping and Subpath Set.",
        "These algorithms are more efficient than Tree Kernel because indexing is possible with practical computation resources.",
        "The results of the experiments comparing these three algorithms showed that structural retrieval with Tree Overlapping and Subpath Set were faster than that with Tree Kernel by 100 times and 1,000 times respectively."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Retrieving similar sentences has attracted much attention in recent years, and several methods have been already proposed.",
        "They are useful for many applications such as information retrieval and machine translation.",
        "Most of the methods are based on frequencies of surface information such as words and parts of speech.",
        "These methods might work well concerning similarity of topics or contents of sentences.",
        "Although the surface information of two sentences is similar, their syntactic structures can be completely different (Figure 1).",
        "If a translation system regards these sentences as similar, the translation would fail.",
        "This is because conventional retrieval techniques exploit only similarity of surface information such as words and parts-of-speech, but not more abstract information such as syntactic structures.",
        "Collins et al.",
        "(Collins, 2001a; Collins, 2001b) proposed Tree Kernel, a method to calculate a similarity between syntactic structures.",
        "Tree Kernel defines the similarity between two syntactic structures as the number of shared subtrees.",
        "Retrieving similar sentences in a huge corpus requires calculating the similarity between a given query and each of sentences in the corpus.",
        "Building an index table in advance could improve retrieval efficiency, but indexing with Tree Kernel is impractical due to the size of its index table.",
        "In this paper, we propose two efficient algorithms to calculate similarity of syntactic structures: Tree Overlapping and Subpath Set.",
        "These algorithms are more efficient than Tree Kernel because it is possible to make an index table in reasonable size.",
        "The experiments comparing these three algorithms showed that Tree Overlapping is 100 times faster and Subpath Set is 1,000 times faster than Tree Kernel when being used for structural retrieval.",
        "After briefly reviewing Tree Kernel in section 2, in what follows, we describe two algorithms in section 3 and 4.",
        "Section 5 describes experiments to compare these three algorithms and discussion on the results.",
        "Finally, we conclude the paper and look at the future direction of our research in section 6."
      ]
    },
    {
      "heading": "2 Tree Kernel",
      "text": []
    },
    {
      "heading": "2.1 Definition of similarity",
      "text": [
        "Tree Kernel is proposed by Collins et al. (Collins, 2001a; Collins, 2001b) as a method to calculate similarity between tree structures.",
        "Tree Kernel defines similarity between two trees as the number of shared subtrees.",
        "Subtree S of tree T is defined as any tree subsumed by T, and consisting of more than one node, and all child nodes are included if any.",
        "Tree Kernel is not always suitable because the desired properties of similarity are different depending on applications.",
        "Takahashi et al. proposed three types of similarity based on Tree Kernel (Takahashi, 2002).",
        "We use one of the similarity measures (equation (1)) proposed by Takahashi et al.",
        "where C(n1, n2) is the number of shared subtrees by two trees rooted at nodes n1 and n2."
      ]
    },
    {
      "heading": "2.2 Algorithm to calculate similarity",
      "text": [
        "Collins et al. (Collins, 2001a; Collins, 2001b) proposed an efficient method to calculate Tree Kernel by using C(n1, n2) as follows.",
        "• If the productions at n1 and n2 are different C(n1, n2) = 0 • If the productions at n1 and n2 are the same, and n1 and n2 are pre-terminals, then C(n1, n2) = 1 • Else if the productions at n1 and n2 are the same and n1 and n2 are not pre-terminals,",
        "(2) where nc(n) is the number of children of node n and ch(n, i) is the i’th child node of n. Equation (2) recursively calculates C on its child node, and calculating Cs in postorder avoids recalculation.",
        "Thus, the time complexity of KC (T1, T2) is O(mn), where m and n are the numbers of nodes in T1 and T2 respectively."
      ]
    },
    {
      "heading": "2.3 Algorithm to retrieve sentences",
      "text": [
        "Neither Collins nor Takahashi discussed retrieval algorithms using Tree Kernel.",
        "We use the following simple algorithm.",
        "First we calculate the similarity KC(T1, T2) between a query tree and every tree in the corpus and rank them in descending order of KC.",
        "Tree Kernel exploits all subtrees shared by trees.",
        "Therefore, it requires considerable amount of time in retrieval because similarity calculation must be performed for every pair of trees.",
        "To improve retrieval time, an index table can be used in general.",
        "However, indexing by all subtrees is difficult because a tree often includes millions of subtrees.",
        "For example, one sentence in Titech Corpus (Noro et al., 2005) with 22 words and 87 nodes includes 8,213,574,246 subtrees.",
        "The number of subtrees in a tree with N nodes is bounded above by 2N."
      ]
    },
    {
      "heading": "3 Tree Overlapping",
      "text": []
    },
    {
      "heading": "3.1 Definition of similarity",
      "text": [
        "When putting an arbitrary node n1 of tree T1 on node n2 of tree T2, there might be the same production rule overlapping in T1 and T2.",
        "We define CTO(n1,n2) as the number of such overlapping production rules when n1 overlaps n2 (Figure 2).",
        "We will define CTO(n1,n2) more precisely.",
        "First we define L(n1, n2) of node n1 of T1 and node n2 of T2.",
        "L(n1, n2) represents a set of pairs of nodes which overlap each other when putting n1 on n2.",
        "For example in Figure 2, L(b11, b21) = {(bi,b21), (di,d21),(ei , e21), (gi,g21), (ii,j21)}.",
        "L(n1, n2) is defined as follows.",
        "Here ni and mi are nodes of tree Ti, ch(n, i) is the i’th child of node n.",
        "2.",
        "If (m1, m2) ∈ L(n1, n2), (ch(m1, i), ch(m2, i)) ∈ L(n1, n2) 3.",
        "If (ch(m1, i), ch(m2, i)) ∈ L(n1, n2), (m1, m2) ∈ L(n1, n2) 4.",
        "L(n1, n2) includes only pairs generated by applying 2. and 3. recursively.",
        "CTO(n1, n2) is defined by using L(n1, n2) as follows.",
        "��� � � where NT (T) is a set of nonterminal nodes in tree T, PR(n) is a production rule rooted at node n. Tree Overlapping similarity STO(T1,T2) is defined as follows by using CTO(n1, n2).",
        "CTO(n1, n2) This formula corresponds to equation (1) of Tree Kernel.",
        "As an example, we calculate STO (T1, T2) in Figure 2 (1).",
        "Putting b11on b2 1 gives Figure 2 (2) in which two production rules b → d e and e → g overlap respectively.",
        "Thus, CTO(b1 1, b21) becomes 2.",
        "While overlapping g11 and g21 gives Figure 2 (3) in which only one production rule g → i overlaps.",
        "Thus, CTO (g11 , g21) becomes 1.",
        "Since there are no other node pairs which gives larger CTO than 2, STO(T1,T2) becomes 2."
      ]
    },
    {
      "heading": "3.2 Algorithm",
      "text": [
        "Let us take an example in Figure 3 to explain the algorithm.",
        "Suppose that T0 is a query tree and the corpus has only two trees, T1 and T2.",
        "The method to find the most similar tree to a given query tree is basically the same as Tree Kernel’s (section 2.2).",
        "However, unlike Tree Kernel, Tree Overlapping-based retrieval can be accelerated by indexing the corpus in advance.",
        "Thus, given a tree corpus, we build an index table I [p] which maps a production rule p to its occurrences.",
        "Occurrences of production rules are represented by their left-hand side symbols, and are distinguished with respect to trees including the rule and",
        "the position in the tree.",
        "I [p] is defined as follows.",
        "where F is the corpus (here {T1, T2}) and the meaning of other symbols is the same as the definition of CTO (equation (3)).",
        "Table 1 shows an example of the index table generated from T1 and T2 in Figure 3 (1).",
        "In Table 1, a superscript of a nonterminal symbol identifies a tree, and a subscript identifies a position in the tree.",
        "By using the index table, we calculate C [n, m] with the following algorithm.",
        "where top(n, m) returns the uppermost pair of overlapped nodes when node n and m overlap.",
        "The value of top uniquely identifies a situation of overlapping two trees.",
        "Function top(n, m) is calculated by the following algorithm.",
        "where parent(n) is the parent node of n, and order(n) is the order of node n among its siblings.",
        "Table 2 shows example values of top(n, m) generated by overlapping T0 and T1 in Figure 3.",
        "Note that top maps every pair of corresponding nodes in a certain overlapping situation to a pair of the uppermost nodes of that situation.",
        "This enables us to use the value of top as an identifier of a situation of overlap."
      ]
    },
    {
      "heading": "3.3 Comparison with Tree Kernel",
      "text": [
        "The value of STO(T1,T2) roughly corresponds to the number of production rules included in the largest sub-tree shared by T1 and T2.",
        "Therefore, this value represents the size of the subtree shared",
        "by both trees, like Tree Kernel’s KC, though the definition of the subtree size is different.",
        "One difference is that Tree Overlapping considers shared subtrees even though they are split by a nonshared node as shown in Figure 4.",
        "In Figure 4, T1 and T2 share two subtrees rooted at b and c, but their parent nodes are not identical.",
        "While Tree Kernel does not consider the superposition putting node a on h, Tree Overlapping considers putting a on h and assigns count 2 to this superposition.",
        "Another, more important, difference is that Tree Overlapping retrieval can be accelerated by indexing the corpus in advance.",
        "The number of indexes is bounded above by the number of production rules, which is within a practical index size."
      ]
    },
    {
      "heading": "4 Subpath Set",
      "text": []
    },
    {
      "heading": "4.1 Definition of similarity",
      "text": [
        "Subpath Set similarity between two trees is defined as the number of subpaths shared by the trees.",
        "Given a tree, its subpaths is defined as a set of every path from the root node to leaves and their partial paths."
      ]
    },
    {
      "heading": "4.2 Algorithm",
      "text": [
        "Suppose T0 is a query tree, TS is a set of trees in the corpus and P(T) is a set of subpaths of T. We can build an index table I [p] for each production rule p as follows.",
        "Using the index table, we can calculate the number of shared subpaths by T0 and T, S[T], by the following algorithm: for all T S[T] := 0; foreach p in P(T0) do"
      ]
    },
    {
      "heading": "4.3 Comparison with Tree Kernel",
      "text": [
        "As well as Tree Overlapping, Subpath Set retrieval can be accelerated by indexing the corpus.",
        "The number of indexes is bounded above by L × D2 where L is the maximum number of leaves of trees (the number of words in a sentence) and D is the maximum depth of syntactic trees.",
        "Moreover, considering a subpath as an index term, we can use existing retrieval tools.",
        "Subpath Set uses less structural information than Tree Kernel and Tree Overlapping.",
        "It does not distinguish the order and number of child nodes.",
        "Therefore, the retrieval result tends to be noisy.",
        "However, Subpath Set is faster than Tree Overlapping, because the algorithm is simpler."
      ]
    },
    {
      "heading": "5 Experiments",
      "text": [
        "This section describes the experiments which were conducted to compare the performance of structure retrieval based on Tree Kernel, Tree Overlapping and Subpath Set."
      ]
    },
    {
      "heading": "5.1 Data",
      "text": [
        "We conducted two experiments using different annotated corpora.",
        "Titech corpus (Noro et al., 2005) consists of about 20,000 sentences of Japanese newspaper articles (Mainiti Shimbun).",
        "Each sentence has been syntactically annotated by hand.",
        "Due to the limitation of computational resources, we used randomly selected 2,483 sentences as a data collection.",
        "Iwanami dictionary (Nishio et al., 1994) is a Japanese dictionary.",
        "We extracted 57,982 sentences from glosses in the dictionary.",
        "Each sentences was analyzed with a morphological analyzer, ChaSen (Asahara et al., 1996) and the MSLR parser (Shirai et al., 2000) to obtain syntactic structure candidates.",
        "The most probable structure with respect to PGLR model (Inui et al., 1996) was selected from the output of the parser.",
        "Since they were not investigated manually, some sentences might have been assigned incorrect structures."
      ]
    },
    {
      "heading": "5.2 Method",
      "text": [
        "We conducted two experiments Experiment I and Experiment II with different corpora.",
        "The queries",
        "were extracted from these corpora.",
        "The algorithms described in the preceding sections were implemented with Ruby 1.8.2.",
        "Table 3 outlines the experiments."
      ]
    },
    {
      "heading": "5.3 Results and discussion",
      "text": [
        "Since we select a query from the target corpus, the query is always ranked in the first place in the retrieval result.",
        "In what follows, we exclude the query tree as an answer from the result.",
        "We evaluated the algorithms based on the following two factors: average retrieval time (CPU time) (Table 4) and the rank of the tree which was top-ranked in other algorithm (Table 5).",
        "For example, in Experiment I of Table 5, the column “≥5th” of the row “TO/TK” means that there were 73 % of the cases in which the top-ranked tree by Tree Kernel (TK) was ranked 5th or above by Tree Overlapping (TO).",
        "We consider Tree Kernel (TK) as the baseline method because it is a well-known existing similarity measure and exploits more information than others.",
        "Table 4 shows that in both corpora, the retrieval speed of Tree Overlapping (TO) is about",
        "100 times faster than that of Tree Kernel, and the retrieval speed of Subpath Set (SS) is about 1,000 times faster than that of Tree Kernel.",
        "This results show we have successfully accelerated the retrieval speed.",
        "The retrieval time of Tree Overlapping, 6.29 and 38.3 sec./per query, seems be a bit long.",
        "However, we can shorten this time if we tune the implementation by using a compiler-type language.",
        "Note that the current implementation uses Ruby, an interpreter-type language.",
        "Comparing Tree Overlapping and Subpath Set with respect to Tree Kernel (see rows “TK/TO” and “TK/SS”), the top-ranked trees by Tree Kernel are ranked in higher places by Tree Overlapping than by Subpath Set.",
        "This means Tree Overlapping is better than Subpath Set in approximating Tree Kernel.",
        "Although the corpus of Experiment II is 20 times larger than that of Experiment I, the figures of Experiment II is better than that of Experiment I in Table 5.",
        "This could be explained as follows.",
        "In Experiment II, we used sentences from glosses in the dictionary, which tend to be formulaic and short.",
        "Therefore we could find similar sentences easier than in Experiment I.",
        "To summarize the results, when being used in"
      ]
    }
  ]
}
