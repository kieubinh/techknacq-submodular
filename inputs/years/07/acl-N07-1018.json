{
  "info": {
    "authors": [
      "Mark Johnson",
      "Thomas L. Griffiths",
      "Sharon Goldwater"
    ],
    "book": "Human Language Technologies 2007: the Conference of the North American Chapter of the Association for Computational Linguistics; Proceedings of the Main Conference",
    "id": "acl-N07-1018",
    "title": "Bayesian Inference for PCFGs via Markov Chain Monte Carlo",
    "url": "https://aclweb.org/anthology/N07-1018",
    "year": 2007
  },
  "references": [
    "acl-P04-1061",
    "acl-P06-1072",
    "acl-W06-1673"
  ],
  "sections": [
    {
      "text": [
        "Bayesian Inference for PCFGs via Markov chain Monte Carlo",
        "Mark Johnson Thomas L. Griffiths Sharon Goldwater",
        "Cognitive and Linguistic Sciences Department of Psychology Department of Linguistics",
        "Brown University University of California, Berkeley Stanford University",
        "Mark_Johnson©brown.edu Tom_Griffithsoberkeley.edu sgwater©Stanford.edu",
        "This paper presents two Markov chain Monte Carlo (MCMC) algorithms for Bayesian inference of probabilistic context free grammars (PCFGs) from terminal strings, providing an alternative to maximum-likelihood estimation using the Inside-Outside algorithm.",
        "We illustrate these methods by estimating a sparse grammar describing the morphology of the Bantu language Sesotho, demonstrating that with suitable priors Bayesian techniques can infer linguistic structure in situations where maximum likelihood methods such as the Inside-Outside algorithm only produce a trivial grammar."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The standard methods for inferring the parameters of probabilistic models in computational linguistics are based on the principle of maximum-likelihood estimation; for example, the parameters of Probabilistic Context-Free Grammars (PCFGs) are typically estimated from strings of terminals using the Inside-Outside (IO) algorithm, an instance of the Expectation Maximization (EM) procedure (Lari and Young, 1990).",
        "However, much recent work in machine learning and statistics has turned away from maximum-likelihood in favor of Bayesian methods, and there is increasing interest in Bayesian methods in computational linguistics as well (Finkel et al., 2006).",
        "This paper presents two Markov chain Monte",
        "Carlo (MCMC) algorithms for inferring PCFGs and their parses from strings alone.",
        "These can be viewed as Bayesian alternatives to the IO algorithm.",
        "The goal of Bayesian inference is to compute a distribution over plausible parameter values.",
        "This \"posterior\" distribution is obtained by combining the likelihood with a \"prior\" distribution P(6) over parameter values 6.",
        "In the case of PCFG inference 6 is the vector of rule probabilities, and the prior might assert a preference for a sparse grammar (see below).",
        "The posterior probability of each value of 6 is given by Bayes' rule:",
        "In principle Equation 1 defines the posterior probability of any value of 6, but computing this may not be tractable analytically or numerically.",
        "For this reason a variety of methods have been developed to support approximate Bayesian inference.",
        "One ofthe most popular methods is Markov chain Monte Carlo (MCMC), in which a Markov chain is used to sample from the posterior distribution.",
        "This paper presents two new MCMC algorithms for inferring the posterior distribution over parses and rule probabilities given a corpus of strings.",
        "The first algorithm is a component-wise Gibbs sampler which is very similar in spirit to the EM algorithm, drawing parse trees conditioned on the current parameter values and then sampling the parameters conditioned on the current set of parse trees.",
        "The second algorithm is a component-wise Hastings sampler that \"collapses\" the probabilistic model, integrating over the rule probabilities of the PCFG, with the goal of speeding convergence.",
        "Both algorithms use an efficient dynamic programming technique to sample parse trees.",
        "Given their usefulness in other disciplines, we believe that Bayesian methods like these are likely to be of general utility in computational linguistics as well.",
        "As a simple illustrative example, we use these methods to infer morphological parses for verbs from Sesotho, a southern Bantu language with agglutinating morphology.",
        "Our results illustrate that Bayesian inference using a prior that favors sparsity can produce linguistically reasonable analyses in situations in which EM does not.",
        "The rest of this paper is structured as follows.",
        "The next section introduces the background for our paper, summarizing the key ideas behind PCFGs, Bayesian inference, and MCMC.",
        "Section 3 introduces our first MCMC algorithm, a Gibbs sampler for PCFGs.",
        "Section 4 describes an algorithm for sampling trees from the distribution over trees defined by a PCFG.",
        "Section 5 shows how to integrate out the rule weight parameters 6 in a PCFG, allowing us to sample directly from the posterior distribution over parses for a corpus of strings.",
        "Finally, Section 6 illustrates these methods in learning Sesotho morphology."
      ]
    },
    {
      "heading": "2. Background",
      "text": [
        "Let G = (T, N, S, R) be a Context-Free Grammar in Chomsky normal form with no useless productions, where T is a finite set of terminal symbols, N is a finite set of nonterminal symbols (disjoint from T), S G N is a distinguished nonterminal called the start symbol, and R is a finite set of productions of the form A – BC or A – w, where A,B,C G N and w G T .In what follows we use // as a variable ranging over (N x N) U T.",
        "A Probabilistic Context-Free Grammar (G, 6) is a pair consisting of a context-free grammar G and a real-valued vector 6 of length | R| indexed by productions, where 6a^/j is the production probability associated with the production A - / G R. We require that 6a^/?",
        "> 0 and that for all nonterminals A G N, Ea^gr 6a^/3 = 1.",
        "A PCFG (G, 6) defines a probability distribution over trees t as follows:",
        "where t is generated by G and fr(t) is the number of times the production r = A – // G R is used in the derivation of t. If G does not generate t let PG(t|6) = 0.",
        "The yield y(t) of a parse tree t is the sequence of terminals labeling its leaves.",
        "The probability of a string w G T + of terminals is the sum of the probability of all trees with yield w, i.e.:",
        "Pg(w|6) = ]T PG(t|6).",
        "Given a corpus of strings w = (wi,..., wn), where each wi is a string of terminals generated by a known CFG G, we would like to be able to infer the production probabilities 6 that best describe that corpus.",
        "Taking w to be our data, we can apply Bayes' rule (Equation 1) to obtain:",
        "Pg(w|6) = Y[Pc(wt |6).",
        "Using t to denote a sequence of parse trees for w, we can compute the joint posterior distribution over t and 6, and then marginalize over t, with P(6| w) = J2t P(t, 6|w).",
        "The joint posterior distribution on t and 6 is given by:",
        "with P(wj |tj) = 1 if y(tj) = wi, and 0 otherwise.",
        "The first step towards computing the posterior distribution is to define a prior on 6.",
        "We take P(6) to be a product of Dirichlet distributions, with one distribution for each non-terminal A G N. The prior is parameterized by a positive real valued vector a indexed by productions R, so each production probability 6a^/j has a corresponding Dirichlet parameter aA^p.",
        "Let Ra be the set of productions in R with left-hand side A, and let 9 a and a a refer to the component subvectors of 9 and a respectively indexed by productions in Ra.",
        "The Dirichlet prior",
        "Yl Pd(9a|aa), where",
        "where r is the generalized factorial function and C(a) is a normalization constant that does not depend on 6A.",
        "Dirichlet priors are useful because they are conjugate to the distribution over trees defined by a PCFG.",
        "This means that the posterior distribution on 6 given a set of parse trees, P(6| t, a), is also a Dirichlet distribution.",
        "Applying Bayes' rule, which is a Dirichlet distribution with parameters f (t) + a, where f (t) is the vector of production counts in t indexed by r G R. We can thus write:",
        "which makes it clear that the production counts combine directly with the parameters of the prior.",
        "Having defined a prior on 6, the posterior distribution over t and 6 is fully determined by a corpus w. Unfortunately, computing the posterior probability of even a single choice of t and 6 is intractable, as evaluating the normalizing constant for this distribution requires summing over all possible parses for the entire corpus and all sets ofproduction probabilities.",
        "Nonetheless, it is possible to define algorithms that sample from this distribution using Markov chain Monte Carlo (MCMC).",
        "MCMC algorithms construct a Markov chain whose states s G S are the objects we wish to sample.",
        "The state space S is typically astronomically large – in our case, the state space includes all possible parses of the entire training corpus w – and the transition probabilities P(s'|s) are specified via a scheme guaranteed to converge to the desired distribution n(s) (in our case, the posterior distribution).",
        "We \"run\" the Markov chain (i.e., starting in initial state s0, sample a state s1 from P(s'|s0), then sample state s2 from P(s'|s1), and so on), with the probability that the Markov chain is in a particular state, P(si), converging to n(si) as i – oo.",
        "After the chain has run long enough for it to approach its stationary distribution, the expectation En[f] of any function f(s) of the state s will be approximated by the average of that function over the set of sample states produced by the algorithm.",
        "For example, in our case, given samples (ti, 6i) for i = 1,..., I produced by an MCMC algorithm, we can estimate 6 as",
        "The remainder of this paper presents two MCMC algorithms for PCFGs.",
        "Both algorithms proceed by setting the initial state of the Markov chain to a guess for (t, 6) and then sampling successive states using a particular transition matrix.",
        "The key difference betwen the two algorithms is the form of the transition matrix they assume.",
        "The Gibbs sampler (Geman and Geman, 1984) is one of the simplest MCMC methods, in which transitions between states of the Markov chain result from sampling each component of the state conditioned on the current value of all other variables.",
        "In our case, this means alternating between sampling from two distributions:",
        "Pd (9|f (t)+ a) IJ Pd(9a|fA(t) + aA).",
        "Thus every two steps we generate a new sample of t and 6.",
        "This alternation between parsing and updating 6 is reminiscent of the EM algorithm, with the Expectation step replaced by sampling t and the Maximization step replaced by sampling 6.",
        "The dependencies among variables in a PCFG are depicted graphically in Figure 1, which makes clear that the Gibbs sampler is highly parallelizable (just like the EM algorithm)• Specifically, the parses tiare independent given 6 and so can be sampled in parallel from the following distribution as described in the next section",
        "We make use of the fact that the posterior is a product of independent Dirichlet distributions in order to sample 6 from PD(6|t,a)• The production probabilities 6a for each nonterminal A e N are sampled from a Dirchlet distibution with parameters «A = /a(t) + OA- There are several methods for sampling 6 = (6i,..., 6m) from a Dirichlet distribution with parameters o = (o1 ,..., om), with the simplest being sampling Xj from a Gamma(oj) distribution for j = 1,..., m and then setting 6j = Xj/ Em=i xfc (Gentle, 2003)."
      ]
    },
    {
      "heading": "4. Efficiently sampling from P(t|w, 9)",
      "text": [
        "This section completes the description of the Gibbs sampler for (t, 6) by describing a dynamic programming algorithm for sampling trees from the set of parses for a string generated by a PCFG^ This algorithm appears fairly widely known: it was described by Goodman (1998) and Finkel et al. (2006) and used by Ding et al. (2005), and is very similar to other dynamic programming algorithms for CFGs, so we only summarize it here^ The algorithm consists of two steps^ The first step constructs a standard \"inside\" table or chart, as used in the Inside-Outside algorithm for PCFGs (Lari and Young, 1990) The second step involves a recursion from larger to smaller strings, sampling from the productions that expand each string and constructing the corresponding tree in a top-down fashion",
        "In this section we take w to be a string of terminal symbols w = (w1,..., wn) where each wi e T, and define wj;k = (wj+1 ,...,wk) (Le^ the substring from wj+1 up to wk)• Further, let Ga = (T, N, A, R), Le^, a CFG just like G except that the start symbol has been replaced with A, so, PGa (t16) is the probability of a tree t whose root node is labeled A and PGa (w|6) is the sum of the probabilities of all trees whose root nodes are labeled A with yield w.",
        "The Inside algorithm takes as input a PCFG (G, 6) and a string w = wo,n and constructs a table with entries PA,i,k for each A e N and 0 < i < k < n, where pA,i,k = Pga (wifk|6), Le^, the probability of A rewriting to wi k • The table entries are recursively defined below, and computed by enumerating all feasible i, k and A in any order such that all smaller values of k – i are enumerated before any larger values.",
        "The second step of the sampling algorithm uses the function Sa mple, which returns a sample from Pg(t|w,6) given the PCFG (G,6) and the inside table pa,i,k• Sample takes as arguments a nonterminal A e N and a pair of string positions 0 < i < k < n and returns a tree drawn from PGa (t|wi k, 6) It functions in a top-down fashion, selecting the production A – BC to expand the A, and then recursively calling itself to expand B and C respectively function Sample (A, i, k) :",
        "if k – i = 1 then return Tree(A, wk)",
        "In this pseudo-code, Tree is a function that constructs unary or binary tree nodes respectively, and",
        "Multi is a function that produces samples from a multinomial distribution over the possible \"split\" positions j and nonterminal children B and C, where:"
      ]
    },
    {
      "heading": "5. A Hastings sampler for P (t|w ,a)",
      "text": [
        "The Gibbs sampler described in Section 3 has the disadvantage that each sample of 6 requires reparsing the training corpus w. In this section, we describe a component-wise Hastings algorithm for sampling directly from P(t|w, a), marginalizing over the production probabilities 6.",
        "Transitions between states are produced by sampling parses U from P(ti|wi, t_j,a) for each string wi in turn, where t_j = (ti,..., ti_i,ti+i,..., tn) is the current set of parses for w_j = (wi,..., Wj_i, Wj+i,..., Wn ).",
        "Marginalizing over 6 effectively means that the production probabilities are updated after each sentence is parsed, so it is reasonable to expect that this algorithm will converge faster than the Gibbs sampler described earlier.",
        "While the sampler does not explicitly provide samples of 6, the results outlined in Sections 2.3 and 3 can be used to sample the posterior distribution over 6 for each sample of t if required.",
        "Let PD (6|a) be a Dirichlet product prior, and let A be the probability simplex for 6.",
        "Then by integrating over the posterior Dirichlet distributions we have:",
        "where C was defined in Equation 2.",
        "Because we are marginalizing over 0, the trees U become dependent upon one another.",
        "Intuitively, this is because wi may provide information about 0 that influences how some other string Wj should be parsed.",
        "We can use Equation 3 to compute the conditional probability P(ti|t_i, a) as follows:",
        "AGN C(aA + fA(t_i)) Now, if we could sample from",
        "we could construct a Gibbs sampler whose states were the parse trees t. Unfortunately, we don't even know if there is an efficient algorithm for calculating P(wi|t_i, a), let alone an efficient sampling algorithm for this distribution.",
        "Fortunately, this difficulty is not fatal.",
        "A Hastings sampler for a probability distribution n(s) is an MCMC algorithm that makes use of a proposal distribution Q(s'|s) from which it draws samples, and uses an acceptance/rejection scheme to define a transition kernel with the desired distribution n(s).",
        "Specifically, given the current state s, a sample s' = s drawn from Q(s'|s) is accepted as the next state with probability and with probability 1 – A(s, s') the proposal is rejected and the next state is the current state s.",
        "We use a component-wise proposal distribution, generating new proposed values for ij, where i is chosen at random.",
        "Our proposal distribution is the posterior distribution over parse trees generated by the PCFG with grammar G and production probabilities 0', where 6' is chosen based on the current t_j as described below.",
        "Each step of our Hastings sampler is as follows.",
        "First, we compute 6' from t_j as described below.",
        "Then we sample ij from P(ij|wj ,6') using the algorithm described in Section 4.",
        "Finally, we accept the proposal ij given the old parse ij for wj with probability:",
        "The key advantage of the Hastings sampler over the Gibbs sampler here is that because the acceptance probability is a ratio of probabilities, the dificult to compute P(wi|t_i,a) is a common factor of both the numerator and denominator, and hence is not required.",
        "The P(wi term also disappears, being 1 for both the numerator and the denominator since our proposal distribution can only generate trees for which wi is the yield.",
        "All that remains is to specify the production probabilities 0' of the proposal distribution P(ti |wi;0').",
        "While the acceptance rule used in the Hastings algorithm ensures that it produces samples from P(ti|wi, t_i;a) with any proposal grammar 0' in which all productions have nonzero probability, the algorithm is more efficient (i.e., fewer proposals are rejected) if the proposal distribution is close to the distribution to be sampled.",
        "Given the observations above about the correspondence between terms in P(ti|t_i,a) and the relative frequency of the corresponding productions in t_i, we set 0' to the expected value E[0|t_i, a] of 0 given t_i and a as follows:"
      ]
    },
    {
      "heading": "6. Inferring sparse grammars",
      "text": [
        "As stated in the introduction, the primary contribution of this paper is introducing MCMC methods for Bayesian inference to computational linguistics.",
        "Bayesian inference using MCMC is a technique of generic utility, much like Expectation-Maximization and other general inference techniques, and we believe that it belongs in every computational linguist's toolbox alongside these other techniques.",
        "Inferring a PCFG to describe the syntactic structure of a natural language is an obvious application of grammar inference techniques, and it is well-known that PCFG inference using maximum-likelihood techniques such as the Inside-Outside (IO) algorithm, a dynamic programming Expectation-Maximization (EM) algorithm for PCFGs, performs extremely poorly on such tasks.",
        "We have applied the Bayesian MCMC methods described here to such problems and obtain results very similar to those produced using IO.",
        "We believe that the primary reason why both IO and the Bayesian methods perform so poorly on this task is that simple PCFGs are not accurate models of English syntactic structure.",
        "We know that PCFGs",
        "Figure 2: A Dirichlet prior a on a binomial parameter 0i.",
        "As ai – 0, P(0i|a) is increasingly concentrated around 0.",
        "that represent only major phrasal categories ignore a wide variety of lexical and syntactic dependencies in natural language.",
        "State-of-the-art systems for unsupervised syntactic structure induction system uses models that are very different to these kinds of PCFGs (Klein and Manning, 2004; Smith and Eisner, 2006).",
        "Our goal in this section is modest: we aim merely to provide an illustrative example of Bayesian inference using MCMC.",
        "As Figure 2 shows, when the Dirichlet prior parameter ar approaches 0 the prior probability PD (0r |a) becomes increasingly concentrated around 0.",
        "This ability to bias the sampler toward sparse grammars (i.e., grammars in which many productions have probabilities close to 0) is useful when we attempt to identify relevant productions from a much larger set ofpossible productions via parameter estimation.",
        "The Bantu language Sesotho is a richly agglutinative language, in which verbs consist of a sequence of morphemes, including optional Subject Markers (sm), Tense (t), Object Markers (om), Mood (m) and derivational afixes as well as the obligatory Verb stem (v), as shown in the following example:",
        "\"We see them\"",
        "We used an implementation of the Hastings sampler described in Section 5 to infer morphological parses t for a corpus w of 2,283 unsegmented Sesotho verb types extracted from the Sesotho corpus available from Childes (MacWhinney and Snow, 1985; Demuth, 1992).",
        "We chose this corpus because the words have been morphologically segmented manually, making it possible for us to evaluate the morphological parses produced by our system.",
        "We constructed a CFG G containing the following productions",
        "Word – V Word – VM Word – SMVM Word – SMTVM Word – SMTOMVM",
        "together with productions expanding the pretermi-",
        "Note that G actually generates a finite language.",
        "However, G parameterizes the probability distribution over the strings it generates in a manner that would be dificult to succintly characterize except in terms of the productions given above.",
        "Moreover, with approximately 20 times more productions than training strings, each string is highly ambiguous and estimation is highly underconstrained, so it provides an excellent test-bed for sparse priors.",
        "We estimated the morphological parses t in two ways.",
        "First, we ran the IO algorithm initialized with a uniform initial estimate 0o for 0 to produce an estimate of the MLE 0, and then computed the Viterbi parses t of the training corpus w with respect to the PCFG (G, 0).",
        "Second, we ran the Hastings sampler initialized with trees sampled from (G, 0o) with several different values for the parameters of the prior.",
        "We experimented with a number of techniques for speeding convergence of both the IO and Hastings algorithms, and two of these were particularly effective on this problem.",
        "Annealing, i.e., using P(t|w)1/T in place of P(t|w) where t is a \"temperature\" parameter starting around 5 and slowly adjusted toward 1, sped the convergence of both algorithms.",
        "We ran both algorithms for several thousand iterations over the corpus, and both seemed to converge fairly quickly once t was set to 1.",
        "\"Jittering\" the initial estimate of 0 used in the IO algorithm also sped its convergence.",
        "The IO algorithm converges to a solution where 0Word – V = 1, and every string w £ w is analysed as a single morpheme V. (In fact, in this grammar P(wi|0) is the empirical probability of wi, and it is easy to prove that this 0 is the MLE).",
        "The samples t produced by the Hastings algorithm depend on the parameters of the Dirichlet prior.",
        "We set ar to a single value a for all productions r. We found that for a > 10_ the samples produced by the Hastings algorithm were the same trivial analyses as those produced by the IO algorithm, but as a was reduced below this t began to exhibit nontrivial structure.",
        "We evaluated the quality of the segmentations in the morphological analyses t in terms of unlabeled precision, recall, f-score and exact match (the fraction of words correctly segmented into morphemes; we ignored morpheme labels because the manual morphological analyses contain many morpheme labels that we did not include in G).",
        "Figure 3 contains a plot of how these quantities vary with a; obtaining an f-score of 0.75 and an exact word match accuracy of 0.54 at a = 10_ (the corresponding values for the MLE 0 are both 0).",
        "Note that we obtained good results as a was varied over several orders of magnitude, so the actual value of a is not critical.",
        "Thus in this application the ability to prefer sparse grammars enables us to ind linguistically meaningful analyses.",
        "This ability to ind linguistically meaningful structure is relatively rare in our experience with unsupervised PCFG induction.",
        "We also experimented with a version of IO modi-ied to perform Bayesian MAP estimation, where the Maximization step of the IO procedure is replaced with Bayesian inference using a Dirichlet prior, i.e., where the rule probabilities 0(k) at iteration k are estimated using:",
        "0(fc) oc max(0, E[/r |w,0(k_1)] + a - 1).",
        "Clearly such an approach is very closely related to the Bayesian procedures presented in this article, nals SM, T, OM, V and M to each ofthe 16,350 distinct substrings occuring anywhere in the corpus, producting a grammar with 81,755 productions in all.",
        "In effect, G encodes the basic morphological structure of the Sesotho verb (ignoring factors such as derivation morphology and irregular forms), but provides no information about the phonological identity of the morphemes.",
        "F-score Precision Recall ■ xact",
        "Figure 3: Accuracy of morphological segmentations of Sesotho verbs proposed by the Hastings algorithms as a function of Dirichlet prior parameter a. F-score, precision and recall are unlabeled morpheme scores, while Exact is the fraction of words correctly segmented.",
        "and in some circumstances this may be a useful estimator.",
        "However, in our experiments with the Sesotho data above we found that for the small values of a necessary to obtain a sparse solution,the expected rule count E [/r] for many rules r was less than 1 – a.",
        "Thus on the next iteration 0r = 0, resulting in there being no parse whatsoever for many of the strings in the training data.",
        "Variational Bayesian techniques offer a systematic way of dealing with these problems, but we leave this for further work."
      ]
    },
    {
      "heading": "7. Conclusion",
      "text": [
        "This paper has described basic algorithms for performing Bayesian inference over PCFGs given terminal strings.",
        "We presented two Markov chain Monte Carlo algorithms (a Gibbs and a Hastings sampling algorithm) for sampling from the posterior distribution over parse trees given a corpus of their yields and a Dirichlet product prior over the production probabilities.",
        "As a component of these algorithms we described an efficient dynamic programming algorithm for sampling trees from a PCFG which is useful in its own right.",
        "We used these sampling algorithms to infer morphological analyses of Sesotho verbs given their strings (a task on which the standard Maximum Likelihood estimator returns a trivial and linguistically uninteresting solution), achieving 0.75 unlabeled morpheme f-score and 0.54 exact word match accuracy.",
        "Thus this is one of the few cases we are aware of in which a PCFG estimation procedure returns linguistically meaningful structure.",
        "We attribute this to the ability of the Bayesian prior to prefer sparse grammars.",
        "We expect that these algorithms will be of interest to the computational linguistics community both because a Bayesian approach to PCFG estimation is more flexible than the Maximum Likelihood methods that currently dominate the field (c.f., the use of a prior as a bias towards sparse solutions), and because these techniques provide essential building blocks for more complex models."
      ]
    }
  ]
}
