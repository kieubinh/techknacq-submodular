{
  "info": {
    "authors": [
      "Daniel Gildea",
      "Daniel Stefankovic"
    ],
    "book": "Human Language Technologies 2007: the Conference of the North American Chapter of the Association for Computational Linguistics; Proceedings of the Main Conference",
    "id": "acl-N07-1019",
    "title": "Worst-Case Synchronous Grammar Rules",
    "url": "https://aclweb.org/anthology/N07-1019",
    "year": 2007
  },
  "references": [
    "acl-H05-1101"
  ],
  "sections": [
    {
      "text": [
        "Daniel Gildea and Daniel Stefankovic",
        "Computer Science Dept.",
        "We relate the problem of finding the best application of a Synchronous Context-Free Grammar (SCFG) rule during parsing to a Markov Random Field.",
        "This representation allows us to use the theory of expander graphs to show that the complexity of SCFG parsing of an input sentence of length N is Q(Ncn), for a grammar with maximum rule length n and some constant c. This improves on the previous best result of Q(N<Vn)."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Recent interest in syntax-based methods for statistical machine translation has lead to work in parsing algorithms for synchronous context-free grammars (SCFGs).",
        "Generally, parsing complexity depends on the length of the longest rule in the grammar, but the exact nature of this relationship has only recently begun to be explored.",
        "It has been known since the early days of automata theory (Aho and Ullman, 1972) that the languages of string pairs generated by a synchronous grammar can be arranged in an infinite hierarchy, with each rule size > 4 producing languages not possible with grammars restricted to smaller rules.",
        "For any grammar with maximum rule size n, a fairly straightforward dynamic programming strategy yields an O(Nn+) algorithm for parsing sentences of length N. However, this is often not the best achievable complexity, and the exact bounds of the best possible algorithms are not known.",
        "Satta and Peserico (2005) showed that a permutation can be defined for any length n such that tabular parsing strategies must take at least Q(N<Vn), that is, the exponent of the algorithm is proportional to the square root of the rule length.",
        "In this paper, we improve this result, showing that in the worst case the exponent grows linearly with the rule length.",
        "Using a probabilistic argument, we show that the number of easily parsable permutations grows slowly enough that most permutations must be difficult, where by difficult we mean that the exponent in the complexity is greater than a constant factor times the rule length.",
        "Thus, not only do there exist permutations that have complexity higher than the square root case of Satta and Peserico (2005), but in fact the probability that a randomly chosen permutation will have higher complexity approaches one as the rule length grows.",
        "Our approach is to first relate the problem of finding an efficient parsing algorithm to finding the treewidth of a graph derived from the SCFG rule's permutation.",
        "We then show that this class of graphs are expander graphs, which in turn means that the treewidth grows linearly with the graph size."
      ]
    },
    {
      "heading": "2. Synchronous Parsing Strategies",
      "text": [
        "We write SCFG rules as productions with one lefthand side nonterminal and two righthand side strings.",
        "Nonterminals in the two strings are linked with superscript indices; symbols with the same index must be further rewritten synchronously.",
        "For example, is a rule with four children and no reordering, while Algorithm 1 BottomUpParser(grammar G, input strings e, f)",
        "end for end for end for expresses a more complex reordering.",
        "In general, we can take indices in the first grammar dimension to be consecutive, and associate a permutation n with the second dimension.",
        "If we use Xj for 0 < i < n as a set of variables over nonterminal symbols (for example, Xi and X2 may both stand for nonterminal A), we can write rules in the general form:",
        "Grammar rules also contain terminal symbols, but as their position does not affect parsing complexity, we focus on nonterminals and their associated permutation n in the remainder of the paper.",
        "In a probabilistic grammar, each rule R has an associated probability P (R).",
        "The synchronous parsing problem consists of finding the tree covering both strings having the maximum product of rule probabilities.",
        "We assume synchronous parsing is done by storing a dynamic programming table of recognized nonterminals, as outlined in Algorithm 1.",
        "We refer to a dynamic programming item for a given nonterminal with specified boundaries in each language as a cell.",
        "The algorithm computes cells by maximizing over boundary variables Xj and yj, which range over positions in the two input strings, and specify beginning and end points for the SCFG rule's child nonterminals.",
        "The maximization in the inner loop of Algorithm 1 is the most expensive part of the procedure, as it would take O(Nn-) with exhaustive search; making this step more efficient is our focus in this paper.",
        "The maximization can be done with further dynamic programming, storing partial results which contain some subset of an SCFG rule's righthand side nonterminals that have been recognized.",
        "A parsing strategy for a specific SCFG rule consists of an order in which these subsets should be combined, until all the rule's children have been recognized.",
        "The complexity of an individual parsing step depends on the number of free boundary variables, each of which can take O(N) values.",
        "It is often helpful to visualize parsing strategies on the permutation matrix corresponding to a rule's permutation n. Figure 1 shows the permutation matrix of rule (2) with a three-step parsing strategy.",
        "Each panel shows one combination step along with the projections of the partial results in each dimension; the endpoints of these projections correspond to free boundary variables.",
        "The second step has the highest number of distinct endpoints, five in the vertical dimension and three horizontally, meaning parsing can be done in time O(N).",
        "As an example of the impact that the choice of parsing strategy can make, Figure 2 shows a permutation for which a clever ordering of partial results enables parsing in time O(Ni0) in the length of the input strings.",
        "Permutations having this pattern of diagonal stripes can be parsed using this strategy in time O(Ni0) regardless of the length n of the SCFG rule, whereas a naive strategy proceeding from left to right in either input string would take time O(Nn+).",
        "In this section, we connect the maximization of probabilities for a cell to the Markov Random Field",
        "y4 y3 y2 yi yo Xo Xi X2 X3 X4",
        "Figure 1: The tree on the left defines a three-step parsing strategy for rule (2).",
        "In each step, the two subsets of nonterminals in the inner marked spans are combined into a new chart item with the outer spans.",
        "The intersection of the outer spans, shaded, has now been processed.",
        "Tic marks indicate distinct endpoints of the spans being combined, corresponding to the free boundary variables.",
        "(MRF) representation, which will later allow us to use algorithms and complexity results based on the graphical structure of MRFs.",
        "A Markov Random Field is defined as a probability distribution over a set of variables x that can be written as a product of factors fj that are functions of various subsets xj of x.",
        "The probability of an SCFG rule instance computed by Algorithm 1 can be written in this functional form:",
        "and the MRF has one factor /j for each child nonterminal Xj in the grammar rule R. The factor's value is the probability ofthe child nonterminal, which can be expressed as a function ofits four boundaries:",
        "For reasons that are explained in the following section, we augment our Markov Random Fields with a dummy factor for the completed parent nonterminal's chart item.",
        "Thus there is one dummy factor d for each grammar rule:",
        "expressed as a function of the four outer boundary variables of the completed rule, but with a constant",
        "Figure 2: A parsing strategy maintaining two spans in each dimension is O(Ni0) for any length permutation of this general form.",
        "value of 1 so as not to change the probabilities computed.",
        "Thus an SCFG rule with n child nonterminals always results in a Markov Random Field with 2n + 2 variables and n + 1 factors, with each factor a function of exactly four variables.",
        "Markov Random Fields are often represented as graphs.",
        "A factor graph representation has a node for each variable and factor, with an edge connecting each factor to the variables it depends on.",
        "An example for rule (2) is shown in Figure 3, with round nodes for variables, square nodes for factors, and a diamond for the special dummy factor.",
        "Efficient computation on Markov Random Fields is performed by first transforming the MRF into a junction tree (Jensen et al., 1990; Shafer and Shenoy, 1990), and then applying the standard message-passing algorithm for graphical models over this tree structure.",
        "The complexity of the message passing algorithm depends on the structure of the junction tree, which in turn depends on the graph structure of the original MRF.",
        "ii.y3",
        "B D",
        "yi yo",
        "A junction tree can be constructed from a Markov Random Field by the following three steps:",
        "• Connect all variable nodes that share a factor, and remove factor nodes.",
        "This results in the graphs shown in Figure 4.",
        "• Choose a triangulation of the resulting graph, by adding chords to any cycle of length greater than three.",
        "• Decompose the triangulated graph into a tree of cliques.",
        "We call nodes in the resulting tree, corresponding to cliques in the triangulated graph, clusters.",
        "Each cluster has a potential function, which is a function of the variables in the cluster.",
        "For each factor in the original MRF, the junction tree will have at least one cluster containing all of the variables on which the factor is defined.",
        "Each factor is associated with one such cluster, and the cluster's potential function is set to be the product of its factors, for all combinations of variable values.",
        "Triangulation ensures that the resulting tree satisfies the junction tree property, which states that for any two clusters containing the same variable x, all nodes on the path connecting the clusters also contain x.",
        "A junction tree derived from the MRF of Figure 3 is shown in Figure 5.",
        "The message-passing algorithm for graphical models can be applied to the junction tree.",
        "The algo-",
        "Figure 4: The graphs resulting from connecting all interacting variables for the identity permutation (1, 2, 3, 4) (top) and the (2, 4,1, 3) permutation of rule (2) (bottom).",
        "rithm works from the leaves ofthe tree inward, alternately multiplying in potential functions and maximizing over variables that are no longer needed, effectively distributing the max and product operators so as to minimize the interaction between variables.",
        "The complexity of the message-passing is O(nNk), where the junction tree contain O(n) clusters, k is the maximum cluster size, and each variable in the cluster can take N values.",
        "However, the standard algorithm assumes that the factor functions are predefined as part of the input.",
        "In our case, however, the factor functions themselves depend on message-passing calculations from other grammar rules:",
        "We must modify the standard algorithm in order to interleave computation among the junction trees corresponding to the various rules in the grammar, using the bottom-up ordering of computation from Algorithm 1.",
        "Where, in the standard algorithm, each message contains a complete table for all assignments to its variables, we break these into a separate message for each individual assignment ofvari-ables.",
        "The overall complexity is unchanged, because each assignment to all variables in each cluster is still considered only once.",
        "The dummy factor d ensures that every junction tree we derive from an SCFG rule has a cluster containing all four outer boundary variables, allowing efficient lookup of the inner maximization in (3).",
        "Because the outer boundary variables need not appear throughout the junction tree, this technique allows reuse of some partial results across different outer boundaries.",
        "As an example, consider message passing on the junction tree of shown in Figure 5, which corresponds to the parsing strategy of Figure 1.",
        "Only the final step involves all four boundaries of the complete cell, but the most complex step is the second, with a total of eight boundaries.",
        "This efficient reuse would not be achieved by applying the junction tree technique directly to the maximization operator in Algorithm 1, because we would be fixing the outer boundaries and computing the junction tree only over the inner boundaries."
      ]
    },
    {
      "heading": "3. Treewidth and Tabular Parsing",
      "text": [
        "The complexity of the message passing algorithm over an MRF's junction tree is determined by the treewidth of the MRF.",
        "In this section we show that, because parsing strategies are in direct correspondence with valid junction trees, we can use treewidth to analyze the complexity of a grammar rule.",
        "We define a tabular parsing strategy as any dynamic programming algorithm that stores partial results corresponding to subsets of a rule's child nonterminals.",
        "Such a strategy can be represented as a recursive partition of child nonterminals, as shown in Figure 1(left).",
        "We show below that a recursive partition of children having maximum complexity k at any step can be converted into a junction tree having k as the maximum cluster size.",
        "This implies that finding the optimal junction tree will give a parsing strategy at least as good as the strategy of the optimal recursive partition.",
        "A recursive partition of child nonterminals can be converted into a junction tree as follows:",
        "• For each leaf of the recursive partition, which represents a single child nonterminal i, create a leaf in the junction tree with the cluster (xi_i, xi, yn(i)-i, yn(i)) and the potential function /i(xi-1,xi,yn(i)-1,yn(i)).",
        "• For each internal node in the recursive partition, create a corresponding node in the junction tree.",
        "• Add each variable xi to all nodes in the junction tree on the path from the node for child nonterminal i – 1 to the node for child nonterminal i.",
        "Similarly, add each variable yn(i) to all nodes in the junction tree on the path from the node for child nonterminal – 1 to the node for child nonterminal",
        "Because each variable appears as an argument of only two factors, the junction tree nodes in which it is present form a linear path from one leafofthe tree to another.",
        "Since each variable is associated only with nodes on one path through the tree, the resulting tree will satisfy the junction tree property.",
        "The tree structure of the original recursive partition implies that the variable rises from two leaf nodes to the lowest common ancestor of both leaves, and is not contained in any higher nodes.",
        "Thus each node in the junction tree contains variables corresponding to the set of endpoints of the spans defined by the two subsets corresponding to its two children.",
        "The number of variables at each node in the junction tree is identical to the number of free endpoints at the corresponding combination in the recursive partition.",
        "Because each recursive partition corresponds to a junction tree with the same complexity, finding the best recursive partition reduces to finding the junction tree with the best complexity, i.e., the smallest maximum cluster size.",
        "Finding the junction tree with the smallest cluster size is equivalent to finding the input graph's treewidth, the smallest k such that the graph can be embedded in a k-tree.",
        "In general, this problem was shown to be NP-complete by Arnborg et al.",
        "(1987).",
        "However, because the treewidth of a given rule lower bounds the complexity of its tabular parsing strategies, parsing complexity for general rules can be bounded with treewidth results for worst-case rules, without explicitly identifying the worst-case permutations.",
        "<^~~xq X2 X3 yo yi y2 y3 y4~~~^>",
        "CI^ox 1X2 yi y2 y33y4^;>"
      ]
    },
    {
      "heading": "4. Treewidth Grows Linearly",
      "text": [
        "In this section, we show that the treewidth of the graphs corresponding to worst-case permutations growths linearly with the permutation's length.",
        "Our strategy is as follows:",
        "1.",
        "Define a 3-regular graph for an input permutation consisting of a subset of edges from the original graph.",
        "2.",
        "Show that the edge-expansion of the 3-regular graph grows linearly for randomly chosen permutations.",
        "3.",
        "Use edge-expansion to bound the spectral gap.",
        "4.",
        "Use spectral gap to bound treewidth.",
        "For the first step, we define H = (V, E) as a random 3-regular graph on 2n vertices obtained as follows.",
        "Let Gi = (Vi,Ei) and G2 = (V>,E2) be cycles, each on a separate set of n vertices.",
        "These two cycles correspond to the edges (xi,xi+i) and (yi,yi+i) in the graphs of the type shown in Figure 4.",
        "Let M be a random perfect matching between Viand V2.",
        "The matching represents the edges (xi,yn(i)) produced from the input permutation n. Let H be the union of Gi, G2, and M. While H contains only some of the edges in the graphs defined in the previous section, removing edges cannot increase the treewidth.",
        "For the second step of the proof, we use a probabilistic argument detailed in the next subsection.",
        "For the third step, we will use the following connection between the edge-expansion and the eigenvalue gap (Alon and Milman, 1985; Tanner, 1984).",
        "Lemma 4.1 Let G be a k-regular graph.",
        "Let A2 be the second largest eigenvalue of G. Let h(G) be the edge-expansion ofG.",
        "Then h(G)2k .",
        "Finally, for the fourth step, we use a relation between the eigenvalue gap and treewidth for regular graphs shown by Chandran and Subramanian (2003).",
        "Lemma 4.2 Let G be a k-regular graph.",
        "Let n be the number of vertices of G. Let A2 be the second largest eigenvalue ofG.",
        "Then",
        "Note that in our setting k = S. In order to use Lemma 4.2 we will need to give a lower bound on the eigenvalue gap k - A2 of G.",
        "The edge-expansion of a set of vertices T is the ratio of the number of edges connecting vertices in T to the rest of the graph, divided by the number of vertices in T, where we assume that I TI < I VI /2.",
        "The edge expansion of a graph is the minimum edge expansion of any subset of vertices:",
        "Intuitively, if all subsets of vertices are highly connected to the remainder of the graph, there is no way to decompose the graph into minimally interacting subgraphs, and thus no way to decompose the dynamic programming problem ofparsing into smaller pieces.",
        "Let be the standard binomial coefficient, and for a e R, let",
        "We will use the following standard inequality valid Lemma 4.3 With probability at least 0.98 the graph H has edge-expansion at least 1/50.",
        "Let e = 1/50.",
        "Assume that T C V is a set with a small edge-expansion, i. e., and |T| < |V|/2 = n. Let Ti = T n Viand let ti = |Ti|, for i = 1,2.",
        "We will w.l.o.g.",
        "assume ti < t2.",
        "We will denote as lithe number of spans of consecutive vertices from Ei contained in T. Thus counted by li and l2 correspond to continuous spans counted incomputing the complexity ofa chartpars-ing operation.",
        "However, unlike in the diagrams in the earlier part of this paper, in our graph theoretic argument there is no requirement that T select only corresponding pairs of vertices from Viand V2.",
        "There are at least 2(li+l2)+t2 – ti edges between T and V – T. This is because there are 2li edges within Vi at the left and right boundaries of the lispans, and at least t2 – ti edges connecting the extra vertices from T2 that have no matching vertex in Ti .",
        "Thus from assumption (5) we have which in turn implies",
        "Similarly, using (6), we have ll + 12 < 2 (tl + t2) < ï^ti.",
        "That is, for T to have small edge expansion, the vertices in Ti and T2 must be collected into a small number of spans li and l2.",
        "This limit on the number of spans allows us to limit the number of ways of choosing Ti and T2.",
        "Suppose that ti is given.",
        "Any pair Ti , T2 is determined by the edges in E(Ti, Vi – Ti), and E(T2, V2 – T2), and two bits (corresponding to the possible \"swaps\" of Tiwith Vi – Ti).",
        "Note that we can choose at most 2li + 2I2 < ti • 2e/(1 – e) edges in total.",
        "Thus the number ofchoices ofTi and T2 is bounded above by",
        "For a given choice of T1 and T2, for T to have small edge expansion, there must also not be too many edges that connect Tl to vertices in V2 - T2.",
        "Let k be the number of edges between T1 and T2.",
        "There are at least t1 +12 – 2k edges between T and V – T and from assumption (5) we have > (1 – e)tl.",
        "The probability that there are > (1 – e)ti edges between Ti and T2 is bounded by where the first term selects vertices in Ti connected to T2, and the second term upper bounds the probability that the selected vertices are indeed connected to T2.",
        "Using 6, we obtain a bound in terms of tialone:",
        "Combining the number of ways of choosing Ti and T2 (8) with the bound on the probability that the edges M from the input permutation connect almost all the vertices in Ti to vertices from T2 (10), and using the union bound over values of ti , we obtain that the probability p that there exists T C V with edge-expansion less than e is bounded by:",
        "where the factor of 2 is due to the assumption ti < t2.",
        "The graph H is connected and hence T has at least one outgoing edge.",
        "Therefore if ti + t2 < 1/e, the edge-expansion of T is at least e. Thus a set with edge-expansion less than e must have ti + t2 > 1/e, which, by (6), implies ti > (1 – e)/(2e).",
        "Thus the sum in (11) can be taken for t from [(1 – e)/(2e)]"
      ]
    },
    {
      "heading": "5. Conclusion",
      "text": [
        "p < 8 °-4* < -°2.",
        "While this constant bound on p is sufficient for our main complexity result, it can further be shown that p approaches zero as n increases, from the fact that the geometric sum in (12) converges, and each term for fixed ti goes to zero as n grows.",
        "This completes the second step of the proof as outlined at the beginning of this section.",
        "The constant bound on the edge expansion implies a constant bound on the eigenvalue gap (Lemma 4.1), which in turn implies an Q(n) bound on treewidth (Lemma 4.2), yielding:",
        "Theorem 4.4 Tabular parsing strategies for Synchronous Context-Free Grammars containing rules with all permutations of length n require time Q(Ncn) in the input string length N for some constant c.",
        "We have shown our result without explicitly constructing a difficult permutation, but we close with one example.",
        "The zero-based permutations oflength p, where p is prime, = ii mod p for 0 < i < p, and n(0) = 0, provide a known family of expander graphs (see Hoory et al.",
        "(2006)).",
        "We have shown in the exponent in the complexity of polynomial-time parsing algorithms for synchronous context-free grammars grows linearly with the length of the grammar rules.",
        "While it is very expensive computationally to test whether a specified permutation has a parsing algorithm of a certain complexity, it turns out that randomly chosen permutations are difficult with high probability.",
        "Acknowledgments This work was supported by",
        "NSF grants IIS-0546554, IIS-0428020, and IIS-0325646."
      ]
    }
  ]
}
