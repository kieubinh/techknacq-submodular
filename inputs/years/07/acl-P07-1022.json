{
  "info": {
    "authors": [
      "Mark Johnson"
    ],
    "book": "45th Annual Meeting of the Association of Computational Linguistics",
    "id": "acl-P07-1022",
    "title": "Transforming Projective Bilexical Dependency Grammars into efficiently-parsable CFGs with Unfold-Fold",
    "url": "https://aclweb.org/anthology/P07-1022",
    "year": 2007
  },
  "references": [
    "acl-C96-1058",
    "acl-E06-1011",
    "acl-J99-1004",
    "acl-P05-1010",
    "acl-P06-1055",
    "acl-P96-1024",
    "acl-P99-1059"
  ],
  "sections": [
    {
      "text": [
        "Transforming Projective Bilexical Dependency Grammars into eficiently-parsable CFGs with Unfold-Fold",
        "Microsoft Research Brown University",
        "Redmond, WA Providence, RI",
        "This paper shows how to use the Unfold-Fold transformation to transform Projective Bilexical Dependency Grammars (PBDGs) into ambiguity-preserving weakly equivalent Context-Free Grammars (CFGs).",
        "These CFGs can be parsed in O(n) time using a CKY algorithm with appropriate indexing, rather than the O(n) time required by a naive encoding.",
        "Informally, using the CKY algorithm with such a CFG mimics the steps of the Eisner-Satta O(n) PBDG parsing algorithm.",
        "This transformation makes all of the techniques developed for CFGs available to PBDGs.",
        "We demonstrate this by describing a maximum posterior parse decoder for PBDGs."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Projective Bilexical Dependency Grammars (PB-DGs) have attracted attention recently for two reasons.",
        "First, because they capture bilexical head-to-head dependencies they are capable of producing extremely high-quality parses: state-of-the-art dis-criminatively trained PBDG parsers rival the accuracy of the very best statistical parsers available today (McDonald, 2006).",
        "Second, Eisner-Satta O(n) PBDG parsing algorithms are extremely fast (Eisner, 1996; Eisner and Satta, 1999; Eisner, 2000).",
        "This paper investigates the relationship between Context-Free Grammar (CFG) parsing and the Eis-ner/Satta PBDG parsing algorithms, including their extension to second-order PBDG parsing (McDonald, 2006; McDonald and Pereira, 2006).",
        "Specifically, we show how to use an off-line preprocessing step, the Unfold-Fold transformation, to transform a PBDG into an equivalent CFG that can be parsed in O(n) time using a version of the CKY algorithm with suitable indexing (Younger, 1967), and extend this transformation so that it captures second-order PBDG dependencies as well.",
        "The transformations are ambiguity-preserving, i.e., there is a one-to-one mapping between dependency parses and CFG parses, so it is possible to map the CFG parses back to the PBDG parses they correspond to.",
        "The PBDG to CFG reductions make techniques developed for CFGs available to PBDGs as well.",
        "For example, incremental CFG parsing algorithms can be used with the CFGs produced by this transform, as can the Inside-Outside estimation algorithm (Lari and Young, 1990) and more exotic methods such as estimating adjoined hidden states (Matsuzaki et al., 2005; Petrov et al., 2006).",
        "As an example application, we describe a maximum posterior parse decoder for PBDGs in Section 8.",
        "The Unfold-Fold transformation is a calculus for transforming functional and logic programs into equivalent but (hopefully) faster programs (Burstall and Darlington, 1977).",
        "We use it here to transform CFGs encoding dependency grammars into other CFGs that are more efficiently parsable.",
        "Since CFGs can be expressed as Horn-clause logic programs (Pereira and Shieber, 1987) and the Unfold-Fold transformation is provably correct for such programs (Sato, 1992; Pettorossi and Proeitti, 1992), it follows that its application to CFGs is provably correct as well.",
        "The Unfold-Fold transformation is used here to derive the CFG schemata presented in sections 5-7.",
        "A system that uses these schemata (such as the one described in section 8) can implement these schemata directly, so the Unfold-Fold transformation plays a theoretical role in this work, justifying the resulting CFG schemata.",
        "The closest related work we are aware of is McAllester (1999), which also describes a reduction of PBDGs to efficiently-parsable CFGs and directly inspired this work.",
        "However, the CFGs produced by McAllester's transformation include epsilon-productions so they require a specialized CFG parsing algorithm, while the CFGs produced by the transformations described here have binary productions so they can be parsed with standard CFG parsing algorithms.",
        "Further, our approach extends to second-order PBDG parsing, while McAllester only discusses first-order PBDGs.",
        "The rest of this paper is structured as follows.",
        "Section 2 defines projective dependency graphs and grammars and Section 3 reviews the \"naive\" encoding of PBDGs as CFGs with an O(n) parse time, where n is the length of the string to be parsed.",
        "Section 4 introduces the \"split-head\" CFG encoding of PBDGs, which has an O(n) parse time and serves as the input to the Unfold-Fold transform.",
        "Section 5 uses the Unfold-Fold transform to obtain a weakly-equivalent CFG encoding of PBDGs which can be parsed in O(n) time, and presents timing results showing that the transformation does speed parsing.",
        "Sections 6 and 7 apply Unfold-Fold in slightly more complex ways to obtain CFG encodings of PBDGs that also make second-order dependencies available in O(n) time parsable CFGs.",
        "Section 8 applies a PBDG to CFG transform to obtain a maximum posterior decoding parser for PBDGs."
      ]
    },
    {
      "heading": "2. Projective bilexical dependency parses and grammars",
      "text": [
        "Let £ be a finite set of terminals (e.g., words), and let 0 be the root terminal not in £.",
        "If w = (wi,..., Wn) e £*, let w* = (0, wi,..., Wn), i.e., w* is obtained by prefixing w with 0.",
        "A dependency parse G for w is a tree whose root is labeled 0 and whose other n vertices are labeled with each of the n terminals in w. If G contains an arc from u to v then we say that v is a dependent of u, and if G contains a path from u to v then we say that v is a descendant of u.",
        "If v is dependent of u that also precedes u in w* then we say that v is a left dependent of u (right dependent and left and right descendants are defined similarly)."
      ]
    },
    {
      "heading": "0. Sandy gave the dog a bone",
      "text": [
        "A dependency parse G is projective iff whenever there is a path from u to v then there is also a path from u to every word between u and v in w* as well.",
        "Figure 1 depicts a projective dependency parse for the sentence \"Sam gave the dog a bone\".",
        "A projective dependency grammar defines a set of projective dependency parses.",
        "A Projective Bilexi-cal Dependency Grammar (PBDG) consists of two relations and , both defined over (£ U {0}) x £ .",
        "A PBDG generates a projective dependency parse G iff u v for all right dependencies (u, v) in G and v u for all left dependencies (u, v) in G. The language generated by a PBDG is the set of strings that have projective dependency parses generated by the grammar.",
        "The following dependency grammar generates the dependency parse in Figure 1.",
        "This paper does not consider stochastic dependency grammars directly, but see Section 8 for an application involving them.",
        "However, it is straightforward to associate weights with dependencies, and since the dependencies are preserved by the transformations, obtain a weighted CFG.",
        "Standard methods for converting weighted CFGs to equivalent PCFGs can be used if required (Chi, 1999).",
        "Alternatively, one can transform a corpus of dependency parses into a corpus of the corresponding CFG parses, and estimate CFG production probabilities directly from that corpus."
      ]
    },
    {
      "heading": "3. A naive encoding of PBDGs",
      "text": [
        "There is a well-known method for encoding a PBDG as a CFG in which each terminal u e £ is associated with a corresponding nonterminal that expands to u and all of u's descendants.",
        "The nonterminals of the naive encoding CFG consist of the start symbol S and symbols Xm for each terminal u e £, and the productions of the CFG are the instances of the following schemata:",
        "where O u",
        "X – XX where v u",
        "X – XX where u v",
        "The dependency annotations associated with each production specify how to interpret a local tree generated by that production, and permit us to map a CFG parse to the corresponding dependency parse.",
        "For example, the topmost local tree in Figure 2 was generated by the production S – X , and indicate that in this parse 0 gave.",
        "Given a terminal vocabulary of size m the CFG contains O(m) productions, so it is impractical to enumerate all possible productions for even modest vocabularies.",
        "Instead productions relevant to a particular sentence are generated on the fly.",
        "The naive encoding CFG in general requires O(n) parsing time with a conventional CKY parsing algorithm, since tracking the head annotations u and v multiplies the standard O(n) CFG parse time requirements by an additional factor proportional to the O(n) productions expanding Xu.",
        "An additional problem with the naive encoding is that the resulting CFG in general exhibits spurious ambiguities, i.e., a single dependency parse may correspond to more than one CFG parse, as shown in Figure 2.",
        "Informally, this is because the CFG permits left and the right dependencies to be arbitrarily intermingled."
      ]
    },
    {
      "heading": "4. Split-head encoding of PBDGs",
      "text": [
        "There are several ways ofremoving the spurious ambiguities in the naive CFG encoding just described.",
        "This section presents a method we call the \"split-head encoding\", which removes the ambiguities and serves as starting point for the grammar transforms described below.",
        "The split-head encoding represents each word u in the input string w by two unique terminals u and ur in the CFG parse.",
        "A split-head CFG's terminal vocabulary is £' = {u1;ur : u e £}, where £ is the set of terminals of the PBDG.",
        "A PBDG parse with yield w = (ui, .",
        ".",
        ".",
        ", un) is transformed to a split-head CFG parse with yield w' = (ui,Z,ui)r, .",
        ".",
        ".",
        ",un,|,un,r), so |w'| = 2|w|.",
        "Sandy X XX gave Xthe",
        "Sandy gave the dog",
        "Figure 2: Two parses using the naive CFG encoding that both correspond to the dependency parse of Figure 1.",
        "The split-head CFG for a PBDG is given by the following schemata:",
        "The dependency parse shown in Figure 1 corresponds to the split-head CFG parse shown in Figure 3.",
        "Each X expands to two new categories, L and R. L consists of u; and all of u's left descendants, while R consists of ur and all of u's right descendants.",
        "The spurious ambiguity present in the naive encoding does not arise in the split-head encoding because the left and right dependents of a head are assembled independently and cannot intermingle.",
        "As can be seen by examining the split-head schemata, the rightmost descendant of Lu is either Lu or u;, which guarantees that the rightmost terminal dominated by Lu is always u;; similarly the leftmost terminal dominated by uR is always ur.",
        "Thus",
        "S",
        " – ",
        "Xu",
        "X",
        "u",
        " – ",
        "Lu",
        "u",
        "R",
        "u",
        "L",
        "u",
        " – ",
        "u;",
        "L",
        "u",
        " – ",
        "X",
        "v",
        "L",
        "u",
        "R",
        "u",
        " – ",
        "ur",
        "R",
        "u",
        "-",
        "R",
        "u",
        "X",
        "v",
        "Figure S: The split-head parse corresponding to the dependency graph depicted in Figure 1.",
        "Notice that u; is always the rightmost descendant of Lu and ur is always the leftmost descendant of uR, which means that these indices are redundant given the constituent spans.",
        "these subscript indices are redundant given the string positions of the constituents, which means we do not need to track the index u in L and R but can parse with just the two categories L and R, and determine the index from the constituent's span when required.",
        "It is straightforward to extend the split-head CFG to encode the additional state information required by the head automata of Eisner and Satta (1999); this corresponds to splitting the non-terminals Luand uR.",
        "For simplicity we work with PBDGs in this paper, but all of the Unfold-Fold transformations described below extend to split-head grammars with the additional state structure required by head automata.",
        "Implementation note: it is possible to directly parse the \"undoubled\" input string w by modifying both the CKY algorithm and the CFGs described in this paper.",
        "Modify Lu and uR so they both ultimately expand to the same terminal u, and special-case the implementation of production X – L R and all productions derived from it to permit Lu and uR to overlap by the terminal u.",
        "The split-head formulation explains what initially seem unusual properties of existing PBDG algorithms.",
        "For example, one of the standard \"sanity checks\" for the Inside-Outside algorithm – that the outside probability of each terminal is equal to the sentence's inside probability – fails for these algorithms.",
        "In fact, the outside probability of each terminal is double the sentence's inside probability because these algorithms implicitly collapse the two terminals u and ur into a single terminal u."
      ]
    },
    {
      "heading": "5. A O(n 3 ) split-head grammar",
      "text": [
        "The split-head encoding described in the previous section requires O(n) parsing time because the index v on X is not redundant.",
        "We can obtain an equivalent grammar that only requires O(n) parsing time by transforming the split-head grammar using Unfold-Fold.",
        "We describe the transformation on L ; the transformation of R is symmetric.",
        "We begin with the definition of Lu in the split-head grammar above (\"| \" separates the right-hand sides of productions).",
        "L – u | XL where v u Our first transformation step is to unfold X in L , i.e., replace Xv by its expansion, producing the following definition for Lu (ignore the underlining for now).",
        "ing definition of Lu contains ternary productions and so still incurs O(n) parse time.",
        "To address this we define new nonterminals M for each x, y e £:",
        "and fold the underlined children in L into M :",
        "Sandyl Sandy^ the the dog dog, Figure 4: The O(n) split-head parse corresponding to the dependency graph of Figure 1.",
        "The O(n) split-head grammar is obtained by unfolding the occurence of Xu in the S production and dropping the Xu schema as Xu no longer appears on the right-hand side of any production.",
        "The resulting O(n) split-head grammar schemata are as follows:",
        "As before, the dependency annotations on the production schemata permit us to map CFG parses to the corresponding dependency parse.",
        "This grammar requires O(n) parsing time to parse because the indices are redundant given the constituent's string positions for the reasons described in section 4.",
        "Specifically, the rightmost terminal of Lu is always uj, the leftmost terminal of uR is always ur and the leftmost and rightmost terminals of M are v and urrespectively.",
        "The O(n) split-head grammar is closely related to the O(n) PBDG parsing algorithm given by Eisner and Satta (1999).",
        "Specifically, the steps involved in parsing with this grammar using the CKY algorithm are essentially the same as those performed by the Eisner/Satta algorithm.",
        "The primary difference is that the Eisner/Satta algorithm involves two separate categories that are collapsed into the single category M here.",
        "To confirm their relative performance we implemented stochastic CKY parsers for the three CFG schemata described so far.",
        "The production schemata were hard-coded for speed, and the implementation trick described in section 4 was used to avoid doubling the terminal string.",
        "We obtained dependency weights from our existing discriminatively-trained PBDG parser (not cited to preserve anonymity).",
        "We compared the parsers' running times on section 24 of the Penn Treebank.",
        "Because all three CFGs implement the same dependency grammar their Viterbi parses have the same dependency accuracy, namely 0.8918.",
        "We precompute the dependency weights, so the times include just the dynamic programming computation on a 3.6GHz Pentium 4."
      ]
    },
    {
      "heading": "6. An O(n 3 ) adjacent-head grammar",
      "text": [
        "This section shows how to further transform the O(n) grammar described above into a form that encodes second-order dependencies between adjacent dependent heads in much the way that a",
        "Markov PCFG does (McDonald, 2006; McDonald and Pereira, 2006).",
        "We provide a derivation for the L constituents; there is a parallel derivation for R.",
        "We begin by unfolding X in the definition of L",
        "Now introduce a new nonterminal ML, which is a specialized version of M requiring that v is a left-dependent of u, and fold the underlined constituents",
        "S",
        " – ",
        "LR",
        "uu",
        "where 0 u",
        "L",
        "u",
        " – ",
        "L",
        "u",
        " – ",
        "LM",
        "v v u",
        "where v u",
        "R",
        "u",
        " – ",
        "R",
        "u",
        " – ",
        "MR",
        "u v v",
        "where u v",
        "M",
        "y",
        "-",
        "RL",
        "x y",
        "where x, y G E",
        "bandyMgave",
        "Sandy Sandy L, „ ML",
        "Figure 5: The O(n) adjacent-head parse corresponding to the dependency graph of Figure 1.",
        "The boxed local tree indicates bone is the dependent of give following the dependent dog, i.e., give dog bone .",
        "Now unfold L in the definition of ML, producing:",
        "Note that in the first production expanding vMu, v is the closest left dependent of u, and in the second production v and v' are adjacent left-dependents of u. vMu has a ternary production, so we introduce",
        "M as before to fold the underlined constituents into.",
        "The resulting grammar schema is as below, and a sample parse is given in Figure 5.",
        "S – LR where 0 u",
        "Lu – u; u has no left dependents",
        "L – L ML v is u's last left dep.",
        "M – R u; v is u's closest left dep.",
        "uR – ur u has no right dependents",
        "R – MR R v is u's last right dep.",
        "M – ur L v is u's closest right dep.",
        "As before, the indices on the nonterminals are redundant, as the heads are always located at an edge of each constituent, so they need not be computed or stored and the CFG can be parsed in O(n) time.",
        "The steps involved in CKY parsing with this grammar correspond closely to those of the McDonald (2006) second-order PBDG parsing algorithm."
      ]
    },
    {
      "heading": "7. An O(n 3 ) dependent-head grammar",
      "text": [
        "This section shows a different application of Unfold-Fold can capture head-to-head-to-head dependencies, i.e., \"vertical\" second-order dependencies, rather than the \"horizontal\" ones captured by the transformation described in the previous section.",
        "Because we expect these vertical dependencies to be less important linguistically than the horizontal ones, we only sketch the transformation here.",
        "The derivation differs from the one in Section 6 in that the dependent R, rather than the head L , is unfolded in the initial definition of M .",
        "This results in a grammar that tracks vertical, rather than horizontal, second-order dependencies.",
        "Since left-hand and right-hand derivations are assembled separately in a split-head grammar, the grammar in fact only tracks zigzag type dependencies (e.g., where a grandparent has a right dependent, which in turn has a left dependent).",
        "The resulting grammar is given below, and a sample parse using this grammar is shown in Figure 6.",
        "Because the subscripts are redundant they can be omitted and the resulting CFG can be parsed in",
        "Sandy Sandy L gaveMthe gave( gaver the( ther dog( dogr",
        "Figure 6: The n dependent-head parse corresponding to the dependency graph of Figure 1.",
        "The boxed local tree indicates that a is a left-dependent of bone, which is in turn a right-dependent of gave, i.e., gave a bone .",
        "O(n) time using the CKY algorithm."
      ]
    },
    {
      "heading": "8. Maximum posterior decoding",
      "text": [
        "As noted in the introduction, one consequence of the PBDG to CFG reductions presented in this paper is that CFG parsing and estimation techniques are now available for PBDGs as well.",
        "As an example application, this section describes Maximum Posterior Decoding (MPD) for PBDGs.",
        "Goodman (1996) observed that the Viterbi parse is in general not the optimal parse for evaluation metrics such as f-score that are based on the number of correct constituents in a parse.",
        "He showed that MPD improves f-score modestly relative to Viterbi decoding for PCFGs.",
        "Since dependency parse accuracy is just the proportion of dependencies in the parse that are correct, Goodman's observation should hold for PBDG parsing as well.",
        "MPD for PBDGs selects the parse that maximizes the sum of the marginal probabilities of each of the dependencies in the parse.",
        "Such a decoder might plausibly produce parses that score better on the dependency accuracy metric than Viterbi parses.",
        "MPD is straightforward given the PBDG to CFG reductions described in this paper.",
        "Specifically, we use the Inside-Outside algorithm to compute the posterior probability of the CFG constituents corresponding to each PBDG dependency, and then use the Viterbi algorithm to find the parse tree that maximizes the sum of these posterior probabilities.",
        "We implemented MPD for first-order PBDGs using dependency weights from our existing discriminatively-trained PBDG parser (not cited to preserve anonymity).",
        "These weights are estimated by an online procedure as in McDonald (2006), and are not intended to define a probability distribution.",
        "In an attempt to heuristically correct for this, in this experiment we used exp(awu>v) as the weight of the dependency between head U and dependent V, where wu>v is the weight provided by the discriminatively-trained model and a is an adjustable scaling parameter tuned to optimize MPD accuracy on development data.",
        "Unfortunately we found no significant difference between the accuracy of the MPD and Viterbi parses.",
        "Optimizing MPD on the development data (section 24 of the PTB) set the scale factor a = 0.21 and produced MPD parses with an accuracy of 0.8921, which is approximately the same as the Viterbi accuracy of 0.8918.",
        "On the blind test data (section 23) the two accuracies are essentially identical (0.8997).",
        "s",
        " – ",
        "LR",
        "uu",
        "where",
        "0 U",
        "L",
        "u",
        " – ",
        "Ui",
        "L",
        "M",
        "v u",
        " – ",
        "LM",
        "v v u",
        "where",
        "V U",
        " – ",
        "Vr L",
        "where",
        "V U",
        "ML",
        "u",
        " – ",
        "MR M",
        "v w w u",
        "where",
        "V w U",
        "R",
        "u",
        "-",
        "Ur",
        "R",
        "MR",
        "u",
        " – ",
        "MR R",
        "u v v",
        "where",
        "U V",
        " – ",
        "R Vi",
        "ui",
        "where",
        "U V",
        "MR",
        "u",
        " – ",
        "MM",
        "u w w v",
        "where",
        "U w U",
        "M",
        "x y",
        " – ",
        "RL",
        "xy",
        "where",
        "x,y G E",
        "There are several possible explanations for the failure ofMPD to produce more accurate parses than Viterbi decoding.",
        "Perhaps MPD requires weights that define a probability distribution (e.g., a Max-Ent model).",
        "It is also possible that discriminative training adjusts the weights in a way that ensures that the Viterbi parse is close to the maximum posterior parse.",
        "This was the case in our experiment, and if this is true with discriminative training in general, then maximum posterior decoding will not have much to offer to discriminative parsing."
      ]
    },
    {
      "heading": "9. Conclusion",
      "text": [
        "This paper shows how to use the Unfold-Fold transform to translate PBDGs into CFGs that can be parsed in O(n) time.",
        "A key component of this is the split-head construction, where each word U in the input is split into two terminals Ui and Ur ofthe CFG parse.",
        "We also showed how to systematically transform the split-head CFG into grammars which track second-order dependencies.",
        "We provided one grammar which captures horizontal second-order dependencies (McDonald, 2006), and another which captures vertical second-order head-to-head-to-head dependencies.",
        "The grammars described here just scratch the surface of what is possible with Unfold-Fold.",
        "Notice that both of the second-order grammars have more nonterminals than the first-order grammar.",
        "If one is prepared to increase the number of nonterminals still further, it may be possible to track additional information about constituents (although if we insist on O(n) parse time we will be unable to track the interaction of more than three heads at once)."
      ]
    }
  ]
}
