{
  "info": {
    "authors": [
      "Min Zhang",
      "Wanxiang Che",
      "Aiti Aw",
      "Chew Lim Tan",
      "Guodong Zhou",
      "Ting Liu",
      "Sheng Li"
    ],
    "book": "45th Annual Meeting of the Association of Computational Linguistics",
    "id": "acl-P07-1026",
    "title": "A Grammar-driven Convolution Tree Kernel for Semantic Role Classification",
    "url": "https://aclweb.org/anthology/P07-1026",
    "year": 2007
  },
  "references": [
    "acl-A00-2018",
    "acl-C04-1197",
    "acl-J02-3001",
    "acl-J05-1004",
    "acl-J93-2004",
    "acl-N06-2025",
    "acl-P04-1016",
    "acl-P04-1043",
    "acl-P05-1072",
    "acl-P06-1104",
    "acl-P06-2010",
    "acl-P98-1013",
    "acl-W03-1012",
    "acl-W04-3211",
    "acl-W04-3212",
    "acl-W04-3213",
    "acl-W05-0634"
  ],
  "sections": [
    {
      "text": [
        "Min ZHANG Wanxiang CHE Ai Ti AW Chew Lim TANGuodong ZHOU' Ting LIU Sheng LI",
        "Institute for Infocomm Research {mzhang, aaiti}@i2r.a-star.edu.sg",
        "National University of Singapore",
        "tancl@comp.nus.edu.sg",
        "Harbin Institute of Technology",
        "{car, tliu}@ir.hit.edu.cn lisheng@hit.edu.cn Soochow Univ., China 215006 gdzhou@suda.edu.cn",
        "Convolution tree kernel has shown promising results in semantic role classification.",
        "However, it only carries out hard matching, which may lead to over-fitting and less accurate similarity measure.",
        "To remove the constraint, this paper proposes a grammar-driven convolution tree kernel for semantic role classification by introducing more linguistic knowledge into the standard tree kernel.",
        "The proposed grammar-driven tree kernel displays two advantages over the previous one: 1) grammar-driven approximate substructure matching and 2) grammar-driven approximate tree node matching.",
        "The two improvements enable the grammar-driven tree kernel explore more linguistically motivated structure features than the previous one.",
        "Experiments on the CoNLL-2005 SRL shared task show that the grammar-driven tree kernel significantly outperforms the previous non-grammar-driven one in SRL.",
        "Moreover, we present a composite kernel to integrate feature-based and tree kernel-based methods.",
        "Experimental results show that the composite kernel outperforms the previously best-reported methods."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Given a sentence, the task of Semantic Role Labeling (SRL) consists of analyzing the logical forms expressed by some target verbs or nouns and some constituents of the sentence.",
        "In particular, for each predicate (target verb or noun) all the constituents in the sentence which fill semantic arguments (roles) of the predicate have to be recognized.",
        "Typical semantic roles include Agent, Patient, Instrument, etc.",
        "and also adjuncts such as Locative, Temporal, Manner, and Cause, etc.",
        "Generally, semantic role identification and classification are regarded as two key steps in semantic role labeling.",
        "Semantic role identification involves classifying each syntactic element in a sentence into either a semantic argument or a non-argument while semantic role classification involves classifying each semantic argument identified into a specific semantic role.",
        "This paper focuses on semantic role classification task with the assumption that the semantic arguments have been identified correctly.",
        "Both feature-based and kernel-based learning methods have been studied for semantic role classification (Carreras and Marquez, 2004; Carreras and Marquez, 2005).",
        "In feature-based methods, a flat feature vector is used to represent a predicate-argument structure while, in kernel-based methods, a kernel function is used to measure directly the similarity between two predicate-argument structures.",
        "As we know, kernel methods are more effective in capturing structured features.",
        "Moschitti (2004) and Che et al.",
        "(2006) used a convolution tree kernel (Collins and Duffy, 2001) for semantic role classification.",
        "The convolution tree kernel takes sub-tree as its feature and counts the number of common sub-trees as the similarity between two predicate-arguments.",
        "This kernel has shown very promising results in SRL.",
        "However, as a general learning algorithm, the tree kernel only carries out hard matching between any two sub-trees without considering any linguistic knowledge in kernel design.",
        "This makes the kernel fail to handle similar phrase structures (e.g., \"buy a car\" vs. \"buy a red car\") and near-synonymic grammar tags (e.g., the POS variations between \"high/JJ degree/NN\" and \"higher/JJR degree/NN\") .",
        "To some degree, it may lead to over-fitting and compromise performance.",
        "This paper reports our preliminary study in addressing the above issue by introducing more linguistic knowledge into the convolution tree kernel.",
        "To our knowledge, this is the first attempt in this research direction.",
        "In detail, we propose a grammar-driven convolution tree kernel for semantic role classification that can carry out more linguistically motivated substructure matching.",
        "Experimental results show that the proposed method significantly outperforms the standard convolution tree kernel on the data set of the CoNLL-2005 SRL shared task.",
        "The remainder of the paper is organized as follows: Section 2 reviews the previous work and Section 3 discusses our grammar-driven convolution tree kernel.",
        "Section 4 shows the experimental results.",
        "We conclude our work in Section 5."
      ]
    },
    {
      "heading": "2. Previous Work",
      "text": [
        "Feature-based Methods for SRL: most features used in prior SRL research are generally extended from Gildea and Jurafsky (2002), who used a linear interpolation method and extracted basic flat features from a parse tree to identify and classify the constituents in the FrameNet (Baker et al., 1998).",
        "Here, the basic features include Phrase Type, Parse Tree Path, and Position.",
        "Most of the following work focused on feature engineering (Xue and Palmer, 2004; Jiang et al., 2005) and machine learning models (Nielsen and Pradhan, 2004; Pradhan et al., 2005a).",
        "Some other work paid much attention to the robust SRL (Pradhan et al., 2005b) and post inference (Punyakanok et al., 2004).",
        "These feature-based methods are considered as the state of the art methods for SRL.",
        "However, as we know, the standard flat features are less effective in modeling the syntactic structured information.",
        "For example, in SRL, the Parse Tree Path feature is sensitive to small changes of the syntactic structures.",
        "Thus, a predicate argument pair will have two different Path features even if their paths differ only for one node.",
        "This may result in data sparseness and model generalization problems.",
        "Kernel-based Methods for SRL: as an alternative, kernel methods are more effective in modeling structured objects.",
        "This is because a kernel can measure the similarity between two structured objects using the original representation of the objects instead of explicitly enumerating their features.",
        "Many kernels have been proposed and applied to the NLP study.",
        "In particular, Haussler (1999) proposed the well-known convolution kernels for a discrete structure.",
        "In the context of it, more and more kernels for restricted syntaxes or specific domains (Collins and Duffy, 2001; Lodhi et al., 2002; Zelenko et al., 2003; Zhang et al., 2006) are proposed and explored in the NLP domain.",
        "Of special interest here, Moschitti (2004) proposed Predicate Argument Feature (PAF) kernel for SRL under the framework of convolution tree kernel.",
        "He selected portions of syntactic parse trees as predicate-argument feature spaces, which include salient substructures of predicate-arguments, to define convolution kernels for the task of semantic role classification.",
        "Under the same framework, Che et al.",
        "(2006) proposed a hybrid convolution tree kernel, which consists of two individual convolution kernels: a Path kernel and a Constituent Structure kernel.",
        "Che et al.",
        "(2006) showed that their method outperformed PAF on the CoNLL-2005 SRL dataset.",
        "The above two kernels are special instances of convolution tree kernel for SRL.",
        "As discussed in Section 1, convolution tree kernel only carries out hard matching, so it fails to handle similar phrase structures and near-synonymic grammar tags.",
        "This paper presents a grammar-driven convolution tree kernel to solve the two problems"
      ]
    },
    {
      "heading": "3. Grammar-driven Convolution Tree Kernel",
      "text": [
        "In convolution tree kernel (Collins and Duffy, 2001), a parse tree t is represented by a vector of integer counts of each sub-tree type (regardless of its ancestors): 0(T) = ( # subtreei(T), ...), where # subtreei(T) is the occurrence number of the ithsub-tree type (subtreei) in T. Since the number of different sub-trees is exponential with the parse tree size, it is computationally infeasible to directly use the feature vector ^(T) .",
        "To solve this computational issue, Collins and Duffy (2001) proposed the following parse tree kernel to calculate the dot product between the above high dimensional vectors implicitly.",
        "K (71, T2) =<<f.(T,),0(T2) > where N1 and N2 are the sets of nodes in trees T1 and T2, respectively, and Isubtree.",
        "(n) is a function that is 1 iff the subtreei occurs with root at node n and zero otherwise, and A(n1; n2) is the number of the common subtrees rooted at n1 and n2, i.e.,",
        "A(n13 n2)can be further computed efficiently by the following recursive rules:",
        "Rule 1: if the productions (CFG rules) at n1 and",
        "n2 are different, A(n1; n2) = 0; Rule 2: else if both n1 and n2 are pre-terminals where nc(n1)is the child number of n1 , ch(n,j) is the jth child of node n andA(0<A<1) is the decay factor in order to make the kernel value less variable with respect to the subtree sizes.",
        "In addition, the recursive Rule 3 holds because given two nodes with the same children, one can construct common sub-trees using these children and common sub-trees of further offspring.",
        "The time complexity for computing this kernel is O(| N1 | • | N2 |) .",
        "This Subsection introduces the two improvements and defines our grammar-driven tree kernel.",
        "Improvement 1: Grammar-driven approximate matching between substructures.",
        "The conventional tree kernel requires exact matching between two contiguous phrase structures.",
        "This constraint may be too strict.",
        "For example, the two phrase structures \"NP^DT JJ NN\" (NP^a red car) and \"NP^DT NN\" (NP->a car) are not identical, thus they contribute nothing to the conventional kernel although they should share the same semantic role given a predicate.",
        "In this paper, we propose a grammar-driven approximate matching mechanism to capture the similarity between such kinds of quasi-structures for SRL.",
        "First, we construct reduced rule set by defining optional nodes, for example, \"NP->DT [JJ] NP\" or \"VP-> VB [ADVP] PP\", where [*] denotes optional nodes.",
        "For convenience, we call \"NP-> DT",
        "JJ NP\" the original rule and \"NP->DT [JJ] NP\" the reduced rule.",
        "Here, we define two grammar-driven criteria to select optional nodes:",
        "1) The reduced rules must be grammatical.",
        "It means that the reduced rule should be a valid rule in the original rule set.",
        "For example, \"NP->DT [JJ]",
        "NP\" is valid only when \"NP->DT NP\" is a valid rule in the original rule set while \"NP->DT [JJ valid rule in the original rule set.",
        "2) A valid reduced rule must keep the head child of its corresponding original rule and has at least two children.",
        "This can make the reduced rules retain the underlying semantic meaning of their corresponding original rules.",
        "Given the reduced rule set, we can then formulate the approximate substructure matching mechanism as follows:",
        "M (l> = I h] (It (71, Tj) X^) (1) where r1 is a production rule, representing a sub-tree of depth one, andTri1is the ith variation of the subtree r1 by removing one ore more optional nodes, and likewise for r2 and TrJ2.",
        "IT (•, •) is a function that is 1 iff the two sub-trees are identical and zero otherwise.",
        "^(0<^<1) is a small penalty to penalize optional nodes and the two parameters ai and bj stand for the numbers of occurrence of removed optional nodes in subtrees Tr1and Tr2, respectively.",
        "M(r1,r2)returns the similarity (ie., the kernel value) between the two sub-trees r1 and r2 by summing up the similarities between all possible variations of the sub-trees r1 and r2.",
        "Under the new approximate matching mechanism, two structures are matchable (but with a small penalty A1) if the two structures are identical after removing one or more optional nodes.",
        "In this case, the above example phrase structures \"NP->a red car\" and \"NP->a car\" are matchable with a penalty A in our new kernel.",
        "It means that one cooccurrence of the two structures contributes A to our proposed kernel while it contributes zero to the traditional one.",
        "Therefore, by this improvement, our method would be able to explore more linguistically appropriate features than the previous one (which is formulated as IT (r1, r2)).",
        "Improvement 2: Grammar-driven tree nodes approximate matching.",
        "The conventional tree kernel needs an exact matching between two (terminal/non-terminal) nodes.",
        "But, some similar POSs may represent similar roles, such as NN (dog) and NNS (dogs).",
        "In order to capture this phenomenon, we allow approximate matching between node features.",
        "The following illustrates some equivalent node feature sets:",
        "• VB, VBD, VBG, VBN, VBP, VBZ ^ ......",
        "where POSs in the same line can match each other with a small penalty 0<A2 <1.",
        "We call this case node feature mutation.",
        "This improvement further generalizes the conventional tree kernel to get better coverage.",
        "The approximate node matching can be formulated as:",
        "M f2) = I .. (If f, //) X/C+bj) (2) where f1 is a node feature, f1i is the ith mutation of f1and ai is 0 iff f1i and f1 are identical and 1 otherwise, and likewise for f2 .",
        "If (•, •) is a function that is 1 iff the two features are identical and zero otherwise.",
        "Eq.",
        "(2) sums over all combinations of feature mutations as the node feature similarity.",
        "The same as Eq.",
        "(1), the reason for taking all the possibilities into account in Eq.",
        "(2) is to make sure that the new kernel is a proper kernel.",
        "The above two improvements are grammar-driven, i.e., the two improvements retain the underlying linguistic grammar constraints and keep semantic meanings of original rules.",
        "The Grammar-driven Kernel Definition: Given the two improvements discussed above, we can define the new kernel by beginning with the feature vector representation of a parse tree T as follows:",
        "0(T) = (# subtreej(T), ..., # subtreen(T)) where # subtreei(T) is the occurrence number of the ith sub-tree type (subtreei) in T. Please note that, different from the previous tree kernel, here we loosen the condition for the occurrence of a subtree by allowing both original and reduced rules (Improvement 1) and node feature mutations (Improvement 2).",
        "In other words, we modify the criteria by which a subtree is said to occur.",
        "For example, one occurrence of the rule \"NP->DT JJ NP\" shall contribute 1 times to the feature \"NP->DT JJ NP\"",
        "and A times to the feature \"NP->DT NP\" in the new kernel while it only contributes 1 times to the feature \"NP->DT JJ NP\" in the previous one.",
        "Now we can define the new grammar-driven kernel KG (7, T2) as follows:",
        "where N1 and N2 are the sets of nodes in trees T1 and T2, respectively.",
        "Is ubtreei (n) is a function that is",
        "• iff the subtreei occurs with root at node n",
        "and zero otherwise, where a and b are the numbers of removed optional nodes and mutated node features, respectively.",
        "A'(n1,n2) is the number of the common subtrees rooted at n1 and n2, i.e. ,",
        "Please note that the value of A'(n1, n2) is no longer an integer as that in the conventional one since optional nodes and node feature mutations are considered in the new kernel.",
        "A'(n1, n2) can be further computed by the following recursive rules:",
        "Rule A: if n1 and n2are pre-terminals, then:",
        "A'(\"1, = AxM(f1, f2) (5) where f1 and f2 are features of nodes n1 and n2 respectively, and M(f1,f2) is defined at Eq.",
        "(2).",
        "Rule B: else if both n and n2 are the same nonterminals, then generate all variations of the subtrees of depth one rooted by n and n2 (denoted by and Tn2 respectively) by removing different optional nodes, then:",
        "• Tni1 and Tnj2 stand for the ith and jth variations in sub-tree set Tn1 and Tn2 , respectively.",
        "• IT (•, •) is a function that is 1 iff the two subtrees are identical and zero otherwise.",
        "• ai and bj stand for the number of removed optional nodes in subtrees Tn\\and Tnj2, respectively.",
        "• nc(n1, i) returns the child number of n1 in its ithsubtree variation Tni1 .",
        "• ch(n1, i, k) is the kth child of node n1 in its ithvariation subtree Tn!1, and likewise for ch(n2, j, k).",
        "• Finally, the same as the previous tree kernel, A(0<A<1) is the decay factor (see the discussion in Subsection 3.1).",
        "Rule A accounts for Improvement 2 while Rule B accounts for Improvement 1.",
        "In Rule B, Eq.",
        "(6) is able to carry out multilayer sub-tree approximate matching due to the introduction of the recursive part while Eq.",
        "(1) is only effective for subtrees of depth one.",
        "Moreover, we note that Eq.",
        "(4) is a convolution kernel according to the definition and the proof given in Haussler (1999), and Eqs (5) and (6) reformulate Eq.",
        "(4) so that it can be computed efficiently, in this way, our kernel defined by Eq (3) is also a valid convolution kernel.",
        "Finally, let us study the computational issue of the new convolution tree kernel.",
        "Clearly, computing Eq.",
        "(6) requires exponential time in its worst case.",
        "However, in practice, it may only need O (| N1 | • | N2 |) .",
        "This is because there are only 9.9% rules (647 out of the total 6,534 rules in the parse trees) have optional nodes and most of them have only one optional node.",
        "In fact, the actual running time is even much less and is close to linear in the size of the trees since A'(n1, n2) = 0 holds for many node pairs (Collins and Duffy, 2001).",
        "In theory, we can also design an efficient algorithm to compute Eq.",
        "(6) using a dynamic programming algorithm (Mo-schitti, 2006).",
        "We just leave it for our future work.",
        "In above discussion, we show that the conventional convolution tree kernel is a special case of the grammar-driven tree kernel.",
        "From kernel function viewpoint, our kernel can carry out not only exact matching (as previous one described by Rules 2 and 3 in Subsection 3.1) but also approximate matching (Eqs.",
        "(5) and (6) in Subsection 3.2).",
        "From feature exploration viewpoint, although they explore the same substructure feature space (defined recursively by the phrase parse rules), their feature values are different since our kernel captures the structure features in a more linguistically appropriate way by considering more linguistic knowledge in our kernel design.",
        "Moschitti (2006) proposes a partial tree (PT) kernel which can carry out partial matching between sub-trees.",
        "The PT kernel generates a much larger feature space than both the conventional and the grammar-driven kernels.",
        "In this point, one can say that the grammar-driven tree kernel is a specialization of the PT kernel.",
        "However, the important difference between them is that the PT kernel is not grammar-driven, thus many non-linguistically motivated structures are matched in the PT kernel.",
        "This may potentially compromise the performance since some of the over-generated features may possibly be noisy due to the lack of linguistic interpretation and constraint.",
        "Kashima and Koyanagi (2003) proposed a convolution kernel over labeled order trees by generalizing the standard convolution tree kernel.",
        "The labeled order tree kernel is much more flexible than the PT kernel and can explore much larger sub-tree features than the PT kernel.",
        "However, the same as the PT kernel, the labeled order tree kernel is not grammar-driven.",
        "Thus, it may face the same issues (such as over-generated features) as the PT kernel when used in NLP applications.",
        "Shen el al.",
        "(2003) proposed a lexicalized tree kernel to utilize LTAG-based features in parse reranking.",
        "Their methods need to obtain a LTAG derivation tree for each parse tree before kernel calculation.",
        "In contrast, we use the notion of optional arguments to define our grammar-driven tree kernel and use the empirical set of CFG rules to determine which arguments are optional."
      ]
    },
    {
      "heading": "4. Experiments",
      "text": [
        "Data: We use the CoNLL-2005 SRL shared task data (Carreras and Màrquez, 2005) as our experimental corpus.",
        "The data consists of sections of the Wall Street Journal part of the Penn TreeBank (Marcus et al., 1993), with information on predicate-argument structures extracted from the Prop-Bank corpus (Palmer et al., 2005).",
        "As defined by the shared task, we use sections 02-21 for training, section 24 for development and section 23 for test.",
        "There are 35 roles in the data including 7 Core (A0-A5, AA), 14 Adjunct (AM-) and 14 Reference (R-) arguments.",
        "Table 1 lists counts of sentences and arguments in the three data sets.",
        "We assume that the semantic role identification has been done correctly.",
        "In this way, we can focus on the classification task and evaluate it more accurately.",
        "We evaluate the performance with Accuracy.",
        "SVM (Vapnik, 1998) is selected as our classifier and the one vs. others strategy is adopted and the one with the largest margin is selected as the final answer.",
        "In our implementation, we use the binary SVMLight (Joachims, 1998) and modify the Tree Kernel Tools (Moschitti, 2004) to a grammar-driven one.",
        "Kernel Setup: We use the Constituent, Predicate, and Predicate-Constituent related features, which are reported to get the best-reported performance (Pradhan et al., 2005a), as the baseline features.",
        "We use Che et al.",
        "(2006)'s hybrid convolution tree kernel (the best-reported method for kernel-based SRL) as our baseline kernel.",
        "It is defined as Khybnd =0Kpath + (1 -9)Kcs (0<9< 1) (for the detailed definitions of Kpath and Kcs, please refer to Che et al.",
        "(2006)).",
        "Here, we use our grammar-driven tree kernel to compute Kpath and Kcs, and we call it grammar-driven hybrid tree kernel while Che et al.",
        "(2006)'s is non-grammar-driven hybrid convolution tree kernel.",
        "We use a greedy strategy to fine-tune parameters.",
        "Evaluation on the development set shows that our kernel yields the best performance when X (decay factor of tree kernel), X1 and X2 (two penalty factors for the grammar-driven kernel), 9 (hybrid kernel parameter) and c (a SVM training parameter to balance training error and margin) are set to 0.4, 0.6, 0.3, 0.6 and 2.4, respectively.",
        "For other parameters, we use default setting.",
        "In the CoNLL 2005 benchmark data, we get 647 rules with optional nodes out of the total 6,534 grammar rules and define three equivalent node feature sets as below:",
        "Here, the verb feature set \"VB, VBD, VBG, VBN, VBP, VBZ\" is removed since the voice information is very indicative to the arguments of ARG0 (Agent, operator) and ARG1 (Thing operated).",
        "Table 2 compares the performances of different methods on the test set.",
        "First, we can see that the new grammar-driven hybrid convolution tree kernel significantly outperforms (x test with p=0.05) the non-grammar one with an absolute improvement of 2.75 (87.96-85.21) percentage, representing a relative error rate reduction of 18.6% (2.75/(100-85.21)) .",
        "It suggests that 1) the linguistically motivated structure features are very useful for semantic role classification and 2) the grammar-driven kernel is much more effective in capturing such kinds of features due to the consideration of linguistic knowledge.",
        "Moreover, Table 2 shows that 1) both the grammar-driven approximate node matching and the grammar-driven approximate substructure matching are very useful in modeling syntactic tree structures for SRL since they contribute relative error rate reduction of7.2% ((86.27-85.21)/(100-85.21)) and 12.9% ((87.12-85.21)/(100-85.21)), respectively; 2) the grammar-driven approximate substructure matching is more effective than the grammar-driven approximate node matching.",
        "However, we find that the performance of the grammar-driven kernel is still a bit lower than the feature-based method.",
        "This is not surprising since tree kernel methods only focus on modeling tree structure information.",
        "In this paper, it captures the syntactic parse tree structure features only while the features used in the feature-based methods cover more knowledge sources.",
        "Training",
        "Development",
        "Test",
        "Sentences",
        "39,832",
        "1,346",
        "2,416",
        "Arguments",
        "239,858",
        "8,346",
        "14,077",
        "Methods",
        "Accuracy (%)",
        "Baseline: Non-grammar-driven",
        "85.21",
        "+Approximate Node Matching",
        "86.27",
        "+Approximate Substructure",
        "87.12",
        "Matching",
        "Ours: Grammar-driven Substruc-",
        "87.96",
        "ture and Node Matching",
        "Feature-based method with poly-",
        "89.92",
        "nomial kernel (d = 2)",
        "In order to make full use of the syntactic structure information and the other useful diverse flat features, we present a composite kernel to combine the grammar-driven hybrid kernel and feature-based method with polynomial kernel:",
        "kcomp = 7khybnd + (1 - Y) kpoly (0 <y< 1) Evaluation on the development set shows that the composite kernel yields the best performance when Y is set to 0.3.",
        "Using the same setting, the system achieves the performance of 91.02% in Accuracy in the same test set.",
        "It shows statistically significant improvement (x test with p= 0.10) over using the standard features with the polynomial kernel (Y = 0, Accuracy = 89.92%) and using the grammar-driven hybrid convolution tree kernel (Y = 1, Accuracy = 87.96%).",
        "The main reason is that the tree kernel can capture effectively more structure features while the standard flat features can cover some other useful features, such as Voice, SubCat, which are hard to be covered by the tree kernel.",
        "The experimental results suggest that these two kinds of methods are complementary to each other.",
        "In order to further compare with other methods, we also do experiments on the dataset of English ment and test sets follow the conventional split of Sections 02-21, 00 and 23.",
        "Table 3 compares our method with other previously best-reported methods with the same setting as discussed previously.",
        "It shows that our method outperforms the previous best-reported one with a relative error rate reduction of 10.8% (0.97/(100-91)).",
        "This further verifies the effectiveness of the grammar-driven kernel method for semantic role classification.",
        "Method Accuracy (%)",
        "Table 4 reports the training times of the two kernels.",
        "We can see that 1) the two kinds of convolution tree kernels have similar computing time.",
        "Although computing the grammar-driven one requires exponential time in its worst case, however, in practice, it may only need O(| N1\\ • | N2 |) or linear and 2) it is very time-consuming to train a SVM classifier in a large dataset."
      ]
    },
    {
      "heading": "5. Conclusion and Future Work",
      "text": [
        "In this paper, we propose a novel grammar-driven convolution tree kernel for semantic role classification.",
        "More linguistic knowledge is considered in the new kernel design.",
        "The experimental results verify that the grammar-driven kernel is more effective in capturing syntactic structure features than the previous convolution tree kernel because it allows grammar-driven approximate matching of substructures and node features.",
        "We also discuss the criteria to determine the optional nodes in a",
        "Ours (Composite Kernel)",
        "91.97",
        "Moschitti (2006): PAF kernel only",
        "87.7",
        "Jiang et al.",
        "(2005): feature based",
        "90.50",
        "Pradhan et al.",
        "(2005a): feature based",
        "91.0",
        "Table 3: Performance comparison between our",
        "method and previous work",
        "Method Training Time",
        "4 Sections",
        "19 Sections",
        "Ours: grammar ~8.1 hours",
        "~7.9 days",
        "driven tree kernel",
        "Moschitti (2006): ~7.9 hours",
        "~7.1 days",
        "non-grammar-driven",
        "tree kernel",
        "CFG rule in defining our grammar-driven convolution tree kernel.",
        "The extension of our work is to improve the performance of the entire semantic role labeling system using the grammar-driven tree kernel, including all four stages: pruning, semantic role identification, classification and post inference.",
        "In addition, a more interesting research topic is to study how to integrate linguistic knowledge and tree kernel methods to do feature selection for tree kernelbased NLP applications (Suzuki et al., 2004).",
        "In detail, a linguistics and statistics-based theory that can suggest the effectiveness of different substructure features and whether they should be generated or not by the tree kernels would be worked out."
      ]
    }
  ]
}
