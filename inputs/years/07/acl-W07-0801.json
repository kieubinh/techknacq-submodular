{
  "info": {
    "authors": [
      "Otakar Smr&zcaron;"
    ],
    "book": "Workshop on Computational Approaches to Semitic Languages: Common Issues and Resources",
    "id": "acl-W07-0801",
    "title": "ElixirFM -- Implementation of Functional Arabic Morphology",
    "url": "https://aclweb.org/anthology/W07-0801",
    "year": 2007
  },
  "references": [
    "acl-W05-0703"
  ],
  "sections": [
    {
      "text": [
        "ElixirFM – Implementation of Functional Arabic Morphology",
        "Otakar Smrz",
        "Institute of Formal and Applied Linguistics Faculty of Mathematics and Physics",
        "Charles University in Prague otakar.smrz@mff.cuni.cz",
        "Functional Arabic Morphology is a formulation of the Arabic inflectional system seeking the working interface between morphology and syntax.",
        "ElixirFM is its high-level implementation that reuses and extends the Functional Morphology library for Haskell.",
        "Inflection and derivation are modeled in terms of paradigms, grammatical categories, lexemes and word classes.",
        "The computation of analysis or generation is conceptually distinguished from the general-purpose linguistic model.",
        "The lexicon of ElixirFM is designed with respect to abstraction, yet is no more complicated than printed dictionaries.",
        "It is derived from the open-source Buckwalter lexicon and is enhanced with information sourcing from the syntactic annotations of the Prague Arabic Dependency Treebank."
      ]
    },
    {
      "heading": "1. Overview",
      "text": [
        "One can observe several different streams both in the computational and the purely linguistic modeling of morphology.",
        "Some are motivated by the need to analyze word forms as to their compositional structure, others consider word inflection as being driven by the underlying system of the language and the formal requirements of its grammar.",
        "In Section 2, before we focus on the principles of ElixirFM, we briefly follow the characterization of morphological theories presented by Stump (2001) and extend the classification to the most prominent computational models of Arabic morphology (Beesley, 2001; Buckwalter, 2002; Habash et al., 2005; El Dada and Ranta, 2006).",
        "In Section 3, we survey some of the categories of the syntax-morphology interface in Modern Written Arabic, as described by the Functional Arabic Morphology.",
        "In passing, we will introduce the basic concepts of programming in Haskell, a modern purely functional language that is an excellent choice for declarative generative modeling of morphologies, as Forsberg and Ranta (2004) have shown.",
        "Section 4 will be devoted to describing the lexicon of ElixirFM.",
        "We will develop a so-called domain-specific language embedded in Haskell with which we will achieve lexical definitions that are simultaneously a source code that can be checked for consistency, a data structure ready for rather independent processing, and still an easy-to-read-and-edit document resembling the printed dictionaries.",
        "In Section 5, we will illustrate how rules of inflection and derivation interact with the parameters of the grammar and the lexical information.",
        "We will demonstrate, also with reference to the Functional Morphology library (Forsberg and Ranta, 2004), the reusability of the system in many applications, including computational analysis and generation in various modes, exploring and exporting of the lexicon, printing of the inflectional paradigms, etc."
      ]
    },
    {
      "heading": "2. Morphological Models",
      "text": [
        "According to Stump (2001), morphological theories can be classified along two scales.",
        "The first one deals with the core or the process of inflection:",
        "lexical theories associate word's morphosyntactic properties with affixes",
        "inferential theories consider inflection as a result of operations on lexemes; morphosyntactic properties are expressed by the rules that relate the form in a given paradigm to the lexeme",
        "The second opposition concerns the question of inferability of meaning, and theories divide into:",
        "incremental words acquire morphosyntactic properties only in connection with acquiring the inflectional exponents of those properties",
        "realizational association of a set of properties with a word licenses the introduction of the exponents into the word's morphology",
        "Evidence favoring inferential-realizational theories over the other three approaches is presented by Stump (2001) as well as Baerman et al.",
        "(2006) or Spencer (2004).",
        "In trying to classify the implementations of Arabic morphological models, let us reconsider this cross-linguistic observation:",
        "The morphosyntactic properties associated with an inflected word's individual inflectional markings may underdeter-mine the properties associated with the word as a whole.",
        "(Stump, 2001, p. 7)",
        "How do the current morphological analyzers interpret, for instance, the number and gender of the Arabic broken masculine plurals gudud ijJ;- new ones or qudah SLiS judges, or the case of mustawan (jjl^ a level?",
        "Do they identify the values of these features that the syntax actually operates with, or is the resolution hindered by some too generic assumptions about the relation between meaning and form?",
        "Many of the computational models of Arabic morphology, including in particular (Beesley, 2001), (Ramsay and Mansur, 2001) or (Buckwalter, 2002), are lexical in nature.",
        "As they are not designed in connection with any syntax-morphology interface, their interpretations are destined to be incremental.",
        "Some signs of a lexical-realizational system can be found in (Habash, 2004).",
        "The author mentions and fixes the problem of underdetermination of inherent number with broken plurals, when developing a generative counterpart to (Buckwalter, 2002).",
        "The computational models in (Soudi et al., 2001) and (Habash et al., 2005) attempt the inferential-realizational direction.",
        "Unfortunately, they implement only sections of the Arabic morphological system.",
        "The Arabic resource grammar in the Grammatical Framework (El Dada and Ranta, 2006) is perhaps the most complete inferential-realizational implementation to date.",
        "Its style is compatible with the linguistic description in e.g. (Fischer, 2001) or (Badawi et al., 2004), but the lexicon is now very limited and some other extensions for data-oriented computational applications are still needed.",
        "ElixirFM is inspired by the methodology in (Forsberg and Ranta, 2004) and by functional programming, just like the Arabic GF is (El Dada and Ranta, 2006).",
        "Nonetheless, ElixirFM reuses the Buckwalter lexicon (2002) and the annotations in the Prague Arabic Dependency Treebank (Hajic et al., 2004), and implements yet more refined linguistic model."
      ]
    },
    {
      "heading": "3. Morphosyntactic Categories",
      "text": [
        "Functional Arabic Morphology and ElixirFM reestablish the system of inflectional and inherent morphosyntactic properties (alternatively named grammatical categories or features) and distinguish precisely the senses of their use in the grammar.",
        "In Haskell, all these categories can be represented as distinct data types that consist of uniquely identified values.",
        "We can for instance declare that the category of case in Arabic discerns three values, that we also distinguish three values for number or person, or two values of the given names for verbal voice:",
        "data Case = Nominative | Genitive |",
        "Accusative data Number = Singular | Dual | Plural data Person = First | Second | Third data Voice = Active | Passive",
        "All these declarations introduce new enumerated types, and we can use some easily-defined methods of Haskell to work with them.",
        "If we load this (slightly extended) program into the interpreter, we can e.g. ask what category the value Genitive belongs to (seen as the :: type signature), or have it evaluate the list of the values that Person allows:",
        "?",
        ":type Genitive – Genitive Case",
        "Lists in Haskell are data types that can be parametrized by the type that they contain.",
        "So, the value [Active, Active, Passive] is a list of three elements oftype Voice, and we can write this ifnec-essary as the signature :: [Voice] .",
        "Lists can also be empty or have just one single element.",
        "We denote lists containing some type a as being of type [a].",
        "Haskell provides a number of useful types already, such as the enumerated boolean type or the parametric type for working with optional values:",
        "data Bool = True | False data Maybe a = Just a | Nothing",
        "Similarly, we can define a type that couples other values together.",
        "In the general form, we can write which introduces the value :-: as a container for some value of type a and another of type b.",
        "Let us return to the grammatical categories.",
        "Inflection of nominals is subject to several formal requirements, which different morphological models decompose differently into features and values that are not always complete with respect to the inflectional system, nor mutually orthogonal.",
        "We will explain what we mean by revisiting the notions of state and definiteness in contemporary written Arabic.",
        "To minimize the confusion of terms, we will depart from the formulation presented in (El Dada and Ranta, 2006).",
        "In there, there is only one relevant category, which we can reimplement as state':",
        "Variation of the values of state' would enable generating the forms al-kitabu <li I def., kitabun 1x5\" indef., and kitabu Jjcf const.",
        "for the nominative singular of book.",
        "This seems fine until we explore more inflectional classes.",
        "The very variation for the nominative plural masculine of the adjective high gets ar-rafiuna jyLijM def., rafiuna oj-*s?j indef., and rafiu const.",
        "But what value does the form ar-rafiu y*-£^) I, found in improper annexations such as in al-masuluna 'r-raftu 'l-mustawa * * *",
        "(j^iLcd I j-iiJ) I oI the-officials the-highs-ofthe-level, receive?",
        "It is interesting to consult for instance (Fischer, 2001), where state has exactly the values of state' , but where the definite state Def covers even forms without the prefixed al JI article, since also some separate words like la S no or ya b oh can have the effects on inflection that the definite article has.",
        "To distinguish all the forms, we might think of keeping state in the sense of Fischer, and adding a boolean feature for the presence of the definite article...",
        "However, we would get one unacceptable combination of the values claiming the presence of the definite article and yet the indefinite state, i.e. possibly the indefinite article or the diptotic declension.",
        "Functional Arabic Morphology refactors the six different kinds of forms (if we consider all inflectional situations) depending on two parameters.",
        "The first controls prefixation of the (virtual) definite article, the other reduces some suffixes if the word is a head of an annexation.",
        "In ElixirFM, we define these parameters as type synonyms to what we recall:",
        "type Definite = Maybe Bool type Annexing = Bool",
        "The Definite values include Just True for forms with the definite article, Just False for forms in some compounds or after la S or ya b (absolute negatives or vocatives), and Nothing for forms that reject the definite article for other reasons.",
        "Functional Arabic Morphology considers state as a result of coupling the two independent parameters:",
        "type State = Couple Definite Annexing",
        "Thus, the indefinite state indef describes a word void of the definite article(s) and not heading an annexation, i.e.",
        "Nothing :-: False.",
        "Conversely, ar-rafTu yi^JJI is in the state Just True :-: True.",
        "The classical construct state is Nothing :-: True.",
        "The definite state is Just _ :-: False, where _ is True for El Dada and Ranta and False for Fischer.",
        "We may discover that now all the values of state are meaningful.",
        "Type declarations are also useful for defining in what categories a given part of speech inflects.",
        "For verbs, this is a bit more involved, and we leave it for Figure 2.",
        "For nouns, we set this algebraic data type:",
        "data ParaNoun = NounS Number Case State",
        "In the interpreter, we can now generate all 54 combinations of inflectional parameters for nouns:",
        "The function values is analogous to enum, and both need to know their type before they can evaluate.",
        "The 'magic' is that the bound variables n, c, and s have their type determined by the NounS constructor, so we need not type anything explicitly.",
        "We used the list comprehension syntax to cycle over the lists that enum and values produce, cf. (Hudak, 2000)."
      ]
    },
    {
      "heading": "4. ElixirFM Lexicon",
      "text": [
        "Unstructured text is just a list of characters, or string: type String = [Char]",
        "Yet words do have structure, particularly in Arabic.",
        "We will work with strings as the superficial word forms, but the internal representations will be more abstract (and computationally more efficient, too).",
        "The definition of lexemes can include the derivational root and pattern information if appropriate, cf. (Habash et al., 2005), and our model will encourage this.",
        "The surface word kitab <_> 1^5\"book can decompose to the triconsonantal root k t b and the morphophonemic pattern FiCAL of type PatternT:",
        "The deriving clause associates PatternT with methods for testing equality, enumerating all the values, and turning the names of the values into strings:",
        "?",
        "show FiCAL – \"FiCAL\"",
        "We choose to build on morphophonemic patterns rather than CV patterns and vocalisms.",
        "Words like istagab to respond and istagwab",
        "to interrogate have the same underlying VstVCCVC pattern, so information on CV patterns alone would not be enough to reconstruct the surface forms.",
        "Morphophonemic patterns, in this case IstaFAL and IstaFCaL , can easily be mapped to the hypothetical CV patterns and vocalisms, or linked with each other according to their relationship.",
        "Morphophonemic patterns deliver more information in a more compact way.",
        "Of course, ElixirFM provides functions for properly interlocking the patterns with the roots:",
        "?",
        "merge \"z h r\" IFtaCaL – \"izdahar\"",
        "The izdahar jiSjJ to flourish case exemplifies that exceptionless assimilations need not be encoded in the patterns, but can instead be hidden in rules.",
        "The whole generative model adopts the multipurpose notation of AabTX (Lagally, 2004) as a meta-encoding of both the orthography and phonology.",
        "Therefore, instantiation of the \" ' \" hamza carriers or other merely orthographic conventions do not obscure the morphological model.",
        "With Encode Arabic interpreting the notation, ElixirFM can at the surface level process the original Arabic script (non-)vocalized to any degree or work with some kind of transliteration or even transcription thereof.",
        "Morphophonemic patterns represent the stems of words.",
        "The various kinds of abstract prefixes and suffixes can be expressed either as atomic values, or as literal strings wrapped into extra constructors:",
        "Affixes and patterns are arranged together via the Morphs a data type, where a is a triliteral pattern PatternT or a quadriliteral PatternQ or a nontemplatic word stem Identity of type PatternL: data PatternL = Identity",
        "The word lâ-silkïy (\"^i-^M wireless can thus be decomposed as the roof s l k cdL» and the value Morphs FiCL [LA] [Iy] .",
        "Shunning such concrete representations, we define new operators >| and |< that denote prefixes, resp.",
        "suffixes, inside Morphs a:",
        "Implementing >| and |< to be applicable in the intuitive way required Haskell's multi-parameter type classes with functional dependencies (Jones, 2000):",
        "instance Morphing (Morphs a) a where morph = id",
        "instance Morphing PatternT PatternT where morph x = Morphs x [] []",
        "The instance declarations ensure how the morph method would turn values of type a into Morphs b.",
        "Supposing that morph is available for the two types,",
        "(|<) is a function on y :: a and x :: Suffix giving a value of type Morphs b.",
        "The intermediate result of morph y is decomposed, and x is prepended to the stack s of the already present suffixes.",
        "where Morphs t p s = morph y",
        "With the introduction of patterns, their synonymous functions and the >| and |< operators, we have started the development of what can be viewed as a domain-specific language embedded in the generalpurpose programming language.",
        "Encouraged by the flexibility of many other domain-specific languages in Haskell, esp.",
        "those used in functional parsing (Ljunglof, 2002) or pretty-printing (Wadler, 2003), we may design the lexicon to look like e.g.",
        "module Elixir.Data.Lexicon import Elixir.Lexicon",
        "and yet be a verifiable source code defining a data structure that is directly interpretable.",
        "The meaning of the combinators |> and <| could be supplied via an external module Elixir.",
        "Lexicon, so is very easy to customize.",
        "The effect of these combinators might be similar to the : and :-: constructors that we met previously, but perhaps other data structures might be built from the code instead of lists and pairs.",
        "Individual entries can be defined with functions in a convenient notational form using ''.",
        "Infix operators can have different precedence and associativity, which further increases the options for designing a lightweight, yet expressive, embedded language.",
        "In Figure 1, each entry reduces to a record of type Entry PatternT reflecting internally the lexeme's inherent properties.",
        "Consider one such reduction below.",
        "Functions like plural or gender or humanness could further modify the Noun's default information:",
        "Entry (Noun [] Nothing Nothing)",
        "The lexicon of ElixirFM is derived from the open-source Buckwalter lexicon (Buckwalter, 2002).",
        "We devised an algorithm in Perl using the morpho-",
        "FaCaL",
        "'verb'",
        "[ \"write\",",
        "\"be destined\" ]",
        "'imperf'",
        "FCuL,",
        "FiCAL",
        "'noun'",
        "[ \"book\" ]",
        "'plural'",
        "FuCuL,",
        "FiCAL",
        "|< aT",
        "'noun'",
        "[ \"writing\"",
        "],",
        "FiCAL",
        "|< aT",
        "'noun'",
        "[ \"essay\",",
        "\"piece of writing\" ]",
        "'plural'",
        "FiCAL |<",
        "At,",
        "FACiL",
        "'noun'",
        "[ \"writer\",",
        "\"author\", \"clerk\" ]",
        "'plural' 'plural'",
        "FaCaL |< FuCCAL,",
        "aT",
        "FuCCAL",
        "'noun '",
        "[ \"kuttab\",",
        "\"Quran school\" ]",
        "'plural'",
        "FaCACIL,",
        "MaFCaL",
        "'noun'",
        "[ \"office\",",
        "\"department\" ]",
        "'plural'",
        "MaFACiL,",
        "MaFCaL",
        "|< Iy",
        "'adj '",
        "[ \"office\"",
        "],",
        "MaFCaL",
        "|< aT",
        "'noun'",
        "[ \"library\", \"bookstore\" ]",
        "'plural'",
        "MaFACiL",
        "data Mood = Indicative | Subjunctive | Jussive | Energetic deriving (Eq, Enum data Gender = Masculine | Feminine deriving (Eq, Enum data ParaVerb = VerbP Voice Person Gender Number | VerbI Mood Voice Person Gender Number | VerbC Gender Number deriving Eq",
        "Figure 2: Excerpt from the implementation of verbal inflectional features and paradigms in ElixirFM.",
        "phonemic patterns of ElixirFM that finds the roots and templates of the lexical items, as they are available only partially in the original, and produces the lexicon in formats for Perl and for Haskell.",
        "Information in the ElixirFM lexicon can get even more refined, by lexicographers or by programmers.",
        "Verbs could be declared via indicating their derivational verbal form (that would, still, reduce to some Morphs a value), and deverbal nouns and participles could be defined generically for the extended forms.",
        "The identification of patterns as to their derivational form is implemented easily with the isForm method:",
        "?",
        "isForm VIII IFtaCaL – True",
        "Nominal parts of speech need to be enhanced with information on the inherent number, gender and humanness, if proper modeling oflinguistic agreement in Arabic is desired.",
        "Experiments with the Prague Arabic Dependency Treebank (Hajic et al., 2004) show that this information can be learned from annotations of syntactic relations (SmrZ, 2007)."
      ]
    },
    {
      "heading": "5. Morphological Rules",
      "text": [
        "Inferential-realizational morphology is modeled in terms of paradigms, grammatical categories, lexemes and word classes.",
        "ElixirFM implements the comprehensive rules that draw the information from the lexicon and generate the word forms given the appropriate morphosyntactic parameters.",
        "The whole is invoked through a convenient inflect method.",
        "The lexicon and the parameters determine the choice of paradigms.",
        "The template selection mechanism differs for nominals (providing plurals) and for verbs (providing all needed stem alternations in the extent of the entry specifications of e.g. Hans Wehr's dictionary), yet it is quite clear-cut (SmrZ, 2007).",
        "In Figure 2, the algebraic data type ParaVerb restricts the space in which verbs are inflected by defining three Cartesian products of the elementary categories: a verb can have VerbP perfect forms inflected in voice, person, gender, number, VerbI imperfect forms inflected also in mood, and VerbC imperatives inflected in gender and number only.",
        "The paradigm for inflecting imperatives, the one and only such paradigm in ElixirFM, is implemented as paraVerbC.",
        "It is a function parametrized by some particular value of gender g and number n. It further takes the initial imperative prefix i and the verbal stem (both inferred from the morphophonemic patterns in the lexical entry) to yield the inflected imperative form.",
        "Note the polymorphic type of the function, which depends on the following:",
        "Singular",
        "->",
        "case g",
        "of",
        "Masculine",
        "->",
        "prefix",
        "i",
        "suffix",
        "n it",
        "Feminine",
        "->",
        "prefix",
        "i",
        "suffix",
        "fij- u",
        "Plural",
        "->",
        "case g",
        "of",
        "Masculine",
        "->",
        "prefix",
        "i",
        "suffix",
        "\"UW\"",
        "Feminine",
        "->",
        "prefix",
        "i",
        "suffix",
        "\"na \"",
        "->",
        "prefix",
        "i",
        "suffix",
        "\"A\"",
        "If one wished to reuse the paradigm and apply it on strings only, it would be sufficient to equate these functions with standard list operations, without any need to reimplement the paradigm itself.",
        "The definition of paraVerbC is simple and concise due to the chance to compose with .",
        "the partially applied prefix and suffix functions and to virtually omit the next argument.",
        "This advanced formulation may seem not as minimal as when specifying the literal endings or prefixes, but we present it here to illustrate the options that there are.",
        "An abstract paradigm can be used on more abstract types than just strings.",
        "Inflected forms need not be merged with roots yet, and can retain the internal structure:",
        "\"uktubna\" uktubna Ifem.",
        "pl.",
        "write!",
        "masc.",
        ": \"iqra' \" iqra\" l^ïj sg.",
        "\"iqra'a\" iqraïï",
        "I^ij du.",
        "\"iqra'ua\" iqrau I^jjïjpl.",
        "fem.",
        ": \"iqra'I\" iqray (Jjij sg.",
        "\"iqra'A\" iqraa",
        "I^ïjdu.",
        "\"iqra'na\" iqrana jl^ïtpl.",
        "read!",
        "The highlight of the Arabic morphology is that the 'irregular' inflection actually rests in strictly observing some additional rules, the nature of which is phonological.",
        "Therefore, surprisingly, ElixirFM does not even distinguish between verbal and nominal word formation when enforcing these rules.",
        "This reduces the number of paradigms to the prototypical 3 verbal and 5 nominal!",
        "Yet, the model is efficient.",
        "Given that the morphophonemic patterns already do reflect the phonological restrictions, the only places of further phonological interaction are the prefix boundaries and the junction of the last letter of the pattern with the very adjoining suffix.",
        "The rules are implemented with ->- and -<-, respectively, and are invoked from within the merge function:",
        "(-<-) is likewise defined when matching on 'Y', 'A' , 'U' , and when not matching.",
        "(->-) implements definite article assimilation and occasional prefix interaction with weak verbs.",
        "Nominal inflection is also driven by the information from the lexicon and by phonology.",
        "The reader might be noticing that the morphophonemic patterns and the Morphs a templates are actually extremely informative.",
        "We can use them as determining the inflectional class and the paradigm function, and thus we can almost avoid other unintuitive or excessive indicators of the kind of weak morphology, diptotic inflection, and the like."
      ]
    },
    {
      "heading": "6. Applications and Conclusion",
      "text": [
        "The ElixirFM linguistic model and the data of the lexicon can be integrated into larger applications or used as standalone libraries and resources.",
        "There is another, language-independent part of the system that implements the compilation of the inflected word forms and their associated mor-phosyntactic categories into morphological analyzers and generators.",
        "This part is adapted from (Forsberg and Ranta, 2004).",
        "The method used for analysis is deterministic parsing with tries (Ljunglof, 2002).",
        "ElixirFM also provides functions for exporting and pretty-printing the linguistic model into XML, LTeX, Perl, SQL, and other custom formats.",
        "We have presented ElixirFM as a high-level functional implementation of Functional Arabic Morphology.",
        "Next to some theoretical points, we proposed a model that represents the linguistic data in an abstract and extensible notation that encodes both orthography and phonology, and whose interpretation is customizable.",
        "We developed a domain-specific language in which the lexicon is stored and which allows easy manual editing as well as automatic verification of consistency.",
        "We believe that the modeling of both the written language and the spoken dialects can share the presented methodology.",
        "AT",
        "-> \"iyaT\"",
        "; Un",
        "Iy",
        "-> \"Iy\"",
        "; In",
        "Suffix",
        "11 fl",
        "->",
        "\"i \"",
        "Suffix",
        "\"Una \"",
        "->",
        "\"Una \"",
        "Suffix",
        "\"U\"",
        "->",
        "\"U\"",
        "Suffix",
        "\"UW\"",
        "->",
        "\"UW\"",
        "Suffix",
        "\"Ina \"",
        "->",
        "\"Ina \"",
        "Suffix",
        "->",
        "\"I\"",
        "Suffix",
        "x | x 'elem'",
        "[ \"i \",",
        "ElixirFM and its lexicons are open-source software licensed under GNU GPL and available on http://sf.net/projects/elixir-fm/.",
        "This work has been supported by the Ministry of Education of the Czech Republic (MSM00216208-38), by the Grant Agency of Charles University in Prague (UK 373/2005), and by the Grant Agency of the Czech Academy of Sciences (1ET101120413)."
      ]
    }
  ]
}
