{
  "info": {
    "authors": [
      "Anders Søgaard"
    ],
    "book": "COLING – Posters",
    "id": "acl-C08-2026",
    "title": "Range Concatenation Grammars for Translation",
    "url": "https://aclweb.org/anthology/C08-2026",
    "year": 2008
  },
  "references": [
    "acl-C90-3045",
    "acl-J97-3002",
    "acl-P03-2041",
    "acl-P04-1084",
    "acl-P06-1123"
  ],
  "sections": [
    {
      "text": [
        "Positive and bottom-up non-erasing binary range concatenation grammars (Boul-lier, 1998) with at most binary predicates ((2,2)-BRCGs) is a 0(\\G\\n) time strict extension of inversion transduction grammars (Wu, 1997) (ITGs).",
        "It is shown that (2,2)-BRCGs induce inside-out alignments (Wu, 1997) and cross-serial discontinuous translation units (CDTUs); both phenomena can be shown to occur frequently in many hand-aligned parallel corpora.",
        "A CYK-style parsing algorithm is introduced, and induction from aligment structures is briefly discussed.",
        "Range concatenation grammars (RCG) (Boul-lier, 1998) mainly attracted attention in the formal language community, since they recognize exactly the polynomial time recognizable languages, but recently they have been argued to be useful for data-driven parsing too (Maier and Sogaard, 2008).",
        "Bertsch and Nederhof (2001) present the only work to our knowledge on using RCGs for translation.",
        "Both Bertsch and Nederhof (2001) and Maier and Sogaard (2008), however, only make use of so-called simple RCGs, known to be equivalent to linear context-free rewrite systems (LCFRSs) (Weir, 1988; Boullier, 1998).",
        "Our strict extension of ITGs, on the other hand, makes use of the ability to copy substrings in RCG derivations; one of the things that makes RCGs strictly more expressive than LCFRSs.",
        "Copying enables us to recognize the intersection of any two translations that we can recognize and induce the union of any two alignment structures that we can induce.",
        "Our extension of ITGs in fact introduces two things: (i) A clause may introduce any number of terminals.",
        "This enables us to induce multiword translation units, (ii) A clause may copy a substring, i.e. a clause can associate two or more nonterminals A\\,... An with the same substring and thereby check if the substring is in the intersection of the languages of the subgrammars with start predicate names A\\,... An.",
        "The first point is motivated by studies such as Zens and Ney (2003) and simply reflects that in order to induce multiword translation units in this kind of synchronous grammars, it is useful to be able to introduce multiple terminals simultaneously.",
        "The second point gives us a handle on context-sensitivity.",
        "It means that (2,2)-BRCGs can define translations such as {(anbmcndm,anbmdmcn) | m,n > 0}, i.e. a translation of cross-serial dependencies into nested ones; but it also means that (2,2)-BRCGs induce a larger class of alignment structures.",
        "In fact the set of alignment structures that can be induced is closed under union, i.e. any alignment structure can be induced.",
        "The last point is of practical interest.",
        "It is shown below that phenomena such as inside-out alignments and CDTUs, which cannot be induced by ITGs, but by (2,2)-BRCGs, occur frequently in many hand-aligned parallel corpora.",
        "(2,2)-BRCGs are positive RCGs (Boullier, 1998) with binary start predicate names, i.e. p(S) 2.",
        "In RCG, predicates can be negated (for complementation), and the start predicate name is typically unary.",
        "The definition is changed only for aesthetic reasons; a positive RCG with a binary start predicate name S is turned into a positive RCG with a unary start predicate name S' simply by adding a clause S'{XiX2) -»■ S{Xl,X2).",
        "Definition 1.1 (Positive RCGs).",
        "A positive RCG is a 5-tuple G = (N,T,V,P,S).",
        "N is a finite set of predicate names with an arity function p: N – > Z*, T and F are finite sets of, resp., terminal and variables.",
        "P is a finite set of clauses of the form ipo – >■ ipi ■ ■ ■ ipm, where and each of the ipi,0 < i < m, is a predicate of the form A(a\\,..., ap^).",
        "Each aj G (T U V)*, 1 < j < p{A), is an argument.",
        "5 G TV is the start predicate name with p(S) = 2.",
        "Note that the order of RHS predicates in a clause is of no importance.",
        "Three subclasses of RCGs are introduced for further reference: An RCG G = (N, T, V, P, S) is simple iff for all c G P, it holds that no variable X occurs more than once in the LHS of c, and if X occurs in the LHS then it occurs exactly once in the RHS, and each argument in the RHS of c contains exactly one variable.",
        "An RCG G = (N, T, V, P, S) is a k-RCG iff for all A G N, p{A) < k. Finally, an RCG G = {N, T, V, P, S) is said to be bottom-up non-erasing iff for all c G P all variables that occur in the RHS of c also occur in its LHS.",
        "A positive RCG is a (2,2)-BRCG iff it is a 2-RCG, if an argument of the LHS predicate contains at most two variables, and if it is bottom-up non-erasing.",
        "The language of a (2,2)-BRCG is based on the notion of range.",
        "For a string pair (wi... wn, vn+2 ■ ■ ■ vn+i+m) a range is a pair of indices with 0 < i < j < n or n < i < j < n + 1 + m, i.e. a string span, which denotes a substring Wi+\\.. .Wj in the source string or a substring Vi+\\ ... Vj in the target string.",
        "Only consequtive ranges can be concatenated into new ranges.",
        "Terminals, variables and arguments in a clause are bound to ranges by a substitution mechanism.",
        "An instantiated clause is a clause in which variables and arguments are consistently replaced by ranges; its components are instantiated predicates.",
        "For example A((g .. .h), (i... j)) – > B({g .. .h), (i + 1... j – 1)) is an instantiation of the clause A(Xi,aYib) B(XhYi) if the target string is such that Vi+\\ = a and Vj = b.",
        "A derive relation => is defined on strings of instantiated predicates.",
        "If an instantiated predicate is the LHS of some instantiated clause, it can be replaced by the RHS of that instantiated clause.",
        "The language of a (2,2)-BRCG G = (N, T, V, P, S) is S((0,n),(n + l,n + l + m)).",
        "Theorem 1.2 ((Boullier, 2000)).",
        "The recognition problem of bottom-up non-erasing k-RCG can be solved in time 0(\\G\\nd) where d = maxc.ep(kj + Vj) where Cj is the jth clause in P, kj is the arity of its LHS predicate, and Vj is the number of different variables in that LHS predicate.",
        "It follows immediately that the recognition problem of (2,2)-BRCG can be solved in time 0(\\G\\n), since kj can be at most 2, and Vj can be at most 4.",
        "which when words that are recognized simultaneously are aligned, induces the alignment:",
        "by inducing the alignments in the, resp., Si and 5*2 derivations:",
        "abed abed efgh efgh",
        "Note that L(G) = {(anV",
        "m,n> 0}.",
        "Since the component grammars in ITGs are context-free, Example 1.4 shows that there is at least one translation not recognizable by ITGs that is recognized by a (2,2)-BRCG; {anbmcndm | m, n > 0} is known to be non-context-free.",
        "ITGs translate into simple (2,2)-BRCGs in the following way; see Wu (1997) for a definition of ITGs.",
        "The left column is ITG production rules; the right column their translations in simple (2,2)-BRCGs.",
        "It follows immediately that Theorem 1.5.",
        "(2,2)-BRCGs are strictly more expressive than ITGs."
      ]
    },
    {
      "heading": "2. Alignment capacity",
      "text": [
        "Zens and Ney (2003) identify a class of alignment structures that cannot be induced by ITGs, but that can be induced by a number of similar synchronous grammar formalisms, e.g. synchronous tree substitution grammar (STSG) (Eisner, 2003).",
        "Inside-out alignments (Wu, 1997), such as the one in Example 1.3, cannot be induced by any of these theories; in fact, there seems to be no useful synchronous grammar formalisms available that handle inside-out alignments, with the possible exceptions of synchronous tree-adjoining grammars (Shieber and Schabes, 1990), Bertsch and Nederhof (2001) and generalized multitext grammars (Melamed et al., 2004), which are all way more complex than ITG, STSG and (2,2)-BRCG.",
        "Nevertheless, Wellington et al.",
        "(2006) report that 5% of the sentence pairs in an aligned parallel Chinese-English corpus contained inside-out alignments.",
        "Example 1.3 shows that (2,2)-BRCGs induce inside-out alignments.",
        "An even stronger motivation for using (2,2)-BRCG for translation is the existence of cross-serial DTUs (CDTUs).",
        "Informally, a CDTU is a DTU such that there is a part of another DTU in its gap.",
        "Here's a simple example:",
        "Neither ITGs nor STSGs can induce CDTUs; ITGs cannot induce DTUs with multiple gaps (MDTUs) either.",
        "Our experiments are summarized in Figure 1.",
        "Overall the results show that handling CDTUs is important for alignment error rates."
      ]
    },
    {
      "heading": "3. Parsing and induction from alignments",
      "text": [
        "A CYK-style algorithm is presented for (2,2)-BRCG in Figure 2; it is assumed, w.l.o.g, that if the same variable occurs twice in the LHS of a clause, the clause is of the form Aq{X\\,Yi) – > Ai(Xi,Yi)A2(Xi,Yi).",
        "It modifies the original CYK algorithm (Younger, 1967) in four ways: (i) It uses two charts; one for the source string (s) and one for the target string (t).",
        "(ii) Pairs of nonterminals and integers (A, t), rather than just nonterminals, are stored in the cells of the chart (1.",
        "2,4,6,7).",
        "Integers represent derivation steps at which nonterminals are inserted, (iii) Multiple terminals are allowed (1.",
        "2,6,7).",
        "(iv) If a clause is copying, the same two cells in the chart are visited twice (1.",
        "4).",
        "Note that the variable i in insertion, e.g. in 1.",
        "4/1, is the current derivation step, but ti in look-up, e.g. in 1.",
        "4/2, is the derivation step in which the associated nonterminal was added to the chart.",
        "The overall runtime of this algorithm is in 0(\\G\\n), since it has, for branching clauses, six embedded loops that iterate over the string, i.e. the four for loops and the two 3s in Figure 2.",
        "The induction problem from alignments can be reduced to the induction problem for ITGs by simply unravelling the alignment structures.",
        "The simplest algorithm for doing this assumes that alignments are sequences of translation units, and considers each at a time.",
        "If a gap is found, the translation unit is a DTU and is moved to a new alignment structure.",
        "The complexity of the algorithm is quadratic in the length of the input sentences, i.e. linear in the size of the alignment structure, and for a sentence pair {w\\... wn, v\\... vm) the ITG induction algorithm has to consider at most - – ahgment structures."
      ]
    },
    {
      "heading": "4. Conclusion",
      "text": [
        "A new class of grammars for syntax-based machine translation was presented; while its recognition problem remains solvable in time 0(\\G\\n), the grammars induce frequently occurring alignment configurations that cannot be induced by comparable classes of grammars in the literature.",
        "A parsing and an induction algorithm were presented.",
        "3i'.",
        "(B,ti) e + |Vi|,*')»(C»t2) e^' + l^l,/- IVaD.Vi = «i'+i...",
        "8 if (S,Li) e s(0,n), (S,Li) e i(0,m) then return success else failure",
        "Sent.",
        "TUs",
        "DTUs",
        "CDTUs",
        "MDTUs",
        "CDTUs/Sent.",
        "English-French:",
        "100",
        "937",
        "95",
        "36",
        "11",
        "36%",
        "English-Portuguese:",
        "100",
        "939",
        "100",
        "52",
        "3",
        "52%",
        "English-Spanish:",
        "100",
        "950",
        "90",
        "26",
        "7",
        "26%",
        "Portuguese-French:",
        "100",
        "915",
        "77",
        "19",
        "3",
        "19%",
        "Portuguese-Spanish:",
        "100",
        "991",
        "80",
        "40",
        "3",
        "40%",
        "Spanish-French:",
        "100",
        "975",
        "74",
        "24",
        "8",
        "24%"
      ]
    }
  ]
}
