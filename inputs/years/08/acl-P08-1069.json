{
  "info": {
    "authors": [
      "Rebecca Nesson",
      "Giorgio Satta",
      "Stuart M. Shieber"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P08-1069",
    "title": "Optimal $k$-arization of Synchronous Tree-Adjoining Grammar",
    "url": "https://aclweb.org/anthology/P08-1069",
    "year": 2008
  },
  "references": [
    "acl-C90-3045",
    "acl-N06-1033",
    "acl-P06-2036",
    "acl-P92-1012",
    "acl-W06-1501",
    "acl-W06-1505",
    "acl-W06-1506",
    "acl-W07-0402",
    "acl-W07-0404"
  ],
  "sections": [
    {
      "text": [
        "Optimal /c-arization of Synchronous Tree-Adjoining Grammar",
        "nessongseas.harvard.edu",
        "satta@dei.unipd.it",
        "shiebergseas.harvard.edu",
        "Synchronous Tree-Adjoining Grammar (STAG) is a promising formalism for syntax-aware machine translation and simultaneous computation of natural-language syntax and semantics.",
        "Current research in both of these areas is actively pursuing its incorporation.",
        "However, STAG parsing is known to be NP-hard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures.",
        "Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within a single elementary structure.",
        "In this paper we present a compile-time algorithm for transforming a STAG into a strongly-equivalent STAG that optimally minimizes the rank, k, across the grammar.",
        "The algorithm performs in 0(\\G\\ + |y| • Lq) time where Lq is the maximum number of links in any single synchronous tree pair in the grammar and Y is the set of synchronous tree pairs of G."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Tree-adjoining grammar is a widely used formalism in natural-language processing due to its mildly-context-sensitive expressivity, its ability to naturally capture natural-language argument substitution (via its substitution operation) and optional modification (via its adjunction operation), and the existence of efficient algorithms for processing it.",
        "Recently, the desire to incorporate syntax-awareness into machine translation systems has generated interest in the application of synchronous tree-adjoining grammar (STAG) to this problem (Nesson, Shieber, and Rush, 2006; Chiang and Rambow, 2006).",
        "In a parallel development, interest in incorporating semantic computation into the TAG framework has led to the use of STAG for this purpose (Nesson and Shieber, 2007; Han, 2006b; Han, 2006a; Nesson and Shieber, 2006).",
        "Although STAG does not increase the expressivity of the underlying formalisms (Shieber, 1994), STAG parsing is known to be NP-hard due to the potential for intertwined correspondences between the linked nonterminal symbols in the elementary structures (Satta, 1992; Weir, 1988).",
        "Without efficient algorithms for processing it, its potential for use in machine translation and TAG semantics systems is limited.",
        "Given a particular grammar, the polynomial degree of efficient STAG parsing algorithms depends directly on the rank of the grammar: the maximum number of correspondences that appear within a single elementary structure.",
        "This is illustrated by the tree pairs given in Figure 1 in which no two numbered links may be isolated.",
        "(By \"isolated\", we mean that the links can be contained in a fragment of the tree that contains no other links and dominates only one branch not contained in the fragment.",
        "A precise definition is given in section 3.)",
        "An analogous problem has long been known to exist for synchronous context-free grammars (SCFG) (Aho and Ullman, 1969).",
        "The task of producing efficient parsers for SCFG has recently been addressed by binarization or fc-arization of SCFG grammars that produce equivalent grammars in which the rank, k, has been minimized (Zhang",
        "J)[3 Em bm bm.",
        "Figure 1: Example of intertwined links that cannot be binarized.",
        "No two links can be isolated in both trees in a tree pair.",
        "Note that in tree pair 71, any set of three links may be isolated while in tree pair 72, no group of fewer than four links may be isolated.",
        "In 73 no group of links smaller than four may be isolated.",
        "S S INP^^VP NPJB^VP Adj N* N* Adj",
        "I I I red rouges",
        "ATI] Drt^Nm likes N aime Del^^N",
        "John Jean / red candies bonbons rouges",
        "Figure 2: An example STAG derivation of the English/French sentence pair \"John likes red candies'V'Jean aime les bonbons rouges\".",
        "The figure is divided as follows: (a) the STAG grammar, (6) the derivation tree for the sentence pair, and (c) the derived tree pair for the sentences.",
        "and Gildea, 2007; Zhang et al., 2006; Gildea, Satta, and Zhang, 2006).",
        "The methods for fc-arization of SCFG cannot be directly applied to STAG because of the additional complexity introduced by the expressivity-increasing adjunction operation of TAG.",
        "In SCFG, where substitution is the only available operation and the depth of elementary structures is limited to one, the fc-arization problem reduces to analysis of permutations of strings of nonterminal symbols.",
        "In STAG, however, the arbitrary depth of the elementary structures and the lack of restriction to contiguous strings of nonterminals introduced by adjunction substantially complicate the task.",
        "In this paper we offer the first algorithm addressing this problem for the STAG case.",
        "We present a compile-time algorithm for transforming a STAG into a strongly-equivalent STAG that optimally minimizes k across the grammar.",
        "This is a critical minimization because k is the feature of the grammar that appears in the exponent of the complexity of parsing algorithms for STAG.",
        "Following the method of Seki et al.",
        "(1991), an STAG parser can be implemented with complexity (d(n'(fc+1) • By minimizing k, the worst-case complexity of a parser instantiated for a particular grammar is optimized.",
        "The k-arization algorithm performs in + \\Y\\ ■ Lq) time where Lq is the maximum number of links in any single synchronous tree pair in the grammar and Y is the set of synchronous tree pairs of G. By comparison, a baseline algorithm performing exhaustive search requires 0(\\G\\ + \\ Y\\ ■ Lq) time.",
        "The remainder of the paper proceeds as follows.",
        "In section 2 we provide a brief introduction to the STAG formalism.",
        "We present the fc-arization algorithm in section 3 and an analysis of its complexity in section 4.",
        "We prove the correctness of the algorithm in section 5.",
        "a synchronous tree pair with L links, there are C(L) pairs of valid fragments.",
        "It takes <D(L) time to check if the two components in a pair have the same set of links.",
        "Once the synchronous fragment with the smallest number of links is excised, this process iterates at most L times, resulting in time <D(L%).",
        "vOvP^ V^NP^",
        "a m",
        "a m",
        "b m",
        "b m",
        "C*l]",
        "cm",
        "bm",
        "bm 1",
        "J;",
        "Figure 3: A synchronous tree pair containing fragments aL = 7L(ni,n2) and aR = 7fl(n3).",
        "Since links(ni,n2) = links(n3) = {[2],[4],[5]}, we can define synchronous fragment a = (aL,aR).",
        "Note also that node n3 is a maximal node and node n5 is not."
      ]
    },
    {
      "heading": "2. Synchronous Tree-Adjoining Grammar",
      "text": [
        "A tree-adjoining grammar (TAG) consists of a set of elementary tree structures of arbitrary depth, which are combined by substitution, familiar from context-free grammars, or an operation of adjunction that is particular to the TAG formalism.",
        "Auxiliary trees are elementary trees in which the root and a frontier node, called the foot node and distinguished by the diacritic *, are labeled with the same nonterminal A.",
        "The adjunction operation involves splicing an auxiliary tree in at an internal node in an elementary tree also labeled with nonterminal A.",
        "Trees without a foot node, which serve as a base for derivations, are called initial trees.",
        "For further background, refer to the survey by Joshi and Schabes (1997).",
        "We depart from the traditional definition in notation only by specifying adjunction and substitution sites explicitly with numbered links.",
        "Each link may be used only once in a derivation.",
        "Operations may only occur at nodes marked with a link.",
        "For simplicity of presentation we provisionally assume that only one link is permitted at a node.",
        "We later drop this assumption.",
        "In a synchronous TAG (STAG) the elementary structures are ordered pairs of TAG trees, with a linking relation specified over pairs of nonterminal nodes.",
        "Each link has two locations, one in the left tree in a pair and the other in the right tree.",
        "An example of an STAG derivation including both substitution and adjunction is given in Figure 2.",
        "For further background, refer to the work of Shieber and Schabes (1990) and Shieber (1994)."
      ]
    },
    {
      "heading": "3. fc-arization Algorithm",
      "text": [
        "For a synchronous tree pair 7 = (7^, 7^), a fragment of 7£ (or 7#) is a complete subtree rooted at some node n of 7^, written 7l(«), or else a subtree rooted at n with a gap at node n', written 7l(«, n'); see Figure 3 for an example.",
        "We write links(n) and links(n, n') to denote the set of links of 7l(«) and 7l(«, n), respectively.",
        "When we do not know the root or gap nodes of some fragment aL, we also write links(a:i).",
        "We say that a set of links A from 7 can be isolated if there exist fragments aL and au of 7^ and 7b, respectively, both with links A.",
        "If this is the case, we can construct a synchronous fragment a = {oll,olr).",
        "The goal of our algorithm is to decompose 7 into synchronous fragments such that the maximum number of links of a synchronous fragment is kept to a minimum, and 7 can be obtained from the synchronous fragments by means of the usual substitution and adjunction operations.",
        "In order to simplify the presentation of our algorithm we assume, without any loss of generality, that all elementary trees of the source STAG have nodes with at most two children.",
        "A node n of 7^ (or 7^) is called maximal if (i) links(n) / 0, and (n) it is either the root node of 72, or, for its parent node n', we have links(n') / links(n).",
        "Note that for every node n' of 7^ such that links(n') / 0 there is always a unique maximal node n such that links(n') = links(n).",
        "Thus, for the purpose of our algorithm, we need only look at maximal nodes as places for excising tree fragments.",
        "We can show that the number of maximal nodes Mn in a subtree 7l(«) always satisfies |links(n)| < Mn < 2 x |links(n)| - 1.",
        "Let n be some node of 7^, and let l{n) be the (unique) link impinging on n if such a link exists, and l{n) = e otherwise.",
        "We associate n with a string a{n), defined by a pre-and post-order traversal of fragment 7l(^)- The symbols of a(n) are the links in links(n), viewed as atomic symbols.",
        "Given a node n with p children m,..., np, 0 < p < 2, we define a(n) = l{n) a(n{) ■ ■ ■ a{np)l{n).",
        "See again Figure 3 for an example.",
        "Note that \\a(n)\\ = 2 x |links(n)|.",
        "Il X XX' X X excise adjoin transform",
        "Figure 4: A diagram of the tree transformation performed when fragment 7l(«4, n2) is removed.",
        "In this and the diagrams that follow, patterned or shaded triangles represent segments of the tree that contain multiple nodes and at least one link.",
        "Where the pattern or shading corresponds across trees in a tree pair, the set of links contained within those triangles are equivalent.",
        "Although it would be possible to excise synchronous fragments without creating new nonterminal nodes, for clarity we present a simple tree transformation when a fragment is excised that leaves existing nodes intact.",
        "A schematic depiction is given in Figure 4.",
        "In the figure, we demonstrate the excision process on one half of a synchronous fragment: 7i(ni,n2) is excised to form two new trees.",
        "The excised tree is not processed further.",
        "In the excision process the root and gap nodes of the original tree are not altered.",
        "The material between them is replaced with a single new node with a fresh nonterminal symbol and a fresh link number.",
        "This nonterminal node and link form the adjunction or substitution site for the excised tree.",
        "Note that any link impinging on the root node of the excised fragment is by our convention included in the fragment and any link impinging on the gap node is not.",
        "To regenerate the original tree, the excised fragment can be adjoined or substituted back into the tree from which it was excised.",
        "The new nodes that were generated in the excision may be removed and the original root and gap nodes may be merged back together retaining any impinging links, respectively.",
        "Note that if there was a link on either the root or gap node in the original tree, it is not lost or duplicated in the process.",
        "3.3 Method",
        "Let riL and ur be the root nodes of trees 7^ and 7^, respectively.",
        "We know that links(ni) = links(nR), and |c(n,L)| = \\a{nu)\\, the second string being a rearrangement of the occurrences of symbols in the first one.",
        "The main data structure of our algorithm is a Boolean matrix 7r of size |cr(ni)| x \\ a(riL)\\, whose rows are addressed by the occurrences of symbols in a(riL), in the given order, and whose columns are similarly addressed by a{nR).",
        "For occurrences of links \\xT\\, \\x2\\, the element of 7r at a row addressed by x\\ and a column addressed by X2 is 1 if x 1 = X2, and 0 otherwise.",
        "Thus, each row and column of 7r has exactly two non-zero entries.",
        "See Figure 5 for an example.",
        "For a maximal node ri\\ of 7^, we let n{n\\) denote the stripe of adjacent rows of 7r addressed by substring a{n\\) of a(riL)- If n\\ dominates «2 in 7^, we let 7r(ni, «2) denote the rows of 7r addressed by a{n\\) but not by a{n2)■ This forms a pair of horizontal stripes in tt.",
        "For nodes n%, of 7^, we similarly define n{n3) and n{n3,n^) as vertical stripes of adjacent columns.",
        "See again Figure 5.",
        "Our algorithm is reported in Figure 6.",
        "For each synchronous tree pair 7 = (7l,7b) from the input grammar, we maintain an agenda B with all candidate fragments from 7^ having at least two links.",
        "These fragments are processed greedily in order of increasing number of links.",
        "The function IsolateQ, described in more detail bel: Function Karize(G) {G a.binary STAG} 2: G' < – STAG with empty set of synch trees;",
        "□",
        "i",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "1",
        "m",
        "0",
        "1",
        "0",
        "0",
        "0",
        "0",
        "1",
        "0",
        "0",
        "0",
        "m",
        "0",
        "0",
        "1",
        "1",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "m",
        "0",
        "0",
        "1",
        "1",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "®",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "1",
        "1",
        "0",
        "®",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "1",
        "1",
        "0",
        "m",
        "0",
        "1",
        "0",
        "0",
        "0",
        "0",
        "1",
        "0",
        "0",
        "0",
        "®",
        "0",
        "0",
        "0",
        "0",
        "1",
        "1",
        "0",
        "0",
        "0",
        "0",
        "®",
        "0",
        "0",
        "0",
        "0",
        "1",
        "1",
        "0",
        "0",
        "0",
        "0",
        "□",
        "1",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "0",
        "1",
        "□",
        "HI",
        "®",
        "®",
        "m",
        "®",
        "®",
        "□",
        "4: init 7r and B; 8: if or / null then",
        "ll: update 7r and B; low, looks for a right fragment a# with the same links as a^.",
        "Upon success, the synchronous fragment a = (an,, olr) is added to the output grammar.",
        "Furthermore, we excise a from 7 and update data structures 7r and B.",
        "The above process is iterated until B becomes empty.",
        "We show in section 5 that this greedy strategy is sound and complete.",
        "The function ISOLATE0 is specified in Figure 7.",
        "We take as input a left fragment ctL, which is associated with one or two horizontal stripes in tt, depending on whether ctL has a gap node or not.",
        "The left boundary of ol in 7r is the index x\\ of the column containing the leftmost occurrence of a 1 in the horizontal stripes associated with a^.",
        "Similarly, the right boundary of c<l in it is the index X2 of the column containing the rightmost occurrence of a 1 in these stripes.",
        "We retrieve the shortest substring a(n) of a(riR) that spans over indices x\\ and #2.",
        "This means that n is the lowest node from 7^ such that the links of oil are a subset of the links of 7i?",
        "(n).",
        "If the condition at line 3 is satisfied, all of the matrix entries of value 1 that are found from column X\\ to column X2 fall within the horizontal stripes associated with (xl- In this case we can report the right fragment (Xr = ^r (n).",
        "Otherwise, we check whether the entries of value 1 that fall outside of the two horizontal stripes in between columns X\\ and X2 occur within adjacent columns, say from column xs > X\\ to column X4 < X2.",
        "In this case, we check whether there exists some node n' such that the substring of a(n) from position x3 to X4 is",
        "2: select n g 7_r such that a(n) is the shortest string within a(riR) including left/right boundaries of oil in 7r;",
        "5: select n' e ^r such that a(n') is the gap string within a(n) for which links(n) – links(n') = links(o:i);",
        "6: if n is not defined then",
        "7: return null; {more than one gap} an occurrence of string a(n').",
        "This means that n' is the gap node, and we report the right fragment otL = \"fn(n, n').",
        "See again Figure 5.",
        "We now drop the assumption that only one link may impinge on a node.",
        "When multiple links impinge on a single node n, l(n) is an arbitrary order over those links.",
        "In the execution of the algorithm, any stripe that contains one link in l(n) it must include every link in l(n).",
        "This prevents the excision of a proper subset of the links at any node.",
        "This preserves correctness because excising any proper subset would impose an order over the links at n that is not enforced in the input grammar.",
        "Because the links at a node are treated as a unit, the complexity of the algorithm is not affected."
      ]
    },
    {
      "heading": "4. Complexity",
      "text": [
        "We discuss here an implementation of the algorithm of section 3 resulting in time complexity 0(\\G\\ + \\Y\\ ■ LG), where Y is the set of synchronous tree pairs of G and Lq is the maximum number of links in a synchronous tree pair in Y.",
        "Consider a synchronous tree pair 7 = (7l,7b) with L links.",
        "If M is the number of maximal nodes in 7£ or 7^, we have M = 0(L) (Section 3.1).",
        "We implement the sparse table tt in 0(L) space, recording for each row and column the indices of its two non-zero entries.",
        "We also assume that we can go back and forth between maximal nodes n and strings a(n) in constant time.",
        "Here each a(n) is represented by its boundary positions within a(ni) or a(riR), til and ur the root nodes of 7^ and 7^, respectively.",
        "At line 2 of the function isolateq (Figure 7) we retrieve the left and right boundaries by scanning the rows of 7r associated with input fragment a^-We then retrieve node n by visiting all maximal nodes of 7l spanning these boundaries.",
        "Under the above assumptions, this can be done in time 0(L).",
        "In a similar way we can implement line 5, resulting in overall run time 0{L) for function isolateq.",
        "In the function KARIZE0 (Figure 6) we use buckets Bi, 1 < i < L, where each Bi stores the candidate fragments ol with |links(a:i) | = i.",
        "To populate these buckets, we first process fragments 7l(«) by visiting bottom up the maximal nodes of 7^.",
        "The quantity |links(n)| is computed from the quantities |links(nj)|, where rii are the highest maximal nodes dominated by n. (There are at most two such nodes.)",
        "Fragments 7l(«, n') can then be processed using the relation |links(n,n')| = |links(n)| – |links(n')|.",
        "In this way each fragment is processed in constant time, and population of all the buckets takes 0(L) time.",
        "We now consider the while loop at lines 5 to 11 in function KarizeQ.",
        "For a synchronous tree pair 7, the loop iterates once for each candidate fragment ctL in some bucket.",
        "We have a total of 0(L) iterations, since the initial number of candidates in the buckets is 0(L), and the possible updating of the buckets after a synchronous fragment is removed does not increase the total size of all the buckets.",
        "If the links in cannot be isolated, one iteration takes time 0(L) (the call to function isolateq).",
        "If the links in can be isolated, then we need to restructure 7r and to repopulate the buckets.",
        "The former can be done in time 0(L) and the latter takes time 0(1?",
        "), as already discussed.",
        "Crucially, the updating of 7r and the buckets takes place no more than L – 1 times.",
        "This is because each time we excise a synchronous fragment, the number of links in 7 is reduced by at least one.",
        "We conclude that function Karize () takes time 0(L) for each synchronous tree 7, and the total running time is 0(\\G\\ + \\Y\\ ■ LG), where Y is the set of synchronous tree pairs of G. The term |G| accounts for the reading of the input, and dominates the complexity of the algorithm only in case there are very few links in each synchronous tree pair.",
        "n2--B\\m cm Dm Em",
        "Figure 8: In 7 links M and M cannot be isolated because the fragment would have to contain two gaps.",
        "However, after the removal of fragment 7(ni,n2), an analogous fragment 7'(n3, n4) may be removed."
      ]
    },
    {
      "heading": "5. Proof of Correctness",
      "text": [
        "The algorithm presented in the previous sections produces an optimal fc-arization for the input grammar.",
        "In this section we sketch a proof of correctness of the strategy employed by the algorithm.",
        "The fc-arization strategy presented above is greedy in that it always chooses the excisable fragment with the smallest number of links at each step and does not perform any backtracking.",
        "We must therefore show that this process cannot result in a non-optimal solution.",
        "If fragments could not overlap each other, this would be trivial to show because the excision process would be confluent.",
        "If all overlapping fragments were cases of complete containment of one fragment within another, the proof would also be trivial because the smallest-to-largest excision order would guarantee optimality.",
        "However, it is possible for fragments to partially overlap each other, meaning that the intersection of the set of links contained in the two fragments is non-empty and the difference between the set of links in one fragment and the other is also non-empty.",
        "Overlapping fragment configurations are given in Figure 9 and discussed in detail below.",
        "The existence of partially overlapping fragments complicates the proof of optimality for two reasons.",
        "First, the excision of a fragment a that is partially overlapped with another fragment [3 necessarily precludes the excision of [3 at a later stage in the ex-",
        "X^K.",
        "Figure 9: The four possible configurations of overlapped fragments within a single tree.",
        "For type 1, let a = 7(ni, n3) and (3 = 7(n2, n4).",
        "The roots and gaps of the fragments are interleaved.",
        "For type 1', let a = 7(ni; n3) and f3 = 7(n2).",
        "The root of f3 dominates the gap of a.",
        "For type 2, let a = 7(n5,n6) and f3 = 7(n5,n7).",
        "The fragments share a root and have gap nodes that do not dominate each other.",
        "For type 3 let a = 7(n8, nw) and f3 = 7(n9, nn).",
        "The root of a dominates the root of f3, both roots dominate both gaps, but neither gap dominates the other.",
        "cision process.",
        "Second, the removal of a fragment may cause a previously non-isolatable set of links to become isolatable, effectively creating a new fragment that may be advantageous to remove.",
        "This is demonstrated in Figure 8.",
        "These possibilities raise the question of whether the choice between removing fragments a and [3 may have consequences at a later stage in the excision process.",
        "We demonstrate that this choice cannot affect the k found for a given grammar.",
        "We begin by sketching the proof of a lemma that shows that removal of a fragment [3 that partially overlaps another fragment a always leaves an analogous fragment that may be removed.",
        "Consider a STAG tree pair 7 containing the set of links A and two synchronous fragments a and [3 with a containing links links(o;) and [3 containing links(/3) (links(a),links(/3) C A).",
        "If a and [3 do not overlap, the removal of [3 is defined as validity preserving with respect to a.",
        "If a and [3 overlap, removal of [3 from 7 is validity preserving with respect to a if after the removal there exists a valid synchronous fragment (containing at most one gap on each side) that contains all and only the links (links(o;) – links(/?))",
        "U {m} where \\x\\ is the new link added to 7.",
        "Figure 10: Removal from a tree pair 7 containing type 1-type 2 fragment overlap.",
        "The fragment a is represented by the horizonal-lined pieces of the tree pair.",
        "The fragment p is represented by the vertical-lined pieces of the tree pair.",
        "Cross-hatching indicates the overlapping portion of the two fragments.",
        "We prove a lemma that removal of any synchronous fragment from an STAG tree pair is validity preserving with respect to all of the other synchronous fragments in the tree pair.",
        "It suffices to show that for two arbitrary synchronous fragments a and [3, the removal of [3 is validity preserving with respect to a.",
        "We show this by examination of the possible configurations of a and [3.",
        "Consider the case in which [3 is fully contained within a.",
        "In this case links(/5) C links(o:).",
        "The removal of [3 leaves the root and gap of a intact in both trees in the pair, so it remains a valid fragment.",
        "The new link is added at the new node inserted where [3 was removed.",
        "Since [3 is fully contained within a, this node is below the root of a but not below its gap.",
        "Thus, the removal process leaves a with the links (Iin Vs(a) – Iinks([3)) U {m}, where \\x\\ is the link added in the removal process; the removal is validity preserving.",
        "Synchronous fragments may partially overlap in several different ways.",
        "There are four possible configurations for an overlapped fragment within a single tree, depicted in Figure 9.",
        "These different singletree overlap types can be combined in any way to form valid synchronous fragments.",
        "Due to space constraints, we consider two illustrative cases and leave the remainder as an exercise to the reader.",
        "An example of removing fragments from a tree set containing type 1-type 2 overlapped fragments is given in Figure 10.",
        "Let a = ('jL(ni,n3),-fR(n5,n6)).",
        "Let 13 = (7'L(n2,n4),-fR(n5,n7)).",
        "If a is removed, the validity preserving fragment for [3 is (7^(ni,«4),7^,(^5)).",
        "It contains the links in the vertical-lined part of the tree and the new link \\x\\.",
        "This forms a valid fragment because both sides contain at most one gap and both contain the same set of links.",
        "In addition, it is validity preserving for [3 because it contains exactly the set of links that were in links(/3) and not in links(o;) plus the new link m. If we instead choose to remove [3, the validity preserving fragment for a is {^'L(n\\, «4), 7^(«5)).",
        "The links in each side of this fragment are the same, each side contains at most one gap, and the set of links is exactly the set left over from links(o;) once I inks (/?)",
        "is removed plus the newly generated link \\x\\.",
        "An example of removing fragments from a tree set containing type l'-type 3 (reversed) overlapped fragments is given in Figure 11.",
        "If a is removed, the validity preserving fragment for [3 is (7^(ni), 7^,(^4)).",
        "If [3 is removed, the validity preserving fragment for a is {^'L(n\\, ng), 7#(^4))-",
        "Similar reasoning follows for all remaining types of overlapped fragments.",
        "We show that smallest-first removal of fragments is optimal.",
        "Consider a decision point at which a choice is made about which fragment to remove.",
        "Call the size of the smallest fragments at this point m, and let the set of fragments of size m be X with a, [3 e X.",
        "There are two cases to consider.",
        "First, consider two partially overlapped fragments a e X and 5 (£ X.",
        "Note that |links(o;)| < |links(<T)|.",
        "Validity preservation of a with respect to 5 guarantees that 5 or its validity preserving analog will still be available for excision after a is removed.",
        "Excising 5 increases k more than excising a or any fragment that removal of a will lead to before 5 is considered.",
        "Thus, removal of 5 cannot result in a smaller value for k if it is removed before a rather than after a.",
        "Second, consider two partially overlapped fragments a,/3 g X.",
        "Due to the validity preservation lemma, we may choose arbitrarily between the fragments in X without jeopardizing our ability to later remove other fragments (or their validity preserving analogs) in that set.",
        "Removal of fragment a cannot increase the size of any remaining fragment.",
        "Removal of a or [3 may generate new fragments",
        "remove a /1 I lx remove f!",
        "Figure 11: Removal from a tree pair 7 containing a type l'-type 3 (reversed) fragment overlap.",
        "The fragment a is represented by the horizontal lined pieces of the tree pair.",
        "The fragment f3 is represented by the vertical-lined pieces of the tree pair.",
        "Cross-hatching indicates the overlapping portion of the two fragments.",
        "that were not previously valid and may reduce the size of existing fragments that it overlaps.",
        "In addition, removal of a may lead to availability of smaller fragments at the next removal step than removal of [3 (and vice versa).",
        "However, since removal of either a or [3 produces a A; of size at least m, the later removal of fragments of size less than m cannot affect the k found by the algorithm.",
        "Due to validity preservation, removal of any of these smaller fragments will still permit removal of all currently existing fragments or their analogs at a later step in the removal process.",
        "If the removal of a generates a new fragment 5 of size larger than m all remaining fragments in X (and all others smaller than 5) will be removed before 5 is considered.",
        "Therefore, if removal of [3 generates a new fragment smaller than 5, the smallest-first strategy will properly guarantee its removal before 5."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "In order for STAG to be used in machine translation and other natural-language processing tasks it must be possible to process it efficiently.",
        "The difficulty in parsing STAG stems directly from the factor k that indicates the degree to which the correspondences are intertwined within the elementary structures of the grammar.",
        "The algorithm presented in this paper is the first method available for fc-arizing a synchronous TAG grammar into an equivalent grammar with an optimal value for k. The algorithm operates offline and requires only 0(\\G\\ + \\Y\\ ■ L^) time.",
        "Both the derivation trees and derived trees produced are trivially homomorphic to those that are produced by the original grammar."
      ]
    }
  ]
}
