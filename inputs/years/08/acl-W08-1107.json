{
  "info": {
    "authors": [
      "Carlos Areces",
      "Alexander Koller",
      "Kristina Striegnitz"
    ],
    "book": "Proceedings of the Fifth International Natural Language Generation Conference",
    "id": "acl-W08-1107",
    "title": "Referring Expressions as Formulas of Description Logic",
    "url": "https://aclweb.org/anthology/W08-1107",
    "year": 2008
  },
  "references": [
    "acl-E91-1028",
    "acl-J02-1003",
    "acl-J03-1003",
    "acl-P02-1013",
    "acl-P06-1131",
    "acl-P07-1043",
    "acl-P89-1009",
    "acl-P97-1027",
    "acl-W00-1416",
    "acl-W06-1420",
    "acl-W98-1419"
  ],
  "sections": [
    {
      "text": [
        "Carlos Areces Alexander Koller Kristina Striegnitz",
        "INRIA Nancy Grand Est University of Edinburgh Union College",
        "Nancy, France Edinburgh, UK Schenectady, NY, US",
        "In this paper, we propose to reinterpret the problem of generating referring expressions (GRE) as the problem of computing a formula in a description logic that is only satisfied by the referent.",
        "This view offers a new unifying perspective under which existing GRE algorithms can be compared.",
        "We also show that by applying existing algorithms for computing simulation classes in description logic, we can obtain extremely efficient algorithms for relational referring expressions without any danger of running into infinite regress."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The generation of referring expressions (GRE) is one of the most active and successful research areas in natural language generation.",
        "Building upon Dale and Reiter's work (Dale, 1989; Dale and Reiter, 1995), various researchers have added extensions such as reference to sets (Stone, 2000), more expressive logical connectives (van Deemter, 2002), and relational expressions (Dale and Haddock, 1991).",
        "Referring expressions (REs) involving relations, in particular, have received increasing attention recently; especially in the context of spatial referring expressions in situated generation (e.g. (Kelleher and Kruijff, 2006)), where it seems particularly natural to use expressions such as \"the book on the table\".",
        "However, the classical algorithm by Dale and Haddock (1991) was recently shown to be unable to generate satisfying REs in practice (Viethen and Dale, 2006).",
        "Furthermore, the Dale and Haddock algorithm and most of its successors (such as (Kelleher and Kruijff, 2006)) are vulnerable to the problem of \"infinite regress\", where the algorithm jumps back and forth between generating descriptions for two related individuals infinitely, as in \"the book on the table which supports a book on the table .",
        ".",
        ".",
        "\".",
        "In this paper, we propose to view GRE as the problem of computing a formula of description logic (DL) that denotes exactly the set of individuals that we want to refer to.",
        "This very natural idea has been mentioned in passing before (Krahmer et al., 2003; Gardent and Striegnitz, 2007); however, we take it one step further by proposing DL as an interlingua for comparing the REs produced by different approaches to GRE.",
        "In this way, we can organize existing GRE approaches in an expressiveness hierarchy.",
        "For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van Deemter (2002) extends this language by adding the other propositional connectives, whereas Dale and Haddock (1991) extends it by allowing existential quantification.",
        "Furthermore, the view of GRE as a problem of computing DL formulas with a given extension allows us to apply existing algorithms for the latter problem to obtain efficient algorithms for GRE.",
        "We present algorithms that compute such formulas for the description logics EL (which allows only conjunction and existential quantification) and ALC (which also allows negation).",
        "These algorithms effectively compute REs for all individuals in the domain at the same time, which allows them to systematically avoid the infinite regress problem.",
        "The EL algorithm is capable of generating 67% of the relational REs in the Viethen and Dale (2006) dataset, in about 15 milliseconds.",
        "The ALC algorithm is even faster; it computes relational REs for all 100 individuals in a random model in 140 milliseconds.",
        "The paper is structured as follows.",
        "In Section 2, we will first define description logics.",
        "We will then show how to generate REs by computing DL similarity sets for ALC and EL in Section 3.",
        "In Section 4, we evaluate our algorithms and discuss our results.",
        "Section 5 compares our approach to related research; in particular, it shows how various prominent GRE algorithms fit into the DL framework.",
        "Section 6 concludes and points to future work."
      ]
    },
    {
      "heading": "2. Description logics and similarity",
      "text": [
        "In this paper, we will represent referring expressions as formulas of description logic (Baader et al., 2003).",
        "In order to make this point, we will now deine the two description logics we will be working with: ALC and EL.",
        "Formulas (or concepts) p of ALC are generated by the following grammar:",
        "where p is in the set of propositional symbols prop, and R is in the set of relational symbols rel.",
        "EL is the negation-free fragment of ALC.",
        "Formulas of both ALC and EL are interpreted in ordinary relational first-order models M = (A, || • | | ) where A is a non-empty set and || • || is an interpretation function such that:",
        "||p|| Ç A for p G prop ||R|| Ç A x A for R G rel",
        "||-p| = A - ||pI ||p n p'|| = ||p|| n ||p'|| ||3R.p|| = {i | for some i', G ||R|| and i' G ||p||}.",
        "Every formula of a description logic denotes a set of individuals in the domain; thus we can use such formulas to describe sets.",
        "For instance, in the model in Fig. 1b, the formula flower denotes the set the formula flower n 3in.hat denotes {/2}; and the formula flower n -3in.hat denotes",
        "Different description logics differ in the inventory of logical connectives they allow: While ALC permits negation, EL doesn't.",
        "There are many other description logics in the literature; some that we will get back to in Section 5 are CL (EL without existential quantification, i.e., only conjunctions of atoms); PL (ALC without existential quantification, i.e., propositional logic); and ELU(_,) (EL plus disjunction and atomic negation).",
        "Below, we will use a key notion of formula preservation that we call similarity.",
        "For any DL L, we will say that an individual i is L-similar to i' in a given model M if for any formula p G L such that i G ||p||, we also have i' G ||p||.",
        "Equivalently, there is no L-formula that holds of i but not of i'.",
        "We say that the L-similarity set of some individual i is the set of all individuals to which i is L-similar.",
        "Notice that similarity is not necessarily a symmetrical relation: For instance, /1 is EL-similar to /2 in Fig. 1b, but /2 is not EL-similar to /1 (it satisfies the formula 3 in.",
        "hat and /1 doesn't).",
        "However, ALC similarity is a symmetrical relation because the language contains negation; and indeed, /1 is not ALC-similar to /2 either because it satisfies -3in.hat.",
        "Because ALC is more expressive than EL, it is possible for some individual a to be EL-similar but not ALC similar to some individual b, but not vice versa."
      ]
    },
    {
      "heading": "3. Generating referring expressions",
      "text": [
        "Now we apply description logic to GRE.",
        "The core claim of this paper is that it is natural and useful to view the GRE problem as the problem of computing a formula of some description logic L whose extension is a given target set A of individuals.",
        "-GRE PROBLEM",
        "Input: A model M and a target set A C A.",
        "Output: A formula 92 e L such that ||y>|| = A (if such a formula exists).",
        "In the examples above, it is because flower n Elin.hat denotes exactly {f2} that we can say \"the flower in the hat\" to refer to f2.",
        "This perspective provides a general framework into which many existing GRE approaches fit: Traditional attribute selection (Dale and Reiter, 1995) corresponds to building DL formulas that are conjunctions of atoms; relational REs as in Dale and Haddock (1991) are formulas of EL; and so on.",
        "We will further pursue the idea of organizing GRE approaches with respect to the variant of DL they use in Section 5.",
        "For the rest of this paper, we assume that we are generating a singular RE, i.e., the target set A will be a singleton.",
        "In this case, we will only be able to generate a formula that denotes exactly A = {a} (i.e., a RE that uniquely refers to a) if there is no",
        "cup in bowl c1 b2 f bowl",
        "(b) rabbit in",
        "rabbit r2 rabbit r3 rabbit J r4in",
        "Figure 1: (a) The Dale and Haddock (1991) scenario; (b) the Stone and Webber (1998) scenario.",
        "other individual b to which a is similar; otherwise, any formula that is satisfied by a is also satisfied by b. Conversely, if we know that a is not similar to any other individual, then there is a formula that is satisfied by a and not by anything else; this formula can serve as a unique singular RE.",
        "In other words, we can reduce the L-GRE problem for a given model to the problem of computing the L-similarity sets of this model.",
        "Notice that this use of similarity sets can be seen as a generalization of van Deemter's (2002) \"satellite sets\" to relational descriptions.",
        "In the rest of this section, we will present algorithms that compute the similarity sets of a given model for ALC and EL, together with characteristic formulas that denote them.",
        "In the ALC case, we adapt a standard algorithm from the literature for computing simulation classes; we will then further adapt this algorithm for EL.",
        "In effect, both algorithms compute REs for all individuals in some model at the same time - very efficiently and without any danger of infinite regress.",
        "It can be shown that for ALC, the similarity sets of a finite model coincide exactly with the simulation classes of this model.",
        "Simulation classes have been studied extensively in the literature (see e.g., Blackburn et al.",
        "(2001); Kurtonina and de Ri-jke (1998)), and there are several efficient algorithms for computing ALC-simulation classes (Hopcroft, 1971; Paige and Tarjan, 1987; Dovier et al., 2004).",
        "However, these algorithms will only compute the simulation classes themselves.",
        "Here we extend the Hopcroft (1971) algorithm such that it computes, along with each set, also a formula that denotes exactly this set.",
        "We can then use these formulas as representations of the referring expressions.",
        "The pseudocode for our ALC algorithm is shown as Algorithm 1 (with L = ALC) and Algorithm 2.",
        "Given a model M = (A, | | • | | ), the algorithm computes a set RE of ALC formulas such that {|| p | | | p £ RE} is the set of ALC-similarity sets of M. The algorithm starts with RE = {T} (where ||T|| = A), and successively refines RE by making its elements denote smaller and smaller sets.",
        "It maintains the invariant that at the start and end ofev-ery iteration, {||p|| | p £ RE} is always a partition of A.",
        "The algorithm iterates over all propositional and relational symbols in prop and rel to construct new formulas until either all formulas in RE denote singletons (i.e., there is only one individual that satisfies them), or no progress has been made in the previous iteration.",
        "In each iteration, it calls the procedure adduce(p, RE), which intersects p with any formula p £ RE which does not denote a singleton and which is not equivalent to p and to -p. In this case, it replaces ip in RE by ip n p and ip n -p.",
        "The ALC algorithm computes the ALC-similarity sets of the model in time O(n), where n is the number of individuals in the domain.",
        "However, it will freely introduce negations in the case distinctions, which can make the resulting formula hard to realize (see also Section 4.3).",
        "This is why we also present an algorithm for the EL-similarity sets; EL corresponds to positive relational REs, which are generally much easier to realize.",
        "We obtain the EL algorithm by replacing the call to add^ce in Algorithm 1 by a call to addEC, which is defined in Algorithm 3.",
        "As before, the algorithm maintains a set RE = {pi,..., pn} of formulas (this time of EL) such that ||p1|| U ... U ||pn || = A, and which it refines iteratively.",
        "However, where the ALC algorithm maintains the invariant that ||p11|,..., ||pn|| is a partition of A, we weaken this invariant to the requirement that there are no m > 2 pairwise different indices 1 < i1,... ,im < n such that || pil || = || pi21| U... U || pim ||.",
        "We call pilsubsumed if such a decomposition exists.",
        "Because it maintains a weaker invariant, the set RE may contain more formulas at the same time in the EL algorithm than in the ALC algorithm.",
        "Given that A has an exponential number of subsets, there is a risk that the EL algorithm might have worst-case",
        "Algorithm 1: Computing the L-similarity sets Input: A model M = (A, || • | | ) Output: A set RE of formulas such that",
        "{|| p || | p £ RE} is the set of L-similarity sets of M.",
        "2 for p £ prop do 5 for p £ RE, R £ rel do"
      ]
    },
    {
      "heading": "7. if made no changes to RE then",
      "text": [
        "Algorithm 2: add^ce(p, RE)"
      ]
    },
    {
      "heading": "4. remove p from RE;",
      "text": [
        "Algorithm 3: addEC(p, RE)",
        "3 add p n p to RE"
      ]
    },
    {
      "heading": "4. remove subsumed formulas from RE",
      "text": [
        "exponential runtime (although we are not aware of such worst-case examples).",
        "We leave a more careful complexity analysis for future work.",
        "We presented both algorithms as first refining RE according to propositional symbols, and then by relational expressions of increasing depth.",
        "But actually, propositional symbols can be encoded using new relational symbols (e.g., we could represent that f1 is a flower in Fig. 1 as a relation labeled flower from f1 to an additional dummy element d).",
        "In this way, we don't need to distinguish between propositions and relations, and any arbitrary preference ordering of properties can be used.",
        "Let's try our algorithms on some examples.",
        "We first run the EL algorithm on the model shown in Fig. 1a, which is taken from Dale and Haddock (1991).",
        "The algorithm starts with RE = {T}.",
        "In the first loop, it adds the formulas floor, bowl, cup, and table, and then removes T because it is now subsumed.",
        "Not all of these formulas denote singletons; for instance, || cup|| contains two individuals.",
        "So we iterate over the relations to refine our formulas.",
        "After the first iteration over the relations, we have RE = {floor, bowl n Elon.floor, bowl n Elon.table, cup, table}.",
        "Notice that bowl has become subsumed, but we haven't distinguished the cups and tables further.",
        "Now we can use the split between the bowls to distinguish the cups in the second iteration.",
        "The result of this is RE = {floor, bowl n 3on .floor, bowl n",
        "Elon.table,cup n E!in.",
        "(bowl n Elon.floor),cup n E!in.",
        "(bowl n Elon.table),table}.",
        "At this point, all formulas except table denote singletons, and further iterations don't allow us to refine table; so the algorithm terminates.",
        "Each formula with a singleton extension {a} is a unique description of a; for instance, cup n E!in.",
        "(bowl n Elon.table) is only satisfied by c2, so we may refer to c2 as \"the cup in the bowl on the table\".",
        "Notice that the algorithm didn't focus on any particular individual; it simultaneously generated REs for all individuals except for the two tables (which are similar to each other).",
        "The EL algorithm has a harder time with the example in Fig. 1b (Stone and Webber, 1998).",
        "While it will correctly identify r1 as \"the rabbit in the hat\" and f2 as \"the flower in the hat\", it will not be able to compute a RE for f1 because f1 is EL-similar to f2.",
        "Indeed, the algorithm terminates with RE containing both flower and flowern Elin.hat.",
        "This is a typical pattern for asymmetrical cases of similarity in EL: If there are two formulas p1 and p2 in the output set with ||p11| C ||p2||, then there is generally some individual b £ ||p21| – ||p11| such that all individuals in | p1 | are similar to b, but not vice versa.",
        "By contrast, the ALC algorithm can exploit the greater expressivity of ALC to split flower into the two new formulas flower n Elin.hat and flower n -lEIin.hat, generating a unique RE for f1 as well."
      ]
    },
    {
      "heading": "4. Discussion",
      "text": [
        "We will now describe two experiments evaluating the quality of the EL algorithm's output and the efficiency of both of our algorithms, and we discuss the interface between our algorithms and realization.",
        "To compare the descriptions generated by our algorithm to those humans produce, we use a corpus of human-generated referring expressions collected and made available by Jette Viethen and Robert Dale.",
        "They asked human subjects to describe one of 16 filing cabinet drawers.",
        "The drawers had different colors and were arranged in a four-by-four grid (see Fig. 2).",
        "The human subjects used four non-relational properties (the drawer's color, its column and row number, and whether it is in a corner) and five relational properties (above, below, next to, left of, right of).",
        "Of the 118 referring expressions obtained in the experiment, only 15 use relations.",
        "Viethen and Dale (2006) describe the data in more detail and present results of evaluating the Full Brevity algorithm, the Incremental Algorithm (both by Dale and Reiter (1995)), and the Relational Algorithm (Dale and Haddock, 1991) on this corpus.",
        "The Incremental Algorithm is dependent on a predefined ordering in which properties are added to the description.",
        "Viethen and Dale, therefore, try all possible orderings and evaluate what percentage of descriptions an algorithm can generate with any of them.",
        "The Full Brevity and the Relational Algorithms choose properties based on their discriminatory power and only use the orderings as tie breakers.",
        "Viethen and Dale found that the Incremental Algorithm is capable of generating 98 of the 103 non-relational descriptions.",
        "However, the Relational Algorithm was unable to generate even a single one of the human-generated relational descriptions.",
        "We replicated Viethen and Dale's experiment for the EL algorithm presented above.",
        "In the nonrelational case, our results are the same as theirs for the Incremental Algorithm: the EL algorithm generates 98 of the 103 non-relational descriptions, using four (of the possible) orderings.",
        "This is because the two algorithms perform essentially the same computations if there are no relations.",
        "When we add relations, our algorithm is able to generate 10 of the 15 human-produced relational descriptions correctly (in addition to the 98 nonrelational descriptions).",
        "Fig.",
        "3 gives example outputs of the EL algorithm for three different orderings, which together achieve this coverage.",
        "Of the five human-produced descriptions that the EL algorithm cannot generate, three involve references to sets (the two blues ones in horizontal sequence/the two yellow drawers), and two contain so much redundant information that our algorithm cannot reproduce them: Similarly to the Incremental Algorithm, our algorithm allows for some redundancy, but stops once it has found a distinguishing description.",
        "It does, however, generate other, simpler descriptions for these referents.",
        "Both the EL and the ALC algorithms took about 15 milliseconds to compute distinguishing formulas for all 16 individuals in the Viethen and Dale dataset.",
        "In order to get a more comprehensive picture of the algorithms' efficiency, we ran them on random models with increasing numbers of individuals.",
        "Each model had random interpretations for ten different propositional and four relational symbols; each individual had a 10% chance to be in the extension of each propositional symbol, and each pair of individuals had a 10% chance to be related by a relational symbol.",
        "The results (averaged over 10 runs for each model size) are shown in Fig. 4.",
        "The EL algorithm takes about 350 ms on average to generate relational REs for all individuals in the model ofsize 100, i.e., less than 4 ms on average for each individual.",
        "The ALC algorithm is even faster, at about 140 ms for the model of size 100.",
        "As far as we know, these are by far the fastest published runtimes for",
        "blue",
        "orange",
        "pink",
        "yellow",
        "blue",
        "blue",
        "yellow",
        "pink",
        "orange",
        "10 blue",
        "yellow",
        "orange",
        "16 yellow",
        "pink",
        "14 orange",
        "pink",
        "Figure 3: The relational descriptions from Viethen and Dale (2006), annotated with the drawer id and the outputs of the EL algorithm using three different orderings.",
        "Notice that four descriptions occurred twice in the corpus.",
        "Descriptions that the EL algorithm cannot generate with any ordering are marked by *.",
        "Generated descriptions that match one produced by humans are in boldface.",
        "any relational GRE algorithm in the literature.",
        "Our GRE algorithms do not guarantee that the formula they compute can actually be realized in language.",
        "For example, none of the formulas our algorithms computed in the Viethen and Dale domain contained an atom that would commonly be realized as a noun; the property drawer is never used because it applies to all individuals in the domain.",
        "This particular problem could easily be worked around in a post-processing step.",
        "However, another problem arises from the massive use of negation in the ALC algorithm; it will be hard for any realizer to find a reasonable way of expressing a formula like -EIR.",
        "(-Pn-Q) as a smooth noun phrase.",
        "Although we agree with van Deemter (2002) and others that the careful use of negation and disjunction can improve REs, these connectives must not be overused.",
        "Thus we consider the formulas computed by the EL algorithm \"safer\" with respect to realization.",
        "Of course, we share the problem of interfacing GRE and realization with every other approach that separates these two modules, i.e., almost the entire GRE literature (notable exceptions are, e.g., Ho-racek (1997) and SPUD (Stone and Webber, 1998)).",
        "EL O ALC",
        "Figure 4: Average runtimes (in ms) of the two algorithms on random models with different numbers of individuals.",
        "In principle, we believe that it is a good idea to handle sentence planning and realization in a single module; for instance, SPUD can use its awareness of the syntactic context to generate succinct REs as in \"take the rabbit from the hat\".",
        "We hope that the ideas we have explored here for efficient and expressive RE generation can eventually be combined with recent efficient algorithms for integrated sentence planning and realization, such as in Koller and",
        "Stone (2007).",
        "One problem that arises in our approach is that both algorithms derive some measure of efficiency from their freedom to build formulas without having to respect any linguistic constraints.",
        "It seems straightforward, for instance, to extend Krahmer et al.",
        "'s (2003) approach such that it only considers subgraphs that can actually be realized, because their algorithm proceeds by a genuine search for uniquely identifying subgraphs, and will simply take a different branch of the search if some subgraph is useless.",
        "This would be harder in our case.",
        "Our algorithms don't search in the same way; if we disallow certain refinements of a partition, we have to allow the algorithms to backtrack and thus jeopardize the worst-case polynomial runtime.",
        "Investigating this interplay between efficiency and linguistic constraints is an interesting avenue for future research.",
        "id",
        "human-produced description output of the £L algorithm",
        "2",
        "the orange drawer above the blue drawer",
        "orange n 3above.blue /orange n 3above.(3below.",
        "(orange) n blue) /orange n 3next.",
        "(blue) n 3next.",
        "(pink)",
        "4",
        "the yellow drawer on the top of the pink one",
        "yellow n 3above.pink / yellow n corner n 3above.pink / yellow n corner n 3above.(3next.",
        "(yellow) n pink)",
        "5",
        "* the pink drawer in the fourth column below the yellow one",
        "pink n 3above.orange / pink n 3below.yellow / pink n 3next.",
        "(yellow) n 3above.(3next.",
        "(yellow) n orange)",
        "6",
        "the yellow drawer on top of the yellow drawer (2x) / * the drawer after the two blue ones in horizontal sequence yellow n 3above.yellow / yellow n 3below.pink / yellow n 3next.",
        "(blue) n 3next.",
        "(pink)",
        "7",
        "the blue drawer below the orange one / * the blue drawer below the orange drawer in the second column",
        "bluen3above.",
        "(blue) n 3next.(3above.",
        "(orange) n blue) / blue n 3below.",
        "(orange) / bluen3next.",
        "(blue) n 3next.",
        "(yellow)",
        "10",
        "the blue drawer above the pink drawer (2x)",
        "blue n 3above.",
        "(pink) / blue n 3above.",
        "(pink) n 3below.",
        "(blue) / blue n 3next.",
        "(orange) n 3next.",
        "(yellow)",
        "11",
        "the yellow drawer next to the orange drawer (2x)",
        "yellow n 3above.orange / yellow n 3below.yellow / yellow n 3next.orange",
        "12",
        "the orange drawer below the pink drawer",
        "orange n 3above.",
        "(pink n corner) / orange n 3below.pink / orange n 3next.yellow",
        "14",
        "* the orange drawer below the two yellow drawers (2x)",
        "orange n 3next.",
        "(pink n corner) n 3next.",
        "(pink) / orange n 3below.yellow / orange n 3next.",
        "(pink n corner)"
      ]
    },
    {
      "heading": "5. A unified perspective on GRE",
      "text": [
        "Viewing GRE as a problem of generating DL formulas offers a unified perspective: It is the problem of computing a DL formula with a given extension.",
        "Many existing approaches can be subsumed under this view; we have summarized this for some of them in Fig. 5, along with the DL fragment they use.",
        "We already discussed some of these approaches in Section 3.",
        "Furthermore, the non-relational but negative and disjunctive descriptions generated by van Deemter (2002) are simply formulas of P L; and Gardent (2002) generalizes this into generating formulas of ELU(_), i.e., EL plus disjunction and atomic negation.",
        "The approach presented here fits well into this landscape, and it completes the picture by showing how to generate REs in ALC, which combines all connectives used in any of these previous approaches.",
        "Where our approach breaks new ground is in the way these formulas are computed: It successively refines a decomposition of the domain into subsets.",
        "In this way, it is reminiscent of the Incremental Algorithm, which in fact can be seen as a special case of the EL algorithm.",
        "However, unlike Dale and Haddock (1991) and its successors, such as Kelleher and Kruijff (2006), we do not have to take special precautions to avoid infinite regress.",
        "While Dale and Haddock's algorithm attempts to generate a RE for a single individual, for successive individuals in the model, our algorithms consider all individuals in parallel.",
        "It monotonically refines a partition of the model and never needs to backtrack, and therefore is always guaranteed to terminate.",
        "Perhaps closest in spirit to our approach is Krah-mer et al.",
        "'s graph algorithm (2003), which also computes REs by extending them successively.",
        "However, their subgraphs go beyond the expressive power of ALC in that they can distinguish between \"the dog that bites a dog\" and \"the dog that bites itself\".",
        "The price they pay for this increase in expressive power is an NP-complete worst-case complexity.",
        "Interestingly, Krahmer et al.",
        "themselves discuss the possibility of seeing their subgraphs as formulas of hybrid logic which are satisfied at the points where the subgraph can be embedded; and hybrid logics can be seen as very expressive description logics (Areces and ten Cate, 2006)."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "In this paper, we have explored the idea of viewing the generation of singular REs as the problem of computing a DL formula with a given extension.",
        "We have shown how such formulas can be computed efficiently (for ALC and EL) by adapting existing algorithms from the literature.",
        "The EL algorithm is able to generate 95% of the non-relational and 67% of the relational REs from Viethen and Dale (2006).",
        "Both algorithms are extremely efficient (350 ms and 140 ms respectively to generate relational REs for all individuals in a random model with 100 individuals); to our knowledge, these are by far the fastest runtimes for relational GRE reported in the literature.",
        "We have made our implementation available online at http://code.google.eom/p/ crisp-nlg/wiki/DlGre.",
        "Because they compute referring expressions for all individuals in the domain at once, our algorithms will perform especially strongly in static settings, such as the generation of descriptions for museum exhibits, in which the individuals and their properties don't change much.",
        "However, even in more dynamic settings, our algorithms have a chance to outperform search algorithms like Dale and Haddock's in the average case because they can't get stuck in unproductive branches of the search space.",
        "Nevertheless, one interesting question for future research is how to incrementally update simulation classes when the model changes.",
        "Similarly, it would be interesting to explore how different linguistic constraints and attribute orderings can be taken into account efficiently, how our algorithms could be integrated with more standard DL T-Box inferences, and how they can be adapted to use inverse relations or to compute REs for sets.",
        "In exploring these extensions we will be able to draw on a rich body of literature that has already considered many variants of simulation algorithms addressing similar issues.",
        "GRE algorithm",
        "DL variant",
        "Dale and Reiter(1995)",
        "CL",
        "van Deemter (2002)",
        "PL",
        "Dale and Haddock (1991)",
        "EL",
        "Kelleher and Kruijff (2006)",
        "EL",
        "Gardent (2002)",
        "ELU (-)",
        "In experimenting with the Viethen and Dale data, we found that there is no single ordering that covers all human-produced descriptions, which seems to be in contrast to Dale and Reiter's (1995) assumption that there is only one ordering for each given domain.",
        "In fact, it is not even the case that each speaker consistently uses just one ordering.",
        "An interesting open research question is thus what factors determine which ordering is used.",
        "Unfortunately, both in the Viethen and Dale dataset and in the TUNA corpus (van Deemter et al., 2006), only a minority of referring expressions is relational, maybe because these domains lend themselves very well to row/column style propositional REs.",
        "We are currently collecting REs in a domain in which propositional REs are less preferred.",
        "Acknowledgments.",
        "We are grateful to Hector Geffner (who independently suggested to view GRE as computation of DL formulas), Kees van Deemter, and Emiel Krahmer for interesting discussions.",
        "We also thank Jette Viethen and Robert Dale for making their corpus available, and the reviewers for their comments."
      ]
    }
  ]
}
