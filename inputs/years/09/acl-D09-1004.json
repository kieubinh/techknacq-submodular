{
  "info": {
    "authors": [
      "Hai Zhao",
      "Wenliang Chen",
      "Chunyu Kitt"
    ],
    "book": "EMNLP",
    "id": "acl-D09-1004",
    "title": "Semantic Dependency Parsing of NomBank and PropBank: An Efficient Integrated Approach via a Large-scale Feature Selection",
    "url": "https://aclweb.org/anthology/D09-1004",
    "year": 2009
  },
  "references": [
    "acl-D08-1034",
    "acl-H05-1081",
    "acl-I08-1012",
    "acl-J02-3001",
    "acl-J05-1004",
    "acl-N04-1030",
    "acl-N06-1055",
    "acl-P05-1006",
    "acl-P05-1072",
    "acl-P05-1073",
    "acl-P07-1027",
    "acl-P08-1068",
    "acl-P08-1108",
    "acl-W04-2705",
    "acl-W04-3212",
    "acl-W05-0302",
    "acl-W05-0620",
    "acl-W05-0625",
    "acl-W06-1617",
    "acl-W06-2932",
    "acl-W08-2121",
    "acl-W08-2122",
    "acl-W08-2123",
    "acl-W08-2134",
    "acl-W08-2138",
    "acl-W09-1201",
    "acl-W09-1208",
    "acl-W09-1209"
  ],
  "sections": [
    {
      "text": [
        "Semantic Dependency Parsing of NomBank and PropBank: An Efficient Integrated Approach via a Large-scale Feature Selection *",
        "Hai Zhao(&j&)t, Wenliang Chen(BJC^t)*, Chunyu Kitt(®#M)",
        "^Department of Chinese, Translation and Linguistics City University of Hong Kong Tat Chee Avenue, Kowloon, Hong Kong, China *Language Infrastructure Group, MASTAR Project National Institute of Information and Communications Technology 3-5 Hikari-dai, Seika-cho, Soraku-gun, Kyoto, Japan, 619-0289 haizhao@cityu.edu.hk, chenwl@nict.go.jp",
        "We present an integrated dependency-based semantic role labeling system for English from both NomBank and Prop-Bank.",
        "By introducing assistant argument labels and considering much more feature templates, two optimal feature template sets are obtained through an effective feature selection procedure and help construct a high performance single SRL system.",
        "From the evaluations on the date set of CoNLL-2008 shared task, the performance of our system is quite close to the state of the art.",
        "As to our knowledge, this is the first integrated SRL system that achieves a competitive performance against previous pipeline systems."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "We investigate the possibility to construct an effective integrated system for dependency-based semantic role labeling (SRL) task.",
        "This means in this work that a single system handles all these sub-tasks, predicate identification/disambiguation and argument identification/classification, regardless of whether the predicate is verbal or nominal.",
        "Traditionally, a SRL task, either dependency or constituent based, is implemented as two sub-tasks, namely, argument identification and classification.",
        "If the predicate is unknown, then a predicate identification or disambiguation subtask should be additionally considered.",
        "A pipeline framework is usually adopted to handle all these sub-tasks.",
        "The reason to divide the whole task",
        "This study is partially supported by CERG grant 9040861 (CityU 1318/03H), CityU Strategic Research Grant 7002037.",
        "into multiple stages is two-fold, one is each subtask asks for its favorable features, the other is at the consideration of computational efficiency.",
        "Generally speaking, a joint system is slower than a pipeline system in training.",
        "(Xue and Palmer, 2004) fount out that different features suited for different subtasks of SRL, i.e. argument identification and classification.",
        "The results from CoNLL shared tasks in 2005 and 2008 (Carreras and Marquez, 2005; Koomen et al., 2005; Surdeanu et al., 2008; Johansson and Nugues, 2008), further show that SRL pipeline may be one of the standard to achieve a state-of-the-art performance in practice.",
        "In the recent years, most works on SRL, including two CoNLL shared task in 2004 and 2005, focus on verbal predicates with the availability of PropBank (Palmer et al., 2005).",
        "As a complement to PropBank, NomBank (Meyers et al., 2004) annotates nominal predicates and their corresponding semantic roles using similar semantic framework as PropBank.",
        "Though SRL for nominal predicates offers more challenge, it draws relatively little attention (Jiang and Ng, 2006).",
        "(Pustejovsky et al., 2005) discussed the issue of merging various treebanks, including PropBank, NomBank, and others.",
        "The idea of merging these two different treebanks was implemented in the CoNLL-2008 shared task (Surdeanu et al., 2008).",
        "However, few empirical studies support the necessity of an integrated learning strategy from NomBank and PropBank.",
        "Though aiming at Chinese SRL, (Xue, 2006) reported that their experiments show that simply adding the verb data to the training set of NomBank and extracting the same features from the verb and noun instances will hurt the overall performance.",
        "From the results of CoNLL-2008 shared task, the top system by (Johansson and Nugues, 2008) also used two",
        "Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 30-39, Singapore, 6-7 August 2009.",
        "©2009 ACL and AFNLP",
        "different subsystems to handle verbal and nominal predicates, respectively.",
        "Despite all the above facts, an integrated SRL system still holds some sort of merits, being easier to implement, a single-stage feature selection benefiting the whole system, an all-in-one model outputting all required semantic role information and so on.",
        "The shared tasks at the CoNLL 2008 and 2009 are devoted to the joint learning of syntactic and semantic dependencies, which show that SRL can be well performed using only dependency syntax input.",
        "Using data and evaluation settings of the CoNLL-2008 shared task, this work will only focus on semantic dependency parsing and compares the best-performing SRL system in the CoNLL-2009 shared Task (Zhao et al., 2009b) with those in the CoNLL-2008 shared task (Sur-deanu et al., 2008; Hajic et al., 2009).",
        "Aiming at main drawbacks of an integrated approach, two key techniques will be applied.",
        "1) Assistant argument labels are introduced for the further improvement of argument pruning.",
        "This helps the development of a fast and lightweight SRL system.",
        "2) Using a greedy feature selection algorithm, a large-scale feature engineering is performed on a much larger feature template set than that in previous work.",
        "This helps us find features that may be of benefit to all SRL subtasks as long as possible.",
        "As two optimal feature template sets have been proven available, for the first time we report that an integrated SRL system may provide a result close to the state-of-the-art achieved by those SRL pipelines or individual systems for some specific predicates."
      ]
    },
    {
      "heading": "2. Adaptive Argument Pruning",
      "text": [
        "A word-pair classification is used to formulate semantic dependency parsing as in (Zhao and Kit, 2008).",
        "As for predicate identification or disambiguation, the first word is set as a virtual root (which is virtually set before the beginning of the sentence.)",
        "and the second as a predicate candidate.",
        "As for argument identification/classification, the first word in a word pair is specified as a predicate candidate and the second as an argument candidate.",
        "In either of case, the first word is called a semantic head, and noted as p in our feature representation, the second is called a semantic dependent and noted as a.",
        "Word pairs are collected for the classifier in such order.",
        "The first word of the pair is set to the virtual root at first, the second word is then specified as a predicate candidate.",
        "According to the result that the predicate candidate is classified or proven to be non-predicate, 1) the second word is reset to next predicate candidate if the answer is non-predicate, otherwise, 2) the first word of the pair is reset to the predicate that is just determined, and the second is set to every argument candidates one by one.",
        "The classifier will scan the input sentence from left to right to check if each word is a true predicate.",
        "Without any constraint, all word pairs in an input sequence must be considered by the classifier, leading to poor computational efficiency and unnecessary performance loss.",
        "Thus, the training sample for SRL task needs to be pruned properly.",
        "We use a simple strategy to prune predicate candidates, namely, only verbs and nouns are chosen in this case.",
        "There are two paths to collect argument candidates over the sequence.",
        "One is based on an input syntactic dependency tree, the other is based on a linear path of the sentence.",
        "As for the former (hereafter it is referred to synPth), we continue to use a dependency version of the pruning algorithm of (Xue and Palmer, 2004).",
        "The pruning algorithm is readdressed as the following.",
        "Initialization: Set the given predicate as the current node;",
        "(1) The current node and all of its syntactic children are selected as argument candidates (children are traversed from left to right.",
        ").",
        "(2) Reset the current node to its syntactic head and repeat step (1) until the root is reached.",
        "Note that this pruning algorithm is slightly different from that of (Xue and Palmer, 2004), the predicate itself is also included in the argument candidate list as the nominal predicate sometimes takes itself as its argument.",
        "The above pruning algorithm has been shown effective.",
        "However, it is still inefficient for a SRL system that needs to tackle argument identification/classification in a single stage.",
        "Assuming that arguments trend to surround their predicate, an assistant argument label ' -NoMoreArgumenf is introduced for further pruning.",
        "If an argument candidate in the above algorithm is assigned to such a label, then the pruning algorithm will end immediately.",
        "In training, this assistant label means no more samples will be generated for the current predicate, while in test, the decoder will not search arguments any more.",
        "It will be seen that this adaptive technique more effectively prunes argument candidates without missing more true arguments.",
        "Along the linear path (hereafter referred to UnPth), the classifier will search all words before and after the predicate.",
        "Similar to the pruning algorithm for synPth, we also introduce two assistant argument labels 'jioLeff and 'jioRighf to adaptively prune words too far away from the predicate.",
        "To show how assistant argument labels actually work, we give an example for UnPth.",
        "Suppose an input sequence with argument labels for a predicate is abed e f g h .",
        "Note that c and g are two boundary words as no more arguments appear before or after them.",
        "After two assistant argument labels are added, it will be abc d e / g h .",
        "Training samples will generated from c to g according to the above sequence.",
        "We use a Maximum Entropy classifier with a tunable Gaussian prior as usual.",
        "Our implementation of the model adopts L-BFGS algorithm for parameter optimization."
      ]
    },
    {
      "heading": "3. Feature Templates",
      "text": [
        "Motivated by previous works, we carefully consider those factors from a wide range of features that can help semantic role labeling for both predicate disambiguation, argument's identification and classification as the predicate is either verbal or nominal.",
        "These works include (Gildea and Juraf-sky, 2002; Carreras and Marquez, 2005; Koomen et al., 2005; Marquez et al., 2005; Dang and Palmer, 2005; Pradhan et al., 2005; Toutanova et al., 2005; Jiang and Ng, 2006; Liu and Ng, 2007; Surdeanu et al., 2007; Johansson and Nugues, 2008; Che et al., 2008).",
        "Most feature templates that we will adopt for this work will come from various combinations or integrations of the following basic elements.",
        "Word Property.",
        "This type of elements include word form (form and its split form, spForm), lemma (lemma,spLemma), and part-of-speech tag (pos, spPos), syntactic dependency label (dprel), and semantic dependency label (semdprelf.",
        "Syntactic Connection.",
        "This includes syntactic head (h), left(right) farthest(nearest) child (Im, In, rm, and rn), and high(low) support verb or noun.",
        "We explain the last item, support verb(noun).",
        "From a given word to the syntactic root along the syntactic tree, the first verb/noun/preposition that is met is called as its low support verb/noun/preposition, and the nearest one to the root is called as its high support verb/noun/preposition.",
        "The concept of support verb was broadly used (Toutanova et al., 2005; Xue, 2006; Jiang and Ng, 2006), we here extend it to nouns and prepositions.",
        "In addition, we introduce a slightly modified syntactic head, pphead, it returns the left most sibling of a given word if the word is headed by a preposition, otherwise it returns the original head.",
        "Path.",
        "There are two basic types of path between the predicate and the argument candidates.",
        "One is the linear path (linePath) in the sequence, the other is the path in the syntactic parsing tree (dp-Path).",
        "For the latter, we further divide it into four subtypes with respect to the syntactic root, dp-Path is the full path in the syntactic tree.",
        "Leading two paths to the root from the predicate and the argument, respectively, the common part of these two paths will be dpPathShare.",
        "Assume that dp-PathShare starts from a node r', then dpPathPred is from the predicate to r, and dpPathArgu is from the argument to r'.",
        "Family.",
        "Two types of children sets for the predicate or argument candidate are considered, the first includes all syntactic children (children), the second also includes all but excludes the left most and the right most children (noFarChildren).",
        "Concatenation of Elements.",
        "For all collected elements according to linePath, children and so on, we use three strategies to concatenate all those strings to produce the feature value.",
        "The first is seq, which concatenates all collected strings without doing anything.",
        "The second is bag, which removes all duplicated strings and sort the rest.",
        "The third is noDup, which removes all duplicated neighbored strings.",
        "We address some other elements that are not included by the above description as the following.",
        "dpTreeRelation.",
        "It returns the relationship of a and p in the input syntactic tree.",
        "The possible values for this feature include parent, sibling etc.",
        "isCurPred.",
        "It judges if a given word is the current predicate.",
        "If the word is the predicate, then it returns the predicate itself, otherwise it returns a default value.",
        "existCross.",
        "It judges if a forthcoming dependency relation that is between a given word pair may cause any cross with all existing dependency relations.",
        "distance.",
        "It counts the number of words along a given path, either dpPath or linePath.",
        "existSemdprel.",
        "It checks if the given argument label for other predicates has been assigned to a given word.",
        "voice.",
        "This feature returns Active or Passive for verbs, and a default value for nouns.",
        "baseline.",
        "Two types of semantic role baseline outputs are used for features from (Carreras and Marquez, 2005).",
        "baseline-Ax tags the head of the first NP before the predicate as AO and the head of the first NP after the predicate as Al.",
        "baseline-Mod tags the dependant of the predicate as AM-MOD as it is a modal verb.",
        "We show some feature template examples derived from the above mentioned items.",
        "a.lm.lemma The lemma of the left most child of the argument candidate.",
        "p.h.",
        "dprel The dependant label of the syntactic head of the predicate candidate.",
        "P-i.pos+p.pos pos of the previous word of the predicate and PoS of the predicate itself.",
        "a:p\\dpPath.lemma.bag Collect all lemmas along the syntactic tree path from the argument to the predicate, then removed all duplicated ones and sort the rest, finally concatenate all as a feature string.",
        "a:p. highSupportNoun \\ linePath.",
        "dprel.",
        "seq Collect all dependant labels along with the line path from the argument to the high support noun of the predicate, then concatenate all as a feature string.",
        "Based on the above mentioned elements, 781 feature templates (hereafter the set of these templates is referred to FT) are initially considered.",
        "Feature templates in this initial set are constructed in a generalized way.",
        "For example, if we find that a feature template a.lm.lemma was once used in some existing work, then such three templates, a.rm.lemma, a.rn.lemma, a.ln.lemma will be also added into the set.",
        "As an optimal feature template subset cannot be expected to be extracted from so large a set by hand, a greedy feature selection similar to that in (Jiang and Ng, 2006; Ding and Chang, 2008) is applied.",
        "The detailed algorithm is described in Algorithm 1.",
        "Assuming that the number of feature templates in a given set is n, the algorithm of (Ding and Chang, 2008) requires 0{n) times of training/test routines, it cannot handle a set that consists of hundreds of templates.",
        "As the time complexity of Algorithm 1 is only 0{n), it permits a large scale feature selection accomplished by paying a reasonable time cost.",
        "Though the time complexity of the algorithm given by (Jiang and Ng, 2006) is also linear, it should assume all feature templates in the initial selected set 'good' enough and handles other feature template candidates in a strict incremental way.",
        "However, these two constraints are not easily satisfied in our case, while Algorithm 1 may release these two constraints.",
        "Choosing the first 1/10 templates in FT as the initial selected set S, the feature selection is performed for two argument candidate traverse schemes, synPth and UnPth, respectively.",
        "4686 machine learning routines run for the former, while 6248 routines for the latter.",
        "Two feature template sets, FTsyn and FTun, are obtained at last.",
        "These two sets are given in Table 1-3.",
        "We see that two sets share 30 identical feature templates as in Table 1.",
        "FTsyn holds 51 different templates",
        "Table 1 : Feature templates for both synPth and UnPth as in Table 2 and FTun holds 57 different templates as in Table 3.",
        "In these tables, the subscripts -2(or -1) and l(or 2) stand for the previous and next words, respectively.",
        "For example, a.lni-i.lemma returns the lemma of the previous word of the argument's left most child."
      ]
    },
    {
      "heading": "4. Decoding",
      "text": [
        "After the predicate sense is disambiguated, an optimal argument structure for each predicate is determined by the following maximal probability.",
        "where Sp is the argument structure, P{ai\\ai-\\...) is the conditional probability to determine the label of the i-th argument candidate label.",
        "A beam search algorithm is used to find the optimal argument structure."
      ]
    },
    {
      "heading": "5. Evaluation Results",
      "text": [
        "Our evaluation is performed on the standard training/development/test corpus of CoNLL-2008 shared task.",
        "The data is derived by merging a dependency version of the Penn Treebank with Prop-Bank and NomBank.",
        "More details on the data are Algorithm 1 Greedy Feature Selection Input:",
        "The set of all feature templates: FT The set of selected feature templates: So",
        "The set of selected feature templates: S Procedure:",
        "Let the counter i = 1 while do",
        "Train a model with features according to Si, test on development set and the result is pi.",
        "Let Cr = null.",
        "for each feature template fj in set Si do",
        "Let S' = Si – fj.",
        "Train a model with features according to S', test on development set and the result is p'.",
        "if p' > pi then",
        "Cr = Cr + fj.",
        "end if end for Si = Si CrLet Si = St",
        "Train a model with features according to S'ittest on development set and the result is",
        "Let Cr = null for each feature template fj in set C do",
        "LetC^^ + Z,.",
        "Train a model with features according to C, test on development set and the result is p'.",
        "if p' > qi then if Si = 5j_i(No feature templates are added or removed) or, neither pi nor Qi is larger than Pi-1 and Qi-i then",
        "Output S = argmaxp.",
        "qi{Si, S^} and the",
        "algorithm ends, else",
        "_",
        "p.lm.dprel",
        "_",
        "p.rm.dprel",
        "_",
        "p.spForm",
        "-",
        "P-i.spLemma",
        "_",
        "p.spLemma",
        "-",
        "P-\\.",
        "spLemma+p.",
        "spLemma",
        "_",
        "p.spLemma + pi.spLemma",
        "_",
        "p.spLemma + p.h.spForm",
        "_",
        "p.spLemma + p.currentSense",
        "p.lemma",
        "_",
        "p.lemma + pi.lemma",
        "-",
        "P-i.pos+p.pos",
        "a. isCurPred.",
        "lemma",
        "a-2-isCurPred.lemma + a-i.isCurPred.lemma",
        "a. isCurPred.",
        "spLemma",
        "a-i.isCurPred.spLemma + a.isCurPredspLemma",
        "a.isCurPredspLemma + a\\.isCurPred.spLemma",
        "_",
        "a. children, dprel.",
        "bag",
        "_",
        "a_i.",
        "spLemma + a.spLemma",
        "_",
        "a_i.",
        "spLemma + a.dprel",
        "_",
        "a_i.",
        "spLemma + a.dprel + a.h.spLemma",
        "_",
        "a.lm-i.spLemma",
        "_",
        "a.rm-i.dprel + a.spPos",
        "-",
        "a-i.lemma + a.dprel + a.h.lemma",
        "-",
        "a.lemma + p.lemma",
        "-",
        "a.pos + p.pos",
        "_",
        "a.spLemma + p.spLemma",
        "_",
        "a:p 1 dpPath.",
        "dprel",
        "_",
        "a:p 1 dpPathArgu.",
        "dprel",
        "-",
        "a:p 1 dpPathPred.",
        "spPos",
        "\"This feature checks if the dependant type is OBJ.",
        "badv means all adverbs.",
        "_",
        "p-",
        ".lemma + p.lemma",
        "-",
        "P-2-p0s",
        "-",
        "p.pos",
        "-",
        "P-2-spForm + p-i.spForm",
        "_",
        "pi.",
        "spForm",
        "_",
        "p.spForm + p.children.dprel.noDup",
        "_",
        "p.lm.spPos",
        "_",
        "p.spForm + p.lm.spPos",
        "+ p.noFarChildren.spPos.bag + p.rm.spPos",
        "_",
        "p.dprel",
        "_",
        "p. children, dprel.",
        "bag",
        "_",
        "p.children.pos.seq",
        "-",
        "p.dprel = OBJ ?",
        "a",
        "_",
        "a.dprel",
        "_",
        "a_]",
        ".lemma + ai.lemma",
        "_",
        "a\\.lemma",
        "-",
        "a-i.pos",
        "_",
        "ai.spPos",
        "_",
        "a.h.lemma",
        "_",
        "a.h.spLemma",
        "_",
        "a.pphead.",
        "lemma",
        "_",
        "a.pphead.",
        "spLemma",
        "-",
        "a.lm.dprel + a.spPos",
        "-",
        "a.rm-i.pos",
        "_",
        "a.spLemma + a.h.spPos",
        "_",
        "a. existS emdp rel-AI",
        "_",
        "a.dprel = OBJ ?",
        "_",
        "a.form + a.children.pos.seq",
        "-",
        "a. children, adv.",
        "bagb",
        "a:p",
        "linePath.",
        "distance",
        "_",
        "a:p",
        "dpPath.distance",
        "_",
        "a:p",
        "existCross",
        "_",
        "a:p",
        "dpPath.",
        "dprel.",
        "bag",
        "_",
        "a:p",
        "dpPathPred.",
        "dp rel.",
        "bag",
        "_",
        "a:p",
        "dp Path, sp Form, seq",
        "_",
        "a:p",
        "dpPathArgu.",
        "spForm.",
        "seq",
        "_",
        "a:p",
        "dpPathPred.spForm.bag",
        "_",
        "a:p",
        "dpPath.",
        "spLemma.",
        "seq",
        "_",
        "a:p",
        "dpPathArgu.",
        "spLemma.",
        "seq",
        "_",
        "a:p",
        "dpPathArgu.spLemma.bag",
        "_",
        "a:p",
        "dpPathPred.",
        "spLemma.",
        "bag",
        "_",
        "a:p",
        "dpPath.spPos.",
        "bag",
        "_",
        "a:p",
        "dpPathPred.spPos.",
        "bag",
        "_",
        "(a:p\\dpPath.dprel.seq) + p.spPos",
        "_",
        "(a:p\\dpTreeRelation) + a.spPos",
        "_",
        "(a:p\\dpTreeRelation) + p.spPos",
        "_",
        "(a.highSupportVerb:p\\dpTreeRelation) + a.spPos",
        "_",
        "a. MghSupportNoun:p \\ dpPath.",
        "dprel.",
        "seq",
        "_",
        "a. lowSupportVerb:p \\ dpPath.",
        "dprel.",
        "seq",
        "_",
        "a:p 1 linePath.",
        "spForm.",
        "bag",
        "_",
        "a:p 1 linePath.",
        "spLemma.",
        "bag",
        "-",
        "a:p 1 linePath.",
        "spLemma.",
        "seq",
        "_",
        "p. currents ens e + a.spLemma",
        "p.currentSense + a.spPos",
        "_",
        "p.voice + (a:p\\direction)",
        "_",
        "p. rm.",
        "dp rel",
        "-",
        "p.children.dprel.noDup",
        "_",
        "p. rm.form",
        "_",
        "p.lowSupportNoun.spFonn",
        "-",
        "p. lowSupportProp:p \\ dpTreeRelation",
        "-",
        "P-2-form + p-i.form",
        "_",
        "p.voice",
        "_",
        "p.form + p.children.dprel.noDup",
        "_",
        "p.pos + p.dprel",
        "-",
        "p.spForm + p. children, dp rel.",
        "bag",
        "_",
        "a.voice + (a:p\\direction)",
        "a-i.is CurPred.",
        "lemma",
        "a i. is CurPred.",
        "lemma",
        "ci-i.isCurPred.lemma + a.isCurPred.",
        "lemma",
        "a. isCurPred.lemma + ai.",
        "isCurPred.",
        "lemma",
        "_",
        "a\\.isCurPred.spLemma",
        "a-2.isCurPred.spLe/nina + a _i.",
        "is CurPred.",
        "spLemma",
        "_",
        "a.baseline-Ax + a.voice + (a:p\\direction)",
        "a.baseline_Mod",
        "_",
        "a. h. children, dp rel.",
        "bag",
        "_",
        "a.lm.dprel + a.dprel",
        "_",
        "a.lm.dprel + a.pos",
        "a.lm-i.lemma",
        "a.lm.lemma",
        "_",
        "a.lm\\.lemma",
        "_",
        "a.lm.pos + a.pos",
        "_",
        "a.lm.spForm",
        "_",
        "a.lni-i.spPos",
        "_",
        "a.lm.spPos",
        "_",
        "a.ln.dprel + a.pos",
        "_",
        "a.noFarChildren.spPos.bag + a.rm.spPos",
        "_",
        "a.children.spPos.seq + p.children.spPos.seq",
        "_",
        "a.rm.dprel + a.pos",
        "_",
        "a.rm-i.spPos",
        "_",
        "a.rm.spPos",
        "_",
        "a.rmi.spPos",
        "-",
        "a.rn.dprel + a.spPos",
        "-",
        "a.form",
        "-",
        "a.form + a\\.form",
        "_",
        "a.form + a.pos",
        "_",
        "a-i.lemma",
        "_",
        "a-i.lemma + a.lemma",
        "_",
        "a-2-pos",
        "_",
        "a.spForm + ai.spForm",
        "_",
        "a. spForm + a.spPos",
        "_",
        "a.spLemma + ai.spLemma",
        "_",
        "a.spForm + a. children, sp Pos.",
        "seq",
        "_",
        "a.spForm + a. children.",
        "spPos.",
        "bag",
        "_",
        "a.spLemma + a.h. spForm",
        "_",
        "a.spLemma + a.pphead.spForm",
        "-",
        "a. existS emdprel-A2",
        "_",
        "a:p 1 dpPathArg u.pos.",
        "seq",
        "_",
        "a:p 1 dpPathPred.",
        "dprel.",
        "seq",
        "-",
        "a:p\\dpTreeRelation",
        "in (Surdeanu et al., 2008).",
        "Note that CoNLL-2008 shared task is essentially a joint learning task for both syntactic and semantic dependencies, however, we will focus on semantic part of this task.",
        "The main semantic measure that we adopt is semantic labeled F\\ score (Sem-Fi).",
        "In addition, the macro labeled F\\ scores (Macro-Fi), which was used for the ranking of the participating systems of CoNLL-2008, the ratio between labeled F\\ score for semantic dependencies and the LAS for syntactic dependencies (Sem-Fi/LAS), are also given for reference.",
        "We consider three types of syntactic information to feed the SRL task.",
        "One is gold-standard syntactic input, and other two are based on automatically parsing results of two parsers, the state-of-the-art syntactic parser described in (Johansson and Nugues, 2008)(it is referred to Johansson) and an integrated parser described as the following (referred to MSTme)-",
        "The parser is basically based on the MSTParserusing all the features presented by (McDonald et al., 2006) with projective parsing.",
        "Moreover, we exploit three types of additional features to improve the parser.",
        "1) Chen et al.",
        "(2008) used features derived from short dependency pairs based on large-scale auto-parsed data to enhance dependency parsing.",
        "Here, the same features are used, though all dependency pairs rather than short dependency pairs are extracted along with the dependency direction from training data rather than auto-parsed data.",
        "2) Koo et al.",
        "(2008) presented new features based on word clusters obtained from large-scale unlabeled data and achieved large improvement for English and Czech.",
        "Here, the same features are also used as word clusters are generated only from the training data.",
        "3) Nivre and McDonald (2008) presented an integrating method to provide additional information for graph-based and transition-based parsers.",
        "Here, we represent features based on dependency relations predicted by transition-based parsers for the MSTParer.",
        "For the sake of efficiency, we use a fast transitionbased parser based on maximum entropy as in Zhao and Kit (2008).",
        "We still use the similar feature notations of that work.",
        "At first, we report the effectiveness of the proposed adaptive argument pruning.",
        "The numbers of argument candidates are in Table 4.",
        "The statistics is conducted on three different syntactic inputs.",
        "The coverage rate in the table means the ratio of how many true arguments are covered by the selected pruning scheme.",
        "Note that the adaptive pruning of argument candidates using assistant labels does not change this rate.",
        "This ratio only depends on which path, either synPth or linPth, is chosen, and how good the syntactic input is (if synPth is the case).",
        "From the results, we see that more than a half of argument candidates can be effectively pruned for synPth and even 2/3 for linPth.",
        "As mentioned by (Pradhan et al., 2004), argument identification plays a bottleneck role in improving the performance of a SRL system.",
        "The effectiveness of the proposed additional pruning techniques may be seen as a significant improvement over the original algorithm of (Xue and Palmer, 2004).",
        "The results also indicate that such an assumption holds that arguments trend to close with their predicate, at either type of distance, syntactic or linear.",
        "Based on different syntactic inputs, we obtain different results on semantic dependency parsing as shown in Table 5.",
        "These results on different syntactic inputs also give us a chance to observe how semantic performance varies according to syntactic performance.",
        "The fact from the results is that the ratio Sem-Fi/LAS becomes relatively smaller as the syntactic input becomes better.",
        "Though not so surprised, the results do show that the argument traverse scheme synPth always outperforms the other linPth.",
        "The result of this comparison partially shows that an integrated semantic role labeler is sensitive to the order of how argument candidates are traversed to some extent.",
        "Parser",
        "Path",
        "Adaptive Pruning",
        "Coverage Rate",
        "/wo /w",
        "Gold",
        "synPth",
        "2.13M 1.05M",
        "(49.30%)",
        "98.4%",
        "linPth",
        "5.29M 1.57M (29.68%)",
        "100.0%",
        "Johansson",
        "synPth",
        "2.15M 1.06M (49.30%)",
        "95.4%",
        "linPth",
        "5.28M 1.57M",
        "(29.73%)",
        "100.0%",
        "MSTme",
        "synPth",
        "2.15M 1.06M (49.30%)",
        "95.0%",
        "linPth",
        "5.29M 1.57M (29.68%)",
        "100.0%",
        "synPth+FTSyn",
        "linPth+FTun",
        "Syn-Parser",
        "LAS",
        "Sem",
        "Sem-Fi",
        "Sem",
        "Sem-Fi",
        "F!",
        "/LAS",
        "fi",
        "/LAS",
        "MSTme",
        "88.39",
        "80.53",
        "91.10",
        "79.83",
        "90.31",
        "Johansson",
        "89.28",
        "80.94",
        "90.66",
        "79.84",
        "89.43",
        "Gold",
        "100.00",
        "84.57",
        "84.57",
        "83.34",
        "83.34",
        "The performance given by synPth is compared to some other systems that participated in the CoNLL-2008 shared task.",
        "They were chosen among the 20 participating systems either because they held better results (the first four participants) or because they used some joint learning techniques (Henderson et al., 2008).",
        "The results of (Titov et al., 2009) that use the similar joint learning technique as (Henderson et al., 2008) are also included.",
        "Results of these evaluations on the test set are in Table 6.",
        "Top three systems of CoNLL-2008, (Johansson and Nugues, 2008; Ciaramita et al., 2008; Che et al., 2008), used SRL pipelines.",
        "In this work, we partially use the similar techniques (synPth) for our participation in the shared tasks of CoNLL-2008 and 2009 (Zhao and Kit, 2008; Zhao et al., 2009b; Zhao et al., 2009a).",
        "Here we report that all SRL subtasks are tackled in one integrated model, while the predicate disambiguation subtask was performed individually in both of our previous systems.",
        "Therefore, this is our first attempt at a full integrated SRL system.",
        "(Titov et al., 2009) reported the best result by using joint learning technique up to now.",
        "The comparison indicates that our integrated system outputs a result quite close to the state-of-the-art by the pipeline system of (Johansson and Nugues, 2008) as the same syntactic structure input is adopted.",
        "It is worth noting that our system actually competes with two independent subsystems of (Johansson and Nugues, 2008), one for verbal predicates, the other for nominal predicates.",
        "In addition, the results of our system is obtained without using additional joint learning technique like syntactic-semantic reranking.",
        "It indicates that our system is expected to obtain some further performance improvement by using such techniques."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "We have described a dependency-based semantic role labeling system for English from NomBank and PropBank.",
        "From the evaluations, the result of our system is quite close to the state of the art.",
        "As to our knowledge, it is the first integrated SRL system that achieves such a competitive performance against previous pipeline systems.",
        "According to the path that the word-pair classifier traverses argument candidates, two integration schemes are presented.",
        "Argument candidate pruning and feature selection are performed on them, respectively.",
        "These two schemes are more than providing a trivial comparison.",
        "As assistant labeled are introduced to help further argument candidate pruning, and this techniques work well for both schemes, it support the assumption that arguments trend to surround their predicate.",
        "The proposed feature selection procedure also work for both schemes and output quite different two feature template sets, and either of the sets helps the system obtain a competitive performance, this fact suggests that the feature selection procedure is robust and effective, too.",
        "Either of the presented integrated systems can provide a competitive performance.",
        "This conclusion about basic learning scheme for SRL is some different from previous literatures.",
        "However, according to our results, there does exist a 'harmony' feature template set that is helpful to both predicate and argument identification/classification, or SRL for both verbal and nominal predicates.",
        "We attribute this different conclusion to two main factors, 1) much more feature templates (for example, ten times more than those used by Xue et al.)",
        "than previous that are considered for a successful feature engineering, 2) a maximum entropy classifier makes it possible to accept so many various features in one model.",
        "Note that maximum entropy is not so sensitive to those (partially) overlapped features, while SVM and other margin-based learners are not so."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "Our thanks give to Dr. Richard Johansson, who kindly provided the syntactic output for his participation in the CoNLL-2008 shared task.",
        "\"Ranking according to Sem-Fi *Labeled Fi for predicate identification and classification cLabeled Fi for argument identification and classification ^Labeled Fi for verbal predicates \"Labeled Fi for nominal predicates",
        "f* means post-evaluation results, which are available at the official website of CoNLL-2008 shared task, http://www.yr-bcn.es/dokuwiki/doku.php?id=conll2008:start.",
        "Systems\"",
        "LAS",
        "Sem-Fi",
        "Macro",
        "Fi",
        "Sem-Fi /LAS",
        "pred-Fi*",
        "argu-_Fic",
        "Verb-iV",
        "Nomi-iV",
        "Johansson^OOS*",
        "89.32",
        "81.65",
        "85.49",
        "91.41",
        "87.22",
        "79.04",
        "84.78",
        "77.12",
        "Ows'.Johansson",
        "89.28",
        "80.94",
        "85.12",
        "90.66",
        "86.57",
        "78.30",
        "83.66",
        "76.93",
        "Ows:MSTme",
        "88.39",
        "80.53",
        "84.93",
        "91.10",
        "86.80",
        "77.60",
        "82.77",
        "77.23",
        "Johansson:2008",
        "89.32",
        "80.37",
        "84.86",
        "89.98",
        "85.40",
        "78.02",
        "84.45",
        "74.32",
        "Ciaramita: 2008*",
        "87.37",
        "78.00",
        "82.69",
        "89.28",
        "83.46",
        "75.35",
        "80.93",
        "73.80",
        "Che:2008",
        "86.75",
        "78.52",
        "82.66",
        "90.51",
        "85.31",
        "75.27",
        "80.46",
        "75.18",
        "Zhao:2008*",
        "87.68",
        "76.75",
        "82.24",
        "87.53",
        "78.52",
        "75.93",
        "78.81",
        "73.59",
        "Ciaramita: 2008",
        "86.60",
        "77.50",
        "82.06",
        "89.49",
        "83.46",
        "74.56",
        "80.15",
        "73.17",
        "Titov:2009",
        "87.50",
        "76.10",
        "81.80",
        "86.97",
        "-",
        "-",
        "-",
        "-",
        "Zhao:2008",
        "86.66",
        "76.16",
        "81.44",
        "87.88",
        "78.26",
        "75.18",
        "77.67",
        "73.28",
        "Henderson:2008*",
        "87.64",
        "73.09",
        "80.48",
        "83.40",
        "81.42",
        "69.10",
        "75.84",
        "68.90",
        "Henderson:2008",
        "86.91",
        "70.97",
        "79.11",
        "81.66",
        "79.60",
        "66.83",
        "73.80",
        "66.26",
        "Ours: Go Id",
        "100.0",
        "84.57",
        "92.20",
        "84.57",
        "87.67",
        "83.15",
        "88.71",
        "78.39"
      ]
    }
  ]
}
