{
  "info": {
    "authors": [
      "Fabio Massimo Zanzotto",
      "Lorenzo Dell'Arciprete"
    ],
    "book": "EMNLP",
    "id": "acl-D09-1010",
    "title": "Efficient kernels for sentence pair classification",
    "url": "https://aclweb.org/anthology/D09-1010",
    "year": 2009
  },
  "references": [
    "acl-H05-1049",
    "acl-P02-1034",
    "acl-P03-1005",
    "acl-P03-2041",
    "acl-P04-1043",
    "acl-P06-1051"
  ],
  "sections": [
    {
      "text": [
        "DISP",
        "zanzottooinfo.uniroma2.it",
        "In this paper, we propose a novel class of graphs, the tripartite directed acyclic graphs (tDAGs), to model first-order rule feature spaces for sentence pair classification.",
        "We introduce a novel algorithm for computing the similarity in first-order rewrite rule feature spaces.",
        "Our algorithm is extremely efficient and, as it computes the similarity of instances that can be represented in explicit feature spaces, it is a valid kernel function."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Natural language processing models are generally positive combinations between linguistic models and automatically learnt classifiers.",
        "As trees are extremely important in many linguistic theories, a large amount of works exploiting machine learning algorithms for NLP tasks has been developed for this class of data structures (Collins and Duffy, 2002; Moschitti, 2004).",
        "These works propose efficient algorithms for determining the similarity among two trees in tree fragment feature spaces.",
        "Yet, some NLP tasks such as textual entailment recognition (Dagan and Glickman, 2004; Dagan et al., 2006) and some linguistic theories such as HPSG (Pollard and Sag, 1994) require more general graphs and, then, more general algorithms for computing similarity among graphs.",
        "Unfortunately, algorithms for computing similarity among two general graphs in term of common subgraphs are still exponential (Ramon and Gartner, 2003).",
        "In these cases, approximated algorithms have been proposed.",
        "For example, the one proposed in (Gartner, 2003) counts the number of subpaths in common.",
        "The same happens for the one proposed in (Suzuki et al., 2003) that is applicable to a particular class of graphs, i.e. the hierarchical directed acyclic graphs.",
        "These algorithms do not compute the number of subgraphs Lorenzo Dell'Arciprete",
        "lorenzo.dellarcipreteOgmail.com",
        "in common between two graphs.",
        "Then, these algorithms approximate the feature spaces we need in these NLP tasks.",
        "For computing similarities in these feature spaces, we have to investigate if we can define a particular class of graphs for the class of tasks we want to solve.",
        "Once we focused the class of graph, we can explore efficient similarity algorithms.",
        "A very important class of graphs can be defined for tasks involving sentence pairs.",
        "In these cases, an important class of feature spaces is the one that represents first-order rewrite rules.",
        "For example, in textual entailment recognition (Dagan et al., 2006), we need to determine whether a text T implies a hypothesis H, e.g., whether or not \"Farmers feed cows animal extracts\" entails \"Cows eat animal extracts\" (T\\, H\\).",
        "If we want to learn textual entailment classifiers, we need to exploit first-order rules hidden in training instances.",
        "To positively exploit the training instance \"Pediatricians suggest women to feed newborns breast milk\" entails \"Pediatricians suggest that newborns eat breast milk\" (T2,i?2) for classifying the above example, learning algorithms should learn that the two instances hide the first-order rule p = feediYffl -»■ \\X\\eat\\Z\\ .",
        "The first-order rule feature space, introduced by (Zanzotto and Moschitti, 2006), gives high performances in term of accuracy for textual entailment recognition with respect to other features spaces.",
        "In this paper, we propose a novel class of graphs, the tripartite directed acyclic graphs (tDAGs), that model first-order rule feature spaces and, using this class of graphs, we introduce a novel algorithm for computing the similarity in first-order rewrite rule feature spaces.",
        "The possibility of explicitly representing the first-order feature space as subgraphs of tDAGs makes the derived similarity function a valid kernel.",
        "With respect to the algorithm proposed in (Moschitti and Zanzotto, 2007), our algorithm is more efficient",
        "Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 91-100, Singapore, 6-7 August 2009.",
        "©2009 ACL and AFNLP",
        "and it is a valid kernel function.",
        "The paper is organized as follows.",
        "In Sec. 2, we firstly describe tripartite directed acyclic graphs (tDAGs) to model first-order feature (FOR) spaces.",
        "In Sec. 3, we then present the related work.",
        "In Sec. 4, we introduce the similarity function for these FOR spaces.",
        "This can be used as kernel function in kernel-based machines (e.g., support vector machines (Cortes and Vapnik, 1995)).",
        "We then introduce our efficient algorithm for computing the similarity among tDAGs.",
        "In Sec. 5, we analyze the computational efficiency of our algorithm showing that it is extremely more efficient than the algorithm proposed in (Moschitti and Zanzotto, 2007).",
        "Finally, in Sec. 6, we draw conclusions and plan the future work.",
        "2 Representing first-order rules and sentence pairs as tripartite directed acyclic graphs",
        "As first step, we want to define the tripartite directed acyclic graphs (tDAGs).",
        "This is an extremely important class of graphs for the first-order rule feature spaces we want to model.",
        "We want here to intuitively show that, if we model first-order rules and sentence pairs as tDAGs, determining whether or not a sentence pair can be unified with a first-order rewrite rule is a graph matching problem.",
        "This intuitive idea helps in determining our efficient algorithm for exploiting first-order rules in learning examples.",
        "To illustrate the above idea we will use an example based on the above rule p= /eedlYlZl – > [YleatlZl and the above sentence pair (T\\,H\\).",
        "The rule p encodes the entailment relation of the verb to feed and the verb to eat.",
        "If represented over a syntactic interpretation, the rule has the following aspect:",
        "Pi – vb npH npHJ",
        "NPlX] VP",
        "VB NP[Z] eat",
        "As in the case of feature structures (Carpenter, 1992), we can observe this rule as a graph.",
        "As we are not interested in the variable names but we need to know the relation between the right hand side and the left hand side of the rule, we can substitute each variable with an unlabelled node.",
        "We then connect tree nodes having variables with",
        "Figure 1 : A simple rewrite rule seen as a graph",
        "np vp dt nn vb np The farmer feed miS yfm cows animal extracts animal extracts",
        "Figure 2: A sample pair seen as a graph the corresponding unlabelled node.",
        "The result is a graph as the one in Fig. 1.",
        "The variables \\Y\\ and \\Z\\ are represented by the unlabelled nodes between the trees.",
        "In the same way we can represent the sentence pair (Ti,i?i) using graph with explicit links between related words and nodes (see Fig. 2).",
        "We can link words using anchoring methods as in (Raina et al., 2005).",
        "These links can then be propagated in the syntactic tree using semantic heads of the constituents (Pollard and Sag, 1994).",
        "The rule pi matches over the pair (T\\,H\\) if the graph pi is among the subgraphs of the graph in Fig. 2.",
        "Both rules and sentence pairs are graphs of the same type.",
        "These graphs are basically two trees connected through an intermediate set of nodes representing variables in the rules and relations between nodes in the sentence pairs.",
        "We will hereafter call these graphs tripartite directed acyclic graphs (tDAGs).",
        "The formal definition follows.",
        "Definition tDAG: A tripartite directed acyclic graph is a graph G = (N, E) where",
        "• the set of nodes N is partitioned in three sets Nt, Ng, and A",
        "• the set of edges is partitioned in four sets Et,",
        "Eg,EAt,mdEAg",
        "such that t = (Nt, Et) and g = (Ng, Eg) are two trees and EAt = {(x,y)\\x G Nt and y G A} and EAg = {(x, y)\\x G Ng and y G A} are the edges connecting the two trees.",
        "A tDAG is a partially labeled graph.",
        "The labeling function L only applies to the subsets of nodes related to the two trees, i.e., L : Nt U Ng – > C. Nodes in the set A are not labeled.",
        "The explicit representation of the tDAG in Fig. 2 has been useful to show that the unification of a rule and a sentence pair is a graph matching problem.",
        "Yet, it is complex to follow.",
        "We will then describe a tDAG with an alternative and more convenient representation.",
        "A tDAG G = (N, E) can be seen as pair G = (r, 7) of extended trees t and 7 where r = (Nt U A, Et U EAt) and 7 = (Ng U A, Eg U Ea9).",
        "These are extended trees as each tree contains the relations with the other tree.",
        "As for the feature structures, we will graphically represent a (x, y) G E&t and a (z, y) G Ea9 as boxes W\\ respectively on the node x and on the node z.",
        "These nodes will then appear as L(x)Wl and L(z)Wl, e.g., NP[H. The name y is not a label but a placeholder representing an unlabelled node.",
        "This representation is used for rules and for sentence pairs.",
        "The sentence pair in Fig. 2 is then represented as reported in Fig. 3."
      ]
    },
    {
      "heading": "3. Related work",
      "text": [
        "Automatically learning classifiers for sentence pairs is extremely important for applications like textual entailment recognition, question answering, and machine translation.",
        "In textual entailment recognition, it is not hard to see graphs similar to tripartite directed acyclic graphs as ways of extracting features from examples to feed automatic classifiers.",
        "Yet, these graphs are generally not tripartite in the sense described in the previous section and they are not used to extract features representing first-order rewrite rules.",
        "In (Raina et al., 2005; Haghighi et al., 2005; Hickl et al., 2006), two connected graphs representing the two sentences s\\ and S2 are used to compute distance features, i.e., features representing the distance between s\\ and S2.",
        "The underlying idea is that lexical, syntactic, and semantic similarities between sentences in a pair are relevant features to classify sentence pairs in classes such as entail and not-entail.",
        "In (de Marneffe et al., 2006), first-order rewrite rule feature spaces have been explored.",
        "Yet, these spaces are extremely small.",
        "Only some features representing first-order rules have been explored.",
        "Pairs of graphs are used here to determine if a feature is active or not, i.e., the rule fires or not.",
        "A larger feature space of rewrite rules has been implicitly explored in (Wang and Neumann, 2007) but this work considers only ground rewrite rules.",
        "In (Zanzotto and Moschitti, 2006), tripartite directed acyclic graphs are implicitly introduced and exploited to build first-order rule feature spaces.",
        "Yet, both in (Zanzotto and Moschitti, 2006) and in (Moschitti and Zanzotto, 2007), the model proposed has two major limitations: it can represent rules with less than 7 variables and the proposed kernel is not a completely valid kernel as it uses the max function.",
        "In machine translation, some methods such as (Eisner, 2003) learn graph based rewrite rules for generative purposes.",
        "Yet, the method presented in (Eisner, 2003) can model first-order rewrite rules only with a very small amount of variables, i.e., two or three variables.",
        "4 An efficient algorithm for computing the first-order rule space kernel",
        "In this section, we present our idea for an efficient algorithm for exploiting first-order rule feature spaces.",
        "In Sec. 4.1, we firstly define the similarity function, i.e., the kernel K(C?i, G2), that we need to determine for correctly using first-order rules feature spaces.",
        "This kernel is strongly based on the isomorphism between graphs.",
        "A relevant idea of this paper is the observation that we can define an efficient way to detect the isomorphism between the tDAGs (Sec.",
        "4.2).",
        "This algorithm exploits the efficient algorithms of tree isomorphism as the one implicitly used in (Collins and Duffy, 2002).",
        "After describing the isomorphism between tDAGs, We can present the idea of our efficient algorithm for computing K(C?i, G2) (Sec.",
        "4.3).",
        "We introduce the algorithms to make it a viable solution (Sec.",
        "4.4).",
        "Finally, in Sec. 4.5, we report the kernel computation we compare against presented by (Zanzotto and Moschitti, 2006; Moschitti and Zanzotto, 2007).",
        "The first-order rule feature space we want to model is huge.",
        "If we use kernel-based machine learning models such as SVM (Cortes and Vapnik, 1995), we can implicitly define the space by defining its similarity functions, i.e., its kernel functions.",
        "We firstly introduce the first-order rule feature space and we then define the prototypical kernel function over this space.",
        "The first-order rule feature space (FOR) is in general the space of all the possible first-order",
        "npED vp NNsED vb np[h",
        "cows animal extracts",
        "NPQ] VPH] NNsH VbH] S Pediatricians suggest NP vp",
        "NNS to vp vxomeB to vb NpŒ] NpH",
        "/eed NNS[H NnH] NnH newborns breast milk",
        "animal extracts npQ] vriH",
        "NNsCD VbH] sbar Pediatricians suggest in s",
        "Aa< nph] vp",
        "NNsH vb npü] newborns eat nnH breast milk",
        "Figure 3 : Two tripartite DAGs rules denned as tDAGs.",
        "Within this space it is possible to define the function S(G) that determines all the possible active features of the tDAG G in FOR.",
        "The function S(G) determines all the possible and meaningful subgraphs of G. We want that these subgraphs represent first-order rules that can be matched with the pair G. Then, meaningful subgraphs of G = (r, 7) are graphs as (t, g) where t and g are subtrees of r and 7.",
        "For example, the subgraphs of P\\ and P2 in Fig. 3 are hereafter partially represented:",
        "nph vp nnscd s",
        "I ) NNsED",
        "In the FOR space, the kernel function K should then compute the number of subgraphs in common.",
        "The trivial way to describe the former kernel function is using the intersection operator, i.e., the kernel K(G\\, G2) is the following:",
        "This is very simple to write and it is in principle correct.",
        "A graph g in the intersection S(Gi) D S(G2) is a graph that belongs to both S(G{) and S(G2).",
        "Yet, this hides a very important fact: determining whether two graphs, g\\ and g2, are the same graph g\\ = g2 is not trivial.",
        "For example, it is not sufficient to superficially compare graphs to determine that pi belongs both to «Si and £2.",
        "We need to use the correct property for g\\ = i.e., the isomorphism between two graphs.",
        "We can call the operator Iso(gi,g2).",
        "When two graphs verify the property Iso(gi, ^2), both g\\ and $2 can be taken as the graph g representing the two graphs.",
        "Detecting Iso(gi,g2) has an exponential complexity (Köbler et al., 1993).",
        "This complexity of the intersection operator between sets of graphs deserves a different way to represent the operation.",
        "We will use the same symbol but we will use the prefix notation.",
        "The operator is hereafter re-defined:",
        "As isomorphism between graphs is an essential activity for learning from structured data, we here review its definition and we adapt it to tDAGs.",
        "We then observe that isomorphism between two tDAGs can be divided in two sub-problems:",
        "• finding the isomorphism between two pairs",
        "of extended trees",
        "• checking whether the partial isomorphism found between the two pairs of extended trees are compatible.",
        "The bijective function / is a member of the combinatorial set T of all the possible bijective functions between the two sets N\\ and N2.",
        "The trivial algorithm for detecting if two graphs are isomorphic is exponential (Köbler et al., 1993).",
        "It explores all the set T. It is still undetermined if the general graph isomorphism problem is NP-complete.",
        "Yet, we can use the fact that tDAGs are two extended trees for building a better algorithm.",
        "There is an efficient algorithm for computing isomorphism between trees (as the one implicitly used in (Collins and Duffy, 2002)).",
        "Given two tDAGs G\\ = (ti,7i) and G2 = (72,72) the isomorphism problem can be divided in detecting two properties:",
        "1.",
        "Partial isomorphism.",
        "Two tDAGs G\\ and G2are partially isomorphic, if n and t2 are isomorphic and if 71 and 72 are isomorphic.",
        "The partial isomorphism produces two bijective functions fT and /7.",
        "2.",
        "Constraint compatibility.",
        "Two bijective functions fT and /7 are compatible on the sets of nodes Ai and A2, if for each n G Ai, it happens that fT(n) = f~((n).",
        "We can rephrase the second property, i.e., the constraint compatibility, as follows.",
        "We define two constraints c(ti,t2) and 0(71,72) representing the functions fT and /7 on the sets Ai and A2.",
        "The two constraints are defined as c(ti,t2) = {(n,fT(n))\\n G Ai} and 0(71,72) = {(n, /7(n))|n G Ai}.",
        "Two partially isomorphic tDAGs are isomorphic if the constraints match, i.e., c(ti,t2) = 0(71,72).",
        "Figure 5 : Simple non-linguistic tDAGs",
        "For example, the third pair of S (Pi) and the second pair of «S(P2) are isomorphic as: (1) these are partially isomorphic, i.e., the right hand sides r and the left hand sides 7 are isomorphic; (2) both pairs of extended trees generate the constraint ci = {(Q],^]),P,H)}.",
        "In the same way, the fourth pair of S(Pi) and the third pair of S(P2) generate c2 = {(CD,CD)}",
        "As above discussed, two tDAGs are isomorphic if the two properties, the partial isomorphism and the constraint compatibility, hold.",
        "To compute the kernel function K(Gi, G2) defined in Sec. 4.1, we can exploit these properties in the reverse order.",
        "Given a constraint c, we can select all the graphs that meet the constraint c (constraint compatibility).",
        "Having the two set of all the tDAGs meeting the constraint, we can detect the partial isomorphism.",
        "We split each pair of tDAGs in the four extended trees and we determine if these extended trees are compatible.",
        "We introduce this innovative method to compute the kernel K(Gi,G2) in the FOR space in two steps.",
        "Firstly, we give an intuitive explanation and, secondly, we formally define the kernel.",
        "To give an intuition of the kernel computation, without loss of generality and for sake of simplicity, we use two non-linguistic tDAGs, Pa and p5 (see Fig. 5), and the subgraph function S (9).",
        "This latter is an approximated version of S (6) that generates tDAGs with subtrees rooted in the root of the initial trees of 6.",
        "To exploit the constraint compatibility property, we define C as the set of all the relevant alternative constraints, i.e., the constraints c that are likely to be generated when detecting the partial isomorphism.",
        "For Pa and Pb, this set is C = {ci,c2} =",
        "aEO aEO iEG bEO cG] mED nG] xx mG] nG] x\\ xx",
        "cEG cH] oEO cE3 mH] mEG",
        "mEH mEO cEO cE3 mE3 mEG",
        "where n(S(Pa), S(Pb))\\ c are the common subgraphs that meet the constraint c. A tDAG g = (r'.V) in S{Pa) is in n(S(Pa),S(Pb))\\c i£g\" = (t\", 7\") in S(Pb) exists, g is partially isomorphic to g\", and d = c(r', r\") = 0(7', 7\") is covered by and compatible with the constraint c, i.e., c' Ç c. For example in Fig. 4, the first tDAG of the set n(S(Pa),S(Pb))\\cl belongs to the set as its constraint d = {(HI,LH)} is a subset of c\\.",
        "Observing the kernel computation in this way is important.",
        "Elements in D(S(Pa), S(Pb))\\calready satisfy the property of constraint compatibility.",
        "We only need to determine if the partially isomorphic properties hold for elements in n(S(Pa),S(Pb))\\c- Then, we can write the following equivalence:",
        "Figure 4 reports this equivalence for the two sets derived using the constraints c\\ and c2.",
        "Note that this equivalence is not valid if a constraint is not applied, i.e., D(S{Pa), S(Pb))",
        "+ n(S(ra),S(n)) x n(5(7„),5(7fe)).",
        "The pair Pa itself does not belong to",
        "n(%),%))xn(%),%)).",
        "The equivalence (2)^allows to compute the cardinality of £\\(S(Pa), S(Pb))\\c using the cardinalities of n(S(Ta),S(n))\\c and n(5(7(l),5(76))|c.",
        "These latter sets contain only extended trees where the equivalences between unlabelled nodes are given by c. We can then compute the cardinalities of these two sets using methods developed for trees (e.g., the kernel function i*Cs(#i,#2) introduced in (Collins and Duffy, 2002)).",
        "Given the idea of the previous section, it is easy to demonstrate that the kernel K(G\\, G 2) can be written as follows:",
        "where C is set of alternative constraints and n(<S(#i),<S(02))|c are aU the common extended trees compatible with the constraint c.",
        "We can compute the above kernel using the inclusion-exclusion property, i.e.,",
        "To describe the application of the inclusion-exclusion model in our case, let firstly define:",
        "where 9\\ can be both n and 71 and O2 can be both T2 and 72.",
        "Trivially, we can demonstrate that:",
        "where c(J) = f)ieJci-",
        "Given the nature of the constraint set C, we can compute efficiently the previous equation as it often happens that two different J\\ and J2 in 2{' -'lcl} generate the same c, i.e.",
        "Then, we can define C* as the set of all intersections of constraints in C, i.e. C* = {c(J)\\J G 2{' -'lcl}}.",
        "We can rewrite the equation as:",
        "The complexity of the above kernel strongly depends on the cardinality of C and the related cardinality of C*.",
        "The worst-case computational complexity is still exponential with respect to the size of A\\ and A2.",
        "Yet, the average case complexity (Wang, 1997) is promising.",
        "The set C is generally very small with respect to the worst case.",
        "If 3r{a1,a2) are a^ mepossible correspondences between the nodes Ai and A2, it happens that \\C\\ « |Jr(Ai,yi2)l where |Jr(yii,yi2)l is the worst case.",
        "For example, in the case of P\\ and P2, the cardinality of",
        "{(lI,L3]),([2],S),(L3],l5])}}.",
        "In Sec. 4.5 we argue that the algorithm presented in (Moschitti and Zanzotto, 2007) has the worst-case complexity.",
        "Moreover, the set C* is extremely smaller than 2i>->\\c\\} due to the above property (6).",
        "We will analyze the average-case complexity with respect to the worst-case complexity in Sec. 5.",
        "The above idea for computing the kernel function is extremely interesting.",
        "Yet, we need to make it viable by describing the way we can determine efficiently the three main parts of the equation (7):",
        "1) the set of alternative constraints C (Sec.",
        "4.4.1);",
        "2) the set C* of all the possible intersections of constraints in C (Sec.",
        "4.4.2); and, finally, 3) the numbers N(c) (Sec.",
        "4.4.3).",
        "The first step of equation (7) is to determine the alternative constraints C. We can here strongly use the possibility of dividing tDAGs in two trees.",
        "We build G as CT U C7 where: 1) CT are the constraints obtained from pairs of isomorphic extended trees t\\ G S(t\\) and i2 S <S(r2); 2) C7 are the constraints obtained from pairs of isomorphic extended trees t\\ G 5(71) and i2 S 5(72).",
        "The idea for an efficient algorithm is that we can compute the C without explicitly looking at all the subgraphs involved.",
        "We instead use and combine the constraints derived comparing the productions of the extended trees.",
        "We can compute then CT with the productions of t\\ and T2 and C7 with the productions of 71 and 72.",
        "For example (see Fig. 3), focusing on the r, the rule NP\\3\\ -»■ NNÏÏInNSÈ of Gi and NP\\4\\ ATAr^ATATS-g] of G2 generates the constraint c = {(ID,g]), ([2],[5])}.",
        "Using the above intuition it is possible to define an algorithm that builds an alternative constraint set C with the following two properties:",
        "1. for each common subtree according to a set of constraints c, 3c' G C such that c ç d;",
        "2.",
        "$d, c\" G C such that d C c\" and d / 0.",
        "The set C* is defined as the set of all possible intersections of alternative constraints in C. Figure 6 presents the algorithm determining C*.",
        "Due to the property (6) discussed in Sec. 4.3, we can empirically demonstrate that the average complexity of the algorithm is not bigger than 0(\\C\\).",
        "Yet, again, the worst case complexity is exponential.",
        "The multiplier N(c) (Eq.",
        "8) represents the number of times the constraint c is considered in the sum of equation 5, keeping into account the sign of",
        "FORALL d G Ci",
        "FORALL d'G Ci such that c' / c\"",
        "IF c £ C+ add c to C2",
        "Figure 6: Algorithm for computing c* the corresponding addend.",
        "It is possible to demonstrate that:",
        "This recursive formulation of the equation allows us to easily determine the value of N(d) for every c belonging to C*.",
        "It is possible to prove this property using set properties and the binomial theorem.",
        "The proof is omitted for lack of space.",
        "To understand if ours is an efficient algorithm, we compare it with the algorithm presented by (Moschitti and Zanzotto, 2007).",
        "We will hereafter call this algorithm Kmax.",
        "The Kmax algorithm and kernel is an approximation of what is a kernel needed for a FOR space as it is not difficult to demonstrate that Kmax(Gi, G2) < K(Gi,G2).",
        "The Kmax approximation is based on maximization over the set of possible correspondences of the placeholders.",
        "Following our formulation, this kernel appears as:",
        "where T{Ax,Aï) are a^ the possible correspondences between the nodes A\\ and A2 of the two tDAGs as the one presented in Sec. 4.3.",
        "This formulation of the kernel has the worst case complexity of our formulation, i.e., Eq.",
        "7.",
        "For computing the basic kernel for the extended trees, i.e. Ks(Oi,02,c) we use the model algorithm presented by (Zanzotto and Moschitti, 2006) and refined by (Moschitti and Zanzotto, 2007) based on the algorithm for tree fragment feature",
        "Figure 7: Mean execution time in milliseconds (ms) of the two algorithms wrt.",
        "n x m where n and m are the number of placeholders of the two tDAGs spaces (Collins and Duffy, 2002).",
        "As we are using the same basic kernel, we can empirically compare the two methods."
      ]
    },
    {
      "heading": "5. Experimental evaluation",
      "text": [
        "In this section we want to empirically estimate the benefits on the computational cost of our novel algorithm with respect to the algorithm proposed by (Moschitti and Zanzotto, 2007).",
        "Our algorithm is in principle exponential with respect to the set of alternative constraints C. Yet, due to what presented in Sec. 4.4 and as the set C* is usually very small, the average complexity is extremely low.",
        "Following the theory on the average-cost computational complexity (Wang, 1997), we estimated the behavior of the algorithms on a large distribution of cases.",
        "We then compared the computing times of the two algorithms.",
        "Finally, as K and Kmax compute slightly different kernels, we compare the accuracy of the two methods.",
        "We implemented both algorithms K(G\\, G2) and Kmax(Gi,G2) in support vector machine classifier (Joachims, 1999) and we experimented with both implementations on the same machine.",
        "We hereafter analyze the results in term of execution time (Sec.",
        "5.1) and in term of accuracy (Sec.",
        "5.2).",
        "For this first set of experiments, the source of examples is the one of the recognizing textual entailment challenge, i.e., RTE2 (Bar-Haim et al.,",
        "Kernel Accuracy Used training Support examples Vectors",
        "Figure 8: Total execution time in seconds (s) of the training phase on RTE2 wrt.",
        "different numbers of allowed placeholders 2006).",
        "The dataset of the challenge has 1,600 sentence pairs.",
        "The computational cost of both K(G\\, G 2) and Kmax(Gi,G2) depends on the number of placeholders n = \\A\\\\ of G\\ and on m = \\A2\\ the number of placeholders of G2- Then, in the first experiment we want to determine the relation between the computational time and the factor nxm.",
        "Results are reported in Fig. 7 where the computation times are plotted with respect ton x m. Each point in the curve represents the average execution time for the pairs of instances having nxm placeholders.",
        "As expected, the computation of the function K is more efficient than the computation",
        "The difference between the two execution times increases with nxm.",
        "We then performed a second experiment that wants to determine the relation of the total execution with the maximum number of placeholders in the examples.",
        "This is useful to estimate the behavior of the algorithm with respect to its application in learning models.",
        "Using the RTE2 data, we artificially build different versions with increasing number of placeholders.",
        "We then have RTE2 with 1 placeholder at most in each pair, RTE2 with 2 placeholders, etc.",
        "The number of pairs in each set is the same.",
        "What changes is the maximal number of placeholders.",
        "Results are reported in Fig. 8 where the execution time of the training phase in seconds (s) is plotted for each different set.",
        "We see that the computation of Kmax is exponential with respect to the number of placeholders and",
        "Table 1 : Comparative performances of Krnax and K it becomes intractable after 7 placeholders.",
        "The computation of K is instead more flat.",
        "This can be explained as the computation of K is related to the real alternative constraints that appears in the dataset.",
        "The computation of the kernel K then outperforms the computation of the kernel Kmax-",
        "As Kmax that has been demonstrated very effective in term of accuracy for RTE and K compute a slightly different similarity function, we want to show that the performance of our more computationally efficient K is comparable, and even better, to the performances of Kmax- We then performed an experiment taking as training all the data derived from RTE1, RTE2, and RTE3, (i.e., 4567 training examples) and taking as testing RTE-4 (i.e., 1000 testing examples).",
        "The results are reported in Tab.",
        "1.",
        "As the table shows, the accuracy of K is higher than the accuracy of Kmax- There are two main reasons.",
        "The first is that Kmax is an approximation of K. The second is that we can now consider sentence pairs with more than 7 placeholders.",
        "Then, we can use the complete training set as the third column of the table shows."
      ]
    },
    {
      "heading": "6. Conclusions and future work",
      "text": [
        "We presented an interpretation of first order rule feature spaces as tripartite directed acyclic graphs (tDAGs).",
        "This view on the problem gave us the possibility of defining a novel and efficient algorithm for computing the kernel function for first order rule feature spaces.",
        "Moreover, the resulting algorithm is a valid kernel as it can be written as dot product in the explicit space of the tDAG fragments.",
        "We demonstrated that our algorithm outperforms in term of average complexity the previous algorithm and it yields to better accuracies for the final task.",
        "We are investigating if this is a valid algorithm for two general directed acyclic graphs."
      ]
    }
  ]
}
