{
  "info": {
    "authors": [
      "Richard Johansson"
    ],
    "book": "EMNLP",
    "id": "acl-D09-1059",
    "title": "Statistical Bistratal Dependency Parsing",
    "url": "https://aclweb.org/anthology/D09-1059",
    "year": 2009
  },
  "references": [
    "acl-C04-1026",
    "acl-C08-1095",
    "acl-C96-1058",
    "acl-D08-1016",
    "acl-J02-3001",
    "acl-J05-1004",
    "acl-J07-2003",
    "acl-J93-2004",
    "acl-P05-1012",
    "acl-P05-1013",
    "acl-P05-1073",
    "acl-P08-1067",
    "acl-W04-2705",
    "acl-W04-3212",
    "acl-W05-1506",
    "acl-W08-2101",
    "acl-W08-2121",
    "acl-W08-2122",
    "acl-W08-2134",
    "acl-W08-2138"
  ],
  "sections": [
    {
      "text": [
        "johansson@disi.unitn.it",
        "We present an inexact search algorithm for the problem of predicting a two-layered dependency graph.",
        "The algorithm is based on a fc-best version of the standard cubic-time search algorithm for projective dependency parsing, which is used as the backbone of a beam search procedure.",
        "This allows us to handle the complex nonlocal feature dependencies occurring in bistratal parsing if we model the interdependency between the two layers.",
        "We apply the algorithm to the syntactic-semantic dependency parsing task of the CoNLL-2008 Shared Task, and we obtain a competitive result equal to the highest published for a system that jointly learns syntactic and semantic structure."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Numerous linguistic theories assume a multistratal model of linguistic structure, such as a layer of surface syntax, deep syntax, and shallow semantics.",
        "Examples include Meaning-Text Theory (Mel'cuk, 1988), Discontinuous Grammar (Buch-Kromann, 2006), Extensible Dependency Grammar (Debusmann et al., 2004), and the Functional Generative Description (Sgall et al., 1986) which forms the theoretical foundation of the Prague Dependency Treebank (Hajic, 1998).",
        "In the statistical NLP community, the most widely used grammatical resource is the Penn Treebank (Marcus et al., 1993).",
        "This is a purely syntactic resource, but we can also include this treebank in the category of multistratal resources since the PropBank (Palmer et al., 2005) and NomBank (Meyers et al., 2004) projects have annotated shallow semantic structures on top of it.",
        "Dependency-converted versions of the Penn Treebank, PropBank and NomBank were used in the CoNLL-2008 Shared Task (Surdeanu et al., 2008), in which the task of the participants was to produce a bistratal dependency structure consisting of surface syntax and shallow semantics.",
        "Producing a consistent multistratal structure is a conceptually and computationally complex task, and most previous methods have employed a purely pipeline-based decomposition of the task.",
        "This includes the majority of work on shallow semantic analysis (Gildea and Jurafsky, 2002, inter alia).",
        "Nevertheless, since it is obvious that syntax and semantics are highly interdependent, it has repeatedly been suggested that the problems of syntactic and semantic analysis should be carried out simultaneously rather than in a pipeline, and that modeling the interdependency between syntax and semantics would improve the quality of all the substructures.",
        "The purpose of the CoNLL-2008 Shared Task was to study the feasibility of a joint analysis of syntax and semantics, and while most participating systems used a pipeline-based approach to the problem, there were a number of contributions that attempted to take the interdependence between syntax and semantics into account.",
        "The top-performing system in the task (Johansson and Nugues, 2008) applied a very simple reranking scheme by means of a fc-best syntactic output, similar to previous attempts (Gildea and Jurafsky, 2002; Toutanova et al., 2005) to improve semantic role labeling performance by using mul-",
        "Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 561-569, Singapore, 6-7 August 2009.",
        "©2009 ACL and AFNLP",
        "tiple parses.",
        "The system by Henderson et al.",
        "(2008) extended previous stack-based algorithms for dependency parsing by using two separate stacks to build the syntactic and semantic graphs.",
        "Lluis and Marquez (2008) proposed a model that simultaneously predicts syntactic and semantic links, but since its search algorithm could not take the syntactic-semantic interdependencies into account, a pre-parsing step was still needed.",
        "In addition, before the CoNLL-2008 shared task there have been a few attempts to jointly learn syntactic and semantic structure; for instance, Merlo and Musillo (2008) appended semantic role labels to the phrase tags in a constituent treebank and applied a conventional constituent parser to predict constituent structure and semantic roles.",
        "In this paper, we propose a new approximate search method for bistratal dependency analysis.",
        "The search method is based on a beam search procedure that extends a fc-best version of the standard cubic-time search algorithm for projective dependency parsing.",
        "This is similar to the search method for constituent parsing used by Huang (2008), who referred to it as cube pruning, inspired by an idea from machine translation decoding (Chiang, 2007).",
        "The cube pruning approach, which is normally used to solve the arg max problem, was also recently extended to summing problems, which is needed in some learning algorithms (Gimpel and Smith, 2009).",
        "We apply the algorithm on the CoNLL-2008 Shared Task data, and obtain the same evaluation score as the best previously published system that simultaneously learns syntactic and semantic structure (Titov et al., 2009)."
      ]
    },
    {
      "heading": "2. Bistratal Dependency Parsing",
      "text": [
        "In the tradition of dependency representation of sentence structure, starting from Tesnière (1959), the linguistic structure of the sentence is represented as a directed graph of relations between words.",
        "In most theories, certain constraints are imposed on this graph; the most common constraint on dependency graphs in syntax, for instance, is that the graph should form a tree (i.e. it should be connected, acyclic, and every node should have at most one incoming edge).",
        "This assumption underlies almost all dependency parsing, although there are also a few parsers based on slightly more general problem formulations (Sagae and Tsuji, 2008).",
        "In this paper, we assume a different type of constraint: that the graph can be partitioned into two subgraphs that we will refer to as strata or layers, where the first of the layers forms a tree.",
        "For the second layer, the only assumption we make is that there is at most one link between any two words.",
        "However, we believe that for any interesting linguistic structure, the second layer will be highly dependent on the structure of the first layer.",
        "Figure 1 shows an example of a bistratal dependency graph such as in the CoNLL-2008 Shared Task on syntactic and semantic dependency parsing.",
        "The figure shows the representation of the sentence We were expecting prices to fall.",
        "The primary layer represents surface-syntactic relations, shown above the sentence, and the secondary layer consists of predicate-argument links (here, we have two predicates expecting and fall).",
        "We were expecting prices to fall",
        "We now give a formal model of the statistical parsing problem of prediction of a bistratal dependency graph.",
        "For a given input sentence x, the task of our algorithm is to predict a structure y consisting of a primary layer yp and a secondary layer ys.",
        "In a discriminative modeling framework, we model this prediction problem as the search for the highest-scoring output from the candidate space y under a scoring function F:",
        "The learning problem consists of searching in the model space for a scoring function F that minimizes the cost of predictions on unseen examples according to a given cost function p. In this work, we consider linear scoring functions of the following form:",
        "where &(x, y) is a numeric feature representation of the tuple (x,yp,ys) and w a high-dimensional vector of feature weights.",
        "Based on the structural assumptions made above, we now decompose the feature representation into three parts:",
        "Here, 3>p represents the primary layer, assumed to be a tree, 3>s the secondary layer, and finally 3>j is the representation of the interdependency between the layers.",
        "For the feature representations of the primary and secondary layers, we employ edge factorization, a decomposition widely used in statistical dependency parsing, and assume that all edges can be scored independently:",
        "The representation of the interdependency between the layers assumes that each secondary link is dependent on the primary layer, but independent of other secondary links.",
        "The interdependency between layers is the bottleneck for the search algorithm that we will present in Section 3.",
        "For semantic role analysis, this involves all features that rely on a syntactic representation, most importantly the PATH feature that represents the grammatical relation between predicate and argument words.",
        "For instance, in Figure 1, we can represent the surface-syntactic relation between the tokens fall and prices as the string IMfOPRDfOBJj.",
        "In this work, all interdependency features will be based on paths in the primary layer."
      ]
    },
    {
      "heading": "3. A Bistratal Search Algorithm",
      "text": [
        "This section presents an algorithm to approximately solve the arg max problem for prediction of bistratal dependency structures.",
        "We present the algorithm in two steps: first, we review a fc-best version of the standard search algorithm for projective monostratal dependency parsing, based on the work by Huang and Chiang (2005).",
        "In the second step, starting from the fc-best monostratal search, we devise a search method for the bistratal problem.",
        "The search method commonly used in dependency parsers is a chart-based dynamic programming algorithm that finds the highest-scoring projective dependency tree under an edge-factored scoring function.",
        "It runs in cubic time with respect to the sentence length.",
        "In a slightly more general formulation, it was first published by Eisner (1996).",
        "Starting from McDonald et al.",
        "(2005), it has been widely used in recent statistical dependency parsing frameworks.",
        "The algorithm works by creating open structures, which consist of a dependency link and the set of links that it spans, and closed structures, consisting of the left or right half of a complete subtree.",
        "An open structure is created by a procedure Link that adds a dependency link to connect a right-pointing and a left-pointing closed structure, and a closed structure by a procedure Ioin that joins an open structure with a closed structure.",
        "Figure 2 shows schematic illustrations: a link operation connects the right-pointing closed structure between s and j with the left-pointing closed structure between j + 1 and e, and a Join operation connects an open structure between s and j with a closed structure between j and e.",
        "The search algorithm can easily be extended to find the fc best parses, not only the best one.",
        "In fc-best parsing, we maintain a fc-best list in every cell in the dynamic programming table.",
        "To create the fc-best list of derivations for an open structure between the positions s and e, for instance, there are up to \\L\\ ■ (e – s) • fc possible combinations to consider if the set of allowed labels is L. The key observation by Huang and Chiang (2005) is to make use of the fact that the lists are sorted.",
        "For every position between s and e, we add the best combination to a priority queue, from which we then repeatedly remove the front item.",
        "For every item we remove, we add three successors: an item with a next-best left part, an item with a next-best right part, and finally an item with a next-best edge label.",
        "The pseudocode of the search algorithm for fc-best dependency parsing is given in Algorithms 1 and 2.",
        "For brevity, we omitted the code for Advance-left and Advance-right, which are similar to Advance-edge, as well as Advance-lower, which resembles Advance-upper.",
        "The Fst function used in the pseudocode returns the first element of a tuple.",
        "The algorithm uses a priority queue with standard operations enqueue, which enqueues an element, and Dequeue, which removes the highest-scoring item from the queue.",
        "With a standard binary heap implementation of the priority queue, these two operations execute in logarithmic time.",
        "To build the queue, we use a constant-time toss operation, which appends an item to the queue without enforcing the priority queue constraint, and a Heapify operation that constructs a consistent priority queue in linear time.",
        "The fc-best algorithm forms the core of the inexact bistratal search algorithm.",
        "Our method is similar to the forest reranking method by Huang (2008), although there is no forest pruning or reranking involved here.",
        "Crucially, we divide the features into local features, which can be computed \"offline\", and nonlocal features, which must be computed during search.",
        "In our case, the local features are 3>p and 3>s, while the nonlocal features are the interdependent features 3>j.",
        "Algorithm 3 shows pseudocode for the main part of the bistratal search algorithm, and Algorithm 4 for its support functions.",
        "The algorithm works as follows: for every span (s, e), the algorithm first uses the Link procedure from the fc-best monostratal search to construct a fc-best list of open structures without semantic links.",
        "In the next step, secondary links are added in the procedure Link-secondary.",
        "For brevity, we show only the procedures that create open structures; they are very similar to their closed-structure counterparts.",
        "The Link-secondary procedure starts by creating an initial candidate (First-sec-open) based on the best open structure for the primary layer.",
        "First-sec-open creates the candidate space for secondary links for a single primary open structure.",
        "To reduce search complexity, it makes use of a problem-specific function Scope Algorithm 1 fc-best search algorithm for dependency parsing.",
        "function fc-best-search(fc) n < – length of the sentence initialize the table O of open structures initialize the table C of closed structures for m e [1,... ,n] procedure Link(s, e, dir, fc)",
        "Enqueue(<j, Advance-edge(o))",
        "Enqueue(<j, Advance-left(o))",
        "Enqueue(<j, Advance-right(o))",
        "procedure Join(s, e, dir, fc) q < – empty priority queue it dir = – >",
        "Enqueue(<j, Advance-upper(c))",
        "Enqueue(<j, Advance-lower(c))",
        "that defines which secondary links are possible from a given token, given a primary-layer context.",
        "An important insight by Huang (2008) is that nonlocal features should be computed as early as possible during search.",
        "In our case, we assume that the interdependency features are based on tree paths in the primary layer.",
        "This means that secondary links between two tokens can be added when there is a complete path in the primary layer between the tokens.",
        "When we create an open Algorithm 2 Support operations for the fc-best search._",
        "function Create-edges(s, e, dir, fc) E <- 0 for / e allowed-labels(s,e, dir)",
        "Append (E, edge) return the top fc edges in E function Create-open(_B,I, r, ie,ii, ir) function Advance-edge(o) where o = (score, E ,l,r,i£,ii,ir)",
        "if ie = Length(_B) return 0 return Create-open(_B,/, r, ie + l,ii,ir) function Advance-upper (c) where c = (u,l,iu,ii)",
        "iîiu = Length(u) return 0",
        "return Create-closed(u,/, iu + l,ii)",
        "structure by adding a link between two substructures, a complete path is created between the tokens in the substructures.",
        "We thus search for possible secondary links only between the two substructures that are joined.",
        "Figure 3 illustrates this process.",
        "A primary open structure between s and e has been created by adding a link from the right-pointing closed structure between s and j to the left-pointing closed structure between j + 1 and e. We now try to add secondary links between the two substructures.",
        "For instance, in the semantic role parsing task described in subsection 3.3, if we know that there is a predicate between s and j, then we look for arguments between j + 1 and e, i.e. we apply the scope function to the right substructure.",
        "When computing the scores for secondary links, note that for efficiency only the interdependent part 3>i should be computed in Create-sec-edges; the part of the score that does not depend on the primary layer can be computed before entering the search procedure.",
        "Figure 3: Illustration of the secondary linking process: When two substructures are connected, we can compute the path between a predicate in the left substructure and an argument in the right substructure.",
        "Algorithm 3 Search algorithm for bistratal dependency parsing.",
        "function BlSTRATAL-search(fc)",
        "n < – length of the sentence initialize the table O of open structures initialize the table C of closed structures using <j>s, compute a table scoress for all",
        "procedure Link-secondary(s, e, dir, fc) q < – empty priority queue o < – FlRST-sec-open(0[s,e,dir], 1, fc) Enqueue(<j,o) buf < – empty list while \\buf\\ < k and \\q\\ > 0 o < – dequeue(g) if o jÈ buf Append (buf, 6)",
        "We applied the bistratal search method in Algorithm 3 on the data from the CoNLL-2008 Shared Task (Surdeanu et al., 2008).",
        "Here, the primary layer is the tree of surface-syntactic relations such as subject and object, and the secondary layer contains the links between the predicate words in the sentence and their respective logical arguments, such as agent and patient.",
        "The training corpus consists of sections 02 - 21 of the Penn Treebank, and contains roughly 1 million words.",
        "Algorithm 4 Support operations in bistratal search._",
        "function First-sec-open(L,iL, fc) if i = Length(L) return 0 function CREATE-sec-edges(/l,d, O, fc) for / g allowed-sec-labels (/l,d) return the top fc edges in E function Create-sec-open(L,iL, E,I) function advance-sec-open(o,fc)",
        "Append(6u/, Create-sec-open(L, il,E, I'E)) return buf",
        "To apply the bistratal search algorithm to the problem of syntactic-semantic parsing, a problem-specific implementation of the scope function is needed.",
        "In this case, we made two assumptions.",
        "First, we assumed that the identities of the predicate words are known a priori.",
        "Secondly, we assumed that every argument of a given predicate word is either a direct dependent of the predicate, one of its ancestors, or a direct dependent of one of its ancestors.",
        "This assumption is a simple adaptation of the pruning algorithm by Xue and Palmer (2004), and it holds for the vast majority of arguments in the CoNLL-2008 data; in the training set, we measured that this covers 99.04% of the arguments of verbs and 97.55% of the arguments of nouns.",
        "Figure 4 shows an example of how the Scope function works in our case.",
        "If a predicate is contained in the right substructure, we find two potential arguments: one at the start of the left substructure, and one more by recursively searching the left structure.",
        "Figure 4: Illustration of the scope function for predicate-argument links.",
        "If the right substructure contains a predicate, we can find potential arguments in the left substructure.",
        "While the primary layer is assumed to be projective in Algorithm 3, the syntactic trees in the CoNLL-2008 data have a small number of nonpro-jective links.",
        "We used a pseudo-projective edge label encoding to handle nonprojectivity (Nivre and Nilsson, 2005).",
        "To implement the model, we constructed feature representations 3>p, 3>s, and 3>i.",
        "The surface-syntactic representation 3>p was a standard first-order edge factorization using the same features as McDonald et al.",
        "(2005).",
        "The features in 3>s and 3>i are shown in Table 1 and are standard features in statistical semantic role classification.",
        "Predicate word Predicate POS Argument word Argument POS Pred.",
        "+ arg.",
        "words Predicate word + label Predicate POS + label Argument word + label Argument POS + label Pred.",
        "+ arg.",
        "words + label",
        "Feature representation for secondary",
        "We trained the discriminative model using the Online Passive-aggressive algorithm (Crammer et al., 2006), which is an efficient online learning method that can be used to train models for learning problems with structured output spaces.",
        "A cost function p is needed in the learning algorithm; we decomposed it into a primary part pp and a secondary part ps.",
        "We computed the primary part as the sum of link errors:",
        "PP(yP, Vp) = T,ieyP Cp(h yP)>where",
        "0 if l gyp and its label is correct CpihVp) = 0.5 if I £ yP but its label is incorrect"
      ]
    },
    {
      "heading": "1. iilivp",
      "text": [
        "In a similar vein, we computed the secondary part ps of the cost function as + #/n + 0.5 • where #fp is the number of false positive secondary links, #/n the number of false negative links, and #fl the number of links with correct endpoints but incorrect label.",
        "The training procedure took roughly 24 hours on an 2.3 GHz AMD Athlon processor.",
        "The memory consumption was about 1 GB during training."
      ]
    },
    {
      "heading": "4. Experiments",
      "text": [
        "We evaluated the performance of our system on the test set from the CoNLL-2008 shared task, which consists of section 23 of the WSJ part of the Penn Treebank, as well as a small part of the Brown corpus.",
        "A beam width A; of 4 was used in this experiment.",
        "Table 2 shows the results of the evaluation.",
        "The table shows the three most important scores computed by the official evaluation script: labeled syntactic dependency accuracy (LAS), labeled semantic dependency Fi measure (Sem.",
        "Fl), and the macro-averaged Fi-measure, a weighted combination of the syntactic and semantic scores (M. Fl).",
        "Our result is competitive; we obtain the same macro Fl as the newly published result by Titov et al.",
        "(2009), which is the highest published figure for a joint syntactic-semantic parser so far.",
        "Importantly, our system clearly outperforms the system by Llufs and Marquez (2008), which is the most similar system in problem modeling, but which uses a different search strategy.",
        "Since the search procedure is inexact, it is important to quantify roughly how much of a detrimental impact the approximation has on the parsing quality.",
        "We studied the influence of the beam width parameter k on the performance of the parser.",
        "The results on the development set can be seen in Table 3.",
        "As can be seen, a modest increase in performance can be obtained by increasing the beam width, at the cost of increased parsing time.",
        "In addition, to have a rough indication of the impact of search errors on the quality of the parses, we computed the fraction of sentences where the gold-standard parse had a higher score according to the model than the parse returned by the search.",
        "Table 4 shows the results of this experiment.",
        "This suggests that the search errors, although they clearly have an impact, are not the major source of errors, even with small beam widths.",
        "Table 4: Fraction of sentences in the development set where the gold-standard parse has a higher score than the parse returned by the search procedure.",
        "To investigate where future optimization efforts should be spent, we used the built-in hprof profiling tool of Java to locate the bottlenecks.",
        "Once again, we ran the program on the development set with a beam width of 4, and Table 5 shows the three types of operations where the algorithm spent most of its time.",
        "It turns out that 74% of the time was spent on the computation and scoring of interdependency features.",
        "To make our algorithm truly useful in practice, we thus need to devise a way to speed up or cache these computations.",
        "k",
        "LAS",
        "Sem.",
        "Fl",
        "M. Fl",
        "Time",
        "1",
        "85.14",
        "77.05",
        "81.10",
        "242",
        "2",
        "85.43",
        "77.17",
        "81.30",
        "369",
        "4",
        "85.49",
        "77.20",
        "81.35",
        "625",
        "8",
        "85.58",
        "77.20",
        "81.40",
        "1178",
        "k",
        "Fraction",
        "1",
        "0.121",
        "2",
        "0.104",
        "4",
        "0.096",
        "8",
        "0.090",
        "System",
        "LAS",
        "Sem.",
        "Fl",
        "M.Fl",
        "This paper",
        "86.6",
        "77.1",
        "81.8",
        "Titov et al.",
        "(2009)",
        "87.5",
        "76.1",
        "81.8",
        "H. et al. (2008)",
        "87.6",
        "73.1",
        "80.5",
        "L. & M. (2008)",
        "85.8",
        "70.3",
        "78.1",
        "Operation Fraction w • $j 0.64 Queue operations 0.15 Computation of $i 0.10"
      ]
    },
    {
      "heading": "5. Discussion",
      "text": [
        "In this paper, we have presented a new approximate search method to solve the problem of jointly predicting the two layers in a bistratal dependency graph.",
        "The algorithm shows competitive performance on the treebank used in the CoNLL-2008 Shared Task, a bistratal treebank consisting of a surface-syntactic and a shallow semantic layer.",
        "In addition to the syntactic-semantic task that we have described in this paper, we believe that our method can be used in other types of multistratal syntactic frameworks, such as a representation of surface and deep syntax as in Meaning-Text Theory (Mel'cuk, 1988).",
        "The optimization problem that we set out to solve is intractable, but we have shown that reasonable performance can be achieved with an inexact, beam search-based search method.",
        "This is not obvious: it has previously been shown that using an inexact search procedure when the learning algorithm assumes that the search is exact may lead to slow convergence or even divergence (Kulesza and Pereira, 2008), but this does not seem to be a problem in our case.",
        "While we used a beam search method as the method of approximation, other methods are certainly possible.",
        "An interesting example is the recent system by Smith and Eisner (2008), which used loopy belief propagation in a dependency parser using highly complex features, while still maintaining cubic-time search complexity.",
        "An obvious drawback of our approach compared to traditional pipeline-based semantic role labeling methods is that the speed of the algorithm is highly dependent on the size of the interdependency feature representation 3>i.",
        "Also, extracting these features is fairly complex, and it is of critical importance to implement the feature extraction procedure efficiently since it is one of the bottlenecks of the algorithm.",
        "It is plausible that our performance suffers from the absence of other frequently used syntax-based features such as dependent-of-dependent and voice.",
        "It is thus highly dubious that a joint modeling of syntactic and semantic structure is worth the additional implementational effort.",
        "So far, no system using tightly integrated syntactic and semantic processing has been competitive with the best systems, which have been either completely pipeline-based (Che et al., 2008; Ciaramita et al., 2008) or employed only a loose syntactic-semantic coupling (Johansson and Nugues, 2008).",
        "It has been conjectured that modeling the semantics of the sentence would also help in syntactic disambiguation; however, it is likely that this is already implicitly taken into account by the lexical features present in virtually all modern parsers.",
        "In addition, a problem that our beam search method has in common with the constituent parsing method by Huang (2008) is that highly nonlocal features must be computed late.",
        "In our case, this means that if there is a long distance between a predicate and an argument, the secondary link between them will be unlikely to influence the final search result."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "The author is grateful for the helpful comments by the reviewers.",
        "This work has been funded by the LivingKnowledge project under the seventh EU framework program."
      ]
    }
  ]
}
