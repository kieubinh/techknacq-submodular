{
  "info": {
    "authors": [
      "Marco Kuhlmann",
      "Giorgio Satta"
    ],
    "book": "EACL",
    "id": "acl-E09-1055",
    "title": "Treebank Grammar Techniques for Non-Projective Dependency Parsing",
    "url": "https://aclweb.org/anthology/E09-1055",
    "year": 2009
  },
  "references": [
    "acl-C96-1058",
    "acl-E06-1011",
    "acl-H05-1066",
    "acl-N07-1050",
    "acl-P05-1013",
    "acl-P06-2066",
    "acl-P07-1021",
    "acl-P07-1077",
    "acl-P87-1015",
    "acl-W05-1505",
    "acl-W06-2920",
    "acl-W06-2922",
    "acl-W07-2216"
  ],
  "sections": [
    {
      "text": [
        "Marco Kuhlmann Giorgio Satta",
        "Uppsala University University of Padua Uppsala, Sweden Padova, Italy",
        "marco.kuhlmann@lingfil.uu.se satta@dei.unipd.it",
        "An open problem in dependency parsing is the accurate and efficient treatment of non-projective structures.",
        "We propose to attack this problem using chart-parsing algorithms developed for mildly context-sensitive grammar formalisms.",
        "In this paper, we provide two key tools for this approach.",
        "First, we show how to reduce non-projective dependency parsing to parsing with Linear Context-Free Rewriting Systems (LCFRS), by presenting a technique for extracting LCFRS from dependency treebanks.",
        "For efficient parsing, the extracted grammars need to be transformed in order to minimize the number of nonterminal symbols per production.",
        "Our second contribution is an algorithm that computes this transformation for a large, empirically relevant class of grammars."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Dependency parsing is the task of predicting the most probable dependency structure for a given sentence.",
        "One of the key choices in dependency parsing is about the class of candidate structures for this prediction.",
        "Many parsers are confined to projective structures, in which the yield of a syntactic head is required to be continuous.",
        "A major benefit of this choice is computational efficiency: an exhaustive search over all projective structures can be done in cubic, greedy parsing in linear time (Eisner, 1996; Nivre, 2003).",
        "A major drawback of the restriction to projective dependency structures is a potential loss in accuracy.",
        "For example, around 23% of the analyses in the Prague Dependency Treebank of Czech (Hajic et al., 2001) are non-projective, and for German and Dutch treebanks, the proportion of non-projective structures is even higher (Havelka, 2007).",
        "The problem of non-projective dependency parsing under the joint requirement of accuracy and efficiency has only recently been addressed in the literature.",
        "Some authors propose to solve it by techniques for recovering non-projectivity from the output of a projective parser in a post-processing step (Hall and Novak, 2005; Nivre and Nilsson, 2005), others extend projective parsers by heuristics that allow at least certain non-projective constructions to be parsed (Attardi, 2006; Nivre, 2007).",
        "McDonald et al.",
        "(2005) formulate dependency parsing as the search for the most probable spanning tree over the full set of all possible dependencies.",
        "However, this approach is limited to probability models with strong independence assumptions.",
        "Exhaustive non-projective dependency parsing with more powerful models is intractable (McDonald and Satta, 2007), and one has to resort to approximation algorithms (McDonald and Pereira, 2006).",
        "In this paper, we propose to attack non-project-ive dependency parsing in a principled way, using polynomial chart-parsing algorithms developed for mildly context-sensitive grammar formalisms.",
        "This proposal is motivated by the observation that most dependency structures required for the analysis of natural language are very nearly projective, differing only minimally from the best projective approximation (Kuhlmann and Nivre, 2006), and by the close link between such 'mildly non-projective' dependency structures on the one hand, and grammar formalisms with mildly context-sensitive generative capacity on the other (Kuhlmann and Mohl, 2007).",
        "Furthermore, as pointed out by McDonald and Satta (2007), chart-parsing algorithms are amenable to augmentation by non-local information such as arity constraints and Markovization, and therefore should allow for more predictive statistical models than those used by current systems for non-projective dependency parsing.",
        "Hence, mildly non-projective dependency parsing promises to be both efficient and accurate.",
        "Contributions In this paper, we contribute two key tools for making the mildly context-sensitive approach to accurate and efficient non-projective dependency parsing work.",
        "First, we extend the standard technique for extracting context-free grammars from phrase-structure treebanks (Charniak, 1996) to mildly context-sensitive grammars and dependency treebanks.",
        "More specifically, we show how to extract, from a given dependency treebank, a lexicalized Linear Context-Free Rewriting System (LCFRS) whose derivations capture the dependency analyses in the treebank in the same way as the derivations of a context-free treebank grammar capture phrase-structure analyses.",
        "Our technique works for arbitrary, even non-projective dependency treebanks, and essentially reduces non-projective dependency to parsing with LCFRS.",
        "This problem can be solved using standard chart-parsing techniques.",
        "Our extraction technique yields a grammar whose parsing complexity is polynomial in the length of the sentence, but exponential in both a measure of the non-projectivity of the treebank and the maximal number of dependents per word, reflected as the rank of the extracted LCFRS.",
        "While the number of highly non-projective dependency structures is negligible for practical applications (Kuhlmann and Nivre, 2006), the rank cannot easily be bounded.",
        "Therefore, we present an algorithm that transforms the extracted grammar into a normal form that has rank 2, and thus can be parsed more efficiently.",
        "This contribution is important even independently of the extraction procedure: While it is known that a rank-2 normal form of LCFRS does not exist in the general case (Rambow and Satta, 1999), our algorithm succeeds for a large and empirically relevant class of grammars."
      ]
    },
    {
      "heading": "2. Preliminaries",
      "text": [
        "We start by introducing dependency trees and Linear Context-Free Rewriting Systems (LCFRS).",
        "Throughout the paper, for positive integers i and j, we write [i, j] for the interval {k | i < k < j }, and use [n] as a shorthand for [1, n].",
        "Dependency parsing is the task to assign dependency structures to a given sentence w. For the purposes of this paper, dependency structures are edge-labelled trees.",
        "More formally, let w be a sentence, understood as a sequence of tokens over some given alphabet T, and let L be an alphabet of edge labels.",
        "A dependency tree for w is a construct D = (w, E, A), where E forms a rooted tree (in the standard graph-theoretic sense) on the set [|w|], and A is a total function that assigns every edge in E a label in L. Each node of D represents a (position of a) token in w.",
        "Let u be a node of a dependency tree D. A node uis a descendant of u, if there is a (possibly empty) path from u to u.",
        "A block of u is a maximal interval of descendants of u.",
        "The number of blocks of u is called the block-degree of u.",
        "The block-degree of a dependency tree is the maximum among the block-degrees of its nodes.",
        "A dependency tree is projective, if its block-degree is 1 .",
        "Example 2 The tree shown in Figure 2 is not projective: both node 2 (hearing) and node 4 (scheduled) have block-degree 2.",
        "Their blocks are {2}, {5,6,7} and {4}, {8}, respectively.",
        "Linear Context-Free Rewriting Systems (LCFRS) have been introduced as a generalization of several mildly context-sensitive grammar formalisms.",
        "Here we use the standard definition of LCFRS (Vijay-Shanker et al., 1987) and only fix our notation; for a more thorough discussion of this formalism, we refer to the literature.",
        "Let G be an LCFRS.",
        "Recall that each nonterminal symbol A of G comes with a positive integer called the fanout of A, and that a production p of G has the form where A, A1,..., Ar are nonterminals with fanout f, fl,..., fr, respectively, g is a function symbol, and the equation to the right of the semicolon specifies the semantics of g. For each i e [r], %, is an fi -tuple of variables, and a = (a1,..., a/) is a tuple of strings over the variables on the left-hand side of the equation and the alphabet of terminal symbols in which each variable appears exactly once.",
        "The production p is said to have rank r, fanout f, and length |a11 CC |a/1 + (f - 1)."
      ]
    },
    {
      "heading": "3. Grammar Extraction",
      "text": [
        "We now explain how to extract an LCFRS from a dependency treebank, in very much the same way as a context-free grammar can be extracted from a phrase-structure treebank (Charniak, 1996).",
        "A simple way to induce a context-free grammar from a phrase-structure treebank is to read off the productions of the grammar from the trees.",
        "We will specify a procedure for extracting, from a given dependency treebank, a lexicalized LCFRS G that is adequate in the sense that for every analysis D of a sentence w in the treebank, there is a derivation tree of G that is isomorphic to D, meaning that it becomes equal to D after a suitable renaming and relabelling of nodes, and has w as its derived string.",
        "Here, a derivation tree of an LCFRS G is an ordered tree such that each node u is labelled with a production p of G, the number of children of u equals the rank r of p, and for each i e [r], the i th child of u is labelled with a production that has as its left-hand side the i th nonterminal on the right-hand side of p.",
        "The basic idea behind our extraction procedure is that, in order to represent the compositional structure of a possibly non-projective dependency tree, one needs to represent the decomposition and relative order not of subtrees, but of blocks of subtrees (Kuhlmann and Mohl, 2007).",
        "We introduce some terminology.",
        "A component of a node u in a dependency tree is either a block B of some child uof u, or the singleton interval that contains u; this interval will represent the position in the string that is occupied by the lexical item corresponding to u.",
        "We say that u contributes B, and that u contributes [u, u] to u.",
        "Notice that the number of components that u contributes to its parent u equals the block-degree of u.",
        "Our goal is to construct for u a production of an LCFRS that specifies how each block of u decomposes into components, and how these components are ordered relative to one another.",
        "These productions will make an adequate LCFRS, in the sense defined above.",
        "The core of our extraction procedure is an efficient algorithm that annotates each node u of a given dependency tree with the list of its components, sorted by their left endpoints.",
        "It is helpful to think of this algorithm as of two independent parts, one that 1: Function Annotate-L(D) 2: for each u of D , from left to right do 3: if u is the first node of D then 6: b = the lca of u and its predecessor annotates each node u with the list of the left endpoints of its components (Annotate-L) and one that annotates the corresponding right endpoints (Annotate-R).",
        "The list of components can then be obtained by zipping the two lists of endpoints together in linear time.",
        "Figure 1 shows pseudocode for Annotate-L; the pseudocode for Annotate-R is symmetric.",
        "We do a single left-to-right sweep over the nodes ofthe input tree D .",
        "In each step, we annotate all nodes uthat have the current node u as the left endpoint of one of their components.",
        "Since the sweep is from left to right, this will get us the left endpoints of uin the desired order.",
        "The nodes that we annotate are the nodes u on the path between u and the least common ancestor (lca) b of u and its predecessor, or the path from the root node to u, in case that u is the leftmost node of D .",
        "Example 3 For the dependency tree in Figure 2, Annotate-L constructs the following lists left[u] of left endpoints, for u = 1, .",
        ".",
        ".",
        ", 8:",
        "The following Lemma establishes the correctness of the algorithm:",
        "Lemma 1 Let D be a dependency tree, and let u and u be nodes of D. Let b be the least common ancestor of u and its predecessor, or the root node in case that u is the leftmost node of D. Then u is the left endpoint of a component of u if and only if u lies on the path from b to u.",
        "□",
        "Proof It is clear that u must be an ancestor of u.",
        "If u is the leftmost node of D , then u is the left endpoint of the leftmost component of all of its ancestors.",
        "Now suppose that u is not the leftmost node of D, and let u be the predecessor of u.",
        "Distinguish three cases: If u is not an ancestor of u, then u does not belong to any component of u; therefore, u is the left endpoint of a component of u.",
        "If u is an ancestor of u but u ^ b, then u and u belong to the same component of u; therefore, u is not the left endpoint of this component.",
        "Finally, if u = b, then u and u belong to different components of u; therefore, u is the left endpoint of the component it belongs to.",
        "■",
        "We now turn to an analysis of the runtime of the algorithm.",
        "Let n be the number of components of D .",
        "It is not hard to imagine an algorithm that performs the annotation task in time O(n log n): such an algorithm could construct the components for a given node u by essentially merging the list of components of the children of u into a new sorted list.",
        "In contrast, our algorithm takes time O(n).",
        "The crucial part of the analysis is the assignment in line 6, which computes the least common ancestor of u and its predecessor.",
        "Using markers for the path from the root node to u, it is straightforward to implement this assignment in time O(|n |), where n is the path b • • • u.",
        "Now notice that, by our correctness argument, line 8 of the algorithm is executed exactly n times.",
        "Therefore, the sum over the lengths of all the paths n, and hence the amortized time of computing all the least common ancestors in line 6, is O(n).",
        "This runtime complexity is optimal for the task we are solving.",
        "We now describe how to extend the annotation algorithm into a procedure that extracts an LCFRS from a given dependency tree D .",
        "The basic idea is to transform the list of components of each node u of D into a production p. This transformation will only rename and relabel nodes, and therefore yield an adequate derivation tree.",
        "For the construction of the production, we actually need an extended version of the annotation algorithm, in which each component is annotated with the node that contributed it.",
        "This extension is straightforward, and does not affect the linear runtime complexity.",
        "Let D be a dependency tree for a sentence w. Consider a single node u of D , and assume that u has r children, and that the block-degree of u is f .",
        "We construct for u a production p with rank r and fanout f. For convenience, let us order the children of u, say by their leftmost descendants, and let us write ui for the i th child of u according to this order, and fi for the block-degree of ui, i e [r].",
        "The production p has the form where L is the label of the incoming edge of u (or the special label root in case that u is the root node of D ) and for each i e [r]: Li is the label of the incoming edge of ui; Xi is a f • -tuple of variables of the form %ij, where j e [f- ]; and a is an f -tuple that is constructed in a single left-to-right sweep over the list of components computed for u as follows.",
        "Let k e [f • ] be a pointer to a current segment of a; initially, k = 1.",
        "If the current component is not adjacent (as an interval) to the previous component, we increase k by one.",
        "If the current component is contributed by the child ui, i e [r], we add the variable %ij to , where j is the number of times we have seen a component contributed by ui during the sweep.",
        "Notice that j e [fi ].",
        "If the current component is the (unique) component contributed by u, we add the token corresponding to u to .",
        "In this way, we obtain a complete specification of how the blocks of u (represented by the segments of the tuple a) decompose into the components of u, and of the relative order of the components.",
        "As an example, Figure 2 shows the productions extracted from the tree above.",
        "Once we have extracted the grammar for a dependency treebank, we can apply any parsing algorithm for LCFRS to non-projective dependency parsing.",
        "The generic chart-parsing algorithm for LCFRS runs in time O(|P | • |w|/.r where P is the set of productions of the input grammar G, w is the input string, r is the maximal rank, and f is the maximal fanout of a production in G (Seki et al., 1991).",
        "For a grammar G extracted by our technique, the number f equals the maximal block-degree per node.",
        "Hence, without any further modification, we obtain a parsing algorithm that is polynomial in the length of the sentence, but exponential in both the block-degree and the rank.",
        "This is clearly unacceptable in practical systems.",
        "The relative frequency of analyses with a block-degree > 2 is almost negligible (Havelka, 2007); the bigger obstacle in applying the treebank grammar is the rank of the resulting LCFRS.",
        "Therefore, in the remainder of the paper, we present an algorithm that can transform the productions of the input grammar G into an equivalent set of productions with rank at most 2, while preserving the fan-out.",
        "This transformation, if it succeeds, yields a parsing algorithm that runs intime O(|P| • r • |w|3/)."
      ]
    },
    {
      "heading": "1. A 2 hearing 3 is ^scheduled s on g the j issue g today",
      "text": [
        "nmod Sbj root -vc",
        "PP -nmod",
        "(scheduled, (on",
        "issue) ( today)"
      ]
    },
    {
      "heading": "4. Adjacency",
      "text": [
        "In this section we discuss a method for factorizing an LCFRS into productions of rank 2.",
        "Before starting, we get rid of the 'easy' cases.",
        "A production p is connected if any two strings a, ay in p's definition share at least one variable referring to the same nonterminal.",
        "It is not difficult to see that, when p is not connected, we can always split it into new productions of lower rank.",
        "Therefore, throughout this section we assume that LCFRS only have connected productions.",
        "We can split p into its connected components using standard methods for finding the strongly connected components of an undirected graph.",
        "This can be implemented in time O(r • f), where r and f are the rank and the fanout of p, respectively.",
        "Let p be a production with length n and fanout f , associated with function a g. The set of positions of p is the set [n].",
        "Informally, each position represents a variable or a lexical element in one of the components of the definition of g, or else a 'gap' between two of these components.",
        "(Recall that n also accounts for the f - 1 gaps in the body ofg.)",
        "Example 4 The set of positions of the production for hearing in Figure 2 is [4]: 1 for variable x1, 2 for hearing, 3 for the gap, and 4 for y 1.",
        "□",
        "Let i1 , j1 , i2, j2 e [n].",
        "An interval [i1 , j1 ] is adjacent to an interval [i2, j2] if either j1 = i2 - 1 (left-adjacent) or i1 = j2 + 1 (right-adjacent).",
        "A multi-interval, or m-interval for short, is a set v of pairwise disjoint intervals such that no interval in v is adjacent to any other interval in v .",
        "The fanout of v, written f (v), is defined as |v|.",
        "We use m-intervals to represent the nonterminals and the lexical element heading p. The i th nonterminal on the right-hand side of p is represented by the m-interval obtained by collecting all the positions of p that represent a variable from the i th argument of g. The head of p is represented by the m-interval containing the associated position.",
        "Note that all these m-intervals are pairwise disjoint.",
        "For disjoint m-intervals v1 , v2, we say that v1 is adjacent to v2, denoted by v1 !",
        "v2, if for every interval 11 e v1, there is an interval 12 e v2 such that 11 is adjacent to 12.",
        "Adjacency is not symmetric: if v1 = { [1, 1], [4,4] } and v2 = { [2,2] },then v2 !",
        "v1, but not vice versa.",
        "Let V be some collection of pairwise disjoint m-intervals representing p as above.",
        "The adjacency graph associated with p is the graph G = (V, !g) whose vertices are the m-intervals in V, and whose edges !g are defined by restricting the adjacency relation !",
        "to the set V.",
        "For m-intervals v1, v2 e V, the merger of v1and v2, denoted by v1 © v2, is the (uniquely determined) m-interval whose span is the union of the spans of v1 and v2.",
        "As an example, if v1 = {[1,1], [3, 3]} and v2 = {[2,2]}, then v1 © v2 = { [1,3] }.",
        "Notice that the way in which we defined m-intervals ensures that a merging operation collapses all adjacent intervals.",
        "The proof of the following lemma is straightforward and omitted for space reasons:",
        "root",
        "node _nn_",
        "fSbjl",
        " – pp – ",
        "rvci",
        "r",
        "^nmod-j",
        "Lemma 2 If v1 !",
        "v2, then f (v1 © v2) < f (v2).",
        "Let G = (V, !g) be some adjacency graph, and let v1 !g v2.",
        "We can derive a new adjacency graph from G by merging v1 and v2.",
        "The resulting graph G has vertices V = V – {v1, v2} U {v1 © v2} and set of edges !g' obtained by restricting the adjacency relation !",
        "to V. We denote the derive relation as G )(V1;V2) G.",
        "Informally, if G represents some LCFRS production p and v1 , v2 represent nonterminals A1 , A2, thenG represents aproductionp obtained fromp by replacing A1, A2 with a fresh nonterminal A.",
        "A new production p can also be constructed, expanding A into A1 , A2, so that p, p together will be equivalent to p. Furthermore, p has a rank smaller than the rank of p and, from Lemma 2, A does not increase the overall fanout of the grammar.",
        "In order to simplify the notation, we adopt the following convention.",
        "Let G )(V1;V2) G and let v !g v1, v ^ v2.",
        "If v v1 © v2, then edges (v, v1) and (v, v1 © v2) will be identified, and we say that G inherits (v, v1 © v2) from G. If v !g' v1 © v2, then we say that (v, v1) does not survive the derive step.",
        "This convention is used for all edges incident upon v1 or v2.",
        "Our factorization algorithm is reported in Figure 3.",
        "We start from an adjacency graph representing some LCFRS production that needs to be factorized.",
        "We arbitrarily choose an edge e of the graph, and push it into a set R, in order to keep a record of the candidate factorization.",
        "We then merge the two m-intervals incident to e, and we recompute the adjacency relation for the new set of vertices.",
        "We iterate until the resulting graph has an empty edge set.",
        "If the final graph has one one vertex, then we have managed to factorize our production into a set of productions with rank at most two that can be computed from R.",
        "We have already argued that, if the algorithm accepts, then a binary factorization that does not increase the fanout of the grammar can be built from R .",
        "We still need to prove that the algorithm answers consistently on a given input, despite of possibly different choices of edges at line 4.",
        "We do this through several intermediate results.",
        "A derivation for an adjacency graph G is a sequence of edges d = (e1,..., en), n > 1, such that G = Go and Gi _1 )ei Gi for every i with 1 < i < n. For short, we write G0 )d Gn.",
        "Two derivations for G are competing if one is a permutation of the other.",
        "Lemma 3 If G )d1 G1 and G )d2 G2 with d1and d2 competing derivations, then G1 = G2.",
        "Proof We claim that the statement of the lemma holds for |d1| = 2.",
        "To see this, let G )eiG1 )e2 G1 and G )e2 G2 )ei G2 be valid derivations.",
        "We observe that G and G2 have the same set of vertices.",
        "Since the edges of G1 and G2are defined by restricting the adjacency relation to their set of vertices, our claim immediately follows.",
        "The statement of the lemma then follows from the above claim and from the fact that we can always obtain the sequence d2 starting from d1 by repeatedly switching consecutive edges.",
        "■",
        "We now consider derivations for the same adjacency graph that are not competing, and show that they always lead to isomorphic adjacency graphs.",
        "Two graphs are isomorphic if they become equal after some suitable renaming of the vertices.",
        "Lemma 4 The out-degree ofG is bounded by 2.",
        "Proof Assume v !g v1 and v !g v2, with v1 ^ v2, and let I e v. I must be adjacent to some interval 11 e v1.",
        "Without loss of generality, assume that I is left-adjacent to 11.",
        "I must also be adjacent to some interval 12 e v2.",
        "Since v1 and v2 are disjoint, 1 must be right-adjacent to 12.",
        "This implies that 1 cannot be adjacent to an interval in any other m-interval v of G. ■",
        "A vertex v of G such that v !g v1 and v !g v2is called a bifurcation.",
        "The example above shows that, when choosing one of the two outgoing edges in a bifurcation for merging, the other edge might not survive.",
        "Thus, such a choice might lead to distinguishable derivations that are not competing (one derivation has an edge that is not present in the other).",
        "As we will see (in the proof of Theorem 1), bifurcations are the only cases in which edges might not survive a merging.",
        "Lemma 5 Let v be a bifurcation of G with outgoing edges e1,e2, and let G )ei G1, G )e2 G2.",
        "Then G1 and G2 are isomorphic.",
        "Proof (Sketch) Assume e1 has the form v !g v1 and e2 has the form v !g v2.",
        "Let also Vs be the set of vertices shared by G1 and G2.",
        "We show that the statement holds under the isomorphism mapping v © v1 and v2 in G1 to v1 and v © v2 in G2, respectively.",
        "When restricted to Vs , the graphs G1 and G2are equal.",
        "Let us then consider edges from G1 and G2 involving exactly one vertex in Vs .",
        "We show that, for v e Vs, v !g1 v © v1 if and only if v !g2 v1.",
        "Consider an arbitrary interval 1 e v. If v !g1 v © v1, then 1 must be adjacent to some interval 11 e v © v1.",
        "If 11 e v1 we are done.",
        "Otherwise, 11 must be the concatenation of two intervals 11v and with 11v e v and e v1.",
        "Since v !g2 v2, 11v is also adjacent to some interval in v2.",
        "However, v and v2 are disjoint.",
        "Thus 1 must be adjacent to e v1.",
        "Conversely, if v !g2 v1, then 1 must be adjacent to some interval 11 e v1.",
        "Because v and v are disjoint, 1must also be adjacent to some interval in v © v1 .",
        "Using very similar arguments, we can conclude that G1 and G2 are isomorphic when restricted to edges with at most one vertex in Vs .",
        "Finally, we need to consider edges from G1 and G2 that are not incident upon vertices in Vs .",
        "We show that v © v1 !g1 v2 only if v1 !g2 v © v2; a similar argument can be used to prove the converse.",
        "Consider an arbitrary interval 11 e v © v1.",
        "If v © v1 !g1 v2, then 11 must be adjacent to some interval 12 e v2.",
        "If 11 e v1 we are done.",
        "Otherwise, 11 must be the concatenation of two adjacent intervals 11v and with 11v e v and e v1.",
        "Since 11v is also adjacent to some interval 12 e v2(here 7-2 might as well be 12), we conclude that e v1 is adjacent to the concatenation of 11vand 12, which is indeed an interval in v © v2.",
        "Note that our case distinction is exhaustive.",
        "We thus conclude that v1 !g2 v © v2.",
        "A symmetrical argument can be used to show that v2 !g1 v © v1 if and only if v © v2 !g2 v1, which concludes our proof.",
        "■ Theorem 1 Let d1 and d2 be derivations for G, describing two different computations c1 and c2 of the algorithm of Figure 3 on input G. Computation c1 is accepting if and only if c2 is accepting.",
        "Proof First, we prove the claim that if e is not an edge outgoing from a bifurcation vertex, then in the derive relation G )e G all of the edges of G but e and its reverse are inherited by G. Let us write e in the form v1 !g v2.",
        "Obviously, any edge of G not incident upon v1 or v2 will be inherited by G. If v !g v2 for some m-interval v ^ v1, then every interval 1 e v is adjacent to some interval in v2.",
        "Since v and v1 are disjoint, 1 will also be adjacent to some interval in v1 © v2.",
        "Thus we have v !g' v1 © v2.",
        "A similar argument shows that v !g v1 implies v !g' v1 © v2.",
        "If v2 !g v for some v ^ v1, then every interval 1 e v2 is adjacent to some interval in v. From v1 !g v2 we also have that each interval 112 e v1 © v2 is either an interval in v2 or else the concatenation of exactly two intervals 11 e v1and 12 e v2.",
        "(The interval 12 cannot be adjacent to more than an interval in v1, because v2 !g v).",
        "In both cases 112 is adjacent to some interval in v, and hence v1 © v2 !g' v. This concludes the proof of our claim.",
        "Let d1 , d2 be as in the statement of the theorem, with G )d1 G1 and G )d2 G2.",
        "If d1and d2 are competing, then the theorem follows from Lemma 3.",
        "Otherwise, assume that d1 and d2 are not competing.",
        "From our claim above, some bifurcation vertices must appear in these derivations.",
        "Let us reorder the edges in d1 in such a way that edges outgoing from a bifurcation vertex are processed last and in some canonical order.",
        "The resulting derivation has the form dd1, where d1involves the processing of all bifurcation vertices.",
        "We can also reorder edges in d2 to obtain dd2, where d2 involves the processing of all bifurcation vertices in exactly the same order as in d1, but with possibly different choices for the outgoing edges.",
        "Let G )d Gd G and G )rf Gd G2.",
        "Derivations dd1 and d1 are competing.",
        "Thus, by Lemma 3, we have G = G .",
        "Similarly, we can conclude that G2 = G2.",
        "Since bifurcation vertices in d and in d2 are processed in the same canonical order, from repeated applications of Lemma 5 we have that G and G2 are isomorphic.",
        "We then conclude that G and G2 are isomorphic as well.",
        "The statement of the theorem follows immediately.",
        "■",
        "We now turn to a computational analysis of the algorithm of Figure 3.",
        "Let G be the representation of an LCFRS production p with rank r. G has r vertices and, following Lemma 4, O(r) edges.",
        "Let v be an m-interval of G with fanout fv.",
        "The incoming and outgoing edges for v can be detected in time O(fv) by inspecting the 2 • fv endpoints of v. Thus we can compute G in time O(|p|).",
        "The number of iterations of the while cycle in the algorithm is bounded by r, since at each iteration one vertex of G is removed.",
        "Consider now an iteration in which m-intervals v and v2 have been chosen for merging, with v1 !g v2.",
        "(These m-intervals might be associated with nonterminals in the right-hand side of p, or else might have been obtained as the result of previous merging operations.)",
        "Again, we can compute the incoming and outgoing edges of v © v2 in time proportional to the number of endpoints of such an m-interval.",
        "By Lemma 2, this number is bounded by O (f), f the fanout of the grammar.",
        "We thus conclude that a run of the algorithm on G takes time O(r • f)."
      ]
    },
    {
      "heading": "5. Discussion",
      "text": [
        "We have shown how to extract mildly context-sensitive grammars from dependency treebanks, and presented an efficient algorithm that attempts to convert these grammars into an efficiently par-seable binary form.",
        "Due to previous results (Ram-bow and Satta, 1999), we know that this is not always possible.",
        "However, our algorithm may fail even in cases where a binarization exists – our notion of adjacency is not strong enough to capture all binarizable cases.",
        "This raises the question about the practical relevance of our technique.",
        "In order to get at least a preliminary answer to this question, we extracted LCFRS productions from the data used in the 2006 CoNLL shared task on data-driven dependency parsing (Buchholz and Marsi, 2006), and evaluated how large a portion of these productions could be binarized using our algorithm.",
        "The results are given in Table 1.",
        "Since it is easy to see that our algorithm always succeeds on context-free productions (productions where each nonterminal has fanout 1 ), we evaluated our algorithm on the 102 687 productions with a higher fan-out.",
        "Out of these, only 24 (0.02%) could not be binarized using our technique.",
        "We take this number as an indicator for the usefulness of our result.",
        "It is interesting to compare our approach with techniques for well-nested dependency trees (Kuhlmann and Nivre, 2006).",
        "Well-nestedness is a property that implies the binarizability of the extracted grammar; however, the classes of well-nested trees and those whose corresponding productions can be binarized using our algorithm are incomparable – in particular, there are well-nested productions that cannot be binarized in our framework.",
        "Nevertheless, the coverage of our technique is actually higher than that of an approach that relies on well-nestedness, at least on the CoNLL 2006 data (see again Table 1).",
        "We see our results as promising first steps in a thorough exploration of the connections between non-projective and mildly context-sensitive parsing.",
        "The obvious next step is the evaluation of our technique in the context of an actual parser.",
        "As a final remark, we would like to point out that an alternative technique for efficient non-projective dependency parsing, developed by Gomez Rodriguez et al.",
        "independently of this work, is presented elsewhere in this volume.",
        "Acknowledgements We would like to thank Ryan McDonald, Joakim Nivre, and the anonymous reviewers for useful comments on drafts of this paper, and Carlos Gomez Rodriguez and David J. Weir for making a preliminary version of their paper available to us.",
        "The work of the first author was funded by the Swedish Research Council.",
        "The second author was partially supported by MIUR under project PRIN No.",
        "2007TJNZRE_002."
      ]
    }
  ]
}
