{
  "info": {
    "authors": [
      "Aarne Ranta",
      "Krasimir Angelov",
      "Björn Bringert"
    ],
    "book": "EACL – Demos",
    "id": "acl-E09-2015",
    "title": "Grammar Development in GF",
    "url": "https://aclweb.org/anthology/E09-2015",
    "year": 2009
  },
  "references": [
    "acl-C00-1036",
    "acl-I05-2035",
    "acl-P98-2173",
    "acl-W02-1503",
    "acl-W07-1801"
  ],
  "sections": [
    {
      "text": [
        "Aarne Ranta and Krasimir Angelov and Björn Bringert*",
        "{aarne,krasimir,bringert}@chalmers.se",
        "GF is a grammar formalism that has a powerful type system and module system, permitting a high level of abstraction and division of labour in grammar writing.",
        "GF is suited both for expert linguists, who appreciate its capacity of generalizations and conciseness, and for beginners, who benefit from its static type checker and, in particular, the GF Resource Grammar Library, which currently covers 12 languages.",
        "GF has a notion of multilingual grammars, enabling code sharing, linguistic generalizations, rapid development of translation systems, and painless porting of applications to new languages."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Grammar implementation for natural languages is a challenge for both linguistics and engineering.",
        "The linguistic challenge is to master the complexities of languages so that all details are taken into account and work seamlessly together; if possible, the description should be concise and elegant, and capture the linguist's generalizations on the level of code.",
        "The engineering challenge is to make the grammar scalable, reusable, and maintainable.",
        "Too many grammars implemented in the history of computational linguistics have become obsolete, not only because of their poor maintainability, but also because of the decay of entire software and hardware platforms.",
        "The first measure to be taken against the \"bit rot\" of grammars is to write them in well-defined formats that can be implemented independently of platform.",
        "This requirement is more or less an axiom in programming language development: a",
        "* Now at Google Inc.",
        "language must have syntax and semantics specifications that are independent of its first implementation; otherwise the first implementation risks to remain the only one.",
        "Secondly, since grammar engineering is to a large extent software engineering, grammar formalisms should learn from programming language techniques that have been found useful in this respect.",
        "Two such techniques are static type systems and module systems.",
        "Since grammar formalism implementations are mostly descendants of Lisp and Prolog, they usually lack a static type system that finds errors at compile time.",
        "In a complex task like grammar writing, compile-time error detection is preferable to runtime debugging whenever possible.",
        "As for modularity, traditional grammar formalisms again inherit from Lisp and Prolog low-level mechanisms like macros and file includes, which in modern languages like Java and ML have been replaced by advanced module systems akin in rigour to type systems.",
        "Thirdly, as another lesson from software engineering, grammar writing should permit an increasing use of libraries, so that programmers can build on ealier code.",
        "Types and modules are essential for the management of libraries.",
        "When a new language is developed, an effort is needed in creating libraries for the language, so that programmers can scale up to real-size tasks.",
        "Fourthly, a grammar formalism should have a stable and efficient implementation that works on different platforms (hardware and operating systems).",
        "Since grammars are often parts of larger language-processing systems (such as translation tools or dialogue systems), their interoperability with other components is an important issue.",
        "The implementation should provide compilers to standard formats, such as databases and speech recognition language models.",
        "In addition to interoperability, such compilers also help keeping the grammars alive even if the original grammar formalism ceases to exist.",
        "Fifthly, grammar formalisms should have rich documentation; in particular, they should have accessible tutorials that do not demand the readers to be experts in a linguistic theory or in computer programming.",
        "Also the libraries should be documented, preferably by automatically generated documentation in the style of JavaDoc, which is guaranteed to stay up to date.",
        "Last but not least, a grammar formalism, as well its documentation, implementation, and standard libraries, should be freely available open-source software that anyone can use, inspect, modify, and improve.",
        "In the domain of general-purpose programming, this is yet another growing trend; proprietary languages are being made open-source or at least free of charge."
      ]
    },
    {
      "heading": "2. The GF programming language",
      "text": [
        "The development of GF started in 1998 at Xerox Research Centre Europe in Grenoble, within a project entitled \"Multilingual Document Authoring\" (Dymetman & al.",
        "2000).",
        "Its purpose was to make it productive to build controlled-language translators and multilingual authoring systems, previously produced by hard-coded grammar rules rather than declarative grammar formalisms (Power & Scott 1998).",
        "Later, mainly at Chalmers University in Gothenburg, GF developed into a functional programming language inspired by ML and Haskell, with a strict type system and operational semantics specified in (Ranta 2004).",
        "A module system was soon added (Ranta 2007), inspired by the parametrized modules of ML and the class inheritance hierarchies of Java, although with multiple inheritance in the style of C++.",
        "Technically, GF falls within the class of so-called Curry-style categorial grammars, inspired by the distinction between tectogrammatical and phenogrammatical structure in (Curry 1963).",
        "Thus a GF grammar has an abstract syntax defining a system of types and trees (i.e. a free algebra), and a concrete syntax, which is a homomorphic mapping from trees to strings and, more generally, to records of strings and features.",
        "To take a simple example, the NP-VP predication rule, written in a context-free notation, becomes in GF a pair of an abstract and a concrete syntax rule,",
        "The keyword fun stands for function declaration (declaring the function Pred of type NP -> VP -> S), whereas lin stands for linearization (saying that trees of form Pred np vp are converted to strings where the linearization of np is followed by the linearization of vp).",
        "The arrow - > is the normal function type arrow of programming languages, and ++ is concatenation.",
        "Patterns more complex than string concatenation can be used in linearizations of the same predication trees as the rule above.",
        "Thus agreement can be expressed by using features passed from the noun phrase to the verb phrase.",
        "The noun phrase is here defined as not just a string, but as a record with two fields – a string s and an agreement feature a. Verb-subject inversion can be expressed by making VP into a discontinuous constituent, i.e. a record with separate verb and complement fields v and c. Combining these two phenomena, we write (For the details of the notation, we refer to documentation on the GF web page.)",
        "Generalizing strings into richer data structures makes it smooth to deal accurately with complexities such as German constituent order and Romance clitics, while maintaining the simple tree structure defined by the abstract syntax of Pred.",
        "Separating abstract and concrete syntax makes it possible to write multilingual grammars, where one abstract syntax is equipped with several concrete syntaxes.",
        "Thus different string configurations can be mapped into the same abstract syntax trees.",
        "For instance, the distinction between SVO and VSO languages can be ignored on the abstract level, and so can all other {S,V,O} patterns as well.",
        "Also the differences in feature systems can be abstracted away from.",
        "For instance, agreement features in English are much simpler than in Arabic; yet the same abstract syntax can be used.",
        "Since concrete syntax is reversible between linearization and parsing (Ljunglof 2004), multilingual grammars can be used for translation, where the abstract syntax works as interlingua.",
        "Experience from translation projects (e.g. Burke and Jo-hannisson 2005, Caprotti 2006) has shown that the interlingua-based translation provided by GF gives good quality in domain-specific tasks.",
        "However, GF also supports the use of a transfer component if the compositional method implied by multilingual grammars does not suffice (Bringert and Ranta 2008).",
        "The language-theoretical strenght of GF is between mildly and fully context-sensitive, with polynomial parsing complexity (Ljunglof 2004).",
        "In addition to multilingual grammars, GF is usable for more traditional, large-scale unilin-gual grammar development.",
        "The \"middle-scale\" resource grammars can be extended to wide-coverage grammars, by adding a few rules and a large lexicon.",
        "GF provides powerful tools for building morphological lexica and exporting them to other formats, including Xerox finite state tools (Beesley and Karttunen 2003) and SQL databases (Forsberg and Ranta 2004).",
        "Some large lexica have been ported to the GF format from freely available sources for Bulgarian, English, Finnish, Hindi, and Swedish, comprising up to 70,000 lemmas and over two million word forms."
      ]
    },
    {
      "heading": "3. The GF Resource Grammar Library",
      "text": [
        "The GF Resource Grammar Library is a comprehensive multilingual grammar currently implemented for 12 languages: Bulgarian, Catalan, Danish, English, Finnish, French, German, Italian, Norwegian, Russian, Spanish, and Swedish.",
        "Work is in progress on Arabic, Hindi/Urdu, Latin, Polish, Romanian, and Thai.",
        "The library is an open-source project, which constantly attracts new contributions.",
        "The library can be seen as an experiment on how far the notion of multilingual grammars extends and how GF scales up to wide-coverage grammars.",
        "Its primary purpose, however, is to provide a programming resource similar to the standard libraries of various programming languages.",
        "When all linguistic details are taken into account, grammar writing is an expert programming task, and the library aims to make this expertise available to non-expert application programmers.",
        "The coverage of the library is comparable to the Core Language Engine (Rayner & al.",
        "2000).",
        "It has been developed and tested in applications ranging from a translation system for software specifications (Burke and Johannisson 2005) to in-car dialogue systems (Perera and Ranta 2007).",
        "The use of a grammar as a library is made possible by the type and module system of GF (Ranta 2007).",
        "What is more, the API (Application Programmer's Interface) of the library is to a large extent language-independent.",
        "For instance, an NP-VP predication rule is available for all languages, even though the underlying details of predication vary greatly from one language to another.",
        "A typical domain grammar, such as the one in Perera and Ranta (2007), has 100-200 syntactic combinations and a lexicon of a few hundred lemmas.",
        "Building the syntax with the help of the library is a matter of a few working days.",
        "Once it is built for one language, porting it to other languages mainly requires writing the lexicon.",
        "By the use of the inflection libraries, this is a matter of hours.",
        "Thus porting a domain grammar to a new language requires very effort and also very little linguistic knowledge: it is expertise of the application domain and its terminology that is needed."
      ]
    },
    {
      "heading": "4. The GF grammar compiler",
      "text": [
        "The GF grammar compiler is usable in two ways: in batch mode, and as an interactive shell.",
        "The shell is a useful tool for developers as it provides testing facilities such as parsing, linerization, random generation, and grammar statistics.",
        "Both modes use PGF, Portable Grammar Format, which is the \"machine language\" of GF permitting fast runtime linearization and parsing (An-gelov & al.",
        "2008).",
        "PGF interpreters have been written in C++, Java, and Haskell, permitting an easy embedding of grammars in systems written in these languages.",
        "PGF can moreover be translated to other formats, including language models for speech recognition (e.g. Nuance and HTK; and JavaScript (Meza Moreno and Bringert 2008).",
        "The grammar compiler is heavily optimizing, so that the use of a large library grammar in small runtime applications produces no penalty.",
        "For the working grammarian, static type checking is maybe the most unique feature of the GF grammar compiler.",
        "Type checking does not only detect errors in grammars.",
        "It also enables aggressive optimizations (type-driven partial evaluation), and overloading resolution, which makes it possible to use the same name for different functions whose types are different."
      ]
    },
    {
      "heading": "5. Related work",
      "text": [
        "As a grammar development system, GF is comparable to Regulus (Rayner 2006), LKB (Copestake unique features of GF are its type and module system, support for multilingual grammars, the large number of back-end formats, and the availability of libraries for 12 languages.",
        "Regulus has resource grammars for 7 languages, but they are smaller in scope.",
        "In LKB, the LinGO grammar matrix has been developed for several languages (Bender and Flickinger 2005), and in XLE, the Pargram grammar set (Butt & al.",
        "2002).",
        "LKB and XLE tools have been targeted to linguists working with large-scale grammars, rather than for general programmers working with applications."
      ]
    }
  ]
}
