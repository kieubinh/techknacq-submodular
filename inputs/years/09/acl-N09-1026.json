{
  "info": {
    "authors": [
      "John DeNero",
      "Mohit Bansal",
      "Adam Pauls",
      "Dan Klein"
    ],
    "book": "HLT-NAACL",
    "id": "acl-N09-1026",
    "title": "Efficient Parsing for Transducer Grammars",
    "url": "https://aclweb.org/anthology/N09-1026",
    "year": 2009
  },
  "references": [
    "acl-D07-1079",
    "acl-D07-1104",
    "acl-D08-1012",
    "acl-D08-1018",
    "acl-J97-3002",
    "acl-J98-2004",
    "acl-J99-4004",
    "acl-N04-1035",
    "acl-N06-1033",
    "acl-N07-1051",
    "acl-N07-1063",
    "acl-P03-1054",
    "acl-P05-1033",
    "acl-P06-1055",
    "acl-P06-1098",
    "acl-P06-1121",
    "acl-P07-1019",
    "acl-P08-1025",
    "acl-W06-1606",
    "acl-W06-3119"
  ],
  "sections": [
    {
      "text": [
        "John DeNero, Mohit Bansal, Adam Pauls, and Dan Klein",
        "Computer Science Division University of California, Berkeley",
        "The tree-transducer grammars that arise in current syntactic machine translation systems are large, flat, and highly lexicalized.",
        "We address the problem of parsing efficiently with such grammars in three ways.",
        "First, we present a pair of grammar transformations that admit an efficient cubic-time CKY-style parsing algorithm despite leaving most of the grammar in nary form.",
        "Second, we show how the number of intermediate symbols generated by this transformation can be substantially reduced through binarization choices.",
        "Finally, we describe a two-pass coarse-to-fine parsing approach that prunes the search space using predictions from a subset of the original grammar.",
        "In all, parsing time reduces by 81%.",
        "We also describe a coarse-to-fine pruning scheme for forest-based language model reranking that allows a 100-fold increase in beam size while reducing decoding time.",
        "The resulting translations improve by 1.3 BLEU."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Current approaches to syntactic machine translation typically include two statistical models: a syntactic transfer model and an n-gram language model.",
        "Recent innovations have greatly improved the efficiency of language model integration through multipass techniques, such as forest reranking (Huang and Chiang, 2007), local search (Venugopal et al., 2007), and coarse-to-fine pruning (Petrov et al., 2008; Zhang and Gildea, 2008).",
        "Meanwhile, translation grammars have grown in complexity from simple inversion transduction grammars (Wu, 1997) to general tree-to-string transducers (Galley et al., 2004) and have increased in size by including more synchronous tree fragments (Galley et al., 2006; Marcu et al., 2006; DeNeefe et al., 2007).",
        "As aresult of these trends, the syntactic component of machine translation decoding can now account for a substantial portion of total decoding time.",
        "In this paper, we focus on efficient methods for parsing with very large tree-to-string grammars, which have flat nary rules with many adjacent non-terminals, as in Figure 1.",
        "These grammars are sufficiently complex that the purely syntactic pass of our multi-pass decoder is the compute-time bottleneck under some conditions.",
        "Given that parsing is well-studied in the monolingual case, it is worth asking why MT grammars are not simply like those used for syntactic analysis.",
        "There are several good reasons.",
        "The most important is that MT grammars must do both analysis and generation.",
        "To generate, it is natural to memorize larger lexical chunks, and so rules are highly lexicalized.",
        "Second, syntax diverges between languages, and each divergence expands the minimal domain of translation rules, so rules are large and flat.",
        "Finally, we see most rules very few times, so it is challenging to subcategorize non-terminals to the degree done in analytic parsing.",
        "This paper develops encodings, algorithms, and pruning strategies for such grammars.",
        "We first investigate the qualitative properties of MT grammars, then present a sequence of parsing methods adapted to their broad characteristics.",
        "We give normal forms which are more appropriate than Chomsky normal form, leaving the rules mostly flat.",
        "We then describe a CKY-like algorithm which applies such rules efficiently, working directly over the -ary forms in cubic time.",
        "We show how thoughtful",
        "NNPi did not slap DT2 green NN3",
        "NNPi no daba una bofetada a DT2 NN3 verde",
        "Mary did not slap the green witch Maria no daba una bofetada a la bruja verde",
        "Figure 1: (a) A synchronous transducer rule has co-indexed non-terminals on the source and target side.",
        "Internal grammatical structure of the target side has been omitted.",
        "(b) The source-side projection of the rule is a monolingual source-language rule with target-side grammar symbols.",
        "(c) A training sentence pair is annotated with a target-side parse tree and a word alignment, which license this rule to be extracted.",
        "binarization can further increase parsing speed, and we present a new coarse-to-fine scheme that uses rule subsets rather than symbol clustering to build a coarse grammar projection.",
        "These techniques reduce parsing time by 81% in aggregate.",
        "Finally, we demonstrate that we can accelerate forest-based reranking with a language model by pruning with information from the parsing pass.",
        "This approach enables a 100-fold increase in maximum beam size, improving translation quality by 1.3 BLEU while decreasing total decoding time."
      ]
    },
    {
      "heading": "2. Tree Transducer Grammars",
      "text": [
        "source-side,",
        "Figure 2: Transducer grammars are composed of very flat rules.",
        "Above, the histogram shows rule counts for each rule size among the 332,000 rules that apply to an individual 30-word sentence.",
        "The size of a rule is the total number of non-terminals and lexical items in its source-side yield.",
        "stituent alignments ((Galley et al., 2004).",
        "Given this correspondence, an array of extraction procedures yidds fules that; are well-suited to machine translation (((alley et al., 2006; DeNeefe et al., 2007; Marcu et al., 2006).",
        "Rule weights are estimated by discriminatively combining relative frequency counts and other rule features.",
        "A transducer grammar G can be projected onto its source language, inducing a monolingual grammar.",
        "If we weight each rule by the maximum weight of its projecting synchronous rules, then parsing with this projected maximizes the translation model score for a source sentence.",
        "We need not even consider the target side of transducer rules until integrating an n-gram language model or other non-local features of the target language.",
        "We conduct experiments with a grammar extracted from 220 million words of Arabic-English bitext, extracting rules with up to 6 non-terminals.",
        "A histogram of the size of rules applicable to a typical 30-word sentence appears in Figure 2.",
        "The grammar includes 149 grammatical symbols, an augmentation of the Penn Treebank symbol set.",
        "To evaluate, we the target side.",
        "Each non-terminal on the source side corresponds to a unique one on the target side.",
        "Aligned non-terminals share a grammar symbol derived from a target-side monolingual grammar.",
        "These grammars are learned from word-aligned sentence pairs annotated with target-side phrase structure trees.",
        "Extraction proceeds by using word alignments to find correspondences between targetside constituents and source-side word spans, then discovering transducer rules that match these condecoded 300 sentences of up to 40 words in length from the NIST05 Arabic-English test set."
      ]
    },
    {
      "heading": "3. Efficient Grammar Encodings",
      "text": [
        "Monolingual parsing with a source-projected transducer grammar is a natural first pass in multi-pass decoding.",
        "These grammars are qualitatively different from syntactic analysis grammars, such as the lexicalized grammars of Charniak (1997) or the heavily state-split grammars of Petrov et al.",
        "(2006).",
        "Tree-to-string transducer grammars consist of weighted rules like the one depicted in Figure 1.",
        "Each nary rule consists of a root symbol, a sequence of lexical items and non-terminals on the and a fragment of a syntax tree on",
        "In this section, we develop an appropriate grammar encodingthat enables efficient parsing.",
        "It is problematic to convert these grammars into Chomsky normal form, which CKY requires.",
        "Because transducer rules are very flat and contain specific lexical items, binarization introduces a large number of intermediate grammar symbols.",
        "Rule size and lexiceaelitzation affectlpiarsing coeme plexity whether the grammar is binarized explicitly (Zhang et al., 2006) or implicitly binarized using Early-style intermediate symbols (Zollmann et al., 2006).",
        "Moreover, the resulting binary rules cannot be Markovized to merge symbols, as in Klein and Manning (2003), because each rule is associated with a target-side tree that cannot be abstracted.",
        "We also do not restrict the form of rules in the grammar, a common technique in syntactic machine translation.",
        "For instance, Zollmann et al.",
        "(2006) follow Chiang (2005) in disallowing adjacent nonterminals.",
        "Watanabe et al.",
        "(2006) limit grammars to Griebach-Normal form.",
        "However, general tree transducer grammars provide excellent translation performance (Galley et al., 2006), and so we focus on parsing with all available rules.",
        "Original grammar rules are flat and lexical",
        "Sequences of consecutive non-terminals complicate parsing because they require a search over nonterminal boundaries when applied to a sentence span.",
        "We transform the grammar to ensure that all rules containing lexical items (lexical rules) do not contain sequences of non-terminals.",
        "We allow both unary and binary non-lexical rules.",
        "Let L be the set of lexical items and V the set of non-terminal symbols in the original grammar.",
        "Then, lexical normal form (LNF) limits productions to two forms:",
        "Non-lexical: X – ",
        "S – NNP no daba una bofetada a DT NN verde NP – DT NN NNS",
        "LNF replaces non-terminal sequences in lexical rules",
        "S – NNP no daba una bofetada a DT+NN verde",
        "Non-lexical rules are binarized using few symbols",
        "Non-lexical rules before binarization:",
        "Equivalent binary rules, minimizing symbol count: NP !",
        "DT+NN NNS DT+NN !",
        "DT NN",
        "Anchored LNF rules are bounded by lexical items",
        "S\\NNP – no daba una bofetada a DT+NN verde",
        "Figure 3: We transform the original grammar by first eliminating non-terminal sequences in lexical rules.",
        "Next, we binarize, adding a minimal number of intermediate grammar symbols and binary non-lexical rules.",
        "Finally, anchored LNF further transforms lexical rules to begin and end with lexical items by introducing additional symbols.",
        "lexical rule we replace each sequence of consecutive non-terminals X1 ... Xn with the intermediate symbol X1+.. .+Xn (abbreviated X1:n) and introduce a non-lexical rule X1 +...+Xn – X1 ... Xn.",
        "In the binarization step, we introduce further intermediate symbols and rules to binarize all non-lexical rules in the grammar, including those added by sequence elimination.",
        "sequence each end and no adjacent non-terminals.",
        "Converting a grammar into LNF requires two steps.",
        "In the sequence elimination step, for every",
        "Exactly how we binarize non-lexical rules affects the total number of intermediate symbols introduced by the LNF transformation.",
        "Binarization involves selecting a set of symbols that will allow us to assemble the right-hand side X\\... Xn of every non-lexical rule using binary productions.",
        "This symbol set must at least include the left-hand side of every rule in the grammar (lexical and non-lexical), including the intermediate",
        "Above, all Xj e V and w+ e L+.",
        "Symbols in parentheses are optional.",
        "The nucleus a of lexical",
        "Right-branching Left-branching Greedy Optimal (ILP)",
        "ILP takes the form:",
        "Figure 4: The number of non-terminal symbols introduced to the grammar through LNF binarization depends upon the policy for binarizing type sequences.",
        "This experiment ^ows results from transforming a grammar that has already been filtered for a particular short sentence.",
        "Both the greedy and optimal binarizations use far fewer symbols than naive binarizations.",
        "symbols X1:n introduced by sequence elimination.",
        "To ensure that a symbol sequence Xi... Xn can be constructed, we select a split point k and add intermediate types X1:k and Xk+1:n to the grammar.",
        "We must also ensure that the sequences X1... Xkand Xk+1... Xn can be constructed.",
        "As baselines, we used left-branching (where k = 1 always) and right-branching (where k = n – 1) binarizations.",
        "We also tested a greedy binarization approach, choosing k to minimize the number of grammar symbols introduced.",
        "We first try to select k such that both X1:k and Xk+1:n are already in the grammar.",
        "The solution to this ILP indicates which symbols appear in a minimal binarization.",
        "Equation 1 explicitly minimizes the number of symbols.",
        "Equation 2 ensures that all symbols already in the grammar remain in the grammar.",
        "Equation 3 does not require that a symbol represent the entire right-hand side of each non-lexical rule, but does ensure that each right-hand side sequence can be built from two subsequence symbols.",
        "Equation 4 ensures that any included intermediate type can also be built from two subsequence types.",
        "Finally, Equation 5 ensures that if a pair is used, each",
        "If no such k exists, we select k such that one of the intermediate types generated is already used.",
        "If no such k exists again, we choose k = nj.",
        "This policy only creates new intermediate types when necessary.",
        "Song et al.",
        "(2008) propose a similar greedy approach to binarization that uses corpus statistics to select common types rather than explicitly reusing types that have already been introduced.",
        "Finally, we computed an optimal binarization that explicitly minimizes the number of symbols in the resulting grammar.",
        "We cast the minimization as an integer linear program (ILP).",
        "Let V be the set of all base non-terminal symbols in the grammar.",
        "We introduce an indicator variable TY for each symbol",
        "Y £ V + to indicate that Y is used in the grammar.",
        "Y can be either a base non-terminal symbol Xj or an intermediate symbol X1:n. We also introduce indicators Aytz for each pairs of symbols, indicating that both Y and Z are used in the grammar.",
        "Let L C V + be the set of left-hand side symbols for all lexical and non-lexical rules already in the grammember of the pair is included.",
        "This program can be optimized with an off-the-shelf ILP solver.",
        "Figure 4 shows the number of intermediate grammar symbols needed for the four binarization policies described above for a short sentence.",
        "Our ILP solver could only find optimal solutions for very short sentences (which have small grammars after relativization).",
        "Because greedy requires very little time to compute and generates symbol counts that are close to optimal when both can be computed, we use it for our remaining experiments.",
        "We also consider a further grammar transformation, anchored lexical normal form (ALNF), in which the yield of lexical rules must begin and end with a lexical item.",
        "As shown in the following section, ALNF improves parsing performance over LNF by shifting work from lexical rule applications to non-lexical mar.",
        "Let R be the set of symbol sequences on the hand sMe of all non-lexical rules.",
        "Then, the s.t.",
        "Non-lexical: X – rule applications.",
        "ALNF consists of rules with the following two forms:",
        "To convert a grammar into ALNF, we first transform it into LNF, then introduce additional binary rules that split off non-terminal symbols from the ends of lexical rules, as shown in Figure 3."
      ]
    },
    {
      "heading": "4. Efficient CKY Parsing",
      "text": [
        "We now describe a CKY-style parsing algorithm for grammars in LNF.",
        "The dynamic program is organized into spans Sj and computes the Viterbi score w(i, j, X) for each edge Sij[X], the weight of the maximum parse over words i + 1 to j, rooted at symbol X.",
        "For each Sij, computation proceeds in three phases: binary, lexical, and unary.",
        "For a span Sij, we first apply the binary non-lexical rules just as in standard CKY, computing an intermediate Viterbi score wb(i, j, X).",
        "Let wr be the weight of rule r. Then, wb(i, j, X) = max ujr max w(i,k,X1) • w(k,j,X2).",
        "The quantities w(i, k, X1) and w(k, j, X2) will have already been computed by the dynamic program.",
        "The work in this phase is cubic in sentence length.",
        "On the other hand, lexical rules in LNF can be applied without binarization, because they only apply to particular spans that contain the appropriate lexical items.",
        "For a given Sij, we first compute all the legal mappings of each rule onto the span.",
        "A mapping consists of a correspondence between non-terminals in the rule and subspans of Sij.",
        "In practice, there is typically only one way that a lexical rule in LNF can map onto a span, because most lexical items will appear only once in the span.",
        "Let m be a legal mapping and r its corresponding rule.",
        "Let s£^ [X] be the edge mapped to the ith nonterminal of r under m, and wr the weight of r. Then, wj(i,j,X) = maxur TT w(k,^,X).",
        "Again, w(k,^, X) will have been computed by the dynamic program.",
        "Assuming only a constant number of mappings per rule per span, the work in this phase is quadratic.",
        "We can then merge and wb:",
        "w(i, j,X) = max(wj (i, j,X ),w6(i, j,X)).",
        "To efficiently compute mappings, we store lexical rules in a trie (or suffix array) - a searchable graph that indexes rules according to their sequence of lexical items and non-terminals.",
        "This data structure has been used similarly to index whole training sentences for efficient retrieval (Lopez, 2007).",
        "To find all rules that map onto a span, we traverse the trie using depth-first search.",
        "Unary non-lexical rules are applied after lexical rules and non-lexical binary rules.",
        "w(i,j,X)= max Wrw(i, j,Xi).",
        "While this definition is recursive, we allow only one unary rule application per symbol X at each span to prevent infinite derivations.",
        "This choice does not limit the generality of our algorithm: chains of unar-ies can always be collapsed via a unary closure.",
        "Non-lexical binary rules can in principle apply to any span Sij where j – i > 2, using any split point k such that i < k < j .In practice, however, many rules cannot apply to many (i, k, j) triples because the symbols for their children have not been constructed successfully over the subspans Sik and Skj.",
        "Therefore, the precise looping order over rules and split points can influence computation time.",
        "We found the following nested looping order for the binary phase of processing an edge Sij [X] gave the fastest parsing times for these grammars:"
      ]
    },
    {
      "heading": "1.. Loop over symbols X 1 for the left child",
      "text": [
        "2.",
        "Loop over all rules X – X1X2 containing X1",
        "This looping order allows for early stopping via additional bookkeeping in the algorithm.",
        "We track the following statistics as we parse:",
        "Grammar Bound checks Parsing time",
        "Table 1: Adding bound checks to CKY and transforming the grammar from LNF to anchored LNF reduce parsing time by 61% for 300 sentences of length 40 or less.",
        "No approximations have been applied, so all three scenarios produce no search errors.",
        "Parsing time is in minutes.",
        "minEND(i, X), maxEND(i,X): The minimum and maximum position k for which symbol X was successfully built over Sik.",
        "minsTART (j,X), maxsTART (j, X): The minimum and maximum position k for which symbol X was successfully built over Skj.",
        "We then bound k by min^ and maxfc in the inner loop using these statistics.",
        "If ever mink > maxk, then the loop is terminated early."
      ]
    },
    {
      "heading": "2.. loop over symbols X i for the left child",
      "text": [
        "minfc = max(minfc, minsTART(j,X2)) maxfc = min(maxfc, maxsTART (j, X2))",
        "In this way, we eliminate unnecessary work by avoiding split points that we know beforehand cannot contribute to j, X).",
        "Table 1 shows the decrease in parsing time from including these bound checks, as well as switching from lexical normal form to anchored LNF.",
        "Using ALNF rather than LNF increases the number of grammar symbols and non-lexical binary rules, but makes parsing more efficient in three ways.",
        "First, it decreases the number of spans for which a lexical rule has a legal mapping.",
        "In this way, ALNF effectively shifts work from the lexical phase to the binary phase.",
        "second, ALNF reduces the time spent searching the trie for mappings, because the first transition into the trie must use an edge with a lexical item.",
        "Finally, ALNF improves the frequency that, when a lexical rule matches a span, we have successfully built every edge S^[X] in the mapping for that rule.",
        "This frequency increases from 45% to 96% with ALNF."
      ]
    },
    {
      "heading": "5. Coarse-to-Fine Search",
      "text": [
        "We now consider two coarse-to-fine approximate search procedures for parsing with these grammars.",
        "Our first approach clusters grammar symbols together during the coarse parsing pass, following work in analytic parsing (Charniak and Caraballo, 1998; Petrov and Klein, 2007).",
        "We collapse all intermediate non-terminal grammar symbols (e.g., NP) to a single coarse symbol X, while pre-terminal symbols (e.g., NN) are hand-clustered into 7 classes (nouns, verbals, adjectives, punctuation, etc.).",
        "We then project the rules of the original grammar into this simplified symbol set, weighting each rule of the coarse grammar by the maximum weight of any rule that mapped onto it.",
        "In our second and more successful approach, we select a subset of grammar symbols.",
        "We then include only and all rules that can be built using those symbols.",
        "Because the grammar includes many rules that are compositions of smaller rules, parsing with a subset of the grammar still provides meaningful scores that can be used to prune base grammar symbols while parsing under the full grammar.",
        "To compress the grammar, we select a small subset of symbols that allow us to retain as much of the original grammar as possible.",
        "We use a voting scheme to select the symbol subset.",
        "After conversion to LNF (or ALNF), each lexical rule in the original grammar votes for the symbols that are required to build it.",
        "A rule votes as many times as it was observed in the training data to promote frequent rules.",
        "We then select the top ri\\ symbols by vote count and include them in the coarse grammar C.",
        "We would also like to retain as many non-lexical rules from the original grammar as possible, but the right-hand side of each rule can be binarized in many ways.",
        "We again use voting, but this time each nonPruning Minutes Model score BLEU",
        "Table 2: Coarse-to-fine pruning speeds up parsing time with minimal effect on either model score or translation quality.",
        "The coarse grammar built using symbol subsets outperforms clustering grammar symbols, reducing parsing time by 52%.",
        "These experiments do not include a language model.",
        "lexical rule votes for its yield, a sequence of symbols.",
        "We select the top nu symbol sequences as the set R of right-hand sides.",
        "Finally, we augment the symbol set of C with intermediate symbols that can construct all sequences in R, using only binary rules.",
        "This step again requires choosing a binarization for each sequence, such that a minimal number of additional symbols is introduced.",
        "We use the greedy approach from section 3.2.",
        "We then include in C all rules from the original grammar that can be built from the symbols we have chosen.",
        "surprisingly, we are able to retain 76% of the grammar rules while excluding 92% of the grammar symbols, which speeds up parsing substantially.",
        "We parse first with the coarse grammar to find the Viterbi derivation score for each edge S^- [X].",
        "We then perform a Viterbi outside pass over the chart, like a standard outside pass but replacing with max (Goodman, 1999).",
        "The product of an edge's Viterbi score and its Viterbi outside score gives a max marginal, the score of the maximal parse that uses the edge.",
        "We then prune away regions of the chart that deviate in their coarse max marginal from the global Viterbi score by a fixed margin tuned on a development set.",
        "Table 2 shows that both methods of constructing a coarse grammar are effective in pruning, but selecting symbol subsets outperformed the more typical clustering approach, reducing parsing time by an additional factor of 2."
      ]
    },
    {
      "heading": "6. Language Model Integration",
      "text": [
        "Large n-gram language models (LMs) are critical to the performance of machine translation systems.",
        "Recent innovations have managed the complexity of LM integration using multi-pass architectures.",
        "Zhang and Gildea (2008) describes a coarse-to-fine approach that iteratively increases the order of the LM.",
        "Petrov et al.",
        "(2008) describes an additional coarse-to-fine hierarchy over language projections.",
        "Both of these approaches integrate LMs via bottom-up dynamic programs that employ beam search.",
        "As an alternative, Huang and Chiang (2007) describes a forest-based reranking algorithm called cube growing, which also employs beam search, but focuses computation only where necessary in a top-down pass through a parse forest.",
        "In this section, we show that the coarse-to-fine idea of constraining each pass using marginal predictions of the previous pass also applies effectively to cube growing.",
        "Max marginal predictions from the parse can substantially reduce LM integration time.",
        "Parsing produces a forest of derivations, where each edge in the forest holds its Viterbi (or one-best) derivation under the transducer grammar.",
        "In forest reranking via cube growing, edges in the forest produce k-best lists of derivations that are scored by both the grammar and an n-gram language model.",
        "Using ALNF, each edge must first generate a k-best list of derivations that are not scored by the language model.",
        "These derivations are then flattened to remove the binarization introduced by ALNF, so that the resulting derivations are each rooted by an nary rule r from the original grammar.",
        "The leaves of r correspond to sub-edges in the chart, which are recursively queried for their best language-model-scored derivations.",
        "These sub-derivations are combined by r, and new n-grams at the edges of these derivations are scored by the language model.",
        "The language-model-scored derivations for the edge are placed on a priority queue.",
        "The top of the priority queue is repeatedly removed, and its successors added back on to the queue, until k language-model-scored derivations have been discovered.",
        "These k derivations are then sorted and",
        "Table 3: Time in minutes and performance for 300 sentences.",
        "We used a trigram language model trained on 220 million words of English text.",
        "The no pruning baseline used a fix beam size for forest-based language model reranking.",
        "Coarse-to-fine parsing included a coarse pruning pass using a symbol subset grammar.",
        "Coarse-to-fine reranking used max marginals to constrain the reranking pass.",
        "Coarse-to-fine parse + rerank employed both of these approximations.",
        "supplied to parent edges upon request.",
        "Even with this efficient reranking algorithm, integrating a language model substantially increased decoding time and memory use.",
        "As a baseline, we reranked using a small fixed-size beam of 20 derivations at each edge.",
        "Larger beams exceeded the memory of our hardware.",
        "Results appear in Table 3.",
        "Coarse-to-fine parsing before LM integration substantially improved language model reranking time.",
        "By pruning the chart with max marginals from the coarse symbol subset grammar from Section 5, we were able to rerank with beams of length 200, leading to a 0.8 BLEU increase and a 31% reduction in total decoding time.",
        "We realized similar performance and speed benefits by instead pruning with max marginals from the full grammar.",
        "We found that LM reranking explored many edges with low max marginals, but used few of them in the final decoder output.",
        "Following the coarse-to-fine paradigm, we restricted the reranker to edges with a max marginal above a fixed threshold.",
        "Furthermore, we varied the beam size of each edge based on the parse.",
        "Let Am be the ratio of the max marginal for edge m to the global Viterbi derivation for the sentence.",
        "We used a beam of size [~k • 2ln Am] for each edge.",
        "Computing max marginals under the full grammar required an additional outside pass over the full parse forest, adding substantially to parsing time.",
        "However, soft coarse-to-fine pruning based on these max marginals also allowed for beams up to length 200, yielding a 1.0 BLEU increase over the baseline and a 30% reduction in total decoding time.",
        "We also combined the coarse-to-fine parsing approach with this soft coarse-to-fine reranker.",
        "Tiling these approximate search methods allowed another 10-fold increase in beam size, further improving BLEU while only slightly increasing decoding time."
      ]
    },
    {
      "heading": "7. Conclusion",
      "text": [
        "As translation grammars increase in complexity while innovations drive down the computational cost of language model integration, the efficiency of the parsing phase of machine translation decoding is becoming increasingly important.",
        "Our grammar normal form, CKY improvements, and symbol subset coarse-to-fine procedure reduced parsing time for large transducer grammars by 81%.",
        "These techniques also improved forest-based language model reranking.",
        "A full decoding pass without any of our innovations required 511 minutes using only small beams.",
        "Coarse-to-fine pruning in both the parsing and language model passes allowed a 100-fold increase in beam size, giving a performance improvement of 1.3 BLEU while decreasing total decoding time by 50%."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "This work was enabled by the Information Sciences Institute Natural Language Group, primarily through the invaluable assistance of Jens Voeckler, and was supported by the National Science Foundation (NSF) under grant IIS-0643742.",
        "Pruning",
        "Max",
        "TM",
        "LM",
        "Total",
        "Inside",
        "Outside",
        "LM",
        "Total",
        "strategy",
        "beam",
        "BLEU",
        "score",
        "score",
        "score",
        "time",
        "time",
        "time",
        "time",
        "No pruning",
        "20",
        "57.67",
        "58,570",
        "-17,202",
        "41,368",
        "99",
        "0",
        "247",
        "346",
        "CTF parsing",
        "200",
        "58.43",
        "58,495",
        "-16,929",
        "41,556",
        "53",
        "0",
        "186",
        "239",
        "CTF reranking",
        "200",
        "58.63",
        "58,582",
        "-16,998",
        "41,584",
        "98",
        "64",
        "79",
        "241",
        "CTF parse + rerank",
        "2000",
        "58.90",
        "58,602",
        "-16,980",
        "41,622",
        "53",
        "52",
        "148",
        "253"
      ]
    }
  ]
}
