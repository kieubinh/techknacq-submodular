{
  "info": {
    "authors": [
      "Carlos Gómez-Rodríguez",
      "Marco Kuhlmann",
      "Giorgio Satta",
      "David Weir"
    ],
    "book": "HLT-NAACL",
    "id": "acl-N09-1061",
    "title": "Optimal Reduction of Rule Length in Linear Context-Free Rewriting Systems",
    "url": "https://aclweb.org/anthology/N09-1061",
    "year": 2009
  },
  "references": [
    "acl-C08-1136",
    "acl-J07-2003",
    "acl-N06-1033",
    "acl-N07-1019",
    "acl-P04-1084",
    "acl-P06-1123",
    "acl-P06-2066",
    "acl-P08-1069",
    "acl-P87-1015"
  ],
  "sections": [
    {
      "text": [
        "Carlos Gomez-Rodriguez, Marco Kuhlmann, Giorgio Satta and David Weir",
        "Departamento de Computation, Universidade da Coruna, Spain (cgomezr@udc.es) Department of Linguistics and Philology, Uppsala University, Sweden (marco.kuhlmann@lingfil.uu.se)",
        "Linear Context-free Rewriting Systems (LCFRS) is an expressive grammar formalism with applications in syntax-based machine translation.",
        "The parsing complexity of an LCFRS is exponential in both the rank of a production, defined as the number of nonterminals on its right-hand side, and a measure for the discontinuity of a phrase, called fan-out.",
        "In this paper, we present an algorithm that transforms an LCFRS into a strongly equivalent form in which all productions have rank at most 2, and has minimal fan-out.",
        "Our results generalize previous work on Synchronous Context-Free Grammar, and are particularly relevant for machine translation from or to languages that require syntactic analyses with discontinuous constituents."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "There is currently considerable interest in syntax-based models for statistical machine translation that are based on the extraction of a synchronous grammar from a corpus of word-aligned parallel texts; see for instance Chiang (2007) and the references therein.",
        "One practical problem with this approach, apart from the sheer number of the rules that result from the extraction procedure, is that the parsing complexity of all synchronous formalisms that we are aware of is exponential in the rank of a rule, defined as the number of nonterminals on the right-hand side.",
        "Therefore, it is important that the rules of the extracted grammar are transformed so as to minimise this quantity.",
        "Not only is this beneficial in terms of parsing complexity, but smaller rules can also improve a translation model's ability to generalize to new data (Zhang et al., 2006).",
        "Optimal algorithms exist for minimising the size of rules in a Synchronous Context-Free Grammar (SCFG) (Uno and Yagiura, 2000; Zhang et al., 2008).",
        "However, the SCFG formalism is limited to modelling word-to-word alignments in which a single continuous phrase in the source language is aligned with a single continuous phrase in the target language; as defined below, this amounts to saying that SCFG have a fanout of 2.",
        "This restriction appears to render SCFG empirically inadequate.",
        "In particular, Wellington et al.",
        "(2006) find that the coverage of a translation model can increase dramatically when one allows a bilingual phrase to stretch out over three rather than two continuous substrings.",
        "This observation is in line with empirical studies in the context of dependency parsing, where the need for formalisms with higher fanout has been observed even in standard, single language texts (Kuhlmann and Nivre, 2006).",
        "In this paper, we present an algorithm that computes optimal decompositions of rules in the formalism of Linear Context-Free Rewriting Systems (LCFRS) (Vijay-Shanker et al., 1987).",
        "LCFRS was originally introduced as a generalization of several so-called mildly context-sensitive grammar formalisms.",
        "In the context of machine translation, LCFRS is an interesting generalization of SCFG because it does not restrict the fanout to 2, allowing productions with arbitrary fanout (and arbitrary rank).",
        "Given an LCFRS, our algorithm computes a strongly equivalent grammar with rank and minimal increase in fan-out.",
        "In this context, strong equivalence means that the derivations of the original grammar can be reconstructed using some simple homomorphism (c.f.",
        "Nijholt, 1980).",
        "Our contribution is significant because the existing algorithms for decomposing SCFG, based on Uno and Yagiura (2000), cannot be applied to LCFRS, as they rely on the crucial property that components of biphrases are strictly separated in the generated string: Given a pair of synchronized nonterminal symbols, the material derived from the source nonterminal must precede the material derived from the target nonterminal, or vice versa.",
        "The problem that we solve has been previously addressed by Melamed et al.",
        "(2004), but in contrast to our result, their algorithm does not guarantee an optimal (minimal) increase in the fanout of the resulting grammar.",
        "However, this is essential for the practical applicability of the transformed grammar, as the parsing complexity of LCFRS is exponential in both the rank and the fan-out.",
        "Structure of the paper The remainder of the paper is structured as follows.",
        "Section 2 introduces the terminology and notation that we use for LCFRS.",
        "In Section 3, we present the technical background of our algorithm; the algorithm itself is discussed in Section 4.",
        "Section 5 concludes the paper by discussing related work and open problems.",
        "General notation The set of non-negative integers is denoted by N. For i, j e N, we write [i, j] to denote the interval { k e N | i < k < j }, and use [i] as a shorthand for [1, i].",
        "Given an alphabet V, we write V* for the set of all (finite) strings over V."
      ]
    },
    {
      "heading": "2. Preliminaries",
      "text": [
        "We briefly summarize the terminology and notation that we adopt for LCFRS; for detailed definitions, see Vijay-Shanker et al.",
        "(1987).",
        "Let V be an alphabet.",
        "For natural numbers r > 0 and f,fi,...,fr > 1, a function is called a linear, non-erasing function over V of type fix • • • x fr – f, if it can be defined by an equation of the form where /3g = (ag,i,..., ag/) is an f -tuple of strings over the variables on the left-hand side of the equation and symbols in V that contains exactly one occurrence of each variable.",
        "We call the value r the rank of g, the value f its fan-out, and write p(g) and p(g), respectively, to denote these quantities.",
        "Note that, if we assume the variables on the left-hand side of the defining equation of g to be named according to the specific schema given above, then g is uniquely determined by [3g.",
        "A linear context-free rewriting system (LCFRS) is a construct G = (VN,VT, P, S), where: VN is an alphabet of nonterminal symbols in which each symbol A e VN is associated with a value p(A), called its fan-out; VT is an alphabet of terminal symbols; S e N is a distinguished start symbol with <p(S) = 1; and P is a set of productions of the form where A,Bi,... ,Br e VN, and g is a linear, non-erasing function over the terminal alphabet VT of type ^(Bi) x • • • x ^(Br) – y?(A).",
        "In a derivation of an LCFRS, the production p can be used to transform a sequence of r tuples of strings, generated by the nonterminals Bi,...,Br, into a single (p (A)-tuple of strings, associated with the nonterminal A.",
        "The values p(g) and p(g) are called the rank and fanout of p, respectively, and we write p(p) and p(p), respectively, to denote these quantities.",
        "The rank and fanout of G, written p(G) and p(G), respectively, are the maximum rank and fanout among all of its productions.",
        "Given that p(S) = 1, a derivation will associate S with a set of one-component tuples of strings over VT; this forms the string language generated by G.",
        "Example 1 The following LCFRS generates the string language { anbncndn | n e N }.",
        "We only specify the set of productions; the remaining components of the grammar are obvious from that.",
        "The functions gi and g2 have rank 1; the function g3has rank 0.",
        "The functions g2 and g3 have fanout 2; the function gi has fanout 1.",
        "□"
      ]
    },
    {
      "heading": "3. Technical background",
      "text": [
        "The general idea behind our algorithm is to replace each production of an LCFRS with a set of \"shorter\" productions that jointly are equivalent to the original production.",
        "Before formalizing this idea, we first introduce a specialized representation for the productions of an LCFRS.",
        "We distinguish between occurrences of symbols within a string by exploiting two different notations.",
        "Let a = aia2 • • • an be a string.",
        "The occurrence a» in a can be denoted by means of its position index i e [n], or else by means of its two (left and right) endpoints, i – 1 and i; here, the left (right) endpoint denotes a boundary between occurrence a% and the previous (subsequent) occurrence, or the beginning (end) of the string a.",
        "Similarly, a substring a% • • • aj of a with i < j can be denoted by the positions i, i +1,..., j of its occurrences, or else by means of its left and right endpoints, i – 1 and j.",
        "For the remainder of this section, let us fix an LCFRS G = (Vn ,Vt ,P,S) and a production p : A – g(Bi,..., Br) of G, with g defined as in Section 2.1.",
        "We define",
        "|p| = p(g) + Yl |ag,j|.",
        "Let $ be a fresh symbol that does not occur in G. We define the characteristic string of the production p and the variable string of p as the string aN (p) obtained from <r(p) by removing all the occurrences of symbols in VT.",
        "Example 2 We will illustrate the concepts introduced in this section using the concrete production po : A – £2, B3), where (3g = (Xi,iaX2,iXi)2,X3)i6X3)2) .",
        "In this case, we have",
        "Let I be an index set, I C [r].",
        "Consider the set B of occurrences Bj in the right-hand side of p such that i e 1.",
        "We define the position set of B, denoted by nB, as the set of all positions 1 < j < |<rN (p)| such that the j th symbol in <rN (p) is a variable of the form xi h, for i e 1 and some h > 1.",
        "Example 3 Some position sets of po are n{Bl} = {1,3}, n{B2} = {2}, n{Ba} = {5,6}.",
        "A position set nB can be uniquely expressed as the union of f > 1 intervals [1i + 1, ri],..., [1/ + 1, r/] such that ri_i < Zj for every 1 < i < f. Thus we define the set of endpoints of nB as Ab = {1j | j e [f] }u{ rj | j e [f]}.",
        "The quantity f is called the fanout of nB, written p(nB).",
        "Notice that the fanout of a position set 77{B} does not necessarily coincide with the fanout of the non-terminal B in the underlying LCFRS.",
        "A set with 2f endpoints always corresponds to a position set of fanout f.",
        "Example 4 For our running example, we have",
        "We drop B from nB and Ab whenever this set is understood from the context or it is not relevant.",
        "Given a set of endpoints A = ..., i2/} with ii < • • • < i2/, we obtain its corresponding position set by calculating the closure of A, defined as [A] = U/=i[i2j_i + 1,i2j].",
        "Assume that r > 2.",
        "The reduction of p by the nonterminal occurrences Br_i, Br is the ordered pair of productions (pi;p2) that is defined as follows.",
        "Let 71;..., 7„ be the maximal substrings of <r(p) that contain only variables with r – 1 < i < r and terminal symbols, and at least one variable.",
        "Then where X is a fresh nonterminal symbol, the characteristic string a(pi) is the string obtained from <r(p) by replacing each substring y by the variable xr_i,i, and the characteristic string <r(p2) is the string Yi$ • • • $y„.",
        "Note that the defining equations of neither ginor g2 are in the specific form discussed in Section 2.1; however, they can be brought into this form by a consistent renaming of the variables.",
        "We will silently assume this renaming to take place.",
        "Example 5 The reduction of po by the nonterminal occurrences B2 and B3 has pi : A – gi(Bi,X) and p2 : X – ^2(^2, B3) with or, after renaming and in standard notation,",
        "It is easy to check that a reduction provides us with a pair of productions that are equivalent to the original production p, in terms of generative capacity, since for all tuples of strings generated from the nonterminals Bi;..., Br, respectively.",
        "Note also that the fanout of production pi equals the fanout of p. However, the fanout of p2 (the value n) may be greater than the fanout of p, depending on the way variables are arranged in <r(p).",
        "Thus, a reduction does not necessarily preserve the fanout of the original production.",
        "In the worst case, the fanout of p2 can be as large as ^(Br_i) + t£>(Br).",
        "1: Function NAIVE-BINARiZATION(p)",
        "3: currentProd – p; 4: while p (currentProd) > 2 do 8: return result U currentProd;",
        "We have defined reductions only for the last two occurrences of nonterminals in the right-hand side of a production p. However, it is easy to see that we can also define the concept for two arbitrary (not necessarily adjacent) occurrences of nonterminals, at the cost of making the notation more complicated."
      ]
    },
    {
      "heading": "4. The algorithm",
      "text": [
        "Let G be an LCFRS with p(G) = f and p(G) = r, and let f' > f be a target fan-out.",
        "We will now present an algorithm that computes an equivalent LCFRS G' of fanout at most f' whose rank is at most 2, if such an LCFRS exists in the first place.",
        "The algorithm works by exhaustively reducing all productions in G.",
        "Given an LCFRS production p, a naive algorithm to compute an equivalent set of productions whose rank is at most 2 is given in Figure 1.",
        "By applying this algorithm to all the productions in the LCFRS G, we can obtain an equivalent LCFRS with rank 2.",
        "We will call such an LCFRS a binarization ofG.",
        "The fanout of the obtained LCFRS will depend on the nonterminals that we choose for the reductions in line 5.",
        "It is not difficult to see that, in the worst case, the resulting fanout can be as high as [ 2 ] • f. This occurs when we choose [2 ] nonterminals with fanout f that have associated variables in the string aN (p) that do not occur at consecutive positions.",
        "The algorithm that we develop in Section 4.3 improves on the naive algorithm in that it can be exploited to find a sequence of reductions that results in a binarization of G that is optimal, i.e., leads to an LCFRS with minimal fan-out.",
        "The algorithm is based on a technical concept called adjacency.",
        "Let p be some production in the LCFRS G, and let Ai; A2 be sets of endpoints, associated with some sets of nonterminal occurrences in p. We say that and A2 overlap if the intersection of their closures is nonempty, that is, if n [A2] = 0.",
        "Overlapping holds if and only if the associated sets of nonterminal occurrences are not disjoint.",
        "If Ai and A2 do not overlap, we define their merge as ©(Ai, Z2) = (Zi u Z2) \\ (Zi n A2).",
        "It is easy to see that [©(Ai; A2)] = u [A2].",
        "We say that Ai and A2 are adjacent for a given fanout f, written Ai <->f A2, if Ai and A2 do not overlap, and <p([©(Ai, A2)]) < f.",
        "showing that A{Bl} ^3 A{B3}, but that neither",
        "The adjacency-based binarization algorithm is given in Figure 2.",
        "It starts with a working set containing the endpoint sets corresponding to each nonterminal occurrence in the input production p. Reductions of p are only explored for nonterminal occurrences whose endpoint sets are adjacent for the target fanout fsince reductions not meeting this constraint would produce productions with fanout greater than fEach reduction explored by the algorithm produces a new endpoint set, associated to the fresh nonterminal that it introduces, and this new endpoint set is added to the working set and potentially used in further reductions.",
        "From the definition of the adjacency relation <-f, it follows that at lines 9 and 10 of Bounded-Binarization we only pick up reductions for p that do not exceed the fanout bound of f'.",
        "This implies soundness for our algorithm.",
        "Completeness means that the algorithm fails only if there exists no binarization for p of fanout not greater than fThis 1: Function Bounded-Binarization(p, f) 2: workingSet – 0; 3: agenda – 0; 4: for all i from 1 to p(p) do 5: workingSet – workingSet U {A{Bi}}; 6: agenda – agenda U {A{Bi}}; 7: while agenda = 0 do 8: A – pop some endpoint set from agenda; 9: for all Ai G workingSet with Ai <-f / A do 10: A2 = ©(A, Ai); 11: if A2 G workingSet then 12: workingSet – workingSet u {A2}; 17: return false; property is intuitive if one observes that our algorithm is a specialization of standard algorithms for the computation of the closure of binary relations.",
        "A formal proof of this fact is rather long and tedious, and will not be reported here.",
        "We notice that there is a very close similarity between algorithm Bounded-Binarization and the deduction procedure proposed by Shieber et al.",
        "(1995) for parsing.",
        "We discuss this more at length in Section 5.",
        "Note that we have expressed the algorithm as a decision function that will return true if there exists a binarization of p with fanout not greater than f and false otherwise.",
        "However, the algorithm can easily be modified to return a reduction producing such a binarization, by adding to each endpoint set A workingSet two pointers to the adjacent endpoint sets that were used to obtain it.",
        "If the algorithm is successful, the tree obtained by following these pointers from the final endpoint set A{Bl^^b^} g workingSet gives us a tree of reductions that will produce a binarization of p with fanout not greater than fwhere each node labeled with the set A{Bi} corresponds to the nonterminal Bj, and nodes labeled with other endpoint sets correspond to the fresh nonterminals created by the reductions.",
        "In order to implement BOUNDED-BINARIZATION, we can represent endpoint sets in a canonical way as 2f '-tuples of integer positions in ascending order, and with some special null value used to fill positions for endpoint sets with fanout strictly smaller than fWe will assume that the concrete null value is larger than any other integer.",
        "We also need to provide some appropriate representation for the set workingSet, in order to guarantee efficient performance for the membership test and the insertion operation.",
        "Both operations can be implemented in constant time if we represent work-ingSet as an (2 x f') dimensional table with Boolean entries.",
        "Each dimension is indexed by values in [0, n] plus our special null value; here n is the length of the string <rN (p), and thus n = O(|p|).",
        "However, this has the disadvantage of using space 6(n2f ), even in case workingSet is sparse, and is affordable only for quite small values of fAlternatively, we can more compactly represent workingSet as a trie data structure.",
        "This representation has size certainly smaller than 2f' x q, where q is the size of the set workingSet.",
        "However, both membership and insertion operations take now an amount of time O(2f').",
        "We now analyse the time complexity of algorithm BOUNDED-BINARIZATION for inputs p and fWe first focus on the while-loop at lines 7 to 13.",
        "As already observed, the number of possible endpoint sets is bounded by O(n2f ).",
        "Furthermore, because of the test at line 11, no endpoint set is ever inserted into the agenda variable more than once in a single run of the algorithm.",
        "We then conclude that our while-loop cycles a number of times O(n2f ).",
        "We now focus on the choice of the endpoint set Ai in the inner for-loop at lines 9 to 13.",
        "Let us fix A as in line 8.",
        "It is not difficult to see that any Ai with Ai <-f / A must satisfy",
        "Let I C A, and consider all endpoint sets Ai with A n Ai = I.",
        "Given (1), we also have",
        "This means that, for each A coming out of the agenda, at line 9 we can choose all endpoint sets Ai such that Ai <-f / A by performing the following",
        "• arbitrarily choose a set I C A;",
        "• choose endpoints in set Ai\\1 subject to (2);",
        "• test whether Ai belongs to workingSet and whether A, Ai do not overlap.",
        "We claim that, in the above steps, the number of involved endpoints does not exceed 3f'.",
        "To see this, we observe that from (2) we can derive |11 > </?",
        "(A) + t^(Ai) - f'.",
        "The total number of (distinct) endpoints in a single iteration step is e = 2^(A) + 2t£>(Ai) - |11.",
        "Combining with the above inequality we have as claimed.",
        "Since each endpoint takes values in the set [0, n], we have a total of O(n3f ) different choices.",
        "For each such choice, we need to classify an endpoint as belonging to either A\\1, Ai\\1, or I.",
        "This amounts to an additional O(33f ) different choices.",
        "Overall, we have a total number of O((3n)3f ) different choices.",
        "For each such choice, the test for membership in workingSet for Ai takes constant time in case we use a multidimensional table, or else O(|p|) in case we use a trie.",
        "The adjacency test and the merge operations can easily be carried out in time O(|p|).",
        "Putting all of the above observations together, and using the already observed fact that n = O(|p|), we can conclude that the total amount of time required by the while-loop at lines 7 to 13 is bounded by O(|p| • (3|p|)3f ), both under the assumption that workingSet is represented as a multidimensional table or as a trie.",
        "This is also a bound on the running time of the whole algorithm.",
        "The algorithm defined in Section 4.3 can be used to binarize an LCFRS in such a way that each rule in the resulting binarization has the minimum possible fan-out.",
        "This can be done by applying the BOUNDED-BINARIZATION algorithm to each production p, until we find the minimum value for the",
        "l: Function MINIMAL-BINARIZATION(G) 2: pb = 0 {Set of binarized productions} 3: for all production p of G do 5: while not BOUNDED-BINARIZATION(p, f')",
        "7: add result of BOUNDED-BINARIZATION(p, f') to pb; {We obtain the tree from BOUNDED-BINARIZATION as explained in Section 4.3 and use it to binarize p}",
        "S: return pb;",
        "bound /' for which this algorithm finds a binarization.",
        "For a production with rank r and fanout /, we know that this optimal value of /' must be in the interval [/, [2] • /] because binarizing a production cannot reduce its fan-out, and the Naive-Binarization algorithm seen in Section 4.1 can binarize any production by increasing fanout to [ 2 ] • / in the worst case.",
        "The simplest way of finding out the optimal value of /' for each production is by a sequential search starting with t£>(p) and going upwards, as in the algorithm in Figure 3.",
        "Note that the upper bound [ | ] • / that we have given for /' guarantees that the while-loop in this algorithm always terminates.",
        "In the worst case, we may need / • ( [ 2 ] – 1) + 1 executions of the Bounded-Binarization algorithm to ind the optimal binarization of a production in G. This complexity can be reduced by changing the strategy to search for the optimal /' : for example, we can perform a binary search within the interval [/, [ 21 • /], which lets us find the optimal binarization in |_log(/ • ([21 – 1) + 1)J +1 executions of Bounded-Binarization.",
        "However, this will not result in a practical improvement, since BOUNDED-Binarization is exponential in the value of /' and the binary search will require us to run it on values of /' larger than the optimal in most cases.",
        "An intermediate strategy between the two is to apply exponential backoff to try the sequence of values / – 1 + 2* (for i = 0,1,2 ...).",
        "When we find the first i such that Bounded-Binarization does not fail, if i > 0, we apply the same strategy to the interval [f - 1+2i-i, f -2+2j], and we repeat this method to shrink the interval until BOUNDED-BINARIZATION does not fail for i = 0, giving us our optimal f'.",
        "With this strategy, the amount of executions of the algorithm that we need in the worst case is where w = f • ([ 21 - 1) + 1, but we avoid using unnecessarily large values of f'."
      ]
    },
    {
      "heading": "5. Discussion",
      "text": [
        "To conclude this paper, we now discuss a number of aspects of the results that we have presented, including various other pieces of research that are particularly relevant to this paper.",
        "The algorithm introduced in this paper can be used to transform an LCFRS into an equivalent form with rank 2.",
        "This will result into a more efficiently parsable LCFRS, since rank exponentially affects parsing complexity.",
        "However, we must take into account that parsing complexity is also influenced by fan-out.",
        "Our algorithm guarantees a minimal increase in fan-out.",
        "In practical cases it seems such an increase is quite small.",
        "For example, in the context of dependency parsing, both Gomez-Rodriguez et al.",
        "(2009) and Kuhlmann and Satta (2009) show that all the structures in several well-known non-projective dependency treebanks are bi-narizable without any increase in their fan-out.",
        "More in general, it has been shown by Seki et al.",
        "(1991) that parsing of LCFRS can be carried out in time O(n|pMwhere n is the length of the input string and pM is the production in the grammar with largest size.",
        "Thus, there may be cases in which one has to find an optimal tradeoff between rank and fan-out, in order to minimize the size of pm .",
        "This requires some kind of Viterbi search over the space of all possible binarizations, constructed as described at the end of Subsection 4.3, for some appropriate value of the fanout f'.",
        "This paper has focussed on string-based LCFRS.",
        "As discussed in Vijay-Shanker et al.",
        "(1987), LCFRS provide a more general framework where the productions are viewed as generating a set of abstract derivation trees.",
        "These trees can be used to specify how structures other than tuples of strings are composed.",
        "For example, LCFRS derivation trees can be used to specify how the elementary trees of a Tree Adjoining Grammar can be composed to produced derived tree.",
        "However, the results in this paper also apply to non-string-based LCFRS, since by limiting attention to the terminal string yield of whatever structures are under consideration, the composition operations can be defined using the string-based version of LCFRS that is discussed here.",
        "The NAIVE-BINARIZATION algorithm given in Figure 1 is not novel to this paper: it is similar to an algorithm developed in Melamed et al.",
        "(2004) for generalized multitext grammars, a formalism weakly equivalent to LCFRS that has been introduced for syntax-based machine translation.",
        "However, the grammar produced by our algorithm has optimal (minimal) fan-out.",
        "This is an important improvement over the result in (Melamed et al., 2004), as this quantity enters into the parsing complexity of both multitext grammars and LCFRS as an exponential factor, and therefore must be kept as low as possible to ensure practically viable parsing.",
        "Rank reduction is also investigated in Nesson et al.",
        "(2008) for synchronous tree-adjoining grammars, a synchronous rewriting formalism based on tree-adjoining grammars Joshi and Schabes (1992).",
        "In this case the search space of possible reductions is strongly restricted by the tree structures specified by the formalism, resulting in simplified computation for the reduction algorithms.",
        "This feature is not present in the case of LCFRS.",
        "There is a close parallel between the technique used in the MINIMAL-BINARIZATION algorithm and deductive parsing techniques as proposed by Shieber et al.",
        "(1995), that are usually implemented by means of tabular methods.",
        "The idea of exploiting tabular parsing in production factorization was first expressed in Zhang et al.",
        "(2006).",
        "In fact, the particular approach presented here has been used to improve efficiency of parsing algorithms that use discontinuous syntactic models, in particular, non-projective dependency grammars, as discussed in Gomez-Rodriguez et al.",
        "(2009).",
        "The bounded binarization algorithm that we have presented has exponential runtime in the value of the input fanout bound f'.",
        "It remains an open question whether the bounded binarization problem for LCFRS can be solved in deterministic polynomial time.",
        "Even in the restricted case of f' = <£>(p), that is, when no increase in the fanout of the input production is allowed, we do not know whether p can be binarized using only deterministic polynomial time in the value of p's fan-out.",
        "However, our bounded binarization algorithm shows that the latter problem can be solved in polynomial time when the fanout of the input LCFRS is bounded by some constant.",
        "Whether the bounded binarization problem can be solved in polynomial time in the value of the input bound f' is also an open problem in the restricted case of synchronous context-free grammars, a special case of an LCFRS of fanout two with a strict separation between the two components of each nonterminal in the right-hand side of a production, as discussed in the introduction.",
        "An interesting analysis of this restricted problem can be found in Gildea and Stefankovic (2007).",
        "Acknowledgements The work of Carlos Gomez-Rodnguez was funded by Ministerio de Education y Ciencia and FEDER (HUM2007-66607-C04) and Xunta de Galicia (PGIDIT07SIN005206PR, IN-CITE08E1R104022ES, INCITE08ENA305025ES, INCITE08PXIB302179PR and Rede Galega de Procesamento da Linguaxe e Recuperation de Information).",
        "The work of Marco Kuhlmann was funded by the Swedish Research Council.",
        "The work of Giorgio Satta was supported by MIUR under project PRIN No.",
        "2007TJNZRE002.",
        "We are grateful to an anonymous reviewer for a very detailed review with a number of particularly useful suggestions."
      ]
    }
  ]
}
