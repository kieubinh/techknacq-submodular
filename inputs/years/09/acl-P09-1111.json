{
  "info": {
    "authors": [
      "Carlos Gómez-Rodríguez",
      "Giorgio Satta"
    ],
    "book": "ACL-IJCNLP",
    "id": "acl-P09-1111",
    "title": "An Optimal-Time Binarization Algorithm for Linear Context-Free Rewriting Systems with Fan-Out Two",
    "url": "https://aclweb.org/anthology/P09-1111",
    "year": 2009
  },
  "references": [
    "acl-C08-1136",
    "acl-N03-1021",
    "acl-P05-1033",
    "acl-P87-1015",
    "acl-W05-1502"
  ],
  "sections": [
    {
      "text": [
        "Carlos Gomez-Rodriguez Giorgio Satta",
        "Departamento de Computacion Department of Information Engineering Universidade da Corufta, Spain University of Padua, Italy",
        "cgomezr@udc.es satta@dei.unipd.it",
        "Linear context-free rewriting systems (LCFRSs) are grammar formalisms with the capability of modeling discontinuous constituents.",
        "Many applications use LCFRSs where the fanout (a measure of the discontinuity of phrases) is not allowed to be greater than 2.",
        "We present an efficient algorithm for transforming LCFRS with fanout at most 2 into a binary form, whenever this is possible.",
        "This results in asymptotical runtime improvement for known parsing algorithms for this class."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Since its early years, the computational linguistics field has devoted much effort to the development of formal systems for modeling the syntax of natural language.",
        "There has been a considerable interest in rewriting systems that enlarge the generative power of context-free grammars, still remaining far below the power of the class of context-sensitive grammars; see (Joshi et al., 1991) for discussion.",
        "Following this line, (Vijay-Shanker et al., 1987) have introduced a formalism called linear context-free rewriting systems (LCFRSs) that has received much attention in later years by the community.",
        "LCFRSs allow the derivation of tuples of strings, i.e., discontinuous phrases, that turn out to be very useful in modeling languages with relatively free word order.",
        "This feature has recently been used for mapping non-projective dependency grammars into discontinuous phrase structures (Kuhlmann and Satta, 2009).",
        "Furthermore, LCFRSs also implement so-called synchronous rewriting, up to some bounded degree, and have recently been exploited, in some syntactic variant, in syntax-based machine translation (Chiang, 2005; Melamed, 2003) as well as in the modeling of syntax-semantic interface (Nesson and Shieber, 2006).",
        "The maximum number f of tuple components that can be generated by an LCFRS G is called the fanout of G, and the maximum number r of nonterminals in the right-hand side of a production is called the rank of G. As an example, context-free grammars are LCFRSs with f = 1 and r given by the maximum length of a production right-hand side.",
        "Tree adjoining grammars (Joshi and Levy, 1977), or TAG for short, can be viewed as a special kind of LCFRS with f = 2, since each elementary tree generates two strings, and r given by the maximum number of adjunction sites in an elementary tree.",
        "Several parsing algorithms for LCFRS or equivalent formalisms are found in the literature; see for instance (Seki etal., 1991; Boullier, 2004; Burden and Ljunglof, 2005).",
        "All of these algorithms work in time O(|G| • \\w\\f<r+l)).",
        "Parsing time is then exponential in the input grammar size, since G depends on both f and r. In the development of efficient algorithms for parsing based on LCFRS the crucial goal is therefore to optimize the term f • (r + 1).",
        "In practical natural language processing applications the fanout of the grammar is typically bounded by some small number.",
        "As an example, in the case of discontinuous parsing discussed above, we have f = 2 for most practical cases.",
        "On the contrary, LCFRS productions with a relatively large number of nonterminals are usually observed in real data.",
        "The reduction of the rank of a LCFRS, called binarization, is a process very similar to the reduction of a context-free grammar into Chomsky normal form.",
        "While in the special case of CFG and TAG this can always be achieved, binarization of an LCFRS requires, in the general case, an increase in the fanout of the grammar much larger than the achieved reduction in the rank.",
        "Worst cases and some lower bounds have been discussed in (Rambow and Satta, 1999; Satta, 1998).",
        "Nonetheless, in many cases of interest binarization of an LCFRS can be carried out without any extra increase in the fan-out.",
        "As an example, in the case where f = 2, binarization of a LCFRS would result in parsing time of O(|G| • |w|).",
        "With the motivation of parsing efficiency, much research has been recently devoted to the design of efficient algorithms for rank reduction, in cases in which this can be carried out at no extra increase in the fan-out.",
        "(Gomez-Rodriguez et al., 2009) reports a general binarization algorithm for LCFRS.",
        "In the case where f = 2, this algorithm works in time O(|p|), where p is the input production.",
        "A more efficient algorithm is presented in (Kuhlmann and Satta, 2009), working in time O(|p|) in case of f = 2.",
        "However, this algorithm works for a restricted typology of productions, and does not cover all cases in which some binarization is possible.",
        "Other linear time algorithms for rank reduction are found in the literature (Zhang et al., 2008), but they are restricted to the case of synchronous context-free grammars, a strict subclass of the LCFRS with f = 2.",
        "In this paper we focus our attention on LCFRS with a fanout of two.",
        "We improve upon all of the above mentioned results, by providing an algorithm that computes a binarization of an LCFRS production in all cases in which this is possible and works in time O(|p|).",
        "This is an optimal result in terms of time complexity, since 6(|p|) is also the size of any output binarization of an LCFRS production."
      ]
    },
    {
      "heading": "2. Linear context-free rewriting systems",
      "text": [
        "We briefly summarize here the terminology and notation that we adopt for LCFRS; for detailed definitions, see (Vijay-Shanker et al., 1987).",
        "We denote the set of non-negative integers by N. For i, j £ N, the interval {k | i < k < j} is denoted by [i, j].",
        "We write [i] as a shorthand for [1, i].",
        "For an alphabet V, we write V * for the set of all (finite) strings over V.",
        "As already mentioned in Section 1, linear context-free rewriting systems generate tuples of strings over some finite alphabet.",
        "This is done by associating each production p of a grammar with a function g that rearranges the string components in the tuples generated by the nonterminals in p's right-hand side, possibly adding some alphabet symbols.",
        "Let V be some finite alphabet.",
        "For natural numbers r > 0 and f, fi,..., fr > 1, consider a function g : (Vx • • • x (V*)/r – (V*)f defined by an equation of the form where a = ..., a/) is an f -tuple of strings over g's argument variables and symbols in V. We say that g is linear, non-erasing if a contains exactly one occurrence of each argument variable.",
        "We call r and f the rank and the fanout of g, respectively, and write r(g) and f (g) to denote these quantities.",
        "A linear context-free rewriting system (LCFRS) is a tuple G = (Vn, Vt, P, S), where VN and VT are finite, disjoint alphabets of nonterminal and terminal symbols, respectively.",
        "Each A £ VN is associated with a value f (A), called its fan-out.",
        "The nonterminal S is the start symbol, with f (S) = 1.",
        "Finally, P is a set of productions of the form where A, Ai,..., Ar(g) £ Vn, and g : (VT*)/x • • • x (VT*)/ – (VT*)/(A) is a linear, non-erasing function.",
        "A production p of G can be used to transform a sequence of r(g) string tuples generated by the nonterminals Ai,..., Ar(g) into a tuple of f (A) strings generated by A.",
        "The values r(g) and f(g) are called the rank and fanout of p, respectively, written r(p) and f (p).",
        "The rank and fanout of G, written r(G) and f(G), respectively, are the maximum rank and fanout among all of G's productions.",
        "Given that f(S) = 1, S generates a set of strings, defining the language of G.",
        "Example 1 Consider the LCFRS G defined by the productions of the following bottom-up process.",
        "First, the tuple (e, e) is generated by A through p3.",
        "We then iterate three times the application of p2 to (e, e), resulting in the tuple (a6, cd).",
        "Finally, the tuple (string) (a6cd) is generated by S through application of pi.",
        "□"
      ]
    },
    {
      "heading": "3. Position sets and binarizations",
      "text": [
        "Throughout this section we assume an LCFRS production p : A – g(Ai,..., Ar) with g defined through a tuple a as in section 2.",
        "We also assume that the fanout of A and the fanout of each Ai are all bounded by two.",
        "We introduce here a specialized representation for p. Let $ be a fresh symbol that does not occur in p. We define the characteristic string of p as the string where each aj is obtained from aj by removing all the occurrences of symbols in V .",
        "Consider now some occurrence Aj of a nonterminal symbol in the right-hand side of p. We define the position set of Ai, written Xa4, as the set of all non-negative integers j £ [|<rN (p)|] such that the j-th symbol in <tn (p) is a variable of the form for some h.",
        "a = (xi,iax2,i£i,2, £3,ibx3,2).",
        "Each position set X C [|<jN(p)|] can be represented by means of non-negative integers ii < i2 < • • • < i2fc satisfying",
        "X = U [i2j-i + 1,i2j].",
        "In other words, we are decomposing X into the union of k intervals, with k as small as possible.",
        "It is easy to see that this decomposition is always unique.",
        "We call set E = i2,..., i2k} the endpoint set associated with X, and we call k the fanout of X, written f (X).",
        "Throughout this paper, we will represent p as the collection of all the position sets associated with the occurrences of nonterminals in its right-hand side.",
        "Let X\\ and X2 be two disjoint position sets (i.e., Xi n X2 = 0), with f (Xi) = ki and f (X2 ) = k2 and with associated endpoint sets E1and E2, respectively.",
        "We define the merge of X1and X2 as the set X1 U X2.",
        "We extend the position set and endpoint set terminology to these merge sets as well.",
        "It is easy to check that the endpoint set associated to position set X1 U X2 is (E1U E2) \\ (E1 n E2).",
        "We say that X1 and X2 are 2-combinable if f (X1 U X2) < 2.",
        "We also say that X1 and X2 are adjacent, written X1 <-> X2, if f (X1 U X2) < max(k1, k2).",
        "It is not difficult to see that X1 <-> X2 if and only if X1 and X2 are disjoint and |E1 n E2| > min(k1; k2).",
        "Note also that X1 <-> X2 always implies that X1 and X2 are 2-combinable (but not the other way around).",
        "Let X be a collection of mutually disjoint position sets.",
        "A reduction of X is the process of merging two position sets X1; X2 G X, resulting in a new collection X' = (X\\{X1 ,X2})U{X1 UX2}.",
        "The reduction is 2-feasible if X1 and X2 are 2-combinable.",
        "A binarization of X is a sequence of reductions resulting in a new collection with two or fewer position sets.",
        "The binarization is 2-feasible if all of the involved reductions are 2-feasible.",
        "Finally, we say that X is 2-feasible if there exists at least one 2-feasible binarization for",
        "X.",
        "As an important remark, we observe that when a collection X represents the position sets of all the nonterminals in the right-hand side of a production p with r(p) > 2, then a 2-feasible reduction merging , Xaô G X can be interpreted as follows.",
        "We replace p by means of a new production p' obtained from p by substituting Aj and Aj with a fresh nonterminal symbol B, so that r(p') = r(p) – 1.",
        "Furthermore, we create a new production p'' with Aj and Aj in its right-hand side, such that f (p'') = f (B) < 2 and r(p') = 2.",
        "Productions p' and p'' together are equivalent to p, but we have now achieved a local reduction in rank of one unit.",
        "Example 3 Let p be defined as in example 2 and let X = {XAl ,XA2 ,XA3}.",
        "We have that XAland Xa2 are 2-combinable, and their merge is the new position set X = Xa1 U Xa2 = {1,2,3}.",
        "This merge corresponds to a 2-feasible reduction of X resulting in X' = {X, Xa3 }.",
        "Such a reduction corresponds to the construction of a new production p' : A – > g'(B, A3) with",
        "X.",
        "It is easy to see that X is 2-feasible if and only if there exists a binarization of p that does not increase its fan-out.",
        "a, a = £2,1X3,1X4,1, £2,2X4,2X1,2£3,2).",
        "It is not difficult to see that replacing any set of two or three nonterminals in p's right-hand side forces the creation of a fresh nonterminal of fanout larger than two.",
        "□",
        "The binarization algorithm presented in this paper proceeds by representing each LCFRS production p as a collection of disjoint position sets, and then finding a 2-feasible binarization of p. This binariz-ation is computed deterministically, by an iterative process that greedily chooses merges corresponding to pairs of adjacent position sets.",
        "The key idea behind the algorithm is based on a theorem that guarantees that any merge of adjacent sets preserves the property of 2-feasibility:",
        "Theorem l Let X be a 2-feasible collection ofpo-sition sets.",
        "The reduction ofX by merging any two adjacent position sets D1 , D2 G X results in a new collection X' which is 2-feasible.",
        "To prove Theorem 1 we consider that, since X is 2-feasible, there must exist at least one 2-feasible binarization for X.",
        "We can write this binarization ß as a sequence of reductions, where each reduction is characterized by a pair of position sets (X1, X2) which are merged into X1 U X2, in such a way that both each of the initial sets and the result of the merge have fanout at most 2.",
        "We will show that, under these conditions, for every pair of adjacent position sets D1 and D2, there exists a binarization that starts with the reduction merging D1 with D2.",
        "Without loss of generality, we assume that f (D1) < f (D2) (if this inequality does not hold we can always swap the names of the two position• hDl_D2 (X) = X; if Dl £ X A D2 £ X.",
        "• hDl_D2 (X) = X; if Dl Ç X A D2 Ç X.",
        "With this, we construct a binarization ß' from ß as follows:",
        "• The first reduction in ß' merges the pair of position sets (D1, D2),",
        "• We consider the reductions in ß in order, and for each reduction o merging",
        "D1 , we append a reduction o' merging (hDl^D2 (Xl),hDl_>D2 (X2)) to ß'.",
        "We will now prove that, if ß is a 2-feasible bin-arization, then ß' is also a 2-feasible binarization.",
        "To prove this, it suffices to show the following:",
        "(i) Every position set merged by a reduction in ß' is either one of the original sets in X, or the result of a previous merge in ß'.",
        "(ii) Every reduction in ß' merges a pair of position sets (X1, X2) which are 2-combinable.",
        "To prove (i) we note that by construction of ß', if an operand of a merging operation in ß' is not one of the original position sets in X, then it must be an hDl_D2 (X) for some X that appears as an operand of a merging operation in ß.",
        "Since the binarization ß is itself valid, this X must be either one of the position sets in X, or the result of a previous merge in the binarization ß.",
        "So we divide the proof into two cases:",
        "• If X G X: First of all, we note that X cannot be D1 , since the merging operations of ß that have D1 as an operand do not produce",
        "a corresponding operation in /?'.",
        "If X equals D2, then hDl^Da (X) is Di U D2, which is the result of the first merging operation in //'.",
        "Finally, if X is one of the position sets in X, and not Di or D2, then hDl^Da (X) = X, so our operand is also one of the position sets in X.",
        "• If X is the result of a previous merging operation o in binarization //: Then, hDl^Da (X) is the result of a previous merging operation d in binarization //', which is obtained by applying the function hDl^Da to the operands and result of o.",
        "To prove (ii), we show that, under the assumptions of the theorem, the function hDl^Da preserves 2-combinability.",
        "Since two position sets of fanout < 2 are 2-combinable if and only if they are disjoint and the fanout of their union is at most 2, it suffices to show that, for every X, Xi, X2 unions of one or more sets of X, having fanout < 2, such that Xi = Di, X2 = Di and X = Di;",
        "(a) The function hDl^Da preserves disjointness, that is, if Xi and X2 are disjoint, then hDl^D2 (Xi) and hDl^Da (X2) are disjoint.",
        "(b) The function hDl^D2 is distributive with respect to the union of position sets, that is, hDl^d2 (Xi U X2) = hdl^d2 (Xi) U hdi^d2 (X2).",
        "(c) The function hDl^D2 preserves the property of having fanout < 2, that is, if X has fanout < 2, then hDl^D2 (X) has fanout < 2.",
        "If Xi and X2 do not contain Di or D2, or if one of the two unions Xi or X2 contains Di U D2, properties (a) and (b) are trivial, since the function hDl^D2 behaves as the identity function in these cases.",
        "It remains to show that (a) and (b) are true in the following cases:",
        "• Xi contains Di but not D2, and X2 does not contain Di or D2:",
        "In this case, if Xi and X2 are disjoint, we can write Xi = 1^ U Di, such that Yi, X2, Di are pairwise disjoint.",
        "By definition, we have that hDi^d2(Xi) = Yi, and hDi^d2(X2) = X2, which are disjoint, so (a) holds.",
        "Property (b) also holds because, with these expressions for Xi and X2, we can calculate hDl ^d2 (Xi U X2) = Yi U X2 = hdi^d2 (Xi) U hdi^d2 (X2).",
        "• Xi contains D2 but not Di, X2 does not contain Di or D2:",
        "In this case, if Xi and X2 are disjoint, we can write Xi = Yi U D2, such that Yi,X2,Di,D2 are pairwise disjoint.",
        "By definition, hDl^D2(Xi) = Yi U D2 U Di, and hDl_^d2 (X2) = X2, which are disjoint, so (a) holds.",
        "Property (b) also holds, since we can check that hDl^D2 (Xi U X2) = Yi U X2 U D2 U",
        "Di = hdl^d2 (Xi) U hdl^d2 (X2).",
        "• Xi contains Di but not D2, X2 contains D2but not Di:",
        "In this case, if Xi and X2 are disjoint, we can write Xi = Yi U Di and X2 = Y2 U D2, such that Yi^, Y2, Di, D2 are pairwise disjoint.",
        "By definition, we know that hDl^D2 (Xi) = Yi, and hDl^D2(X2) = Y2 U Di U D2, which are disjoint, so (a) holds.",
        "Finally, property (b) also holds in this case, since hDl^D2 (Xi U X2) = Yi U X2 U D2 U",
        "Di = hdi^d2 (Xi) U hdi^d2 (X2).",
        "This concludes the proof of (a) and (b).",
        "To prove (c), we consider a position set X, union of one or more sets of X, with fanout < 2 and such that X = Di.",
        "First of all, we observe that if X does not contain Di or D2, or if it contains Di U D2, (c) is trivial, because the function hDl^D2 behaves as the identity function in this case.",
        "So it remains to prove (c) in the cases where X contains Di but not D2, and where X contains D2 but not Di .",
        "In any of these two cases, if we call E(Y) the endpoint set associated with an arbitrary position set Y, we can make the following observations:",
        "1.",
        "Since X has fanout < 2, E(X) contains at most 4 endpoints.",
        "2.",
        "Since Di has fanout f (Di), E(Di) contains at most 2f (Di) endpoints.",
        "3.",
        "Since D2 has fanout f(D2), E(D2) contains at most 2f(D2) endpoints.",
        "4.",
        "Since D1 and D2 are adjacent, we know that E(D1) n E(D2) contains at least min (f (Dl),f (D2)) = f (Dl) endpoints.",
        "endpoints.",
        "6.",
        "On the other hand, since X contains only one of D1 and D2, we know that the endpoints where D1 is adjacent to D2 must also be endpoints of X, so that E(D1) n E(D2) Ç",
        "E(X).",
        "Therefore, E(X) \\ (E(Dl) n E(D2)) can contain at most 4 - f(D1) endpoints.",
        "Now, in the case where X contains D1 but not D2, we know that hDl_D2 (X) = X\\D1.",
        "We calculate a bound for the fanout ofX\\D1 as follows: we observe that all the endpoints in E(X \\ D1) must be either endpoints of X or endpoints of (E(X \\ D1) n E(D1)), so every position that is in E(X \\ Dl) but not in E(Dl) must be in E(X).",
        "But we also observe that E(X \\ D1) cannot contain any of the endpoints where D1 is adjacent to D2 (i.e., the members of E(D1) n E(D2)), since X \\ D1 does not contain D1 or D2.",
        "Thus, we can say that any endpoint of X \\ D1 is either a member of E(Dl) \\ (E(Dl) n E(D2)), or a member of E(X) \\ (E(Dl) n E(D2)).",
        "Thus, the number of endpoints in E(X \\ D1) cannot exceed the sum of the number of endpoints in these two sets, which, according to the reasonings above, is at most 4 - f(D1) + f(D1) = 4.",
        "Since E (X \\ D1) cannot contain more than 4 endpoints, we conclude that the fanout of X \\ D1 is at most 2, so the function hDl_D2 preserves the property of position sets having fanout < 2 in this case.",
        "In the other case, where X contains D2 but not D1 , we follow a similar reasoning: in this case, hDl_D2 (X) = X U D1.",
        "To bound the fanout of X U D1 , we observe that all the endpoints in E(X U D1) must be either in E(X) or in E(D1), since E(X U Dl) = (E(X) U E(Dl)) \\ (E(X) n E(D1)).",
        "But we also know that E(X U D1) cannot contain any of the endpoints where D1 is adjacent to D2 (i.e., the members of E(D1) n E(D2)), since X U D1 contains both D1 and D2.",
        "Thus, we can say that any endpoint of X U D1 is either a",
        "1: Function BlNARIZATION(p)",
        "6: while |A| > 2 and A contains two adjacent position sets do 14: return fail;",
        "Figure 1: Binarization algorithm for a production p : A – g(A1,..., Ar(p)).",
        "Result is either a list of reductions or failure.",
        "in the previous case, we conclude that the fanout of X U D1 is at most 2, so the function hDl^D2also preserves the property of position sets having fanout < 2 in this case.",
        "This concludes the proof of Theorem 1."
      ]
    },
    {
      "heading": "4. Binarization algorithm",
      "text": [
        "Let p : A – g(A1,..., Ar(p)) be a production with r(p) > 2 from some LCFRS with fanout not greater than 2.",
        "Recall from Subsection 3.1 that each occurrence of nonterminal Aj in the right-hand side of p is represented as a position set .",
        "The specification of an algorithm for finding a 2-feasible binarization of p is reported in Figure 1.",
        "The algorithm uses an agenda A as a working set, where all position sets that still need to be processed are stored.",
        "A is initialized with the position sets , 1 < i < r(p).",
        "At each step in the algorithm, the size of A represents the maximum rank among all productions that can be obtained from the reductions that have been chosen so far in the binarization process.",
        "The algorithm also uses a list R, initialized as the empty list, where all reductions that are attempted in the binarization process are appended.",
        "At each iteration, the algorithm performs a reduction by arbitrarily choosing a pair of adjacent endpoint sets from the agenda and by merging them.",
        "As already discussed in Subsection 3.1, this corresponds to some specific transformation of the input production p that preserves its generative capacity and that decreases its rank by one unit.",
        "We stop the iterations of the algorithm when we reach a state in which there are no more than two position sets in the agenda.",
        "This means that the binarization process has come to an end with the reduction of p to a set of productions equivalent to p and with rank and fanout at most 2.",
        "This set of productions can be easily constructed from the output list R. We also stop the iterations in case no adjacent pair of position sets can be found in the agenda.",
        "If the agenda has more than two position sets, this means that no binarization has been found and the algorithm returns a failure.",
        "To prove the correctness of the algorithm in Figure 1, we need to show that it produces a 2-feasible binarization of the given production p whenever such a binarization exists.",
        "This is established by the following theorem:",
        "Theorem 2 Let X be a 2-feasible collection ofpo- sition sets, such that the union ofall sets in X is a position set with fanout < 2.",
        "The procedure:",
        "while ( X contains any pair of adjacent sets X1 , X2 ) reduce X by merging X1 with X2; always finds a 2-feasible binarization of X.",
        "In order to prove this, the loop invariant is that X is a 2-feasible set, and that the union of all position sets in X has fanout < 2: reductions can never change the union of all sets in X, and Theorem 1 guarantees us that every change to the state of X maintains 2-feasibility.",
        "We also know that the algorithm eventually finishes, because every iteration reduces the amount of position sets in X by 1 ; and the looping condition will not hold when the number of sets gets to be 1.",
        "So it only remains to prove that the loop is only exited if X contains at most two position sets.",
        "If we show this, we know that the sequence of reductions produced by this procedure is a 2-feasible binarization.",
        "Since the loop is exited when X is 2-feasible but it contains no pair of adjacent position sets, it suffices to show the following:",
        "Proposition 1 Let X be a 2-feasible collection of position sets, such that the union ofall the sets in X is a position set with fanout < 2.",
        "IfX has more than two elements, then it contains at least a pair of adjacent position sets.",
        "□",
        "Let X be a 2-feasible collection of more than two position sets.",
        "Since X is 2-feasible, we know that there must be a 2-feasible binarization of X.",
        "Suppose that / is such a binarization, and let Di and D2 be the two position sets that are merged in the first reduction of //.",
        "Since // is 2-feasible, Diand D2 must be 2-combinable.",
        "If Di and D2 are adjacent, our proposition is true.",
        "If they are not adjacent, then, in order to be 2-combinable, the fanout of both position sets must be 1 : if any of them had fanout 2, their union would need to have fanout > 2 for Di and D2not to be adjacent, and thus they would not be 2-combinable.",
        "Since Di and D2 have fanout 1 and are not adjacent, their sets of endpoints are of the form b2} and {ci, c2}, and they are disjoint.",
        "If we call EX the set of endpoints corresponding to the union of all the position sets in X and EDlD2 = b2, ci, c2}, we can show that at least one of the endpoints in EDl D2 does not appear in EX, since we know that EX can have at most 4 elements (as the union has fanout < 2) and that it cannot equal EDlD2 because this would mean that X = {Di, D2}, and by hypothesis X has more than two position sets.",
        "If we call this endpoint x, this means that there must be a position set D3 in X, different from Di and D2, that has x as one of its endpoints.",
        "Since Di and D2have fanout 1, this implies that D3 must be adjacent either to Di or to D2, so we conclude the proof.",
        "We now turn to the computational analysis of the algorithm in Figure 1.",
        "We define the length of an LCFRS production p, written |p|, as the sum of the length of all strings aj in a in the definition of the linear, non-erasing function associated with p. Since we are dealing with LCFRS of fanout at most two, we easily derive that |p| = O(r(p)).",
        "In the implementation of the algorithm it is convenient to represent each position set by means of the corresponding endpoint set.",
        "Since at any time in the computation we are only processing position sets with fanout not greater than two, each endpoint set will contain at most four integers.",
        "The for-loop at lines 4 and 5 in the algorithm can be easily implemented through a left-to-right scan of the characteristic string <rN (p), detecting the endpoint sets associated with each position set Xa4 .",
        "This can be done in constant time for each",
        "Xa4 , and thus in linear time in |p|.",
        "At each iteration of the while-loop at lines 6 to 10 we have that A is reduced in size by one unit.",
        "This means that the number of iterations is bounded by r(p).",
        "We will show below that each iteration of this loop can be executed in constant time.",
        "We can therefore conclude that our binariz-ation algorithm runs in optimal time O(|p|).",
        "In order to run in constant time each single iteration of the while-loop at lines 6 to 10, we need to perform some additional bookkeeping.",
        "We use two arrays Ve and Vt, whose elements are indexed by the endpoints associated with characteristic string <rN (p), that is, integers i £ [0, |<rN (p)|].",
        "For each endpoint i, Ve[i] stores all the endpoint sets that share endpoint i.",
        "Since each endpoint can be shared by at most two endpoint sets, such a data structure has size O(|p|).",
        "If there exists some position set X in A with leftmost endpoint i, then V« [i] stores all the position sets (represented as endpoint sets) that are adjacent to X.",
        "Since each position set can be adjacent to at most four other position sets, such a data structure has size O(|p|).",
        "Finally, we assume we can go back and forth between position sets in the agenda and their leftmost endpoints.",
        "We maintain arrays Ve and Vj through the following simple procedures.",
        "• Whenever a new position set X is added to A, for each endpoint i of X we add X to V [i].",
        "We also check whether any position set in Ve[i] other than X is adjacent to X, and add these position sets to Vjiz], where ij is the leftmost end point of X.",
        "• Whenever some position set X is removed from A, for each endpoint i of X we remove X from V [i].",
        "We also remove all of the position sets in Vjiz], where ij is the leftmost end point of X.",
        "It is easy to see that, for any position set X which is added/removed from A, each of the above procedures can be executed in constant time.",
        "We maintain a set I of integer numbers i £ [0, |<7N(p)|] such that i £ I if and only if Vji] is not empty.",
        "Then at each iteration of the while-loop at lines 6 to 10 we pick up some index in I and retrieve at Vji] some pair X, X' such that X <-> X'.",
        "Since X, X' are represented by means of endpoint sets, we can compute the endpoint set of X U X' in constant time.",
        "Removal of X, X' and addition of",
        "X U X' in our data structures Ve and Vj is then performed in constant time, as described above.",
        "This proves our claim that each single iteration of the while loop can be executed in constant time."
      ]
    },
    {
      "heading": "5. Discussion",
      "text": [
        "We have presented an algorithm for the binarization of a LCFRS with fanout 2 that does not increase the fan-out, and have discussed how this can be applied to improve parsing efficiency in several practical applications.",
        "In the algorithm of Figure 1, we can modify line 14 to return R even in case of failure.",
        "If we do this, when a binarization with fanout < 2 does not exist the algorithm will still provide us with a list of reductions that can be converted into a set of productions equivalent to p with fanout at most 2 and rank bounded by some rb, with 2 < rb < r(p).",
        "In case rb < r(p), we are not guaranteed to have achieved an optimal reduction in the rank, but we can still obtain an asymptotic improvement in parsing time if we use the new productions obtained in the transformation.",
        "Our algorithm has optimal time complexity, since it works in linear time with respect to the input production length.",
        "It still needs to be investigated whether the proposed technique, based on determinization of the choice of the reduction, can also be used for finding binarizations for LCFRS with fanout larger than two, again without increasing the fan-out.",
        "However, it seems unlikely that this can still be done in linear time, since the problem of binarization for LCFRS in general, i.e., without any bound on the fan-out, might not be solvable in polynomial time.",
        "This is still an open problem; see (Gomez-Rodriguez et al., 2009) for discussion."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "The first author has been supported by Ministerio de Education y Ciencia and FEDER (HUM2007-66607-C04) and Xunta de Galicia (PGIDIT-07SIN005206PR, INCITE08E1R104022ES, INCITE08ENA305025ES, INCITE08PXIB-302179PR and Rede Galega de Procesamento da Linguaxe e Recuperation de Information).",
        "The second author has been partially supported by MIUR under project PRIN No.",
        "2007TJN-ZRE_002."
      ]
    }
  ]
}
