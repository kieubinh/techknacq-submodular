{
  "info": {
    "authors": [
      "Esra Erdem",
      "Reyyan Yeniterzi"
    ],
    "book": "Proceedings of the BioNLP 2009 Workshop",
    "id": "acl-W09-1315",
    "title": "Transforming Controlled Natural Language Biomedical Queries into Answer Set Programs",
    "url": "https://aclweb.org/anthology/W09-1315",
    "year": 2009
  },
  "references": [],
  "sections": [
    {
      "text": [
        "Transforming Controlled Natural Language Biomedical Queries",
        "into Answer Set Programs",
        "Esra Erdem and Reyyan Yeniterzi",
        "Faculty of Engineering and Natural Sciences Sabanci University Orhanli, Tuzla 34956 Istanbul, Turkey",
        "We introduce a controlled natural language for biomedical queries, called BioQueryCNL, and present an algorithm to convert a biomedical query in this language into a program in answer set programming (ASP) – a formal framework to automate reasoning about knowledge.",
        "BioQueryCNL allows users to express complex queries (possibly containing nested relative clauses and cardinality constraints) over biomedical ontologies; and such a transformation of BioQueryCNL queries into ASP programs is useful for automating reasoning about biomedical ontologies by means of ASP solvers.",
        "We precisely describe the grammar of BioQueryCNL, implement our transformation algorithm, and illustrate its applicability to biomedical queries by some examples."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The rapid increase in the popularity and usage of Web leads researchers to store data and make it publicly available in many ways.",
        "In particular, to facilitate access to its desired parts, it is stored in a structured form, like ontologies.",
        "These ontologies can be queried with an SQL-like formal query language.",
        "However, since these ontologies have been developed for and widely used by people that lacks the necessary knowledge in a formal query language, a simpler and more commonly known language is needed to represent queries.",
        "A natural language is the perfect answer, but ambiguities in its grammar and vocabulary make it difficult to automate reasoning about queries in natural language.",
        "Therefore, to represent queries, we consider a middle ground between these two options: a Controlled Natural Language (CNL).",
        "A CNL is a subset of a natural language, with a restricted grammar and vocabulary, that overcomes the ambiguity of natural languages.",
        "Since we consider queries in a specific domain, namely biomedicine, and over specific sources of information, namely biomedical ontologies, a CNL designed and developed for reasoning about biomedical ontologies is sufficient to represent biomedical queries.",
        "Essentially, a CNL is a formal language but with a look of a natural language.",
        "Therefore, compared to a natural language, a CNL can be easily converted to some other formalisms.",
        "This allows us to use automated reasoners, specifically developed for such formalisms, to find answers to queries expressed in a CNL.",
        "One such formalism is Answer Set Programming (ASP) (Baral, 2003).",
        "ASP is a new knowledge representation and reasoning paradigm which supports representation of defaults, constraints, preferences, aggregates, etc., and provides technologies that allow us to automate reasoning with incomplete information, and to integrate other technologies, like description logics reasoners and Semantic Web technologies.",
        "For instance, in (Bodenreider et al., 2008), the authors illustrate the applicability and effectiveness of using ASP to represent a rule layer that integrates relevant parts of some biomedical ontologies in RDF(S)/OWL, and to compute answers to some complex biomedical queries over these ontologies.",
        "Although CNLs are appropriate for expressing biomedical queries, and methods and technologies of ASP are appropriate for automated reasoning about biomedical ontologies, there is no algorithm to convert a CNL biomedical query into a program.",
        "In (Bodenreider et al., 2008), biomedical queries are represented as programs in ASP; however, these programs are constructed manually.",
        "However, manually constructing ASP programs to represent biomedical queries is not only time consuming but also requires expertise in ASP.",
        "This prevents automating the whole process of computing an answer to a query, once it is given in a CNL.",
        "In this paper, we design and develop a CNL (called BioQueryCNL) for expressing biomedical queries over some ontologies, and introduce an algorithm to convert a biomedical query expressed in this CNL into a program in ASP.",
        "The idea is to automatically compute an answer to the query using methods of (Bodenreider et al., 2008), once the user types the query.",
        "This idea is illustrated in Figure 1.",
        "Similar approaches of using a CNL for querying ontologies have been investigated in various studies.",
        "For instance, (Bernstein et al., 2005) considers queries in the controlled natural language, At-tempto Controlled English (ACE) (Attempto, 2008), and transforms them into queries in Pql (Klein and Bernstein, 2004) to be evaluated by a query engine.",
        "(Bernstein et al., 2006) presents a system that guides the user to write a query in ACE, and translates the query into Sparql to be evaluated by the reasoner of Jena (Jena, 2008).",
        "On the other hand, (Kaufmann et al., 2006) transforms a given natural language query to a Sparql query (using the Stanford Parser and WordNet) to be evaluated by a reasoner like that of Jena.",
        "Our work is different from these studies in two ways: we consider queries over biomedical ontologies (thus different forms of queries, and vocabulary), and we transform a query into an ASP program to automate reasoning over a rule layer presented in ASP.",
        "Transformations of natural language sentences into ASP has been studied in (Baral et al., 2008) and (Baral et al., 2007).",
        "In (Baral et al., 2008), the authors introduce methods to transform some simple forms of sentences into ASP using Lambda Calculus.",
        "In (Baral et al., 2007), the authors use C&C tools (CC, 2009) to parse the some forms of natural language input, and perform a semantic analysis over the parser output using Boxer (Boxer, 2009), to do reasoning in ASP.",
        "Our work is different in that we consider a CNL to express queries, and introduce a different method for converting CNL to a program in ASP, via Discourse Representation Structures (DRS) (Kamp, 1981).",
        "In the rest of the paper, first we briefly discuss ASP with some examples (Section 2).",
        "Then we define the grammatical structure of BioQueryCNL and give some examples (Section 3).",
        "Next, we introduce our algorithm for transforming a Bio-QueryCNL query into an ASP program and explain it by an example (Section 4).",
        "We conclude with a discussion of challenges related to the implementation of our algorithm (Section 5) and other related problems that we are working on (Section 6)."
      ]
    },
    {
      "heading": "2. Answer Set Programming",
      "text": [
        "Answer Set Programming (ASP) (Lifschitz, 1999; Marek and Truszczyriski, 1999; Niemela, 1999; Baral, 2003) is a new knowledge representation and reasoning paradigm which supports representation of defaults, constraints, preferences, aggregates, etc., and provides technologies that allow us to automate reasoning with incomplete information, and to integrate other technologies, like description logics reasoners and Semantic Web technologies.",
        "In ASP, knowledge is represented as a \"program\" (a finite set of \"rules\") whose meaning is captured by its models (called \"answer sets\" (Gelfond and Lifschitz, 1988)).",
        "Answer sets for a program can be computed by \"answer set solvers\" such as dlv (DLV, 2009).",
        "Consider for instance the program:",
        "gene_gene(,,ADRB1\",,,CHRM5'').",
        "gene_gene(,,CHRM1\",,,CHRM5'').",
        "chain(X,Y) :- gene_gene(X,Y).",
        "chain(X,Y) :- gene_gene(Y,X).",
        "chain(X,Y) :- gene_gene(X,Z), chain(Z,Y).",
        "The first rule expresses that the gene ADRB1 interacts with the gene CHRM5.",
        "The second rule expresses that the gene CHRM1 interacts with the gene CHRM5.",
        "The third, the fourth, and the fifth rules express a chain of such interactions.",
        "In a rule containing :-, the left-hand-side of :- is called the head of the rule, the right-hand-side is called the body of the rule.",
        "Such a rule p :- q, r. is read as \"p if q and r\".",
        "Here the head atom is p, and the body atoms are q and r. The answer set for this program describes that there is a chain of interactions between",
        "CHRM1 and CHRM5, ADRB1 and CHRM5, and ADRB1 and CHRM1.",
        "As mentioned above, the language of ASP is expressive enough to represent defaults, constraints, preferences, aggregates, etc.. For instance, the rule",
        "treats_2diseases(R) :-#count{D:treats(R,D)}>=2, drug(R).",
        "describes drugs R that treat at least 2 diseases."
      ]
    },
    {
      "heading": "3. A Controlled Natural Language for Biomedical Queries",
      "text": [
        "We introduce a controlled natural language, called BioQueryCNL, to express biomedical queries, whose grammar is shown in Table 1.",
        "This grammar should be considered in connection with the given biomedical ontologies.",
        "The italic words in the grammar, for instance, represent the information extracted from the related ontologies.",
        "We call these italic words ontology functions; the detailed description of these functions are given in Table 2.",
        "With BIOQUERYCNL, the users can ask simple queries, queries with nested relative clauses (with any number of conjunctions and disjunctions), and queries with cardinalities.",
        "Some sample queries are given below.",
        "(Q1) Which symptoms are alleviated by the drug Epinephrine?",
        "(Q2) What are the side-effects of the drugs that treat the disease Asthma?",
        "(Q3) What are the genes that are related to the disease Asthma and are targeted by the drug Epinephrine?",
        "(Q4) What are the symptoms of the diseases that are related to the gene ADRB1 or that are treated by the drug Epinephrine?",
        "(Q5) Which genes are targeted by at least 2 drugs and are related to at most 3 diseases?",
        "BioQueryCNL is a subset of Attempto Controlled English (ACE) (Attempto, 2008), which can represent a wide range of queries (Fuchs et al., 2008), specialized for biomedical ontologies."
      ]
    },
    {
      "heading": "4. Converting Controlled Natural Language Queries to Programs",
      "text": [
        "We have implemented an algorithm, QUERY, presented in Algorithm 1, that obtains an ASP rule Head – Body from a query q expressed in BioQueryCNL, via transforming q into a DRS.",
        "We will explain the main steps of the QUERY algorithm by an example, considering query (Q4).",
        "Algorithm 1 QUERY(Q) Input: A query Q",
        "Output: An ASP rule Head – Body 1: D := Find the DRS of Q 2: Head := HEAD(D) 3: Body' := BODY(D) 4: Body := PoSTPROCESSING(Body') 5: return Head – Body",
        "Attempto Controlled English (ACE) text can be converted into Discourse Representation Structures (DRS) (Kamp, 1981) – a variant of the first-order logic that is used for the dynamic interpretation of natural language and systematic translation of natural language into logical form – without any ambiguity, using tools like Attempto Parsing Engine (APE).",
        "APE converts ACE text to DRS by an approach similar to (Blackburn and Bos, 2005), as explained in (Fuchs et al., 2008).",
        "For instance, APE transforms query (Q4) into the following DRS:",
        "Type() returns the type information the ontologies keep, ex.",
        "gene, disease, drug Instance(T) returns instances of the type T, ex.",
        "Asthma for type disease Verb(T) returns the verbs related to the type T, ex.",
        "approve for type drug Verb(T, T') returns the verbs where type T is the subject and type T is the object, ex.",
        "drug treat disease Noun(T) returns the nouns that are related to the type T, ex.",
        "symptom for type disease",
        "object(C,symptoms,countable,na,eq,1)-1 property(G,related,pos)-1 object(E,gene_ADRB1,countable,na,eq,1)-1 v predicate(I,treated,H,D)-1 object(H,drug_Epinephrine, countable,na,eq,1)-1 object(D,diseases,countable,na,geq,2)-1",
        "Note that the DRS consists of two kinds of expressions.",
        "The lines with a list of uppercase letters, like [e,f,g] , describe the domain of the DRS; each uppercase letter is a referent.",
        "The rest of the DRS describe the conditions about the domain.",
        "The DRS above contains some predefined predicates, such as object, property, predicate,",
        "query, etc.. All the nouns, adjectives, verbs, modifiers, etc.",
        "are represented with one of them.",
        "For instance,",
        "• object describes objects and the relevant forms of nouns denoting them (like \"diseases\")",
        "• predicate describes relations that are pro-",
        "Query – ",
        "YesNoQuery | WhQuery QuestionMark",
        "YesNoQuery – ",
        "DoDoesQuery | IsAreQuery",
        "WhQuery – ",
        "WhatQuery | WhichQuery",
        "DoDoesQuery – ",
        "[ Do | Does ] Type() Instance(T) PredicateRelation",
        "IsAreQuery – ",
        "[ Is | Are ] Type() Instance(T) Verb(T)",
        "WhatQuery – ",
        "What Be Type() that PredicateRelation",
        "WhatQuery – ",
        "What Be OfRelation that PredicateRelation",
        "WhatQuery – ",
        "What Be OfRelationInstance that PredicateRelation",
        "WhichQuery – ",
        "Which Type() PredicateRelation",
        "OfRelation – ",
        "Noun(T) of Type()",
        "OfRelationInstance – ",
        "Noun(T) of Type() Instance(T)",
        "PredicateRelation – ",
        "ActiveRelation (Connector (that)?",
        "PredicateRelation)*",
        "PredicateRelation – ",
        "PassiveRelation (Connector (that)?",
        "PredicateRelation)*",
        "ActiveRelation – ",
        "Verb(T, T) Type() Instance(T')",
        "ActiveRelation – ",
        "Verb(T, T) GeneralisedQuantor PositiveNumber Type()",
        "PassiveRelation – ",
        "Be Verb(T', T) by Type() Instance(T')",
        "PassiveRelation – ",
        "Be Verb(T', T) by GeneralisedQuantor PositiveNumber Type()",
        "Be – ",
        "is | are",
        "Connector – ",
        "and | or",
        "GeneralisedQuantor – ",
        "at least | at most | more than | less than | exactly",
        "QuestionMark – ",
        "?",
        "duced by different forms of verbs (like \"treated\"),",
        "• relation describes relations that are produced by of-constructions (like \"symptoms of disease\"),",
        "• query describes the form of the query and the objects that the query is referring to.",
        "ontologies represent relations between concepts.",
        "A rule layer over ontologies introduce further concepts integrating them.",
        "ASP takes into account relevant concepts and relations to answer a given query about these ontologies.",
        "in the biomedical queries we consider, the concepts and instances are represented with object and the relations between these concepts are represented with predicate and relation.",
        "The query is also important in terms of the type of information the user asks for.",
        "once the corresponding DRS is obtained from a given BioQueryCNL query, the head and the body atoms are constructed by analyzing the conditions in the DRS, as described in Algorithms 2 and 3.",
        "The Head algorithm is about the query predicate, which refers to objects or relations that are asked for in the given query.",
        "By following the referents, starting from the one mentioned in query, the algorithm finds out the type of the information that is asked for in the given query.",
        "Consider, for instance, query (Q4).",
        "The referent mentioned in query(A,what) is a.",
        "and here it denotes an object with referent c. Now let's find where c is mentioned: in",
        "object(C,symptoms,countable,na,eq,1)-1 to",
        "denote symptoms.",
        "Therefore, the query asks for symptoms.",
        "Based on this information, Algorithm 2 returns the head of the ASP rules as follows:",
        "what_be_symptoms(SYM1)",
        "The Body algorithm analyzes the predicate and the relation predicates.",
        "These two predicates describe relations between objects described by the object predicates.",
        "The algorithm starts from the predicate and the relation predicates, and then, by following the referents, it returns the body atoms of the ASP rule.",
        "For instance, Algorithm 3 returns the following body atoms for query (Q4):",
        "symptoms_of_diseases(symptom_SYM1,",
        "disease_DIS1) diseases_be_related_to_gene(disease_DIS1,",
        "gene_,,ADRB1\") drug_treated_diseases(drug_,,Epinephrine'', disease_DIS1)",
        "These body atoms are given to Postprocessing step, to produce bodies of the ASP rules.",
        "Postprocessing is the last step of the QUERY algorithm.",
        "At this step, first the number of rules is determined, and then the body atoms are placed in the bodies of these rules.",
        "In ASP, a conjunctive query can be represented by a rule.",
        "However, disjunctive queries are represented by several rules with same head but different bodies.",
        "For instance, query (Q4) is a disjunctive query (a disjunction of two queries), so there will be two rules representing this query:",
        "what_be_symptoms(SYM1) :-symptoms_of_diseases(symptom_SYM1,",
        "disease_DIS1), diseases_be_related_to_gene(disease_DIS1, gene_,,ADRB1\").",
        "what_be_symptoms(SYM1) :-drug_treated_diseases(drug_,,Epinephrine'',",
        "disease_DIS1), symptoms_of_diseases(symptom_SYM1, disease_DIS1).",
        "Next, the predicate names in the bodies of these rules are matched with the names of the already defined predicates in ontologies or in the rule layer over these ontologies.",
        "After matching the predicate names, the parameters of the predicates may have to be reordered.",
        "The matching of the predicates very much depends on the user interface (UI).",
        "If UI enforces users to use a specific grammar and lexicon while forming the query, then the matching can be done with an easy table lookup method.",
        "If the UI allows more flexibility of constructing a query, then the matching algorithm should use some basic Natural Language Processing methods and similarity metrics to find the most probable matching.",
        "After matching the predicates, the ordering of the parameters can be done easily.",
        "The Body algorithm Algorithm 2 Head(D) Input: ADRS",
        "Output: Head of an ASP rule 1: query(Ref, QuestionWord) // e.g., query(A, which) for \"Which drug ...\" 2: if Ref is an object then 3: Object := RefersTo(Ref) // e.g., A refers to a \"drug\" DRG1 4: Head := Concat(QuestionWord, Object, Ref) // e.g., whichArug(DRGl) 5: else if Ref is a subject of a predicate then // query(A, what) for \"What are the genes ...\" 6: Object := RefersTo (Ref) //e.g., A refers to \"genes\" GENE 1 7: Head := Conc at(QuestionWord, Predicate, Object, Ref) // e.g., whatJbe-genes(GEN E1) 8: end if 9: return Head returns the body predicates with the parameters.",
        "In these parameters, the type and the instance names are kept together.",
        "Thus, ordering of those parameters are done just by using the type information.",
        "After the ordering is done, the type information part is removed from the parameters.",
        "For instance, after matching the predicates, we get the following ASP rule for query (Q4).",
        "what_be_symptoms(SYM1) :-disease_symptom(DIS1,SYM1), disease_gene(DIS1,,,ADRB1\").",
        "what_be_symptoms(SYM1) :-treats_disease(,,Epinephrine'',DIS1), disease_symptom(DIS1,SYM1).",
        "With an ASP rule layer over ontologies, and this ASP program, an ASP solver, like dlvhex (DLVHEX, 2009), returns an answer to query (Q4).",
        "For instance, consider the ASP rule layer, and the gene, disease, drug ontologies of (Bodenreider et al., 2008).",
        "The ontologies of (Bodenreider et al., 2008) are obtained from the ontologies Phar-mGKB (PharmGKB, 2008), UniProt (UniProt, 2008), Gene Ontology (GO) (GeneOntology, 2008), GeneNetwork database (GeneNetwork, 2008), DrugBank (DrugBank, 2008), and the Medical Symptoms and Signs of Disease web page (MedicalSymptomsSignsDisease, 2008).",
        "With this rule layer and the ontologies, and the ASP program above, the following is a part of the answer dlvhex finds to the query above:",
        "noisy breathing faster breathing shortness of breath coughing chest tightness wheezing",
        "The algorithm discussed above returns the following ASP program for query (Q5):",
        "which_genes(GN1) :-2<=#count{DRG1:drug_gene(DRG1,GN1)}, #count{DIS1:disease_gene(DIS1,GN1)}<=3.",
        "Since query (Q5) contains cardinality constraints, the ASP program uses the aggregate #count.",
        "More examples of biomedical queries, and the ASP programs generated by our program can be seen at http://people.sabanciuniv.edu/ esraerdem/bioquery-asp/bionlp0 9/."
      ]
    },
    {
      "heading": "5. Implementational Issues",
      "text": [
        "We have implemented the algorithms explained above in perl.",
        "We have used Attempto Parsing Engine APE to convert a given BioQueryCNL query into a DRS.",
        "Since BioQueryCNL is about biomedical ontologies, we provided APE some information about biomedical concepts, such as gene, drug, and words that represent relations between these concepts such as treat, target etc..",
        "However, providing such information is not sufficient to convert all BioQueryCNL biomedical queries into programs, mainly due to specific instances of these concepts (consider, for instance, various drug names that appear in ontologies).",
        "one way to deal with this problem is to extract from the ontologies all instances of each concept and provide them to APE as an additional lexicon.",
        "This may not be the perfect solution since this process has to be repeated when an instance is added to the ontology.",
        "An alternative way can be enforcing the user to enter Algorithm 3 Body(D) Input: ADRS",
        "Output: Body of an ASP rule 1: Body := empty string 2: for each predicate P do 3: // P can be of the form predicate(Ref, Verb, SubRef), like predicate(H, targeted, A) 4: Subject := RefersTo(SubRef ) // e.g., A refers to \"genes\" GENE 1 5: if P has a verb phrase modifier then 8: if P has an object then // P can be of the form predicate(Ref, Verb, SubRef, ObjRef) 9: Object := REFERSTo(ObjRef) 10: end if 11: Body := ConcAT(Body, Subject, Verb, Modifier, Object) 12: // e.g., genes-targetedJby-drugs(GENEl, DRG1) 13: end for 14: for each relation R do 21: return Body the concept name just before the instance (like \"the drug Epinephrine\") in the query.",
        "This is how we deal with instance names, in the current version of our implementations.",
        "However, such BIOQUERYCNL queries are not in the language of APE; so, with some preprocessing, we rewrite these queries in the correct syntax for APE."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "We have designed and developed a Controlled Natural Language (CNL), called BioQueryCNL, to represent biomedical queries over some ontologies, and provided a precise description of its grammatical structure.",
        "We have introduced an algorithm to convert queries in BIOQUERYCNL to a program in Answer Set Programming (ASP).",
        "The idea is to compute answers to these queries automatically, by means of automated reasoners in ASP, over biomedical ontologies in RDF(S)/OWL and a rule layer in ASP integrating these ontologies.",
        "Our algorithm can handle various forms of simple/complex disjunctive/conjunctive queries that may contain (nested) relative clauses and cardinality constraints.",
        "We have implemented this algorithm in PERL, and tried it with the ASP rule layer, and the ontologies of (Bodenreider et al., 2008).",
        "One essential part of the overall system is an intelligent user interface that allows a user to enter biomedical queries in BIOQUERYCNL.",
        "Design and implementation of such a user-interface is a part of our ongoing work."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "Thanks to Tobias Kuhn for his help with ACE.",
        "This work is supported by the Scientific and Technological Research Council of Turkey (TUBITAK) grant 108E229."
      ]
    }
  ]
}
