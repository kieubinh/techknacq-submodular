{
  "info": {
    "authors": [
      "Dan Garrette",
      "Ewan Klein"
    ],
    "book": "Proceedings of the Eight International Conference on Computational Semantics",
    "id": "acl-W09-3712",
    "title": "An Extensible Toolkit for Computational Semantics",
    "url": "https://aclweb.org/anthology/W09-3712",
    "year": 2009
  },
  "references": [],
  "sections": [
    {
      "text": [
        "dhgarretteQgmail.com",
        "Ewan Klein University of Edinburgh",
        "ewanQinf.ed.ac.uk",
        "1 Introduction"
      ]
    },
    {
      "heading": null,
      "text": [
        "In this paper we focus on the software for computational semantics provided by the Python-based Natural Language Toolkit (nltk).",
        "The semantics modules in nltk are inspired in large part by the approach developed in Blackburn and Bos (2005) (henceforth referred to as B&B).",
        "Since Blackburn and Bos have also provided a software suite to accompany their excellent textbook, one might ask what the justification is for the nltk offering, which is similarly slanted towards teaching computational semantics.",
        "This question can be answered in a number of ways.",
        "First, we believe there is intrinsic merit in the availability of different software tools for semantic analysis, even when there is some duplication of coverage; and this will become more true as computational semantics starts to be as widely studied as computational syntax.",
        "For example, one rarely hears the objection that too many implementations of syntactic parsers are available.",
        "Moreover, the nltk software significantly goes beyond B&B in providing an implementation of Glue Semantics.",
        "Second, whatever the relative merits of Prolog vs. Python as programming languages, there is surely an advantage in offering students and instructors a choice in this respect.",
        "Given that many students have either already been exposed to Java, or else have had no programming experience at all, Python offers them the option of accomplishing interesting results with only a shallow learning curve.",
        "Third, nltk is a rapidly developing, open source project with a broad coverage of natural language processing (nlp) tools; see Bird et al.",
        "(2008) for a recent overview.",
        "This wide functionality has a number of benefits, most notably that lexical, syntactic and semantic processing can be carried out within a uniform computational framework.",
        "As a result, nltk makes it much easier to include some computational semantics subject matter in a broad course on natural language analysis, rather than having to devote a whole course exclusively to the topic.",
        "xSee http://www.nltk.org",
        "Fourth, nltk is accompanied by a substantial collection of corpora, plus easy-to-use corpus readers.",
        "This collection, which currently stands at over 50 corpora and trained models, includes parsed, POS-tagged, plain text, categorized text, and lexicons.",
        "The availability of corpora can help encourage students to go beyond writing toy grammars, and instead to start grappling with the complexities of semantically analysing realistic bodies of text.",
        "Fifth, nltk is not just for students.",
        "Although Python is slower than languages like Java and C++, its suitability for rapid prototyping makes it an attractive addition to the researcher's inventory of resources.",
        "Building an experimental set-up in nltk to test a hypothesis or explore some data is straightforward and quick, and the rich variety of existing nlp components in the toolkit allows rapid assembly of quite sophisticated processing pipelines."
      ]
    },
    {
      "heading": "2. Overview",
      "text": [
        "Like B&B, we assume that one of the most important tasks for the teacher is to ground students in the basic concepts of first order logic and the lambda calculus, model-theoretic interpretation and inference.",
        "This provides a basis for exploring more modern approaches like Discourse Representation Theory (drt; Kamp and Reyle (1993)) and underspecification.",
        "Theorem Proving",
        "In the accompanying figure, we give a diagrammatic overview of the main semantics-related functionality that is currently available in nltk.",
        "Logical forms (lfs) can be induced as result of syntactic parsing, using either feature-based grammars that are processed with an Earley chart parser, or else by associating lfs with the output of a broad-coverage dependency parser.",
        "Our basic lfs are expressions of first order logic, supplemented with the lambda operator.",
        "However, we also admit Discourse Representation Structures (drss) as lfs, and underspecified lfs can be built using either Hole Semantics (Blackburn and Bos, 2005) or Glue Semantics (Dalrymple et al., 1999).",
        "Once we have constructed lfs, they can be evaluated in a first order model (Klein, 2006), tested for equivalence and validity in a variety of theorem provers, or tested for consistency in a model builder.",
        "The latter two tasks are aided by nltk interfaces to third-party inference tools, currently Prover9 and Mace4 (McCune, 2008).",
        "L1",
        "Tableau TP",
        "Non-monotonic TP |",
        "Prover9",
        "We do not have space in this paper to discuss all of these components, but will try to present some of the key aspects, and along the way noting certain points of difference vis-à-vis B&B."
      ]
    },
    {
      "heading": "3. Logical Form",
      "text": [
        "From a pedagogical point of view, it is usually important to ensure that students have some grasp of the language of first order predicate logic (fol), and can also manipulate A-abstraction.",
        "The nltk.sem.logic module contains an object-oriented approach to representing fol plus A-abstraction.",
        "Logical formulas are typically fed to the logic parser as strings, and then represented as instances of various subclasses of Expression, as we will see shortly.",
        "An attractive feature of Python is its interactive interpreter, which allows the user to enter Python expressions and statements for evaluation.",
        "In the example below and subsequently, »> is the Python interpreter's prompt."
      ]
    },
    {
      "heading": "1. >» from nltk.sem import logic",
      "text": [
        "As illustrated, the result of parsing the formula at line 3 is an object e belonging to the class AllExpression, itself a subclass of Expression.",
        "All such subclasses have numerous methods that implement standard logical operations.",
        "For example, the simplify() method carries out /3-conversion; the f ree() method finds all the free variables in an expression; and for quantified expressions (such as AllExpressions), there is an alpha_convert() method.",
        "The logic module will a-convert automatically when appropriate to avoid name-clashes in the replace() method.",
        "Let's illustrate these methods with a formula involving A-abstraction, namely \\x.P(x)(y); we use \\ to represent A.",
        "(Since \\ is a special character in Python, we add the r prefix to strings containing it to preclude additional escape characters.)",
        ">» print e2.alpha_convert(Variable('z'))",
        "Allowing students to build simple first order models, and evaluate expressions in those models, can be useful for helping them clarify their intuitions about quantification.",
        "In the next example, we show one of the available methods in nltk for specifying a model and using it to determine the set of satisfiers of the open formula 3x.",
        "(girl(y) a chase(x,y)).,",
        ">» from nltk.sem import parse_valuation, Model, Assignment >» m = Model(val.domain, val) #initialize a Model >» g = Assignment(val.domain) #initialize an Assignment",
        "In B&B, A-abstracts are second-class citizens, used exclusively as a 'glue' mechanism for composing meaning representations.",
        "Although we use A-abstracts as glue too, abstracts over individual variables are semantically interpreted in nltk, namely as characteristic functions.",
        "Expressions in nltk can be optionally typed (using Montague-style types) by passing the parameter type_check=True to LogicParser.",
        "Apart from allowing the user to display the Expression's type with type, type checking will raise an exception for non-well typed expressions:",
        "TypeException: The function '\\x y.see(x,y)' is of type '<e,<e,t>>' and cannot be applied to '\\x.man(x)' of type '<e,t>'.",
        "Its argument must match type 'e'.",
        "As mentioned earlier, nltk contains an extension to the logic module for working with Discourse Representation Theory (drt) (Kamp and Reyle, 1993).",
        "The nltk.sem.drt module introduces a DRS() constructor which takes lists of discourse referents and conditions as initialization parameters:",
        "On top of the functionality available for fol expressions, drt expressions have a 'drs-concatenation' operator, represented as the + symbol.",
        "The concatenation of two drss is a single drs containing the merged discourse referents and the conditions from both arguments.",
        "drs-concatenation automatically a-converts bound variables to avoid name-clashes.",
        "The + symbol is overloaded so that drt expressions can be added together easily.",
        "The nltk.sem.drt parser allows drss to be specified succinctly as strings.",
        ">» from nltk.",
        "sem import drt »> dp = drt.DrtParserO",
        "drt expressions can be converted to their first order predicate logic equivalents using the toFolO method and can be graphically rendered on screen with the drawQ method.",
        "Since the A operator can be combined with drt expressions, the nltk.sem.drt module can be used plug-in replacement for nltk.sem.logic in building compositional se"
      ]
    },
    {
      "heading": "4. Scope Ambiguity and Underspecification",
      "text": [
        "Two key questions in introducing students to computational semantics are:",
        "Ql: How are semantic representations constructed from input sentences?",
        "Q2: What is scope ambiguity and how is it captured?",
        "A standard pedagogical approach is to address (Ql) with a simple syntax-driven induction of logical forms which fails to deal with scope ambiguity, while (Q2) is addressed by introducing underspecified representations which are resolved to produce différent readings of ambiguous sentences.",
        "nltk includes a suite of parsing tools, amongst which is a chart parser for context free grammars augmented with feature structures.",
        "A 'semantics' feature sem allows us to compose the contributions of constituents to build a logical form for a complete sentence.",
        "To illustrate, the following minimal grammar seml.fcfg handles quantification and intransitive verbs (where values such as ?subj and ?vp are unification variables, while P and Q are Abound object language variables):",
        "Using seml.fcfg, we can parse A dog barks and view its semantics.",
        "The load_earley() method takes an optional parameter logic_parser which specifies the logic-parser for processing the value of the sem feature, thus allowing different kinds of logical forms to be constructed.",
        "»> print dl.toFolO",
        "mantics.",
        "xy",
        "Bill(x) Fred(y)",
        "u",
        "V",
        "Porsche!j) own(x, u)",
        "->",
        "Ferra ri(v) own(y, u)",
        "Underspecified logical forms allow us to loosen the relation between syntactic and semantic representations.",
        "We consider two approaches to under-specification, namely Hole Semantics and Glue Semantics.",
        "Since the former will be familiar from B&B, we devote most of our attention to presenting Glue Semantics.",
        "Hole Semantics in nltk is handled by the nltk.sem.hole module, which uses a context free grammar to generate an underspecified logical form.",
        "Since the latter is itself a formula of first order logic, we can continue to use the sem feature in the context free grammar:",
        "The Hole Semantics module uses a standard plugging algorithm to derive the sentence's readings from the underspecified lf.",
        ">» from nltk.",
        "sem import hole >» readings = hole.hole_readings('every girl chases a dog') >» for r in reading: print r",
        "Glue Semantics (Dalrymple et al., 1999), or Glue for short, is an approach to compositionality that tries to handle semantic ambiguity by using resource-sensitive logic to assemble meaning expressions.",
        "The approach builds proofs over 'meaning constructors'; these are of the form A4 : Q, where A4 is a meaning representation and Q is a term of linear logic.",
        "The linear logic term Q dictates how the meaning expression A4 can be combined.",
        "Each distinct proof that can be derived reflects a different semantic reading of the entire sentence.",
        "The variant of linear logic that we use has (linear) implication (i.e., – o) as its only operator, so the primary operation during the proof is Modus Ponens.",
        "Linear logic is an appropriate logic to serve as 'glue' because it is resource-sensitive.",
        "This means that when Modus Ponens combines two terms to create a new one, the two original terms are 'consumed', and cannot be used again in the proof; cf. (2) vs. (3).",
        "Additionally, every premise must be used for the proof to be valid; cf. (4).",
        "This resource-sensitivity dictates that each word contributes its meaning exactly once to the meaning of the whole.",
        "nltk's nltk.gluesemantics.linearlogic module contains an implementation of linear logic.",
        "The primary rule for composing Glue formulas is (5).",
        "Function-argument application of meaning expressions is reflected {via the Curry-Howard isomorphism) by the application of Modus Ponens in a linear logic proof.",
        "Note that A and B are meta-variables over constants of linear logic; these constants represent 'attachment points' for meaning expressions in some kind of syntactically-derived representation (such as an LFG /-structure).",
        "It is (5) which allows Glue to guide the construction of complex meaning expressions.",
        "The nltk modules gluesemantics.glue and gluesemantics.drt_glue implement Glue for fol and drt meaning expressions, respectively.",
        "The following example shows how Glue formulas are created and combined to derive a logical form for John walks:",
        "»> from nltk.gluesemantics.glue import GlueFormula >» john_walks = walks.applyto(john) >» print john_walks.meaning.simplify() walk(john)",
        "Thus, the non-logical constant john is associated with the Glue term g, while the meaning expression Xx.walk(x) is associated with (g – o /) since it is a function that takes g as input and returns the meaning expression /, corresponding to the whole sentence.",
        "Consequently, a proof of / from the premises is a derivation of a meaning representation for the sentence.",
        "Scope ambiguity, resulting, for example, from quantifiers, requires the use of variables in the Glue terms.",
        "Such variables may be instantiated to any linear logic constant, so long as this is carried out uniformly.",
        "Let's assume that the quantified noun phrase every girl has the meaning constructor (6) (where G is a linear logic variable):",
        "Then the Glue derivation shown below correctly generates two readings for the sentence Every girl chases a dog:",
        "»> from nltk.gluesemantics.glue import GlueFormula, Glue >» for reading in glue.get_readings(glue.gfl_to_compiled([a,b,c])): ... print reading.simplify()"
      ]
    },
    {
      "heading": "5. Inference tools",
      "text": [
        "In order to perform inference over semantic representations, nltk can call both theorem provers and model builders.",
        "The library includes a pure Python tableau-based first order theorem prover; this is intended to allow students to study tableau methods for theorem proving, and provides an opportunity for experimentation.",
        "In addition, nltk provides interfaces to two off-the-shelf tools, namely the theorem prover Prover9, and the model builder Mace4 (McCune, 2008).",
        "The get_prover (G, A) method by default calls Prover9, and takes as parameters a proof goal G and a list A of assumptions.",
        "Here, we verify that if every dog barks, and Rover is a dog, then it is true that Rover barks:",
        ">» from nltk.inference import inference",
        "A theorem prover can also be used to check the logical equivalence of expressions.",
        "For two expressions A and B, we can pass (A B) into a theorem prover and know that the theorem will be proved if and only if the expressions are logically equivalent, nltk's standard equality operator for Expressions (==) is able to handle situations where two expressions are identical up to a-conversion.",
        "However, it would be impractical for nltk to invoke a wider range of logic rules every time we checked for equality of two expressions.",
        "Consequently, both the logic and drt modules in nltk have a separate method, tp_equals, for checking 'equality' up to logical equivalence."
      ]
    },
    {
      "heading": "6. Discourse Processing",
      "text": [
        "nltk contains a discourse processing module, nltk.",
        "inference, discourse, similar to the curt program presented in B&B.",
        "This module processes sentences incrementally, keeping track of all possible threads when there is ambiguity.",
        "For simplicity, the following example ignores scope ambiguity.",
        ">» from nltk.inference.discourse import DiscourseTester as DT >» dt = DT(['A student dances', 'Every student is a person']) >» dt.readings() sO readings:",
        "sO-rO: exists x.",
        "(student(x) & dance(x)) si readings:",
        "When a new sentence is added to the current discourse, setting the parameter consistchk=True causes consistency to be checked by invoking the model checker for each 'thread', i.e., discourse sequence of admissible readings.",
        "In this case, the user has the option of retracting the sentence in question.",
        ">» dt.retract_sentence('No person dances', quiet=False) Current sentences are sO: A student dances si: Every student is a person",
        "In a similar manner, we use inf ormchk=True to check whether the new sentence is informative relative to the current discourse (by asking the theorem prover to derive it from the discourse).",
        "sO readings:",
        ">» dt.add_sentence('A person dances', informchk=True) Sentence 'A person dances' under reading 'exists x.",
        "(person(x) & dance(x))':",
        "Not informative relative to thread 'dO'",
        "It is also possible to pass in an additional set of assumptions as background knowledge and use these to filter out inconsistent readings.",
        "The discourse module can accommodate semantic ambiguity and filter out readings that are not admissable.",
        "By invoking both Glue Semantics and drt, the following example processes the two-sentence discourse Every dog chases a boy.",
        "He runs.",
        "As shown, the first sentence has two possible readings, while the second sentence contains an anaphoric pronoun, indicated as PRO(x).",
        ">» from nltk.inference.discourse import DrtGlueReadingCommand as RC »> dt = DT(['Every dog chases a boy', 'He runs'], RCO) >» dt.readings() si readings:",
        "When we examine the two threads dO and dl, we see that that reading sO-rO, where every dog out-scopes a boy, is deemed inadmissable because the pronoun in the second sentence cannot be resolved.",
        "By contrast, in thread dl the pronoun (relettered to z24) has been bound via the equation (z24 = z20).",
        ">» dt.readings(show_thread_readings=True)"
      ]
    },
    {
      "heading": "7. Conclusions and Future Work",
      "text": [
        "nltk's semantics functionality has been written with extensibility in mind.",
        "The logic module's LogicParser employs a basic parsing template and contains hooks that an extending module can use to supplement or substitute functionality.",
        "Moreover, the base Expression class in logic, as well as any derived classes, can be extended, allowing variants to reuse the existing functionality.",
        "For example, the drt and linear logic modules are implemented as extensions to logic.py.",
        "The theorem prover and model builder code has also been carefully architected to allow extensions and the nltk.",
        "inference.",
        "api library exposes the framework for the inference architecture.",
        "The library therefore provides a good starting point for creating interfaces with other theorem provers and model builders in addition to Prover9, Mace4, and the tableau prover.",
        "nltk already includes the beginnings of a framework for 'recognizing textual entailment'; access to the rte data sets is provided and we are in the course of developing a few simple modules to demonstrate rte techniques.",
        "For example, a Logical Entailment rte tagger based on Bos and Markert (2005) begins by building a semantic representation of both the text and the hypothesis in drt.",
        "It then runs a theorem prover with the text as the assumption and the hypothesis as the goal in order to check whether the text entails the hypothesis.The tagger is also capable of adding background knowledge via an interface to the WordNet dictionary in nltk.wordnet as a first step in making the entailment checking more robust."
      ]
    }
  ]
}
