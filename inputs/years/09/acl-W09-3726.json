{
  "info": {
    "authors": [
      "Philipp Cimiano"
    ],
    "book": "Proceedings of the Eight International Conference on Computational Semantics",
    "id": "acl-W09-3726",
    "title": "Flexible Semantic Composition with DUDES (short paper)",
    "url": "https://aclweb.org/anthology/W09-3726",
    "year": 2009
  },
  "references": [],
  "sections": [
    {
      "heading": null,
      "text": [
        "Flexible Semantic Composition with DUDES",
        "Philipp Cimiano Web Information Systems Group, TU Delft"
      ]
    },
    {
      "heading": "1. DUDES",
      "text": [
        "In this paper we present a novel formalism for semantic construction called DUDES (Dependency-based Underspecified Discourse REpresentation Structures).",
        "The DUDES formalism has been designed to overcome the rigidity of semantic composition based on the lambda calculus (where the order of application is typically fixed) and provides some flexibility with respect to the direction of the dependence and with respect to the order of application of arguments.",
        "In this short paper we present the DUDES formalism and work through a simple example.",
        "DUDES bears some resemblance to the work on A-DRT [2] and LUDs [I] as well as with the work of Copestake et al.",
        "[4] and represents a generalization of the formalism introduced in [3].",
        "A detailed discussion of the relation to these formalisms is clearly out of the scope of this paper.",
        "DUDES are characterized by three main facts.",
        "First, they represent semantic dependencies and are thus inherently suitable for a dependency-based grammar formalism assuming that syntactic dependencies correspond to semantic dependencies (though the correspondence might be \"inverted\").",
        "Second, they explicitly encode scope relations and are thus able to yield underspecified representations as output (in contrast to the linear logic approach for LFG [5] where different scopings correspond to different derivations).",
        "Third, there is one single operation for semantic composition which is, to some extent, order-independent (in contrast to traditional lambda-based formalisms) as well as flexible with respect to the direction of the syntactic dependency.",
        "As the name suggests, DUDES builds on DRT [6] and in particular on UDRT [7] in the sense that it relies on labeled DRSs and dominance relations between these to talk about scope.",
        "First of all, we now first formally introduce DUDES:",
        "Definition 1 (DUDES)",
        "A DUDES is a 7-tuple (m, I, t, U, A, S, C) consisting of - A main discourse referent m and a distinguished label I - The type t of the semantic structure (after inserting all arguments)",
        "- A set U of UDRS components.",
        "These UDRS components are in essence labeled DRSs [6].",
        "- A set of argument quadruples (I, v, rel, type) consisting of i) a label I (the main label of a DUDE inserted as argument, ii) the main variable v of the argument DUDE, Hi) a grammatical relation and iv) a semantic type.",
        "- A set S of scope relations between labels introduced in U.",
        "- A set C of constraints on the arguments, e.g. including ontological constraints or selectional restrictions etc.",
        "We now give the semantic representation of the entries for our running example: \"John likes every nice woman.",
        "\":_",
        "if(l,v,r,t2) e Ai (Complementation )",
        "Further, we introduce the semantic composition operation for DUDES along a dependency tree, distinguishing tree cases:",
        "Definition 2 (Semantic Composition for DUDES)",
        "Let (71,72) be an edge in some DAG (dependency tree, LTAG derivation tree or F-Structure DAG).",
        "Assume the edge is labeled with r (a grammatical function) and the semantics of the vertices 71 and 72 are given by DUDEs as follows: o\\ : = (m\\,l\\,t\\, U\\,A\\,S\\,G\\) and a2 = (rn2,l2,t2, U2, A2, S2,C2).",
        "Then the result of applying a\"2 to o\\ is the DUDE a' = a\\(a2) = (m?,1',t', U',A', S, C'), where we need to distinguish the following cases:",
        "where '=' is the operation of unification between variables.",
        "Concerning the order of application, from the definition of the semantic composition operator it follows that complements and modifiers can be applied in any order, but inversions have to be carried out at the end as they change the mother DUDES and would thus inhibit the application of the complements and the modifiers.",
        "In the following section we show how the semantic composition operation defined above applies to a concrete example.",
        "We will also discuss that our operations still work if (some of) the dependencies are inverted.",
        "1:",
        "3",
        "John(.i)",
        "T:",
        ", -L:",
        "e:like(x,y)",
        "(d",
        ", x,",
        "sub j",
        "2,y,obj, <<e,t),t»",
        "_L < scope(li), li < T, _L < scope(l2), I2 ^ T",
        "1",
        "nice(x)",
        "(",
        "' , x, mod,",
        "e,t»",
        "I < I'",
        "w | 1 | <e,t) |",
        "1:",
        "woman(w)",
        "rn",
        "= mi",
        "rn",
        "= mi",
        "rn",
        "= rn2",
        "t' :--",
        "= h",
        "t' :--",
        "= h",
        "t' :--",
        "= t2",
        "u'",
        "= u1vju2",
        "u'",
        "= u1vju2",
        "u'",
        "= u1vju2",
        "A'",
        "= A1\\{(l,v,r,t2)}",
        "A' :",
        "= A1",
        "A' :",
        "= A2\\{(l,v,r,h)}",
        "S' :",
        "= S!US2",
        "S' :",
        "= SX\\JS2",
        "S' :",
        "= S!US2",
        "c",
        "= c\\uc2",
        "c",
        "= c\\ u c2",
        "c",
        "= C\\UC2",
        "v =",
        "rn2,l = l2",
        "v =",
        "mi(= «12),/ = h",
        "v =",
        "mi,I = h"
      ]
    },
    {
      "heading": "2. A Worked Example",
      "text": [
        "We will consider the two following (possible) analyses for the sentence: \"John likes every nice woman.",
        "\", corresponding to the NP analysis (a) and DP analysis (b), respectively.",
        "The two possible dependency analyses for determiner/noun constructions give rise to two configurations, corresponding to a) and b) below, for the semantic composition operator.",
        "In both cases, independent of the fact whether",
        "Given the dependency analysis in a) to the right, result of applying our semantic composition operator for the comple mentation case we get a DUDES where the argument has been correctly inserted, the DRS components and the scope conditions have been merged and one argument has been removed.",
        "Note that this was possible because i) the edge was labeled with the appropriate grammatical relation 'subj' and ii) the types of 02 and of the argument match (both are of type ((e, t),t)).",
        "The resulting DUDES for {John likes} is shown in b) to the right.",
        "(In case of DRS conditions which are not complex, we assume that the functions 'res' and 'scope' are resolved to the identity function.)",
        "the determiner is the dependent or the head, we get that first the semantic representation of the adjective is applied to the one of the noun (as the modifier has to be applied before the inversion is carried out in configuration a), thus yielding the two configurations in c) and d).",
        "T",
        "e:like(x,y)",
        "(d",
        ", x,",
        "subj",
        "2 , y,obj, <<e, t) , t))",
        "_L < scope(li) < T, A.",
        "< scope(l2) < T",
        "j 1 1 1 «£,*>,*>",
        "1",
        "3",
        "John(.i)",
        "e 1 T 1 t 1",
        "T",
        "h",
        "X' e:like(i,y)",
        "3",
        "John(.i)",
        "(h",
        ",y,obj, <<e,t},t>)",
        "± < h < T, ± < scope(l2) < T",
        "In case c) we have a case of inversion, while in case d) we have a case of complementation.",
        "Overall, in both cases we yield the following DUDES:",
        "{every nice woman\\ =",
        "After a further semantic composition step (case complementation), applying {every nice woman} (from Sec. 2.2) to {John likes} (from Sec. 2.1), we yield as resulting UDRS:",
        "w | 1 | <e,t) |",
        "1:",
        "woman(w)",
        "x 1 1",
        "X",
        "x,sp«",
        "iC,{&, t)",
        ")",
        "x 1 1",
        "x | 1 | <e,t) |",
        "X",
        "h'-",
        "1",
        "nice(x)",
        "U'",
        "x,sp«",
        "iC,{&, t)",
        ")",
        "(",
        "' , x, mod,",
        "e,t»",
        "V < h",
        "I < V",
        "w | 1 | <e,t) |",
        "1",
        "woman(w)",
        "1",
        "nice(x)",
        "(",
        "' , x, mod,",
        "e,t»",
        "I < I'",
        "h h",
        "X",
        "(1'",
        "x,sp",
        "ec,(e, t) )",
        "I' < il",
        "X",
        "(1'",
        "x,sp",
        "ec,(e,£))",
        "V < ii",
        "w 1 1",
        "1",
        "w",
        "h'-",
        ", 1",
        "woman(w)",
        ", 1':",
        "nice(w)",
        "V <l,l<h",
        "woman(w)"
      ]
    }
  ]
}
