{
  "info": {
    "authors": [
      "Andreas Maletti",
      "Giorgio Satta"
    ],
    "book": "Proceedings of the 11th International Conference on Parsing Technologies (IWPT’09)",
    "id": "acl-W09-3801",
    "title": "Parsing Algorithms based on Tree Automata",
    "url": "https://aclweb.org/anthology/W09-3801",
    "year": 2009
  },
  "references": [],
  "sections": [
    {
      "text": [
        "Departament de Filologies Romaniques Universitat Rovira i Virgili, Tarragona, Spain",
        "andreas.maletti@urv.cat",
        "satta@dei.unipd.it",
        "We investigate several algorithms related to the parsing problem for weighted automata, under the assumption that the input is a string rather than a tree.",
        "This assumption is motivated by several natural language processing applications.",
        "We provide algorithms for the computation of parse-forests, best tree probability, inside probability (called partition function), and prefix probability.",
        "Our algorithms are obtained by extending to weighted tree automata the Bar-Hillel technique, as defined for context-free grammars."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Tree automata are finite-state devices that recognize tree languages, that is, sets of trees.",
        "There is a growing interest nowadays in the natural language parsing community, and especially in the area of syntax-based machine translation, for probabilistic tree automata (PTA) viewed as suitable representations of grammar models.",
        "In fact, probabilistic tree automata are generatively more powerful than probabilistic context-free grammars (PCFGs), when we consider the latter as devices that generate tree languages.",
        "This difference can be intuitively understood if we consider that a computation by a PTA uses hidden states, drawn from a finite set, that can be used to transfer information within the tree structure being recognized.",
        "As an example, in written English we can empirically observe different distributions in the expansion of so-called noun phrase (NP) nodes, in the contexts of subject and direct-object positions, respectively.",
        "This can be easily captured using some states of a PTA that keep a record of the different contexts.",
        "In contrast, PCFGs are unable to model these effects, because NP node expansion should be independent of the context in the derivation.",
        "This problem for PCFGs is usually solved by resorting to so-called parental annotations (Johnson, 1998), but this, of course, results in a different tree language, since these annotations will appear in the derived tree.",
        "Most of the theoretical work on parsing and estimation based on PTA has assumed that the input is a tree (Graehl et al., 2008), in accordance with the very definition of these devices.",
        "However, both in parsing as well as in machine translation, the input is most often represented as a string rather than a tree.",
        "When the input is a string, some trick is applied to map the problem back to the case of an input tree.",
        "As an example in the context of machine translation, assume a probabilistic tree transducer T as a translation model, and an input string w to be translated.",
        "One can then intermediately construct a tree automaton Mw that recognizes the set of all possible trees that have w as yield, with internal nodes from the input alphabet of T. This automaton Mw is further transformed into a tree transducer implementing a partial identity translation, and such a transducer is composed with T (relation composition).",
        "This is usually called the 'cascaded' approach.",
        "Such an approach can be easily applied also to parsing problems.",
        "In contrast with the cascaded approach above, which may be rather inefficient, in this paper we investigate a more direct technique for parsing strings based on weighted and probabilistic tree automata.",
        "We do this by extending to weighted tree automata the well-known Bar-Hillel construction defined for context-free grammars (Bar-Hillel et al., 1964) and for weighted context-free grammars (Nederhof and Satta, 2003).",
        "This provides an abstract framework under which several parsing algorithms can be directly derived, based on weighted tree automata.",
        "We discuss several applications of our results, including algorithms for the computation of parse-forests, best tree probability, inside probability (called partition function), and prefix probability."
      ]
    },
    {
      "heading": "2. Preliminary definitions",
      "text": [
        "Let S be a nonempty set and • be an associative binary operation on S. If S contains an element 1 such that 1 • s = s = s • 1 for every s £ S, then (S, •, 1) is a monoid.",
        "A monoid (S, •, 1) is commutative if the equation si • s2 = s2 • si holds for every s1;s2 £ S. A commutative semiring (S, +, •, 0,1) is a nonempty set S on which a binary addition + and a binary multiplication • have been defined such that the following conditions are satisfied:",
        "• • distributes over + from both sides, and",
        "• s • 0 = 0 = 0 • s for every s £ S.",
        "• Q is a finite alphabet of states,",
        "• E is a finite alphabet of input symbols,",
        "• v: Q x E x Q – S assigns a weight to each transition, and",
        "• F: Q – S assigns final weights.",
        "wtM(r) = Y\\ v(r(i - 1), w(i), r(i)) .",
        "We assume the right-hand side of the above equation evaluates to 1 in case n = 0.",
        "The WSA M recognizes the mapping M : E* – S, which is defined for every w £ E* of length n by",
        "M(w) = Yl (r(0)) • wtM(r) • F(r(n)) .",
        "In order to define weighted tree automata (Bers-tel and Reutenauer, 1982; Esik and Kuich, 2003; Borchardt, 2005), we need to introduce some additional notation.",
        "Let E be a ranked alphabet, that is, an alphabet whose symbols have an associated arity.",
        "We write Ek to denote the set of all k-ary symbols in E. We use a special symbol e £ Eo to syntactically represent the empty string e. The set of E-trees, denoted by Ts, is the smallest set satisfying both of the following conditions",
        "• for every a £ Ek with k > 1 and for every t1,..., tk £ Ts, the tree with a root node labeled a and trees t1,..., tk as its k children, written a(t1,..., tk), belongs to Ts.",
        "As a convention, throughout this paper we assume that a(t1,..., tk) denotes a() if k = 0.",
        "The size of the tree t £ Ts, written |t|, is defined as the number of occurrences of symbols from E in t.",
        "[yd(t1) • • • yd(tk) otherwise.",
        "The set of positions of t, denoted by Pos(t), is recursively defined by",
        "Pos(a(t1,... ,tk)) = {e} U {iw | 1 < i < k, w £ Pos(t,)} .",
        "Note that |t| = |Pos(t) | and, according to our convention, when k = 0 the above definition provides Pos(a()) = {e}.",
        "We denote the symbol of t at position w by t(w) and its rank by rkt(w).",
        "• E is a finite ranked alphabet of input symbols,",
        "• // is an indexed family (//k)keN of mappings /Xk :Ek – SQxQk ,and",
        "In the above definition, Qk is the set of all strings over Q having length k, with Q = {e}.",
        "Further note that SQxQ is the set of all matrices with elements in S, row index set Q, and column index set Qk.",
        "Correspondingly, we will use the common matrix notation and write instances of // in the form //k(a)q0;qi...qfc.",
        "Finally, we assume <?1 • • • qk = e if k = 0.",
        "We define the semantics also in terms of runs.",
        "Let t £ Ts.",
        "A run of M on t is a mapping r: Pos(t) – Q.",
        "We denote the set of all such runs by Ruiim (t).",
        "The weight of a run r G Ruiim (t)",
        "Note that, according to our convention, the string r(w1) ••• r(wk) denotes e when k = 0.",
        "The WTA M recognizes the mapping M: Ts – > S, which is defined by for every t G Ts.",
        "We say that t is recognized by M if M(t) = 0.",
        "In our complexity analyses, we use the following measures.",
        "The size of a transition (p, a, q) in (the domain of v in) a WSA is |paq| = 3.",
        "The size of a transition in a WTA, viewed as an instance (a, q0, q1 • • • qk) of some mapping jk, is defined as | aq0 • • • qk |, that is, the rank of the input symbol occurring in the transition plus two.",
        "Finally, the size | M| of an automaton M (WSA or WTA) is defined as the sum of the sizes of its nonzero transitions.",
        "Note that this does not take into account the size of the representation of the weights."
      ]
    },
    {
      "heading": "3. Binarization",
      "text": [
        "We introduce in this section a specific transformation of WTA, called binarization, that reduces the transitions of the automaton to some normal form in which no more than three states are involved.",
        "This transformation maps the set of recognized trees into a special binary form, in such a way that the yields of corresponding trees and their weights are both preserved.",
        "We use this transformation in the next section in order to guarantee the computational efficiency of the parsing algorithm we develop.",
        "The standard 'first-child, next-sibling' binary encoding for trees (Knuth, 1997) would eventually result in a transformed WTA of quadratic size.",
        "To obtain instead a linear size transformation, we introduce a slightly modified encoding (Hogberg et al., 2009, Section 4), which is inspired by (Carme et al., 2004) and the classical currying operation.",
        "Let £ be a ranked alphabet and assume a fresh symbol @ G £ (corresponding to the basic list concatenation operator).",
        "Moreover, let A = A2 U A1 U A0 be the ranked alphabet such that A2 = {@}, Ai = (Jk> 1 £fc,and Ao = £0.",
        "In words, all the original non-nullary symbols from £ are now unary, @ is binary, and the original nullary symbols from £ have their rank preserved.",
        "We encode each tree of Ts as a tree of Ta as follows:",
        "a(@(enc(t1),... @(enc(tk-1), enc(tk)) • • •)).",
        "An example of the above encoding is illustrated in Figure 1.",
        "Note that |enc(t)| G O(|t|) for every t G Ts.",
        "Furthermore, t can be easily reconstructed from enc(t) in linear time.",
        "F'([q]) = F(q) for every q G Q, and the transitions are constructed as follows:",
        "(iii) J2(@)[qw],[q][w] = 1 for every [qw] G P with | w| > 1 and q Q.",
        "All remaining entries in F' and J are 0.",
        "□",
        "Notice that each transition of enc(M) involves no more than three states from P. Furthermore, we have |enc(M)| G O(|M|).",
        "The following result is rather intuitive (Hogberg et al., 2009, Lemma4.2); its proof is therefore omitted."
      ]
    },
    {
      "heading": "4. Bar-Hillel construction",
      "text": [
        "The so-called Bar-Hillel construction was proposed in (Bar-Hillel et al., 1964) to show that the intersection of a context-free language and a regular language is still a context-free language.",
        "The proof of the result consisted in an effective construction of a context-free grammar Prod(G, N) from a context-free grammar G and a finite automaton N, such that Prod(G, N) generates the intersection of the languages generated by G and N.",
        "It was later recognized that the Bar-Hillel construction constitutes one of the foundations of the theory of tabular parsing based on context-free grammars.",
        "More precisely, by taking the finite automaton N to be of some special kind, accepting only a single string, the Bar-Hillel construction provides a framework under which several well-known tabular parsing algorithms can easily be derived, that were proposed much later in the literature.",
        "In this section we extend the Bar-Hillel construction to WTA, with a similar purpose of establishing an abstract framework under which one could easily derive parsing algorithms based on these devices.",
        "In order to guarantee computational efficiency, we avoid here stating the Bar-Hillel construction for WTA with alphabets of arbitrary rank.",
        "The next result therefore refers to WTA with alphabet symbols of rank at most 2.",
        "These may, but need not, be automata obtained through the binary encoding discussed in Section 3.",
        "as follows:",
        "J2(a)(po,qo,P2),(po,qi,Pl)(pi,q2,P2) = J2(a)qo,qiq2 .",
        "Figure 2: Information transport in the first and third components of the states in our Bar-Hillel construction.",
        "f v(p0 ,a,p1) if a = e 1 if = e and p0 = p1 .",
        "(iv) F'(p0,q,p1) = I(p0) • F(q) • G(p1) for every p0, p1 P and q Q.",
        "All remaining entries in // are 0. m Theorem 2 Let M and N be as in Definition 2,",
        "Proof For a state q G P x Q x P, we write qj to denote its i-th component with i G {1, 2, 3}.",
        "Let t G Ts and r G RunM/ (t) be a run of M' on t. We call the run r well-formed if for every w G Pos(t):",
        "(c) if rkt(w) = 2, then r(w1)3 = r(w2)1.",
        "Note that no conditions are placed on the second components of the states in r. We try to illustrate the conditions in Figure 2.",
        "A standard proof shows that wtM/ (r) = 0 for all runs r G RunM/ (t) that are not well-formed.",
        "We now need to map runs of M' back into 'corresponding' runs for M and N. Let us fix some t G Ts and some well-formed run r G RunM/ (t).",
        "We define the run nM (r) G RunM (t) by letting nw(r)(n) = r(w„)3 .",
        "Note that conversely every run of M on t and every run of N on yd(t) yield a unique run of M'on t.",
        "Now, we claim that = Jk(a)r(e),r(1)-r(k) ^ Y\\_ wtM/ (ri) .",
        "Using the fact that r is well-formed, commutativity, and the induction hypothesis, we obtain where in the last step we have again used the fact that r is well-formed.",
        "Using the auxiliary statement wtM/(r) = wtM(nM(r)) • wtN(n«(r)),the main proof now is easy.",
        "r€RunM/ (t) r well-formed rGRunM (t)",
        "Let us analyze now the computational complexity of a possible implementation of the construction in Definition 2.",
        "In step (i), we could restrict the computation by considering only those transitions in M satisfying J2(a)qo>qiq2 = 0, which provides a number of choices in O(|M|).",
        "Combined with the choices for the states p0, p1 , p2 of N, this provides O(|M| • |P|) non-zero transitions in Prod(M, N).",
        "This is also a bound on the overall running time of step (i).",
        "Since we additionally assume that weights can be multiplied in constant time, it is not difficult to see that all of the remaining steps can be accommodated within such a time bound.",
        "We thus conclude that the construction in Definition 2 can be implemented to run in time and space O(|M| • |P|)."
      ]
    },
    {
      "heading": "5. Parsing applications",
      "text": [
        "In this section we discuss several applications of the construction presented in Definition 2 that are relevant for parsing based on WTA models.",
        "Parsing is usually defined as the problem of constructing a suitable representation for the set of all possible parse trees that are assigned to a given input string w by some grammar model.",
        "The set of all such parse trees is called parse forest.",
        "The extension of the Bar-Hillel construction that we have presented in Section 4 can be easily adapted to obtain a parsing algorithm for WTA models.",
        "This is described in what follows.",
        "First, we should represent the input string w in a WSA that recognizes the language {w}.",
        "Such an automaton has a state set P = {p0,..., p | w |} and transition weights v(pi-1, w(i),p^ = 1 for each i with 1 < i < |w|.",
        "We also set /(p0) = 1 and F(p|w|) = 1.",
        "Setting all the weights to 1 for a WSA N amounts to ignoring the weights, i.e., those weights will not contribute in any way when applying the Bar-Hillel construction.",
        "Assume now that M is our grammar model, represented as a WTA.",
        "The WTA Prod(M, N) constructed as in Definition 2 is not necessarily trim, meaning that it might contain transitions with non-zero weight that are never used in the recognition.",
        "Techniques for eliminating such useless transitions are well-known, see for instance (Gecseg and Steinby, 1984, Section II.6), and can be easily implemented to run in linear time.",
        "once Prod(M, N) is trim, we have a device that recognizes all and only those trees that are assigned by M to the input string w, and the weights of those trees are preserved, as seen in Theorem 2.",
        "The WTA Prod(M, N) can then be seen as a representation of a parse forest for the input string w, and we conclude that the construction in Definition 2, combined with some WTA reduction algorithm, represents a parsing algorithm for WTA models working in cubic time on the length of the input string and in linear time on the size of the grammar model.",
        "More interestingly, from the framework developed in Section 4, one can also design more efficient parsing algorithms based on WTA.",
        "Borrowing from standard ideas developed in the literature for parsing based on context-free grammars, one can specialize the construction in Definition 2 in such a way that the number of useless transitions generated for Prod(M, N) is considerably reduced, resulting in a more efficient construction.",
        "This can be done by adopting some search strategy that guides the construction of Prod(M, N) using knowledge of the input string w as well as knowledge about the source model M.",
        "As an example, we can apply step (i) only on demand, that is, we process a transition j2(a)qo,qiq2in Prod(M, N) only if we have already computed non-zero transitions of the form //ki (a1)qi;Wi and Jk2(a2)q2,w2, for some a1 G £ki, w1 G Qki and a2 £k2, w2 Qk2 where Q is the state set of Prod(M, N).",
        "The above amounts to a bottom-up strategy that is also used in the Cocke-Kasami-Younger recognition algorithm for context-free grammars (Younger, 1967).",
        "More sophisticated strategies are also possible.",
        "For instance, one could adopt the Earley strategy developed for context-free grammar parsing (Ear-ley, 1970).",
        "In this case, parsing is carried out in a top-down left-to-right fashion, and the binarization construction of Section 3 is carried out on the flight.",
        "This has the additional advantage that it would be possible to use WTA models that are not restricted to the special normal form of Section 3, still maintaining the cubic time complexity in the length of the input string.",
        "We do not pursue this idea any further in this paper, since our main goal here is to outline an abstract framework for parsing based on WTA models.",
        "Let us now look into specific semirings that are relevant for statistical natural language processing.",
        "The semiring of non-negative real numbers is R>0 = (R>0, +, •, 0,1).",
        "For the remainder of the section, let M = (Q, £, R>0, J, F) be a WTA over R>0.",
        "M is convergent if",
        "M(t) < oo.",
        "We say that M is a probabilistic tree automaton (Ellis, 1971; Magidor and Moran, 1970), or PTA for short, if Jk(a)q,qi...qfc G [0,1] and F(q) [0, 1], for every a £k and q, q1,..., qk G Q.",
        "In other words, in a PTA all weights are in the range [0, 1] and can be interpreted as probabilities.",
        "For a PTA M we therefore write pM(r) = wt(r) and pM(t) = M(t), for each t G Ts and r G RunM (t).",
        "for every q G Q.",
        "Since the set of symbols is finite, we could have only required that the sum over all weights as shown with w Qk equals 1 for every q Q and a £ k. A simple rescaling would then be sufficient to arrive at our notion.",
        "Furthermore, a PTA is consistent if ^teTs pM (t) = 1.",
        "If a PTA is consistent, then pM is a probability distribution over the set Ts.",
        "The WTA M is unambiguous if for every input tree t G Ts, there exists at most one r G RunM (t) such that r(e) G F and wtM(r) = 0.",
        "In other words, in an unambiguous WTA, there exists at most one successful run for each input tree.",
        "Finally, M is in final-state normal form if there exists a state qs G Q such that",
        "• Jk(<7)q,w = 0 if w(i) = qs for some 1 < i < k.",
        "We commonly denote the unique final state by qs.",
        "For the following result we refer the reader to (Droste et al., 2005, Lemma 4.8) and (Bozapa-lidis, 1999, Lemma 22).",
        "The additional properties mentioned in the items of it are easily seen.",
        "Theorem 3 For every WTA M there exists an equivalent WTA M' in final-state normal form.",
        "• If M is convergent (respectively, proper, consistent), then M' is such, too.",
        "• If M is unambiguous, then M' is also unambiguous and for every t G Ts and r G RunM (t) we have wtM'(r') = wtM(r) • F(r(e)) where r'(e) = qs and r'(w) = r(w) for every w G Pos(t) \\ {e}.",
        "□",
        "It is not difficult to see that a proper PTA in final-state normal form is always convergent.",
        "In statistical parsing applications we use grammar models that induce a probability distribution on the set of parse trees.",
        "In these applications, there is often the need to visit a parse tree with highest probability, among those in the parse forest obtained from the input sentence.",
        "This implements a form of disambiguation, where the most likely tree under the given model is selected, pretending that it provides the most likely syntactic analysis of the input string.",
        "In our setting, the above approach reduces to the problem of 'unfolding' a tree from a PTA Prod(M, N), that is assigned the highest probability.",
        "In order to find efficient solutions for the above problem, we make the following two assumptions.",
        "• M is in final-state normal form.",
        "By Theorem 3 this can be achieved without loss of generality.",
        "• M is unambiguous.",
        "This restrictive assumption avoids the so-called 'spurious' ambiguity, that would result in several computations in the model for an individual parse tree.",
        "It is not difficult to see that PTA satisfying these",
        "l: Function BestParse(M) 3: repeat",
        "S: until qs E 9: return 5(qs)",
        "Figure 3: Search algorithm for the most probable parse in an unambiguous PTA M in final-state normal form.",
        "two properties are still more powerful than the probabilistic context-free grammar models that are commonly used in statistical natural language processing.",
        "Once more, we borrow from the literature on parsing for context-free grammars, and adapt a search algorithm developed by Knuth (1977); see also (Nederhof, 2003).",
        "The basic idea here is to generalize Dijkstra's algorithm to compute the shortest path in a weighted graph.",
        "The search algorithm is presented in Figure 3.",
        "The algorithm takes as input a trim PTA M that recognizes at least one parse tree.",
        "We do not impose any bound on the rank of the alphabet symbols for M. Furthermore, M needs not be a proper PTA.",
        "In order to simplify the presentation, we provide the algorithm in a form that returns the largest probability assigned to some tree by M.",
        "The algorithm records into the S(q) variables the largest probability found so far for a run that brings M into state q, and stores these states into an agenda A.",
        "States for which S(q) becomes optimal are popped from A and stored into a set E. Choices are made on a greedy base.",
        "Note that when a run has been found leading to an optimal probability S(q), from our assumption we know that the associated tree has only one run that ends up in state q.",
        "Since E is initially empty (line 2), only weights satisfying /Jo (c)q,e > 0 are considered when line 4 is executed for the first time.",
        "Later on (line 7) the largest probability is selected among all those that can be computed at this time, and the set E is populated.",
        "As a consequence, more states become available in the agenda in the next iteration, and new transitions can now be considered.",
        "The algorithm ends when the largest probability has been calculated for the unique final state qs.",
        "We now analyze the computational complexity of the algorithm in Figure 3.",
        "The 'repeat-until' loop runs at most |Q| times.",
        "Entirely reprocessing set A at each iteration would be too expensive.",
        "We instead implement A as a priority heap and maintain a clock for each weight Jk(a)q,qi...qk, initially set to k. Whenever a new optimal probability £(q) becomes available through E, we decrement the clock associated with each /jk(a)q,qi...qkby d, in case d > 0 occurrences of q are found in the string qi • • • qk.",
        "In this way, at each iteration of the 'repeat-until' loop, we can consider only those weights /Jk(a)q,qi-.qk with associated clock of zero, compute new values £(q), and update the heap.",
        "For each Jk(a)q,q1-qk all clock updates and the computation of quantity Jk(a)q,qv..qk IIki=1 <%) (when the associated clock becomes zero) both take an amount of time proportional to the length of the transition itself.",
        "The overall time to execute these operations is therefore linear in | M| .",
        "Accounting for the heap, the algorithm has overall running time in O(|M| + |Q| log|Q|).",
        "The algorithm can be easily adapted to return a tree having probability £(qs), if we keep a record of all transitions selected in the computation along with links from a selected transition and all of the previously selected transitions that have caused its selection.",
        "If we drop the unambiguity assumption for the PTA, then the problem of computing the best parse tree becomes NP-hard, through a reduction from similar problems for finite automata (Casacuberta and de la Higuera, 2000).",
        "In contrast, the problem of computing the probability of all parse trees of a string, also called the inside probability, can be solved in polynomial time in most practical cases and will be addressed in Subsection 5.4.",
        "Consider the WTA Prod(M, N) obtained as in Definition 2.",
        "If N is a WSA encoding an input string w as in Subsection 5.1 and if M is a proper and consistent PTA, then Prod(M, N) is a PTA as well.",
        "However, in general Prod(M, N) will not be proper, nor consistent.",
        "Properness and consistency of Prod(M, N) are convenient in all those applications where a statistical parsing module needs to be coupled with other statistical modules, in such a way that the composition of the probability spaces still induces a probability distribution.",
        "In this subsection we deal with the more general problem of how to transform a WTA that is convergent into a PTA that is proper and consistent.",
        "This process is called normalization.",
        "The normalization technique we propose here has been previously explored, in the context of probabilistic context-free grammars, in (Abney et al., 1999; Chi, 1999; Nederhof and Satta, 2003).",
        "We start by introducing some new notions.",
        "Let us assume that M is a convergent WTA.",
        "For every q G Q, we define wtM (q) = ^ wtM (r) .",
        "Note that quantity wtM(q) equals the sum of the weights of all trees in Ts that would be recognized by M if we set F(q) = 1 and F(p) = 0 for each P G Q \\ {q}, that is, if q is the unique final state of M. It is not difficult to show that, since M is convergent, the sum in the definition of wtM(q) converges for each q Q.",
        "We will show in Subsection 5.4 that the quantities wtM(q) can be approximated to any desired precision.",
        "To simplify the presentation, and without any loss of generality, throughout this subsection we assume that our WTA are in final-state normal form.",
        "We can now introduce the normalization technique.",
        "Definition 3 Let M = (Q, E, r>o, F) be a convergent WTA in final-state normal form.",
        "We construct the WTA",
        "We now show the claimed property for our transformation.",
        "Theorem 4 Let M be as in Definition 3, and let M' = Norm(M).",
        "Then M' is a proper and consistent PTA, and for every t G Ts we have",
        "PROOF Clearly, M is again in final-state normal form.",
        "An easy derivation shows that for every q G Q.",
        "Using the previous remark, we obtain",
        "Y Jk (a)q,qi-qk ]J wtM(qi)",
        "which proves that M' is a proper PTA.",
        "wePos(t) wtM (ri)wtM (rk)",
        "Consequently,",
        "reRunM'(t) reRunM (t) teTE teTE,reRunM'(t) teTE,reRunM (t)",
        "which prove the main statement and the consistency of Mrespectively.",
        "■",
        "Assume M is a convergent WTA.",
        "We have defined quantities wtM(q) for each q G Q.",
        "Note that when M is a proper PTA in final-state normal form, then wtM(q) can be seen as the probability mass that 'rests' on state q.",
        "When dealing with such PTA, we use the notation ZM (q) in place of wtM(q), and call ZM the partition function of M. This terminology is borrowed from the literature on exponential or Gibbs probabilistic models.",
        "In the context of probabilistic context-free grammars, the computation of the partition function has several applications, including the elimination of epsilon rules (Abney et al., 1999) and the computation of probabilistic distances between probability distributions realized by these formalisms (Nederhof and Satta, 2008).",
        "Besides what we have seen in Subsection 5.3, we will provide one more application of partition functions for the computations of so-called prefix probabilities in Subsection 5.5 We also add that, when computed on the Bar-Hillel automata of Section 4, the partition function provides the so-called inside probabilities of (Graehl et al., 2008) for the given states and substrings.",
        "Let |Q| = n and let us assume an arbitrary ordering q1;..., qn for the states in Q.",
        "We can then rewrite the definition of wtM(q) as",
        "wtM (q) = Y Jk (a)q,qii -qik II (qij )",
        "system of n nonlinear polynomial equations of the form",
        "CTGSfc ,k>0",
        "for each i with 1 < i < n.",
        "Throughout this subsection, we will consider solutions of the above system in the extended nonnegative real number semiring with the usual operations extended to oo.",
        "We can write the system in (1) in the compact form X = F (X), where we represent the unknowns as a vector X = (Xqi, • • •, Xqn) and F is a mapping of type (Eg0)n – (Eg0)n consisting of the polynomials fqi (X).",
        "We denote the vector (0, • • •, 0) e (Eg0)n as X.",
        "Let X, X' e (Eg0)n. We write X < X' if Xqi < X^i for every 1 < i < n. Since each polynomial fqi (X) has coefficients represented by positive real numbers, it is not difficult to see that, for each X, X' e (Eg0)n, we have F(X) < F(X') whenever X < X < XThis means that F is an order preserving, or monotone, mapping.",
        "We observe that ((Eg0)n, <) is a complete lattice with least element X and greatest element ( o , • • • , o ) .",
        "Since F is monotone on a complete lattice, by the Knaster-Tarski theorem (Knaster, 1928; Tarski, 1955) there exists a least and a greatest fixed-point of F that are solutions ofX = F(X).",
        "The Kleene theorem states that the least fixed-point solution of X = F (X) can be obtained by iterating F starting with the least element X.",
        "In other words, the sequence Xk = F(Xk-), k = 1,2, • • • converges to the least fixed-point solution.",
        "Notice that each Xk provides an approximation for the partition function of M where only trees of depth not larger than k are considered.",
        "This means that limk^g Xk converges to the partition function of M, and the least fixed-point solution is also the sought solution.",
        "Thus, we can approximate wtM (q) with q e Q to any degree by iterating F a sufficiently large number of times.",
        "The fixed-point iteration method discussed above is also well-known in the numerical calculus literature, and is frequently applied to systems of nonlinear equations in general, because it can be easily implemented.",
        "When a number of standard conditions are met, each iteration of the algorithm (corresponding to the value ofk above) adds a fixed number of bits to the precision of the approximated solution; see (Kelley, 1995) for further discussion.",
        "Systems of the form X = F (X) where all fqi (X) are polynomials with nonnegative real coefficients are called monotone system of polynomials.",
        "Monotone systems of polynomials associated with proper PTA have been specifically investigated in (Etessami and Yannakakis, 2005) and (Kiefer et al., 2007), where worst case results on exponential rate of convergence are reported for the fixed-point method.",
        "In this subsection we deal with one more application of the Bar-Hillel technique presented in Section 4.",
        "We show how to compute the so-called prefix probabilities, that is, the probability that a tree recognized by a PTA generates a string starting with a given prefix.",
        "Such probabilities have several applications in language modeling.",
        "As an example, prefix probabilities can be used to compute the probability distribution on the terminal symbol that follows a given prefix (under the given model).",
        "For probabilistic context-free grammars, the problem of the computation of prefix probabilities has been solved in (Jelinek et al., 1992); see also (Persoon and Fu, 1975).",
        "The approach we propose here, originally formulated for probabilistic context-free grammars in (Nederhof and Satta, 2003; Nederhof and Satta, 2009), is more abstract than the previous ones, since it entirely rests on properties of the Bar-Hillel construction that we have already proved in Section 4.",
        "Let M = (Q, E, E>0,/j,F) be a proper and consistent PTA in final-state normal form, A = E0 \\ {e}, and let u e A+ be some string.",
        "We assume here that M is in the binary form discussed in Section 3.",
        "In addition, we assume that M has been preprocessed in order to remove from its recognized trees all of the unary branches as well as those branches that generate the null string e. Although we do not discuss this construction at length in this paper, the result follows from a transformation casting weighted context-free grammars into Chomsky Normal Form (Fu yd(t) = uv, v e A*} .",
        "The prefix probability of u under M is defined as",
        "Let |u| = n. We define a WSA Nu with state set P = {p0,...,pn} and transition weights v(pj_i,u(i),pj) = 1 for each i with 1 < i < n, and v(pn,CT,pra) = 1 for each a e A.",
        "We also set I(p0) = 1 and F(pn) = 1.",
        "It is easy to see that Nu recognizes the language {uv | v e A*}.",
        "Furthermore, the PTA Mp = Prod(M, Nu) specified as in Definition 2 recognizes the desired tree set Pref(M, u), and it preserves the weights of those trees with respect to M. We therefore conclude that ZMp (qS) is the prefix probability of u under M. Prefix probabilities can then be approximated using the fixed-point iteration method of Subsection 5.4.",
        "Rather than using an approximation method, we discuss in what follows how the prefix probabilities can be exactly computed.",
        "Let us consider more closely the product automaton Mp, assuming that it is trim.",
        "Each state of Mp has the form n = (pj, q, pj), pi; pj e P and q e Q, with i < j.",
        "We distinguish three, mutually exclusive cases.",
        "(i) j < n: From our assumption that M (and thus Mp) does not have unary or e branches, it is not difficult to see that all ZMp (n) can be exactly computed in time – i)).",
        "(ii) i = j = n: We have n = (pra,q,pra).",
        "Then the equations for ZMp (n) exactly mirror the equations for ZM (q), and Zmp (n) = Zmp (q).",
        "Because M is proper and consistent, this means that ZMp (n) = 1.",
        "(iii) i < j = n: A close inspection of Definition 2 reveals that in this case the equations (1) are all linear, assuming that we have already replaced the solutions from (i) and (ii) above into the system.",
        "This is because any weight",
        "> 0 in Mp with n = (pi; q,p„) and i < n must have (n1)3 < n. Quantities ZMp (n) can then be exactly computed as the solution of a linear system of equations in time O(n).",
        "Putting together all of the observations above, we obtain that for a proper and consistent PTA that has been preprocessed, the prefix probability of u can be computed in cubic time in the length of the prefix itself."
      ]
    },
    {
      "heading": "6. Concluding remarks",
      "text": [
        "In this paper we have extended the Bar-Hillel construction to WTA, closely following the methodology proposed in (Nederhof and Satta, 2003) for weighted context-free grammars.",
        "Based on the obtained framework, we have derived several parsing algorithms for WTA, under the assumption that the input is a string rather than a tree.",
        "As already remarked in the introduction, WTA are richer models than weighted context-free grammar, since the formers use hidden states in the recognition of trees.",
        "This feature makes it possible to define a product automaton in Definition 2 that generates exactly those trees of interest for the input string.",
        "In contrast, in the context-free grammar case the Bar-Hillel technique provides trees that must be mapped to the tree of interest using some homomorphism.",
        "For the same reason, one cannot directly convert WTA into weighted context-free grammars and then apply existing parsing algorithms for the latter formalism, unless the alphabet of nonterminal symbols is changed.",
        "Finally, our main motivation in developing a framework specifically based on WTA is that this can be extended to classes of weighted tree transducers, in order to deal with computational problems that arise in machine translation applications.",
        "We leave this for future work."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "The first author has been supported by the Minis-terio de Education y Ciencia (MEC) under grant JDCI-2007-760.",
        "The second author has been partially supported by MIUR under project PRIN No.",
        "2007TJNZRE002."
      ]
    }
  ]
}
