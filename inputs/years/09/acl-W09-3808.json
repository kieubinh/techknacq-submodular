{
  "info": {
    "authors": [
      "Laura Kallmeyer",
      "Wolfgang Maier"
    ],
    "book": "Proceedings of the 11th International Conference on Parsing Technologies (IWPT’09)",
    "id": "acl-W09-3808",
    "title": "An Incremental Earley Parser for Simple Range Concatenation Grammar",
    "url": "https://aclweb.org/anthology/W09-3808",
    "year": 2009
  },
  "references": [],
  "sections": [
    {
      "text": [
        "Laura Kallmeyer and Wolfgang Maier",
        "Collaborative Research Center 833 University of Tübingen Tübingen, Germany {lk,wmaier}@sfs.uni-tuebingen.de",
        "We present an Earley-style parser for simple range concatenation grammar, a formalism strongly equivalent to linear context-free rewriting systems.",
        "Furthermore, we present different filters which reduce the number of items in the parsing chart.",
        "An implementation shows that parses can be obtained in a reasonable time."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Linear context-free rewriting systems (LCFRS) (Vijay-Shanker et al., 1987), the equivalent multiple context-free grammars (MCFG) (Seki et al., 1991) and simple range concatenation grammars (sRCG) (Boullier, 1998) have recently attracted an increasing interest in the context of natural language processing.",
        "For example, Maier and Sogaard (2008) propose to extract simple RCGs from constituency treebanks with crossing branches while Kuhlmann and Satta (2009) propose to extract LCFRS from non-projective dependency treebanks.",
        "Another application area of this class of formalisms is biological computing (Kato etal.,2006).",
        "This paper addresses the symbolic parsing of sRCG/LCFRS.",
        "Starting from the parsing algorithms presented in Burden and Ljunglof (2005) and Villemonte de la Clergerie (2002), we propose an incremental Earley algorithm for simple RCG.",
        "The strategy is roughly like the one pursued in Villemonte de la Clergerie (2002).",
        "However, instead of the automaton-based formalization in Villemonte de la Clergerie's work, we give a general formulation of an incremental Earley algorithm, using the framework of parsing as deduction.",
        "In order to reduce the search space, we introduce different types of filters on our items.",
        "We have implemented this algorithm and tested it on simple RCGs extracted from the German treebanks Negra and Tiger.",
        "In the following section, we introduce simple RCG and in section 3, we present an algorithm for symbolic parsing of simple RCG.",
        "Section 4 then presents different filtering techniques to reduce the number of items.",
        "We close discussing future work."
      ]
    },
    {
      "heading": "2. Grammar Formalism",
      "text": [
        "A range concatenation grammar (RCG) is a 5tuple G = (N, T, V, P,S).",
        "N is a finite set of nonterminals (predicate names) with an arity function dim: N – N+, T and V are disjoint finite sets of terminals and variables.",
        "P is a finite set of clauses of the form ip0 – V • • • Vm, where m > 0 and each of the tpi, 0 < i < m, is a predicate of the form Ai(a1, adim {A)).",
        "Each aj e (T U V )*, 1 < j < dim (A) and 0 < i < k, is an argument.",
        "As a shorthand notation for Ai(a1, • • •, adim(a)), we use Ai(a).",
        "S e N is the start predicate name with dim(S) = 1.",
        "Note that the order of right-hand side (RHS) predicates in a clause is of no importance.",
        "Subclasses of RCGs are introduced for further reference: An RCG G = (N, T, V, P, S) is simple if for all c e P, it holds that every variable",
        "X occurring in c occurs exactly once in the left-hand side (LHS) and exactly once in the RHS, and each argument in the RHS of c contains exactly one variable.",
        "A simple RCG is ordered if for all V0 – V1 • • • Vm e P, it holds that if a variable X1precedes a variable X2 in a Vi, 1 < i < m, then",
        "XI also precedes X2 in ip0.",
        "The ordering requirement does not change the expressive power, i.e., ordered simple RCG is equivalent to simple RCG (Villemonte de la Clergerie, 2002).",
        "An RCG is e-free if it either contains no e-rules or there is exactly one rule S (e) and S does not appear in any of the righthand sides of the rules in the grammar.",
        "A rule is an e-rule if one of the arguments of the lefthand side is the empty string e. (Boul-lier, 1998) shows that for every simple RCG, one can construct an equivalent e-free simple RCG.",
        "An RCG G = (N, T, V, P, S) is a k-RCG if for all",
        "A G N, dim (A) < k.",
        "The language of RCGs is based on the notion of range.",
        "For a string w1 • • • wn a range is a pair of indices with 0 < i < j < n, i.e., a string span, which denotes a substring wi+1 • • • Wj in the source string or a substring vi+1 • • • Vj in the target string.",
        "Only consecutive ranges can be concatenated into new ranges.",
        "Terminals, variables and arguments in a clause are bound to ranges by a substitution mechanism.",
        "An instantiated clause is a clause in which variables and arguments are consistently replaced by ranges; its components are instantiated predicates.",
        "For example A((g • • • h)) – B((g + 1 • • • h)) is an instantiation of the clause A(aX1) – B(X1) if the target string is such that wg+1 = a.",
        "A derive relation => is defined on strings of instantiated predicates.",
        "If an instantiated predicate is the LHS of some instantiated clause, it can be replaced by the RHS of that instantiated clause.",
        "The language of an RCG G = (N, T, V, P, S) is the set L(G) = {w1 • • • wn | S((0, n)) 4> e}, i.e., an input string w1 • • • wn is recognized if and only if the empty string can be derived from S((0, n)).",
        "In this paper, we are dealing only with ordered simple RCGs.",
        "The ordering requirement does not change the expressive power (Villemonte de la Clergerie, 2002).",
        "Furthermore, without loss of generality, we assume that for every clause, there is a k > 0 such that the variables occurring in the clause are exactly X1, ...,Xfc.",
        "We define derivation trees for simple RCGs as unordered trees whose internal nodes are labelled with predicate names and whose leaves are labelled with ranges such that all internal nodes are licensed by RCG clause instantiations: given a simple RCG G and a string w, a tree D = (V, E, r) is a derivation tree of w = a1... aniff 1. there are exactly n leaves in D labelled (0,1),..., (n – 1, n) and 2. for all v0 G V with v1,..., vn G V, n > 1 being all vertices with (v0, vi ) G E (1 < i < n) such that the leftmost range dominated by Vj precedes the leftmost range dominated by vj+1 (1 < i < n): there is a clause instantiation Ao(p0) – A1 (p1 ) ...An(pn) such that a) Z(vj) = Ai for 0 < i < n and b) the yield of the leaves dominates by vi is pj."
      ]
    },
    {
      "heading": "3. Parsing",
      "text": [
        "Our parsing algorithm is a modification of the \"incremental algorithm\" of Burden and Ljunglof (2005) with a strategy very similar to the strategy adopted by Thread Automata (Villemonte de la Clergerie, 2002).",
        "It assumes the grammar to be ordered and e-free.",
        "We refrain from supporting non-e-free grammars since the treebank grammars used with our implementation are all e-free.",
        "However, note that only minor modifications would be necessary in order to support non-e-free grammars (see below).",
        "We process the arguments of LHS of clauses incrementally, starting from an S-clause.",
        "Whenever we reach a variable, we move into the clause of the corresponding RHS predicate (predict or resume).",
        "Whenever we reach the end of an argument, we suspend this clause and move into the parent clause that has called the current one.",
        "In addition, we treat the case where we reach the end of the last argument and move into the parent as a special case.",
        "Here, we first convert the item into a passive one and then complete the parent item with this passive item.",
        "This allows for some additional factorization.",
        "The item form for passive items is [A, p] where A a predicate of some arity k, p is a range vector of arity k. The item form for active items: [A((/>) – A1(<p1)... Am(0m),pos, (i, j), p] where A((() – A1(01)... Am(0m) G P; pos G {0,..., n} is the position up to which we have processed the input; (i, j) G N marks the position of our dot in the arguments of the predicate A: ( i, j) indicates that we have processed the arguments up to the jth element of the ith argument; p is an range vector containing the bindings of the variables and terminals occurring in the lefthand side of the clause (p(i) is the range the ith element is bound to).",
        "When first predicting a clause, it is initialized with a vector containing only symbols \"?\"",
        "for \"unknown\".",
        "We call such a vector (of appropriate arity) pinit.",
        "We introduce an additional piece of notation.",
        "We write p(X) for the range bound to the variable X in p. Furthermore, we write p((i, j )) for the range bound to the jth element in the ith argument of the clause lefthand side.",
        "Applying a range vector p containing variable bindings for a given clause c to the argument vector of the lefthand side of c means mapping the ith element in the arguments to p(i) and concatenating adjacent ranges.",
        "The result is defined iff every",
        "argument is thereby mapped to a range.",
        "We start by predicting the S-predicate:",
        "is the next terminal in the input, we can scan it:",
        "where p is p updated with p(i,j + 1) = (pos,pos + 1).",
        "In order to support e-free grammars, one would need to store the pair of indices a e is mapped to in the range vector, along with the mappings of terminals and variables.",
        "The indices could be obtained through a Scan-e operation, parallel to the Scan operation.",
        "Predict: Whenever our dot is left of a variable that is the first argument of some RHS predicate B, we predict new B-clauses:",
        "■ B(X,...)."
      ]
    },
    {
      "heading": "5. p init\\",
      "text": [
        "with the side condition 0(i, j + 1) = X, B(■0) – p G P.",
        "Suspend: Whenever we arrive at the end of an argument that is not the last argument, we suspend the processing of this clause and we go back to the item that was used to predict it.",
        "where the dot in the antecedent A-item precedes the variable p(i), |0= j (the ith argument has length j and has therefore been completely processed), |0| < i (the ith argument is not the last argument of B), pB(0(i)) = (pos,pos') and for all 1 < m < i: pB(0(m)) = pA(p(m)).",
        "p is pA updated with pA(p(i)) = (pos,pos').",
        "Convert: Whenever we arrive at the end of the last argument, we convert the item into a passive one:",
        "Complete: Whenever we have a passive B item we can use it to move the dot over the variable of the last argument of B in a parent A-clause that was used to predict it.",
        "PA(p(m)).",
        "p is pA updated with pA(p(|pB|)) = (pos,pos').",
        "Resume: Whenever we are left of a variable that is not the first argument of one of the RHS predicates, we resume the clause ofthe RHS predicate.",
        "pA(p(m)) = pB(0)(m) for all 1 < m < k – 1.",
        "The goal item has the form [S, (0, n)].",
        "Note that, in contrast to a purely bottom-up CYK algorithm, the Earley algorithm presented here is prefix valid, provided that the grammar does not contain useless symbols."
      ]
    },
    {
      "heading": "4. Filters",
      "text": [
        "During parsing, various optimizations known from (P)CFG parsing can be applied.",
        "More concretely, because of the particular form of our simple RCGs, we can use several filters to reject items very early that cannot lead to a valid parse tree for a given input w = w1 • • • wn.",
        "Since our grammars are e-free, we know that each variable or occurrence of a terminal in the clause must cover at least one terminal in the input.",
        "Furthermore, since separations between arguments are generated only in cases where between two terminals belonging to the yield of a non-terminal, there is at least one other terminals that is not part of the yield, we know that between different arguments of a predicate, there must be at least one terminal in the input.",
        "Consequently, we obtain as a filtering condition on the validity of an active item that the length of the remaining input must be greater or equal to the number of variables and terminal occurrences plus the number of argument separations to the right of the dot in the left-hand side of the clause.",
        "More formally, an active item [A(0) – A1 (01) • • • Am(0m),pos, (i,j),p] satisfies the length filter iff",
        "The length filter is applied to results of predict, resume, suspend and complete.",
        "A second filter, first proposed in Klein and Manning (2003), checks for the presence of required preterminals.",
        "In our case, we assume the preterminals to be treated as terminals, so this filter amounts to checking for the presence of all terminals in the predicted part of a clause (the part to the right of the dot) in the remaining input.",
        "Furthermore, we check that the terminals appear in the predicted order and that the distance between two of them is at least the number of variables/terminals and argument separations in between.",
        "In other words, an active item [A(0) – Ai(0i) • • • Am(0m),pos, (i, j),p] satisfies the terminal filter iff we can find an injective mapping /t : Term = {(k,1) | 0(k)(1) e T and either k > i or (k = i and l > j)} – {pos + 1, • • •, n} such that",
        "3. for all (k1(k2,12) e Term with k1 < k2: /t((k2,12)) > /t((ki, + (|0(ki)| – 1i) + Ek=\"fc;+i |0(k)| + 12 + (k2 – ki).",
        "Checking this filter amounts to a linear traversal of the part of the lefthand side of the clause that is to the right of the dot.",
        "We start with index i = pos + 1 , for every variable or gap we increment i by 1.",
        "For every terminal a, we search the next a in the input, starting at position i.",
        "If it occurs at position j, then we set i = j and continue our traversal ofthe remaining parts ofthe lefthand side of the clause.",
        "The preterminal filter is applied to results of the predict and resume operations.",
        "We have implemented the incremental Earley parser with the filtering conditions on items.",
        "In order to test it, we have extracted simple RCGs from the first 1000 sentences of Negra and Tiger (with removed punctuation) using the algorithm described in Maier and Sogaard (2008) and parsed the sentences 1001-1100 with it.",
        "The grammars contained 2474 clauses (Negra) and 2554 clauses (Tiger).",
        "The following table contains the total number of sentences for different length and resp.",
        "the number of sentences for which a parse was found, along with the average parsing times of those that had a parse:"
      ]
    },
    {
      "heading": "5. Conclusion and Future Work",
      "text": [
        "We have presented an Earley-style algorithm for simple range concatenation grammar, formulated as deduction system.",
        "Furthermore, we have presented a set of filters on the chart reducing the number of items.",
        "An implementation and a test with grammars extracted from treebanks showed that reasonable parsing times can be achieved.",
        "We are currently working on a probabilistic k-best extension of our parser which resumes comparable work for PCFG (Huang and Chiang, 2005).",
        "Unfortunately, experiments with the Ear-ley algorithm have shown that with grammars of a reasonable size for data-driven parsing (> 15,000 clauses), an exhaustive parsing is no longer efficient, due to the highly ambiguous grammars.",
        "Algorithms using only passive items seem more promising in this context since they facilitate the application of A* parsing techniques.",
        "Negra",
        "Tiger",
        "parse/tot av.",
        "t.",
        "parse/tot",
        "av.",
        "t.",
        "|w| < 20",
        "73/84 0.40 sec. 50/79",
        "0.32",
        "20 <",
        "\\w\\ < 35",
        "14/16 2.14 sec. 10/19",
        "2.16"
      ]
    }
  ]
}
