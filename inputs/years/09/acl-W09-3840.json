{
  "info": {
    "authors": [
      "Guillaume Bonfante",
      "Bruno Guillaume",
      "Mathieu Morey"
    ],
    "book": "Proceedings of the 11th International Conference on Parsing Technologies (IWPT’09)",
    "id": "acl-W09-3840",
    "title": "Dependency Constraints for Lexical Disambiguation",
    "url": "https://aclweb.org/anthology/W09-3840",
    "year": 2009
  },
  "references": [],
  "sections": [
    {
      "text": [
        "LORIA INPL",
        "guillaume.bonfante@loria.fr",
        "LORIA INRIA",
        "bruno.guillaume@loria.fr",
        "Mathieu Morey LORIA Nancy-Universite",
        "mathieu.morey@loria.fr",
        "We propose a generic method to perform lexical disambiguation in lexicalized grammatical formalisms.",
        "It relies on dependency constraints between words.",
        "The soundness of the method is due to invariant properties of the parsing in a given grammar that can be computed statically from the grammar."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "In this work, we propose a method of lexical disambiguation based on the notion of dependencies.",
        "In modern linguistics, Lucien Tesniere developed a formal and sophisticated theory with dependencies (Tesniere, 1959).",
        "Nowadays, many current grammatical formalisms rely more or less explicitly on the notion of dependencies between words.",
        "The most straightforward examples are formalisms in the Dependency Grammars family but it is also true of the phrase structure based formalisms which consider that words introduce incomplete syntactic structures which must be completed by other words.",
        "This idea is at the core of Categorial Grammars (CG) (Lambek, 1958) and all its trends such as Abstract Categorial Grammars (ACG) (de Groote, 2001) or Combinatory Categorial Grammars (CCG) (Steedman, 2000), being mostly encoded in their type system.",
        "Dependencies in CG were studied in (Moortgat and Morrill, 1991) and for CCG in (Clark et al., 2002; Koller and Kuhlmann, 2009).",
        "Other formalisms can be viewed as modeling and using dependencies, such as Tree Adjoining Grammars (TAG) (Joshi, 1987) with their substitution and adjunction operations.",
        "Dependencies for TAG were studied in (Joshi and Rambow, 2003).",
        "More recently, Marchand et al.",
        "(2009) showed that it is also possible to extract a dependency structure from a syntactic analysis in Interaction Grammars (IG) (Guillaume and Perrier, 2008).",
        "Another much more recent concept of polarity can be used in grammatical formalisms to express that words introduce incomplete syntactic structures.",
        "IG directly use polarities to describe these structures but it is also possible to use polarities in other formalisms in order to make explicit the more or less implicit notion of incomplete structures: for instance, in CG (Lamarche, 2008) or in TAG (Kahane, 2006; Bonfante et al., 2004; Gardent and Kow, 2005).",
        "On this regard, Marchand et al.",
        "(2009) exhibited a direct link between polarities and dependencies.",
        "This encourages us to say that in many respects dependencies and polarities are two sides of the same coin.",
        "The aim of this paper is to show that dependencies can be used to express constraints on the tag-gings of a sentence and hence these dependency constraints can be used to partially disambiguate the words of a sentence.",
        "We will see that, in practice, using the link between dependencies and polarities, these dependency constraints can be computed directly from polarized structures.",
        "Exploiting the dependencies encoded in lexical entries to perform disambiguation is the intuition behind supertagging (Bangalore and Joshi, 1999), a method introduced for LTAG and successfully applied since then to CCG (Clark and Curran, 2004) and HPSG (Ninomiya et al., 2006).",
        "These approaches select the most likely lexical entry (entries) for each word, based on Hidden Markov Models or Maximum Entropy Models.",
        "Like the work done by Boullier (2003), our method is not based on statistics nor heuristics, but on a necessary condition of the deep parsing.",
        "Consequently, we accept to have more than one lexical tagging for a sentence, as long as we can ensure to have the good ones (when they exist!).",
        "This property is particulary useful to ensure that the deep parsing will not fail because of an error at the disambiguation step.",
        "In wide-coverage lexicalized grammars, a word typically has about 10 corresponding lexical descriptions, which implies that for a short sentence of 10 words, we get 10 possible taggings.",
        "It is not reasonable to treat them individually.",
        "To avoid this, it is convenient to use an automaton to represent the set of all paths.",
        "This automaton has linear size with regard to the initial lexical ambiguity.",
        "The idea of using automata is not new.",
        "In particular, methods based on Hidden Markov Models (HMM) use such a technique for part-of-speech tagging (Kupiec, 1992; Merialdo, 1994).",
        "Using automata, we benefit from dynamic programming procedures, and consequently from an exponential temporal and space speed up."
      ]
    },
    {
      "heading": "2. Abstract Grammatical Framework",
      "text": [
        "Our filtering method is applicable to any lexical-ized grammatical formalism which exhibits some basic properties.",
        "In this section we establish these properties and define from them the notion of Abstract Grammatical Framework (AGF).",
        "Formally, an Abstract Grammatical Framework is an n-tuple (V, S, G, anc, F, p, dep) where:",
        "• V is the vocabulary: a finite set of words of the modeled natural language;",
        "• S is the set of syntactic structures used by the formalism;",
        "• G C S is the grammar: the finite set of initial syntactic structures; a finite list [t1,... ,tn] of elements of G is called a lexical tagging;",
        "• anc : G – V maps initial syntactic structures to their anchors;",
        "• F C S is the set of final syntactic structures that the parsing process builds (for instance trees);",
        "• p is the parsing function from lexical tag-gings to finite subsets of F;",
        "• dep is the dependency function which maps a couple composed of a lexical tagging and a final syntactic structure to dependency structures.",
        "Note that the anc function implies that the grammar is lexicalized: each initial structure in G is associated to an element of V. Note also that no particular property is required on the dependency structures that are obtained with the dep function, they can be non-projective for instance.",
        "We call lexicon the function (written £) from V to subsets of G defined by:",
        "£(w) = {t e G | anc(t) = w}.",
        "We will say that a lexical tagging L = [t1;... ,tn] is a lexical tagging of the sentence",
        "[anc(t1), .",
        ".",
        ".",
        ", anc(tn)].",
        "The final structures in p (L) C F are called the parsing solutions of L.",
        "Henceforth, in our examples, we will consider the ambiguous French sentence (1).",
        "(1) \"La belle ferme la porte\" Example 1 We consider the following toy AGF, suited for parsing our sentence:",
        "• the grammar G is given in the table below: each x corresponds to an element in G , written with the category and the French word as subscript.",
        "For instance, the French word \"porte\" can be either a common noun (\"door\") or a transitive verb (\"hangs\"); hence G contains the 2 elements CNporte and",
        "In our example, categories stand for, respectively: determiner, left adjective, right adjective, common noun, clitic pronoun, transitive verb and intransitive verb.",
        "With respect to our lexicon, for sentence (1), there are 3 x 3 x 5 x 3 x 2 = 270 lexical tag gings.",
        "The parsing function p is such that 3 lexical taggings have one solution and the 267 remaining ones have no solution; we do not need to precise the final structures, so we only give the English translation as the result ofthe parsing function:",
        "la",
        "belle",
        "ferme",
        "porte",
        "Det",
        "X",
        "LAdj",
        "X",
        "X",
        "RAdj",
        "X",
        "X",
        "CN",
        "X",
        "X",
        "X",
        "X",
        "Clit",
        "X",
        "TrV",
        "X",
        "X",
        "IntrV",
        "X",
        "{ \"The nice girl closes the door\"}",
        "• p([Det;a , LAdjbeIIe , CNferme , Clitfa , TrVporte ]) =",
        "• p([Detia , CNbelle , RAdjferme , Clitia , TrVporte]) =",
        "{ \"The firm nice girl hangs it\"}"
      ]
    },
    {
      "heading": "3. The Companionship Principle",
      "text": [
        "We have stated in the previous section the framework and the definitions required to describe our principle.",
        "We say that u e G is a companion of t e G if anc(t) and anc(u) are linked by a dependency in dep(L, m) for some lexical tagging L which contains t and u and some m e p(L).",
        "The subset of elements of G that are companions of t is called the potential companion set of t.",
        "The Companionship Principle says that if a lexical tagging contains some t but no potential companion of t, then it can be removed.",
        "In what follows, we will generalize a bit this idea in two ways.",
        "First, the same t can be implied in more than one kind of dependency and hence it can have several different companion sets with respect to the different kinds of dependencies.",
        "Secondly, it can be the case that some companion t has to be on the right (resp.",
        "on the left) to fulfill its duty.",
        "These generalizations are done through the notion of atomic constraints defined below.",
        "We say that a pair (L, R) of subsets of G is an atomic constraint for an initial structure t e G if for each lexical tagging L = [t1;..., tn] such that p(L) = 0 and t = tj for some i then:",
        "• either there is some j < i such that tj e L,",
        "• or there is some j > i such that tj e R.",
        "In other words, (L, R) lists the potential companions of t, respectively on the left and on the right.",
        "A system of constraints for a grammar G is a function C which associates a finite set of atomic constraints to each element of G.",
        "The Companionship Principle is an immediate consequence of the definition of atomic constraints.",
        "It can be stated as the necessary condition:",
        "The Companionship Principle",
        "If a lexical tagging [t1;..., tn] has a solution then for all i and for all atomic constraints",
        "• or {ti+1,...,tn}n R = 0.",
        "Example 2 Often, constraints can be expressed independently ofthe anchors.",
        "In our example, we use the category to refer to the subset ofG ofstruc-tures defined with this category: LAdj for instance refers to the subset {LAdj belle, LAdj ferme }.",
        "We complete the example ofthe previous section with the following constraints :",
        "© t e Det == (TrV, TrV U IntrV) e C(t)",
        "The two constraints O and © for instance express that every determiner is implied in two dependencies.",
        "First, it must find a common noun on its right to build a noun phrase.",
        "Second, the noun phrase has to be used in a verbal construction.",
        "Now, let us consider the lexical tagging: [Dette, LAdj 6e;;e, TrV/erme, Clitte, CNporte] and the constraint © (a clitic is waiting for a transitive verb on its right).",
        "This constraint is not fulfilled by the tagging so this tagging has no solution.",
        "Actually, a lexical tagging is an element of the formal language G* and we can consider the following three languages.",
        "First, G* itself.",
        "Second, the set C C G* corresponds to the lexical tag-gings which can be parsed.",
        "The aim of lexical disambiguation is then to exhibit for each sentence [w1,..., wn] all the lexical taggings that are within C. Third, the Companionship Principle defines the language P of lexical taggings which verify this Principle.",
        "P squeezes between the two latter sets C C P C G*.",
        "Remarkably, the language P can be described as a regular language.",
        "Since C is presumably not a regular language (at least for natural languages!",
        "), P is a better regular approximation than the trivial G*.",
        "Let us consider one lexical entry t and an atomic constraint (L, R) C(t).",
        "Then, the set of lexical taggings verifying this constraint can be described as where C denotes the complement of a set.",
        "Since P is defined as the lexical taggings verifying all constraints, P is a regular language defined",
        "From the Companionship Principle, we derive a lexical disambiguation Principle which simply tests tagging candidates with P. Notice that P can be statically computed (at least, in theory) from the grammar itself.",
        "Example 3 For instance, for our example grammar, this automaton is given in the figure 1 where c=Clit, n=CN, d=Det, i=IntrV, l=LAdj, r=RAdj and t=TrV.",
        "A rough approximation of the size of the automaton corresponding to P can be easily computed.",
        "Since each automaton Lt:(L R) has 4 states, P has at most 4m states where m is the number of atomic constraints.",
        "For instance, the grammar used in the experiments contains more than one atomic constraint for each lexical entry, and m > |G| > 10.",
        "Computing P by brute-force is then intractable."
      ]
    },
    {
      "heading": "4. Implementation of the Companionship Principle with automata",
      "text": [
        "In this section we show how to use the Companionship Principle for disambiguation.",
        "Actually, we propose two implementations based on the principle, an exact one and an approximate one.",
        "The latter is really fast and can be used as a first step before applying the first one.",
        "taggings",
        "The number of lexical taggings grows exponentially with the length of sentences.",
        "To avoid that, we represent sets of lexical taggings as the sets of paths of some acyclic automata where transitions are labeled by elements of G .",
        "We call such an automaton a lexical taggings automaton (LTA).",
        "Generally speaking, such automata save a lot of space.",
        "For instance, given a sentence [w1,..., wn] the number of lexical taggings to consider at the beginning of the parsing process is n1<j<n|^(wj) |.",
        "This set of taggings can be efficiently represented as the set of paths of the automaton with n + 1 states s0,...,sn and with a transition from si_1to si with the label t for each t e ^(wj).",
        "This automaton has ^^i<n |^(wi)| transitions.",
        "Example 4 With the data ofthe previous examples, we have the initial automaton:",
        "To improve readability, only the categories are given on the edges, while the French words can be inferred from the position in the automaton.",
        "Suppose we have a LTA A for a sentence [w1,..., wn].",
        "For each transition t and for each atomic constraint in (L, R) e C(t), we construct an automaton At L R in the following way.",
        "Each state s of At L R is labeled with a triple composed of a state of the automaton A and two booleans.",
        "The intended meaning of the first boolean is to say that each path reaching this state passes through the transition t. The second boolean means that the atomic constraint (L, R) is necessarily fulfilled.",
        "The initial state is labeled (s0, F, F) where s0 is the initial state of A and other states are labeled as follows: if s – – s' in A then, in At;L;R, we have:",
        "5.",
        "(s, T,b) where b e {T, F}.",
        "It is then routine to show that, for each state labeled (s, b1, b2):",
        "• b1 is Tiff all paths from the initial state to s contain the transition t;",
        "• b2 is Tiff for all paths p reaching this state, either there is some u e L or p goes through t and there is some u R. In other words, the constraint is fulfilled.",
        "In conclusion, a path ending with (s/, T, F) with s/ a final state of A is built with transitions 1, 3 and 5 only and hence contains t but no transition able to fulfill the constraint.",
        "The final states are:",
        "• ( s / , F , b) : each path ending here does not contain the edge t and thus the constraint does not apply here,",
        "• ( s / , T, T) each path ending here contains the edge t but it contains also either a transition 2 or 4, so the constraint is fulfilled by these paths.",
        "The size of these automata is easily bounded by 4n where n is the size of A.",
        "Using a slightly more intricated presentation, we built automata of size 2n.",
        "Example 5 We give below the automaton A for the atomic constraint © (an intransitive verb is waiting for a determiner on its left):",
        "The dotted part of the graph corresponds to the part ofthe automaton that can be safely removed.",
        "After minimization, we finally obtain:",
        "This automaton contains 234 paths (36 lexical taggings are removed by this constraint).",
        "For each transition t of the lexical taggings automaton and for each constraint (L, R) C(t), we construct the atomic constraint automaton At;L,R.",
        "The intersection of these automata represents all the possible lexical taggings of the sentence which respect the Companionship Principle.",
        "• or there is some j > i such that tj e R.",
        "That is, we output :",
        "It can be shown that the automaton is the same as the one obtained by intersection with the automaton of the language defined in 3.3:",
        "Example 6 In our example, the intersection of the 9 automata built for the atomic constraints is given below:",
        "This automaton has 8 paths: there are 8 lexical taggings which fulfill every constraint.",
        "Companionship Principle (QCP)",
        "The issue with the previous algorithm is that it involves a large number of automata (actually O(n)) where n is the size of the input sentence.",
        "Each of these automata has size O(n).",
        "The theoretical complexity of the intersection is then O(nn).",
        "Sometimes, we face the exponential.",
        "So, let us provide an algorithm which approximates the Principle.",
        "The idea is to consider at the same time all the paths that contain some transition.",
        "We consider a LTA A.",
        "We write - – A the precedence relation on transitions in an automaton A.",
        "We define 1A(t) = {u e G, u – A t} and rA(t) = {u e G,t – a u}.",
        "For each transition s – – s' and each constraint (L, R) e C(t), if 1A(t) n L = 0 and rA(t) n R = 0, then none of the lexical taggings which use the transition t has a solution and the transition t can be safely removed from the automaton.",
        "This can be computed by a double-for loop: for each atomic constraint of each transition, verify that either the left context or the right context of the transition contains some structure to solve the constraint.",
        "Observe that the cost of this algorithm is O(n), where n is the size of the input automaton.",
        "Note that one must iterate this algorithm until a fixpoint is reached.",
        "Indeed, removing a transition which serves as a potential companion breaks the verification.",
        "Nevertheless, since for each step before the fixpoint is reached, we remove at least one transition, we iterate the double-for at most O(n) times.",
        "The complexity of the whole algorithm is then O(n).",
        "In practice, we have observed that the complexity is closer to O(n): only 2 or 3 loops are enough to reach the fixpoint.",
        "Example 7 If we apply the QCP to the automaton of Example 4, in the first step, only the transition 0 - – 1 is removed by applying the atomic constraint O.",
        "In the next step, the transition 1-> 2 is removed by applying the atomic constraint ©.",
        "The fixpoint is reached and the output automaton (with 120 paths) is:"
      ]
    },
    {
      "heading": "5. The Generalized Companionship Principle",
      "text": [
        "In practice, of course, we have to face the problem of the computation of the constraints.",
        "In a large coverage grammar, the size of G is too big to compute all the constraints in advance.",
        "However, as we have seen in example 2 we can identify subsets of G that have the same constraints; the same way, we can use these subsets to give a more concise presentation of the L and R sets of the atomic constraints.",
        "This motivates us to define a Generalized Principle which is stated on a quotient set of",
        "G.",
        "Let U be a set of subsets of G that are a partition of G. For t e G, we write t the subset of U which contains t.",
        "We say that a pair (L, R) of subsets of U is a generalized atomic constraint for u U if for",
        "• either there is some j < i such that tj e L,",
        "A system of generalized constraints for a partition U of a grammar G is a function C which associates a finite set of generalized atomic constraints to each element of U.",
        "The Generalized Companionship Principle is then an immediate consequence of the previous definition and can be stated as the necessary condition:",
        "The Generalized Companionship Principle",
        "If a lexical tagging [t1,..., tn] has a solution then for all i and for all generalized atomic constraints (L, R) e C(ti)",
        "• or {ti+T,..., tn} n R = 0.",
        "Example 8 The constraints given in example 2 are in fact generalized atomic constraints on the set (recall that we write LAdj for the 2 elements set (LAdj 6eHe, LAdj/erme}):",
        "U = {Det,LAdj,RAdj,CN, Clit, TrV, IntrV}.",
        "Then the constraints are expressed on |U| = 7 elements and not on | G | = 13.",
        "A generalized atomic constraint on U can, of course, be expressed as a set of atomic constraints on G: let u G U and t G G such that t = u",
        "In implementations of large coverage linguistic resources, it is very common to have, first, the description of the set of \"different\" structures needed to describe the modeled natural language and then an anchoring mechanism that explains how words of the lexicon are linked to these structures.",
        "We call unanchored grammar the set U of different structures (not yet related to words) that are needed to describe the grammar.",
        "In this context, the lexicon is split in two parts:",
        "• a function 1 from V to subsets of U,",
        "• an anchoring function a which builds the grammar elements from a word w G V and an unanchored structure u G 1(w); we suppose that a verifies that anc(a(w, u)) = w.",
        "In applications, we suppose that U, £ and a are given.",
        "In this context, we define the grammar as the codomain of the anchoring function:",
        "Now, we can define generalized constraints on the unanchored grammar, which are independent of the lexicon and can be computed statically for a given unanchored grammar."
      ]
    },
    {
      "heading": "6. Application to Interaction Grammars",
      "text": [
        "In this section, we apply the Companionship Principle to the Interaction Grammars formalism.",
        "We first give a short and simplified description of IG and an example to illustrate them at work; we refer the reader to (Guillaume and Perrier, 2008) for a complete and detailed presentation.",
        "We illustrate some of the important features on the French sentence (2).",
        "In this sentence, \"la\" is an object clitic pronoun which is placed before the verb whereas the canonical place for the (nonclitic) object is on the right of the verb.",
        "The set F of final structures, used as output of the parsing process, contains ordered trees called parse trees (PT).",
        "An example of a PT for the sentence (2) is given in Figure 2.",
        "A PT for a sentence contains the words of the sentence or the empty word e in its leaves (the left-right order of the tree leaves follows the left-right order of words in the input sentence).",
        "The internal nodes of a PT represent the constituents of the sentence.",
        "The morpho-syntactic properties of these constituents are described with feature structures (only the category is shown in the figure).",
        "As IG use the Model-Theoretic Syntax (MTS) framework, a PT is defined as the model of a set of constraints.",
        "Constraints are defined at the word level: words are associated to a set of constraints formally described as a polarized tree description (PTD).",
        "A PTD is a set of nodes provided with relations between these nodes.",
        "The three PTDs used to build the model above are given in Figure 3.",
        "The relations used in the PTDs are: immediate dominance (lines) and immediate sisterhood (arrows).",
        "Nodes represent syntactic constituents",
        "One of the strong points of IG is the flexibility given by the MTS approach: PTDs can be partially superposed to produce the final tree (whereas superposition is limited in usual CG or in TAG for instance).",
        "In our example, the four grey nodes in the PTD which contains \"la\" are superposed to the four grey nodes in the PTD which contains \"demande\" to produce the four grey nodes in the model.",
        "and relations express structural dependencies between these constituents.",
        "Moreover, nodes carry a polarity: the set of polarities is {+, – , =, ~}.",
        "A + (resp. – ) polarity represents an available (resp.",
        "needed) resource, a ~ polarity describes a node which is unsaturated.",
        "Each + must be associated to exactly one – (and vice versa) and each ~ must be associated to at least another polarity.",
        "Now, we define a PT to be a model of a set of PTDs if there is a surjective function I from nodes of the PTDs to nodes of the PT such that:",
        "• relations in the PTDs are realized in the PT: if M is a daughter (resp.",
        "immediate sister) of N in some PTD then J(M) is a daughter (resp.",
        "immediate sister) of J(N);",
        "• each node N in the PT is saturated: the composition of the polarities of the nodes in J-1(N) with the associative and commutative rule given in Table 4 is =;",
        "• the feature structure of a node N in the PT is the unification of the feature structures of the nodes in J-1(N).",
        "In order to give an idea of the full IG system, we briefly give here the main differences between our presentation and the full system.",
        "• Dominance relations can be underspecified: for instance a PTD can impose a node to be an ancestor of another one without constraining the length of the path in the model.",
        "This is mainly used to model unbounded extraction.",
        "• Sisterhood relations can also be underspeci-fied: when the order on subconstituents is not total, it can be modeled without using several",
        "PTDs.",
        "• Polarities are attached to features rather than nodes: it sometimes gives more freedom to the grammar writer when the same constituent plays a role in different constructions.",
        "• Feature values can be shared between several nodes: once again, this is a way to factorize the unanchored grammar.",
        "The application of the Companionship Principle is described on the reduced IG but it can be straightforwardly extended to full IG with unessential technical details.",
        "Following the notation given in 5.3, an IG is made of:",
        "• A finite set V of words;",
        "• A finite set U of unanchored PTDs (without any word attached to them);",
        "• A lexicon function £ from V to subsets of U.",
        "~ - + =",
        "Figure 2: The PT of sentence (2)",
        "~ - + =",
        "+",
        "+ =",
        "=",
        "=",
        "C2",
        "D2",
        "B3",
        "C3",
        "D3",
        "~V",
        "+NP",
        "-NP",
        "=V",
        "-NP",
        "E2",
        "F2",
        "When t G £(w), we can construct the anchored PTD a(w,u).",
        "Technically, in each unanchored PTD u, a place is marked to be the anchor, i.e. to be replaced by the word during the anchoring process.",
        "Moreover, the anchoring process can also be used to refine some features.",
        "The fact that the feature can be refined gives more flexibility and more compactness to the unanchored grammar construction.",
        "In the French IG grammar, the same unanchored PTD can be used for masculine or feminine common nouns and the gender is specified during the anchoring to produce distinct anchored PTDs for masculine and feminine nouns.",
        "G is defined by:",
        "The parsing solutions of a lexical tagging is the set of PTs that are models of the list of PTDs described by the lexical tagging:",
        "With the definitions of this section, an IG is a special case of AGF as defined in section 2.",
        "In order to apply the Companionship Principle, we have to explain how the generalized atomic constraints are built for a given grammar.",
        "One way is to look at dependency structures but in IG polarities are built in and then we can read the dependency information we need directly on polarities.",
        "A requirement to build a model is the saturation of all the polarities.",
        "This requirement can be expressed using atomic constraints.",
        "Each time a PTD contains an unsaturated polarity +, – or ~, we have to find some other compatible dual polarity somewhere else in the grammar to saturate it.",
        "From the general MTS definition of IG above, we can define a step by step process to build models of a lexical tagging.",
        "The idea is to build incrementally the interpretation function I with the atomic operation of node merging.",
        "In this atomic operation, we choose two nodes and make the hypothesis that they have the same image through I and hence that they can be identified.",
        "Now, suppose that the unanchored PTD u contains some unsaturated polarity p. We can use the atomic operation of node merging to test if the unanchored PTD U can be used to saturate the polarity p. Let L (resp R) be the set of PTDs that can be used on the left (resp.",
        "on the right) of u to saturate p, then (L, R) is a generalized atomic constraint in C(u)."
      ]
    },
    {
      "heading": "7. Companionship Principle for other formalisms",
      "text": [
        "As we said in the introduction, many current grammatical formalisms can more or less directly be used to generate dependency structures and hence are candidate for disambiguation with the Companionship Principle.",
        "With IG, we have seen that dependencies are strongly related to polarities: dependency constraints in IG are built with the polarity system.",
        "We give below two short examples of polarity use to define atomic constraints on TAG and on CG.",
        "We use, as for IG, the polarity view of dependencies to describe how the constraints are built.",
        "Feature-based Tree Adjoining Grammars (hereafter FTAG) (Joshi, 1987) are a unification based version of Tree Adjoining Grammars.",
        "An FTAG consists of a set of elementary trees and of two tree composition operations: substitution and adjunction.",
        "There are two kinds of trees: auxiliary and initial.",
        "Substitution inserts a tree t with root r onto a leaf node l of another tree t under the condition that l is marked as a place for substitution and l and r have compatible feature structures.",
        "Adjunction inserts an auxiliary tree t into a tree t by splitting a node n of t under the condition that the feature structures of the root and foot nodes of t are compatible with the fop and bottom ones of n.",
        "Getting the generalized atomic constraints and the model building procedure for lexical tagging is extremely similar to what was previously described for IG if we extend the polarization procedure which was described in (Gardent and Kow, 2005) to do polarity based filtering in FTAG.",
        "The idea is that for each initial tree t, its root of category C is marked as having the polarity +C, and its substitution nodes of category S are marked as having the polarity – S.",
        "A first constraint set contains trees t whose root is polarized +S and such that feature structures are unifiable.",
        "A second constraint set contains trees t\" which have a leaf that is polarized – C. We can extend this procedure to auxiliary trees: each auxiliary tree t of category A needs to be inserted in a node of category A of another tree t'.",
        "This gives us a constraint in the spirit of the ~ polarity in IG: C(i) contains all the trees t' in which t could be inserted.",
        "In their type system, Categorial Grammars encode linearity constraints and dependencies between constituents.",
        "For example, a transitive verb is typed NP\\S/NP, meaning that it waits for a subject NP on its left and an object NP on its right.",
        "This type can be straightforwardly decomposed as two – NP and one +S polarities.",
        "Then again, getting the generalized atomic constraints is immediate and in the same spirit as what was described for IG.",
        "The lexicalization condition stated in section 2 excludes non-lexicalized formalisms like LFG or HPSG.",
        "Nothing actually prevents our method from being applied to these, but adding non-lexicalized combinators requires to complexify the formal account of the method.",
        "Adapting our method to HPSG would result in a generalization and unification of some of the techniques described in (Kiefer et al., 1999)."
      ]
    },
    {
      "heading": "8. Experimental results 8.1 Setup",
      "text": [
        "The experiments are performed using a French IG grammar on a set of 31 000 sentences taken from the newspaper Le Monde.",
        "The French grammar we consider (Perrier, 2007) contains |U| = 2 088 unanchored trees.",
        "It covers 88% of the grammatical sentences and rejects 85% of the ungrammatical ones on the TSNLP (Lehmann et al., 1996) corpus.",
        "The constraints have been computed on the unanchored grammar as explained in section 5: each tree contains several polarities and therefore several atomic constraints.",
        "Overall, the grammar contains 20 627 atomic constraints.",
        "It takes 2 days to compute the set of constraints and the results can be stored in a constraints file of 10MB.",
        "Of course, an atomic constraint is more interesting when the sizes of L and Ji are small.",
        "In our grammar, 50% of the constraints set (either Ji or £) contain at most 40 elements and 80% of these sets contain at most 200 elements over 2 088.",
        "We give in figure 5 the number of sentences of each length in the corpus we consider.",
        "Two preliminary comments need to be made on the treatment of the results.",
        "First, as we observed above, the number n of lexical laggings is a priori exponential in the length of the sentence.",
        "We thus consider its log.",
        "Moreover, because we use a raw corpus, some sentences are considered as ungrammatical by the grammar; in this case it may happen that the disambiguation method removes all taggings.",
        "In order to avoid undefined values when n = 0, we in fact consider log10(l + n).",
        "Second, as expected, the ECP method is more time consuming and for some sentences the time and/or memory required is problematic.",
        "To be able to apply the ECP to a large number of sentences, we have used it after another filtering method based on polarities and described in (Bonfante et al., 2004).",
        "Thus, for each sentence we have computed 3 different filters, each one finer than the previous:",
        "• QCP the Quick Companionship Principle;",
        "• QCP+POL QCP followed by a filtering technique based on polarity counting;",
        "• QCP+POL+ECP the Exact Companionship Principle applied to the previous filter.",
        "Figure 6 displays the mean computation time for each length: it confirms that the ECP is more time consuming and goes up to 5s for our long sentences.",
        "1",
        "1 2CCO",
        "■",
        "f",
        "=",
        "1",
        "1",
        "1",
        "umber of words)",
        "III-",
        "Finally, we report the number of lexical laggings that each method returns.",
        "Figure 7 displays the mean value of log10(l + n) where n is either the initial number of lexical laggings or the number of lexical laggings left by the filter.",
        "We can observe that the slope of the lines corresponds to the mean word ambiguity: if the mean ambiguity is a then the number of taggings for a sentence of length n is about an and then log(an) = n ■ log(a).",
        "As a consequence, the mean ambiguity can be read as 10s where s is the slope in the last figure.",
        "An illustration is given in figure 8 which exhibits the mean word ambiguity for sentences of length 16."
      ]
    },
    {
      "heading": "9. Conclusion",
      "text": [
        "We have presented a disambiguation method based on dependency constraints which allows to filter out many wrong lexical taggings before entering the deep parsing.",
        "As this method relies on the computation of static constraints on the linguistic data and not on a statistical model, we can be sure that we will never remove any correct lexical tagging.",
        "Moreover, we manage to apply our methods to an interesting set of data and prove that it is efficient for a large coverage grammar and not only for a toy grammar.",
        "These results are also an encouragement to develop further this kind of disambiguation methods.",
        "In the near future, we would like to explore some improvements.",
        "First, we have seen that our principle cannot be computed on the whole grammar and that in its implementation we consider unanchored structures.",
        "We would like to explore the possibility of computing finer constraints (relative to the full grammar) on the fly for each sentence.",
        "We believe that this can eliminate some more laggings before entering the deep parsing.",
        "Concerning the ECP, as we have seen, there is a kind of interplay between the efficiency of the filtering and the time of the compulation.",
        "We would like to explore the possibility to define some intermediate way between QCP and ECP either by using approximate automata or using the ECP but only on a subset of elements where it is known to be efficient.",
        "Another challenging method we would like to investigate is to use the Companionship Principle not only as a disambiguation method but as a guide for the deep parsing.",
        "Actually, we have observed for at least 20% of the words that dependencies are completely determined by the filtering methods.",
        "If deep parsing can be adapted to use this observation (this is the case for IG), this can be of great help.",
        "Finally, we can improve the filtering using both worlds: the Companionship Principle and the polarity counting method.",
        "Two different constraints cannot be fulfilled by the same potential companion: this may allow to discover some more lexical taggings that can be safely removed."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We would like to thank the anonymous reviewers for their helpful comments and suggestions.",
        "init",
        "QCP",
        "QCP+POL",
        "QCP+POL+ECP",
        "6.13",
        "3.41",
        "1.93",
        "1.41"
      ]
    }
  ]
}
