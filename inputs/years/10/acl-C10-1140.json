{
  "info": {
    "authors": [
      "Naoki Yoshinaga",
      "Masaru Kitsuregawa"
    ],
    "book": "COLING",
    "id": "acl-C10-1140",
    "title": "Kernel Slicing: Scalable Online Training with Conjunctive Features",
    "url": "https://aclweb.org/anthology/C10-1140",
    "year": 2010
  },
  "references": [
    "acl-C02-1054",
    "acl-C04-1002",
    "acl-D08-1071",
    "acl-D09-1160",
    "acl-L08-1309",
    "acl-N09-2025",
    "acl-P03-1004",
    "acl-P07-1010",
    "acl-P07-2017",
    "acl-P08-2060",
    "acl-P09-1054",
    "acl-W08-2103"
  ],
  "sections": [
    {
      "text": [
        "This paper proposes an efficient online method that trains a classifier with many conjunctive features.",
        "We employ kernel computation called kernel slicing, which explicitly considers conjunctions among frequent features in computing the polynomial kernel, to combine the merits of linear and kernel-based training.",
        "To improve the scalability of this training, we reuse the temporal margins of partial feature vectors and terminate unnecessary margin computations.",
        "Experiments on dependency parsing and hyponymy-relation extraction demonstrated that our method could train a classifier orders of magnitude faster than kernel-based online learning, while retaining its space efficiency."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The past twenty years have witnessed a growing use of machine-learning classifiers in the field of nlp.",
        "Since the classification target of complex nlp tasks (e.g., dependency parsing and relation extraction) consists of more than one constituent (e.g., a head and a dependent in dependency parsing), we need to consider conjunctive features, i.e., conjunctions of primitive features that focus on the particular clues of each constituent, to achieve a high degree of accuracy in those tasks.",
        "Training with conjunctive features involves a space-time trade-off in the way conjunctive features are handled.",
        "Linear models, such as loglinear models, explicitly estimate the weights of conjunctive features, and training thus requires a great deal of memory when we take higher-order conjunctive features into consideration.",
        "Kernelbased models such as support vector machines, on the other hand, ensure space efficiency by using the kernel trick to implicitly consider conjunctive features.",
        "However, training takes quadratic time in the number of examples, even with online algorithms such as the (kernel) perceptron (Freund and Schapire, 1999), and we cannot fully exploit ample 'labeled' data obtained with semi-supervised algorithms (Ando and Zhang, 2005; Bellare et al., 2007; Liang et al., 2008; Daumé III, 2008).",
        "We aim at resolving this dilemma in training with conjunctive features, and propose online learning that combines the time efficiency of linear training and the space efficiency of kernel-based training.",
        "Following the work by Goldberg and Elhadad (2008), we explicitly take conjunctive features into account that frequently appear in the training data, and implicitly consider the other conjunctive features by using the polynomial kernel.",
        "We then improve the scalability of this training by a method called kernel slicing, which allows us to reuse the temporal margins of partial feature vectors and to terminate computations that do not contribute to parameter updates.",
        "We evaluate our method in two nlp tasks: dependency parsing and hyponymy-relation extraction.",
        "We demonstrate that our method is orders of magnitude faster than kernel-based online learning while retaining its space efficiency.",
        "The remainder of this paper is organized as follows.",
        "Section 2 introduces preliminaries and notations.",
        "Section 3 proposes our training method.",
        "Section 4 evaluates the proposed method.",
        "Section 5 discusses related studies.",
        "Section 6 concludes this paper and addresses future work.",
        "Algorithm 1 Base Learner: Kernel pa-i"
      ]
    },
    {
      "heading": "2. Preliminaries",
      "text": [
        "This section first introduces a passive-aggressive algorithm (Crammer et al., 2006), which we use as a base learner.",
        "We then explain fast methods of computing the polynomial kernel.",
        "Each example x in a classification problem is represented by a feature vector whose element Xj is a value of a feature function, fj G F. Here, we assume a binary feature function, fj (x) G {0,1}, which returns one if particular context data appear in the example.",
        "We say that feature fj is active in example x when Xj = fj (x) = 1.",
        "We denote a binary feature vector, x, as a set of active features",
        "x = {fj I fj G F, fj(x) = } forbrevity; fj G xmeans that fj is active in x, and |x| represents the number of active features in x.",
        "A passive-aggressive algorithm (pa) (Crammer et al., 2006) represents online learning that updates parameters for given labeled example (x,y)t G T in each round t. We assume a binary label, y G { – 1, +1}, here for clarity.",
        "Algorithm 1 is a variant of pa (pa-i) that incorporates a kernel function, k. In round t, pa-i first computes a (signed) margin mt(x) of x by using the kernel function with support set St-i and coefficients at-1 (Line 4).",
        "pa-i then suffers a hinge-loss, it = max{0,1 – ymt(x)} (Line 5).",
        "If it > 0, pa-i adds x to St-1 (Line 7).",
        "Hyperparameter C controls the aggressiveness of parameter updates.",
        "The kernel function computes a dot product in",
        "space without mapping x G Rn to 0(x) G RH (k(x, x') = 0(x)T0(x')).",
        "We can implicitly consider (weighted) d or less order conjunctions of primitive features by using polynomial kernel function kd(s, x) = (sTx + For example, given support vector s = (s1;s2)T and input example x = (x1 ,x2)T, the second-order polynomial kernel returns k2(s, x) = (s1x1 +",
        "Si,Xi G {0,1}).",
        "This function thus implies mapping 02(x) = (1, \\/3X1, \\/3X2, \\/2X1X2)T.",
        "Although online learning is generally efficient, the kernel spoils its efficiency (Dekel et al., 2008).",
        "This is because the kernel evaluation (Line 4) takes O(|St-1||x|) time and |St-1| increases as training continues.",
        "The learner thus takes the most amount of time in this margin computation.",
        "This section explains fast, exact methods of computing the polynomial kernel, which are meant to test the trained model, (S, a), and involve substantial computational cost in preparation.",
        "Kudo and Matsumoto (2003) proposed polynomial kernel inverted (pki), which builds inverted indices h(fj) = {s | s G S, fj G s} from each feature fj to support vector s G S to only consider support vector s relevant to given x such that sTx = 0.",
        "The time complexity of pki is O(B • |x| + |S|) where B = ^ £/.ex |h(fj)|, which is smaller than O(|S||x|) if x has many rare features fj suchthat )| <C |S|.",
        "To the best of our knowledge, this is the only exact method that has been used to speed up margin computation in the context of kernel-based online learning (Okanohara and Tsujii, 2007).",
        "Isozaki and Kazawa (2002) and Kudo and Matsumoto (2003) proposed kernel expansion, which explicitly maps both support set S and given example x G Rn into RH by mapping 0d imposed by kd:",
        "where xd G {0,1}H is a binary feature vector in which xd = 1 for (0d(x))i = 0, and w is a weight vector in the expanded feature space, Fd.",
        "The weight vector w is computed from S and a:",
        "where cd is a squared coefficient of k-th order conjunctive features for d-th order polynomial kernel (e.g., c° = 1, c\\ = 3, and = 2) and Ik(sd) is sd G {0,1}H whose dimensions other than those of k-th order conjunctive features are set to zero.",
        "The time complexity of kernel expansion is O(|xd|) where |xd| = Yl=° (Ï) « |x|d, which can be smaller than O(|S||x|) in usual nlp tasks (|x| < |S| and d < 4).",
        "Since kernel expansion demands a huge memory volume t(o st)ore the weight vector, w, in (H = Ed=° ('k')), Goldberg and Elhadad (2008) only explicitly considered conjunctions among features fc G Fc that commonly appear in support set S, and handled the other conjunctive features relevant to rare features fR G F \\ Fc by using the polynomial kernel:",
        "where x is x whose dimensions of rare features are set to zero, W is a weight vector computed with Eq.",
        "1 for Fc, and k'd(s, x, x) is defined as:",
        "kd(s, x, x) = kd(s, x) – fcd(s, x).",
        "We can space-efficiently compute the first term of Eq.",
        "2 since |W| ^ |w|, while we can quickly compute the second term of Eq.",
        "2 since kd(si; x, x) = 0 when sTx = sTx; we only need to consider a small subset of the support set, Sr = U fRex\\x h(fn), that has at least one of the rare features, fR, appearing in x\\x (|SR| <C |S|).",
        "Counting the number of features examined, the time complexity of Eq.",
        "2 is ö(|;»d| + |Sr||sc|).",
        "cd=Et*nd ) (Em=o(-i)fc-m • mi(m ))."
      ]
    },
    {
      "heading": "3. Algorithm",
      "text": [
        "This section first describes the way kernel splitting is integrated into PA-I (Section 3.1).",
        "We then propose kernel slicing (Section 3.2), which enables us to reuse the temporal margins computed in the past rounds (Section 3.2.1) and to skip unnecessary margin computations (Section 3.2.2).",
        "In what follows, we use PA-I as a base learner.",
        "Note that an analogous argument can be applied to other perceptron-like online learners with the additive weight update (Line 7 in Algorithm 1).",
        "A problem in integrating kernel splitting into the base learner presented in Algorithm 1 is how to determine F , features among which we explicitly consider conjunctions, without knowing the final support set, S't'.",
        "We heuristically solve this by ranking feature f according to their frequency in the training data and by using the top-N frequent features in the training data as Fc(= {f | f G F, RANK(f ) < N}).",
        "Since Smis a subset of the examples, this approximates the selection from S't'.",
        "We empirically demonstrate the validity of this approach in the experiments.",
        "We then use F to construct a base learner with kernel splitting; we replace the kernel computation (Line 4 in Algorithm 1) with Eq.",
        "2 where (S, a) = (St_i, at_i).",
        "To compute mt(x) by using kernel expansion, we need to additionally maintain the weight vector w for the conjunctions of common features that appear in St-1.",
        "The additive parameter update of PA-I enables us to keep w to correspond to (St-1, at-1).",
        "When we add x to support set St-1 (Line 7 in Algorithm 1), we also update w with Eq.",
        "1:",
        "w <- + TtyJ^cdIk(xd).",
        "Following (Kudo and Matsumoto, 2003), we use a trie (hereafter, weight trie) to maintain conjunctive features.",
        "Each edge in the weight trie is labeled with a primitive feature, while each path represents a conjunctive feature that combines all the primitive features on the path.",
        "The weights of conjunctive features are retrieved by traversing nodes in the trie.",
        "We carry out an analogous traversal in updating the parameters of conjunctive features, while registering a new conjunctive feature by adding an edge to the trie.",
        "The base learner with kernel splitting combines the virtues of linear training and kernel-based training.",
        "It reduces to linear training when we increase N to while it reduces to kernel-based training when we decrease N to 0.",
        "The output is support set S\\t\\ and coefficients a\\j-\\ (optionally, w), to which the efficient classification techniques discussed in Section 2.2 and the one proposed by Yoshinaga and Kitsuregawa (2009) can be applied.",
        "Note on weight trie construction The time and space efficiency of this learner strongly depends on the way the weight trie is constructed.",
        "We need to address two practical issues that greatly affect efficiency.",
        "First, we traverse the trie from the rarest feature that constitutes a conjunctive feature.",
        "This rare-to-frequent mining helps us to avoid enumerating higher-order conjunctive features that have not been registered in the trie, when computing margin.",
        "Second, we use rank(f ) encoded into a |~log128 rank(f )~|-byte string by using variable-byte coding (Williams and Zobel, 1999) as f's representation in the trie.",
        "This encoding reduces the trie size, since features with small rank(f) will appear frequently in the trie.",
        "Although a base learner with kernel splitting can enjoy the merits of linear and kernel-based training, it can simultaneously suffer from their demerits.",
        "Because the training takes polynomial time in the number of common features in x (|xd| =",
        "2~^fc=o oc |X|d) at each round, we need to set N to a smaller value when we take higher-order conjunctive features into consideration.",
        "However, since the margin computation takes linear time in the number of support vectors |SR| relevant to rare features fR G F\\FC, we need to set N to a larger value when we handle a larger number of training examples.",
        "The training thereby slows down when",
        "we train a classifier with high-order conjunctive features and a large number of training examples.",
        "We then attempt to improve the scalability of the training by exploiting a characteristic of labeled data in nlp.",
        "Because examples in nlp tasks are likely to be redundant (Yoshinaga and Kitsure-gawa, 2009), the learner computes margins of examples that have many features in common.",
        "If we can reuse the 'temporal' margins of partial feature vectors computed in past rounds, this will speed up the computation of margins.",
        "We propose kernel slicing, which generalizes kernel splitting in a purely feature-wise manner and enables us to reuse the temporal partial margins.",
        "Starting from the most frequent feature f1 in x (f1 = argmin/ex rank(f )), we incrementally compute mt(x) by accumulating a partial margin, mj(x) = mt(xj) – mt(xj-1 ), when we add the j-th frequent feature fj in x:",
        "xj = U£=0{argmin/ex\\Xk rank(f )}).",
        "partial margin mtj(x) can be computed by using the polynomial kernel:",
        "or by using kernel expansion:",
        "/iexd\\xd_i",
        "Kernel splitting is a special case of kernel slicing, which uses Eq.",
        "5 for fj G FC and Eq.",
        "4 for fj G F\\Fc .",
        "We can speed up both Eqs.",
        "4 and 5 by reusing a temporal partial margin, bj, = mj, (x) that had been computed in past round t (< t):",
        "mj (x) = bj, + aik'd (si, xj, xj_i), (6) where Sj = {s | s G St_i \\ fj G s}.",
        "Algorithm 2 Kernel Slicing",
        "2: repeat",
        "Eq.",
        "6 is faster than Eq.",
        "4, and can even be faster than Eq.",
        "5.",
        "When rank(/j) is high, Xj appears frequently in the training examples and |sj | becomes small since t' will be close to t. When rank(/j) is low, Xj rarely appears in the training examples but we can still expect |sj | to be small since the number of support vectors in st-1\\St>-i that have rare feature /j will be small.",
        "To compute Eq.",
        "3, we now have the choice to choose Eq.",
        "5 or 6 for /j g Fc.",
        "Counting the number of features to be examined in computing mj (x), we have the following criteria to determine whether we can use Eq.",
        "6 instead of Eq.",
        "5:",
        "where the left-and right-hand sides indicate the number of features examined in Eq.",
        "6 for the former and Eq.",
        "5 for the latter.",
        "Expanding the right-hand side for d = 2, 3 and dividing both sides with |xj-1| = j – 1, we have:",
        "if this condition is met after retrieving the temporal partial margin, bj,, we can compute partial margin mj (x) with Eq.",
        "6.",
        "This analysis reveals that we can expect little speed-up for the second-order polynomial kernel; we will only use Eq.",
        "6 with third or higher-order polynomial kernel.",
        "Algorithm 2 summarizes the margin computation with kernel slicing.",
        "it processes each feature /j g x in frequent-to-rare order, and accumulates partial margin mj (x) to have mt(x).",
        "Intuitively speaking, when the algorithm uses the partial margin, it only considers support vectors on each feature that have been added since the last evaluation of the partial feature vector, to avoid the repetition in kernel evaluation as much as possible.",
        "Kernel slicing enables another optimization that exploits a characteristic of online learning.",
        "Because we need an exact margin, mt(x), only when hinge-loss £t = 1 – ymt(x) is positive, we can finish margin computation as soon as we find that the lower-bound of ymt(x) is larger than one.",
        "When ymt(x) is larger than one after processing feature /j in Eq.",
        "3, we quickly examine whether this will hold even after we process the remaining features.",
        "We can compute a possible range of partial margin mk(x) with Eq.",
        "4, having the upper-and lower-bounds, k'd and k'd, of kd(si, xk, xfc-i) (= kd(si, xk) – kd(si, xfc-i)):",
        "stes.",
        "| si g St-i, fk",
        "si gs+ us-).",
        "We accumulate Eqs.",
        "8 and 9 from rare to frequent features, and use the intermediate results to estimate the possible range of mt(x) before line 3 in Algorithm 2. if the lower bound of ymt(x) turns out to be larger than one, we terminate the computation of mt(x).",
        "As training continues, the model becomes discriminative and given x is likely to have a larger margin.",
        "The impact of this termination will increase as the amount of training data expands."
      ]
    },
    {
      "heading": "4. Evaluation",
      "text": [
        "We evaluated the proposed method in two nlp tasks: dependency parsing (Sassano, 2004) and hyponymy-relation extraction (Sumida et al., 2008).",
        "We used labeled data included in open-source softwares to promote the reproducibility of our results.",
        "All the experiments were conducted on a server with an Intel® XeonTM 3.2 GHz CPU.",
        "We used a double-array trie (Aoe, 1989; Yata et al., 2009) as an implementation of the weight trie and the partial margin trie.",
        "Japanese Dependency Parsing A parser inputs a sentence segmented by a bunsetsu (base phrase in Japanese), and selects a particular pair of bun-setsus (dependent and head candidates); the classifier then outputs label y = +1 (dependent) or – 1 (independent) for the pair.",
        "The features consist of the surface form, POS, POS-subcategory and the inflection form of each bunsetsu, and surrounding contexts such as the positional distance, punctuations and brackets.",
        "See (Yoshinaga and Kitsuregawa, 2009) for details on the features.",
        "Hyponymy-Relation Extraction A hyponymy relation extractor (Sumida et al., 2008) first extracts a pair of entities from hierarchical listing structures in Wikipedia articles (hypernym and hyponym candidates); a classifier then outputs label y = +1 (correct) or – 1 (incorrect) for the pair.",
        "The features include a surface form, morphemes, POS and the listing type for each entity, and surrounding contexts such as the hierarchical distance between the entities.",
        "See (Sumida et al., 2008) for details on the features.",
        "Table 1 summarizes the training data for the two tasks.",
        "The examples for the Japanese dependency parsing task were generated for a transition-based parser (Sassano, 2004) from a standard data set.We used the dependency accuracy of the parser",
        "DATA SET DEP REL",
        "as model accuracy in this task.",
        "in the hyponymy-relation extraction task, we randomly chosen two sets of 10,000 examples from the labeled data for development and testing, and used the remaining examples for training.",
        "Note that the number of active features, |Fd|, dramatically grows when we consider higher-order conjunctive features.",
        "We compared the proposed method, pa-i sl (Algorithm 1 with Algorithm 2), to PA-I KERNEL (Algorithm 1 with PKI; Okanohara and Tsu-jii (2007)), PA-I KE (Algorithm 1 with kernel expansion; viz., kernel splitting with N = SVM (batch training of support vector machines),and (stochastic gradient descent training of the £1 regularized log-linear model: Tsuruoka et al.",
        "(2009)).",
        "We refer to pa-i sl that does not reuse temporal partial margins as PA-I sl*.",
        "To demonstrate the impact of conjunctive features on model accuracy, we also trained PA-I without conjunctive features.",
        "The number of iterations in PA-I was set to 20, and the parameters of PA-I were averaged in an efficient manner (Daumé III, 2006).",
        "We explicitly considered conjunctions among top-N (N = 125 x 2n; n > 0) features in PA-I SL and PA-I sl*.",
        "The hyperparameters were tuned to maximize accuracy on the development set.",
        "Tables 2 and 3 list the experimental results for the two tasks (due to space limitations, Tables 2 and 3 list PA-1 sl with parameter N that achieved the fastest speed).",
        "The accuracy of the models trained with the proposed method was better than ^1-LLMs and was comparable to svms.",
        "The infe-",
        "Table 2: Training time for classifiers used in de-Table 3: Training time for classifiers used in pendency parsing task.",
        "N: # of expanded primitive features",
        "hyponymy-relation extraction task.",
        "Figure 1: Training time for PA-I variants as a function of the number of expanded primitive features in dependency parsing task (d = 3).",
        "Figure 2: Training time for PA-I variants as a function of the number of expanded primitive features in hyponymy-relation extraction task (d = 3).",
        "rior accuracy of PA-I (d = 1) confirmed the necessity of conjunctive features in these tasks.",
        "The minor difference among the model accuracy ofthe three PA-1 variants was due to rounding errors.",
        "PA-I sl was the fastest of the training methods with the same feature set, and its space efficiency was comparable to the kernel-based learners.",
        "PA-I SL could reduce the memory footprint from 993MB to 175MB for d = 3 in the dependency parsing task, while speeding up training.",
        "Although linear training (f^-LLM and PA-I KE) dramatically slowed down when we took higherorder conjunctive features into account, kernel slicing alleviated deterioration in speed.",
        "Especially in the hyponymy-relation extraction task, PA-I sl took almost the same time regardless of the order of conjunctive features.",
        "Figures 1 and 2 plot the trade-off between the number of expanded primitive features and training time with PA-I variants (d = 3) in the two tasks.",
        "Here, PA-I SP is PA-I with kernel slicing without the techniques described in Sections 3.2.1 and 3.2.2, viz., kernel splitting.",
        "The early termination of margin computation reduces the training time when N is large.",
        "The reuse of temporal margins makes the training time stable regardless of parameter N. This suggests a simple, effective strategy for calibrating N; we start the training with N = and when the learner reaches the allowed memory size, we shrink N to N/2 by pruning sub-trees rooted by rarer features with RANK(f ) > N/2 in the weight trie.",
        "Figures 3 and 4 plot training time with PA-I variants (d = 3) for the two tasks as a function of the training data size.",
        "PA-I SP inherited the demerit of PA-I KERNEL which takes quadratic time in the number of examples, while PA-I SL took almost linear time in the number of examples.",
        "PA-I",
        "1",
        "88.56%",
        "3s",
        "55MB",
        "PA-I",
        "1",
        "91.75%",
        "2s",
        "28MB",
        "^1-LLM",
        "2",
        "90.55%",
        "340s",
        "1656MB",
        "^1-LLM",
        "2",
        "92.67%",
        "136s",
        "1683MB",
        "svm",
        "2",
        "90.76%",
        "29863s",
        "245MB",
        "svm",
        "2",
        "92.85%",
        "12306s",
        "139MB",
        "PA-I KERNEL",
        "2",
        "90.68%",
        "8361s",
        "84MB",
        "PA-I KERNEL",
        "2",
        "92.91%",
        "1251s",
        "54MB",
        "PA-I KE",
        "2",
        "90.67%",
        "41s",
        "155MB",
        "PA-I KE",
        "2",
        "92.96%",
        "27s",
        "143MB",
        "pA- sln=4000",
        "2",
        "90.71%",
        "33s",
        "95MB",
        "pA- sln=8000",
        "2",
        "92.88%",
        "17s",
        "77MB",
        "^1-LLM",
        "3",
        "90.76%",
        "4057s",
        "21,499MB",
        "^1-LLM",
        "3",
        "92.86%",
        "779s",
        "14,089MB",
        "svm",
        "3",
        "90.93%",
        "25912s",
        "243MB",
        "svm",
        "3",
        "93.09%",
        "17354s",
        "140MB",
        "PA-I KERNEL",
        "3",
        "90.90%",
        "8704s",
        "83MB",
        "PA-I KERNEL",
        "3",
        "93.14%",
        "1074s",
        "49MB",
        "PA-I KE",
        "3",
        "90.90%",
        "465s",
        "993MB",
        "PA-I KE",
        "3",
        "93.11%",
        "103s",
        "751MB",
        "PA-I SLn=250",
        "3",
        "90.89%",
        "262s",
        "175MB",
        "PA-I SLn=125",
        "3",
        "93.05%",
        "17s",
        "131MB",
        "Figure 3: Training time for pa-i variants as a function of the number of training examples in dependency parsing task (d = 3)."
      ]
    },
    {
      "heading": "5. Related Work",
      "text": [
        "There are several methods that learn 'simpler' models with fewer variables (features or support vectors), to ensure scalability in training.",
        "Researchers have employed feature selection to assure space-efficiency in linear training.",
        "Wu et al.",
        "(2007) used frequent-pattern mining to select effective conjunctive features prior to training.",
        "Okanohara and Tsujii (2009) revised grafting for ^1-llm (Perkins et al., 2003) to prune useless conjunctive features during training.",
        "Iwakura and Okamoto (2008) proposed a boosting-based method that repeats the learning of rules represented by feature conjunctions.",
        "These methods, however, require us to tune the hyperparameter to trade model accuracy and the number of conjunctive features (memory footprint and training time); note that an accurate model may need many conjunctive features (in the hyponymy-relation extraction task, ^1-llm needed 15,828,122 features to obtain the best accuracy, 92.86%).",
        "Our method, on the other hand, takes all conjunctive features into consideration regardless of parameter N.",
        "improved the scalability of the (kernel) percep-tron, by exploiting redundancy in the training data to bound the size of the support set to given threshold B (> |St|).",
        "However, Orabona et al.",
        "(2009) reported that the models trained with these methods were just as accurate as a naive method that ceases training when |St| reaches the same threshold, B.",
        "They then proposed budget online learning based on pa-1, and it reduced the size of the support set to a tenth with a tolerable loss of accu-",
        "Figure 4: Training time for pa-i variants as a function of the number of training examples in hyponymy-relation extraction task (d = 3).",
        "racy.",
        "Their method, however, requires O ( 11 ) time in updating the parameters in round t, which disables efficient training.",
        "We have proposed an orthogonal approach that exploits the data redundancy in evaluating the kernel to train the same model as the base learner."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "In this paper, we proposed online learning with kernel slicing, aiming at resolving the space-time trade-off in training a classifier with many conjunctive features.",
        "The kernel slicing generalizes kernel splitting (Goldberg and Elhadad, 2008) in a purely feature-wise manner, to truly combine the merits of linear and kernel-based training.",
        "To improve the scalability of the training with redundant data in nlp, we reuse the temporal partial margins computed in past rounds and terminate unnecessary margin computations.",
        "Experiments on dependency parsing and hyponymy-relation extraction demonstrated that our method could train a classifier orders of magnitude faster than kernel-based learners, while retaining its space efficiency.",
        "We will evaluate our method with ample labeled data obtained by the semi-supervised methods.",
        "The implementation of the proposed algorithm for kernel-based online learners is available from http://www.tkl.iis.u-tokyo.ac.jp/~ynaga/.",
        "Acknowledgment We thank Susumu Yata for providing us practical lessons on the double-array trie, and thank Yoshimasa Tsuruoka for making his ^1-llm code available to us.",
        "We are also indebted to Nobuhiro Kaji and the anonymous reviewers for their valuable comments."
      ]
    }
  ]
}
