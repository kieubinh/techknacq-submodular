{
  "info": {
    "authors": [
      "Amarnag Subramanya",
      "Slav Petrov",
      "Fernando Pereira"
    ],
    "book": "EMNLP",
    "id": "acl-D10-1017",
    "title": "Efficient Graph-Based Semi-Supervised Learning of Structured Tagging Models",
    "url": "https://aclweb.org/anthology/D10-1017",
    "year": 2010
  },
  "references": [
    "acl-N03-1033",
    "acl-N09-1014",
    "acl-P06-1063",
    "acl-P07-1033",
    "acl-P07-1096",
    "acl-P09-1056",
    "acl-P95-1026",
    "acl-W06-1615"
  ],
  "sections": [
    {
      "text": [
        "Google Research Mountain View, CA 94043",
        "Google Research New York, NY 10011",
        "Google Research",
        "Mountain View, CA 94043",
        "We describe a new scalable algorithm for semi-supervised training of conditional random fields (CRF) and its application to part-of-speech (POS) tagging.",
        "The algorithm uses a similarity graph to encourage similar n-grams to have similar POS tags.",
        "We demonstrate the efficacy of our approach on a domain adaptation task, where we assume that we have access to large amounts of unlabeled data from the target domain, but no additional labeled data.",
        "The similarity graph is used during training to smooth the state posteriors on the target domain.",
        "Standard inference can be used at test time.",
        "Our approach is able to scale to very large problems and yields significantly improved target domain accuracy."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Semi-supervised learning (SSL) is the use of small amounts of labeled data with relatively large amounts of unlabeled data to train predictors.",
        "In some cases, the labeled data can be sufficient to provide reasonable accuracy on in-domain data, but performance on even closely related out-of-domain data may lag far behind.",
        "Annotating training data for all sub-domains of a varied domain such as all of Web text is impractical, giving impetus to the development of SSL techniques that can learn from unla-beled data to perform well across domains.",
        "The earliest SSL algorithm is self-training (Scudder, 1965), where one makes use of a previously trained model to annotate unlabeled data which is then used to retrain the model.",
        "While self-training is widely used and can yield good results in some applications (Yarowsky, 1995), it has no theoretical guarantees except under certain stringent conditions, which rarely hold in practice(Haffari and Sarkar, 2007).",
        "Other SSL methods include co-training (Blum and Mitchell, 1998), transductive support vector machines (SVMs) (Joachims, 1999), and graph-based SSL (Zhu et al., 2003).",
        "Several surveys cover a broad range of methods (Seeger, 2000; Zhu, 2005; Chapelle et al., 2007; Blitzer and Zhu, 2008).",
        "A majority of SSL algorithms are computationally expensive; for example, solving a transductive SVM exactly is intractable.",
        "Thus we have a conflict between wanting to use SSL with large unlabeled data sets for best accuracy, but being unable to do so because of computational complexity.",
        "Some researchers attempted to resolve this conflict by resorting to approximations (Collobert et al., 2006), but those lead to suboptimal results (Chapelle et al., 2007).",
        "Graph-based SSL algorithms (Zhu et al., 2003; Joachims, 2003; Corduneanu and Jaakkola, 2003; Belkin et al., 2005; Subramanya and Bilmes, 2009) are an important subclass of SSL techniques that have received much attention in the recent past, as they outperform other approaches and also scale easily to large problems.",
        "Here one assumes that the data (both labeled and unlabeled) is represented by vertices in a graph.",
        "Graph edges link vertices that are likely to have the same label.",
        "Edge weights govern how strongly the labels of the nodes linked by the edge should agree.",
        "Most previous work in SSL has focused on unstructured classification problems, that is, problems with a relatively small set of atomic labels.",
        "There has been much less work on SSL for structured prediction where labels are composites of many atomic labels with constraints between them.",
        "While the number of atomic labels might be small, there will generally be exponentially many ways to combine them into the final structured label.",
        "Structured prediction problems over sequences appear for example in speech recognition, named-entity recognition, and part-of-speech tagging; in machine translation and syntactic parsing, the output may be tree-structured.",
        "Altun et al.",
        "(2005) proposed a max-margin objective for semi-supervised learning over structured spaces.",
        "Their objective is similar to that of manifold regularization (Belkin et al., 2005) and they make use of a graph as a smoothness regularizer.",
        "However their solution involves inverting a matrix whose size depends on problem size, making it impractical for very large problems.",
        "Brefeld and Scheffer (2006) present a modified version of the co-training algorithm for structured output spaces.",
        "In both of the above cases, the underlying model is based on structured SVM, which does not scale well to very large datasets.",
        "More recently Wang et al.",
        "(2009) proposed to train a conditional random field (CRF) (Lafferty et al., 2001) using an entropy-based regularizer.",
        "Their approach is similar to the entropy minimization algorithm (Grandvalet and Bengio, 2005).",
        "The problem here is that their objective is not convex and thus can pose issues for large problems.",
        "Further, graph-based SSL algorithms outperform algorithms based on entropy minimization (Chapelle et al., 2007).",
        "In this work, we propose a graph-based SSL method for CRFs that is computationally practical for very large problems, unlike the methods in the studies cited above.",
        "Our method is scalable because it trains with efficient standard building blocks for CRF inference and learning and also standard graph label propagation machinery.",
        "Graph regular-izer computations are only used for training, so at test time, standard CRF inference can be used, unlike in graph-based transductive methods.",
        "Briefly, our approach starts by training a CRF on the source domain labeled data, and then uses it to decode unla-beled data from the target domain.",
        "The state posteriors on the target domain are then smoothed using the graph regularizer.",
        "Best state sequences for the unla-beled target data are then created by Viterbi decoding with the smoothed state posteriors, and this automatic target domain annotation is combined with the labeled source domain data to retrain the CRF.",
        "We demonstrate our new method in domain adaptation for a CRF part-of-speech (POS) tagger.",
        "While POS tagging accuracies have reached the level of inter-annotator agreement (>97%) on the standard PennTreebank test set (Toutanova et al., 2003; Shen et al., 2007), performance on out-of-domain data is often well below 90%, impairing language processing tasks that need syntactic information.",
        "For example, on the question domain used in this paper, the tagging accuracy of a supervised CRF is only 84%.",
        "Our domain adaptation algorithm improves performance to 87%, which is still far below in-domain performance, but a significant reduction in error."
      ]
    },
    {
      "heading": "2. Supervised CRF",
      "text": [
        "We assume that we have a set of labeled source domain examples Dl = {(xl, yi)}'=1, but only unlabeled target domain examples Du = {x}i=u+1.",
        "Here xl = x\\ x\\ ••• x\\ is the sequence of words in sentence % and yl = yi y\\ • • • yi is the corresponding POS tag sequence, with yl G Y where Y is the set of POS tags.",
        "Our goal is to learn a CRF of the form:",
        "p(yi |xi; A) ocexp for the target domain.",
        "In the above equation, A = {\\u ...,\\k } g Rk , fk (y(j-1), y(j), x,j ) is the k-th feature function applied to two consecutive CRF states and some window of the input sequence, and Xk is the weight of that feature.",
        "We discuss our features in detail in Section 6.",
        "Given only labeled data T>i, the optimal feature weights are given by:",
        "Here ||A|| is the squared ^2-norm and acts as the regularizer, and 7is atrade-offparameterwhoseset-ting we discuss in Section 6.",
        "In our case, we also have access to the unlabeled data Du from the target domain which we would like to use for training the CRF.",
        "We first describe how we construct a similarity graph over the unlabeled which will be used in our algorithm as a graph regularizer."
      ]
    },
    {
      "heading": "3. Graph Construction",
      "text": [
        "Graph construction is the most important step in graph-based SSL.",
        "The standard approach for unstructured problems is to construct a graph whose vertices are labeled and unlabeled examples, and whose weighted edges encode the degree to which the examples they link should have the same label (Zhu et al., 2003).",
        "Then the main graph construction choice is what similarity function to use for the weighted edges between examples.",
        "However, in structured problems the situation is more complicated.",
        "Consider the case of sequence tagging we are studying.",
        "While we might be able to choose some appropriate sequence similarity to construct the graph, such as edit distance or a string kernel, it is not clear how to use whole sequence similarity to constrain whole tag sequences assigned to linked examples in the learning algorithm.",
        "Al-tun et al.",
        "(2005) had the nice insight of doing the graph construction not for complete structured examples but instead for the parts of structured examples (also known as factors in graphical model terminology), which encode the local dependencies between input data and output labels in the structured problem.",
        "However, their approach is too demanding computationally (see Section 5), so instead we use local sequence contexts as graph vertices, exploting the empirical observation that the part of speech of a word occurrence is mostly determined by its local context.",
        "Specifically, the set V of graph vertices consists of all the word n-grams (types) that have occurrences (tokens) in training sentences (labeled and unlabeled).",
        "We partition V = V U Vu where V corresponds to n-grams that occur at least once in the labeled data, and Vu corresponds to n-grams that occur only in the unlabeled data.",
        "Given a symmetric similarity function between types to be defined below, we link types u and v with an edge of weight wuv, defined as:",
        "where K(u) is the set of k-nearest neighbors of u according to the given similarity.",
        "For all experiments in this paper, n = 3 and k = 5.",
        "To define the similarity function, for each token of a given type in the labeled and unlabeled data, we extract a set of context features.",
        "For example, for the token x2 x3 x4 occurring in the sequence x1 x2 x3 x4 x5, we use feature templates that capture the left (x1 x2) and right contexts (x4 x5).",
        "Additionally, we extract suffix features from the word in the middle.",
        "Table 1 gives an overview of the features that we used.",
        "For each n-gram type, we compute the vector of pointwise mutual information (PMI) values between the type and each of the features that occur with tokens of that type.",
        "Finally, we use the cosine distance between those PMI vectors as our similarity function.",
        "We have thus circumvented the problem of defining similarities over sequences by defining the graph over types that represent local sequence contexts.",
        "Since our CRF tagger only uses local features of the input to score tag pairs, we believe that the graph we construct captures all significant context information.",
        "Figure 1 shows an excerpt from our graph.",
        "The figure shows the neighborhoods of a subset of the vertices with the center word 'book.'",
        "To reduce clutter, we included only closest neighbors and the edges that involve the nodes of interest.",
        "Description",
        "Feature",
        "Trigram + Context",
        "x1 x2 x3 x4 x5",
        "Trigram",
        "x2 x3 x4",
        "Left Context",
        "x1 x2",
        "Right Context",
        "Center Word",
        "x2",
        "Trigram - Center Word",
        "x2 x4",
        "Left Word + Right Context",
        "x2 x4 x5",
        "Left Context + Right Word",
        "x1 x2 x4",
        "Suffix",
        "HasSuffix(xs)",
        "[to schedule a] [to postpone a] [the auction on] [to approve some] __--^(jf[to book some] *■-.",
        "r, flW I [you log a] [to fly some]",
        "[a movie agent] [a book agent] [the movie that] [to approve parental-consent] [you unrar a] [the conference speakers] [the job that] [the city that] [the constituition that]",
        "Figure 1: Vertices with center word 'book' and their local neighborhoods, as well as the shortest-path distance between them.",
        "Note that the noun (NN) and verb (VB) interpretations form two disjoint connected components.",
        "It is remarkable that the neighborhoods are coherent, showing very similar syntactic configurations.",
        "Furthermore, different vertices that (should) have the same label are close to each other, forming connected components for each part-of-speech category (for nouns and verbs in the figure).",
        "We expect the similarity graph to provide information that cannot be expressed directly in a sequence model.",
        "In particular, it is not possible in a CRF to directly enforce the constraint that similar trigrams appearing in different sentences should have similar POS tags.",
        "This constraint however is important during (semi-supervised) learning, and is what makes our approach different and more effective than self-training.",
        "In practice, we expect two main benefits from our graph-based approach.",
        "First, the graph allows new features to be discovered.",
        "Many words occur only in the unlabeled data and a purely supervised CRF would not be able to learn feature weights for those observations.",
        "We could use self-training to learn weights for those features, but self-training just tends to reinforce the knowledge that the supervised model already has.",
        "The similarity graph on the other hand can link events that occur only in the unlabeled data to similar events in the labeled data.",
        "Furthermore, because the graph is built over types rather than tokens, it will encourage the same interpretation to be chosen for similar trigrams occurring in different sentences.",
        "For example, the word 'unrar' will most likely not occur in the labeled training data.",
        "Seeing it in the neighborhood of words for which we know the POS tag will help us learn the correct POS tag for this otherwise unknown word (see Figure 1).",
        "Second, the graph propagates adjustments to the weights of known features.",
        "Many words occur only a handful of times in our labeled data, resulting in poor estimates of their contributions.",
        "Even for frequently occurring events, their distribution in the target domain might be different from their distribution in the source domain.",
        "While self-training might be able to help adapt to such domain changes, its effectiveness will be limited because the model will always be inherently biased towards the source domain.",
        "In contrast, labeled vertices in the similarity graph can help disambiguate ambiguous contexts and correct (some of) the errors of the supervised model."
      ]
    },
    {
      "heading": "4. Semi-Supervised CRF",
      "text": [
        "Given unlabeled data Du, we only have access to the prior p(x).",
        "As the CRF is a discriminative model, the lack of label information renders the CRF weights independent of p(x) and thus we cannot directly utilize the unlabeled data when training the CRF.",
        "Therefore, semi-supervised approaches to training discriminative models typically use the unlabeled data to construct a regularizer that is used to guide the learning process (Joachims, 1999; Lawrence and Jordan, 2005).",
        "Here we use the graph as a smoothness regularizer to train CRFs in a semi-supervised manner.",
        "Our algorithm iterates between the following five",
        "Algorithm 1 Semi-Supervised CRF Training As = crf-train(Di, A ) Set a04) = A(s)while not converged do {p} = posterior_decode(Du, Aoid)",
        "{q} = graph_propagate({q}) = viterbi_decode({q}, AoU )",
        "An++l = crf-train(D u A?)",
        "end while Return last A(t) simple (and convex) steps: Given a set of CRF parameters, we first compute marginals over the unlabeled data (posterior_decode).",
        "The marginals over tokens are then aggregated to marginals over types (token_to_type), which are used to initialize the graph label distributions.",
        "After running label propagation (graph_propagate), the posteriors from the graph are used to smooth the state posteriors.",
        "Decoding the unlabeled data (viterbLdecode) produces a new set of automatic annotations that can be combined with the labeled data to retrain the CRF using the supervised CRF training objective (crf-train).",
        "These steps, summarized in Algorithm 1, are iterated until convergence.",
        "Let a1*) (t refers to target domain) represent the estimate of the CRF parameters for the target domain after the nth iteration.",
        "In this step, we use the current parameter estimates to compute the marginal probabilities over POS tags for every word position j for i indexing over sentences in V\\ U Du.",
        "Recall that our graph is defined over types while the posteriors computed above involve particular tokens.",
        "We accumulate token-based marginals to create type marginals as follows.",
        "For a sentence i and word position j in that sentence, let Tbe the trigram (graph node) centered at position j. Conversely, for a trigram type u, let T-1(u) be the set of actual occurrences (tokens) of that trigram u; that is, all pairs (i, j) where i is the index of a sentence where u occurs and j is the position of the center word of an occurrence of u in that sentence.",
        "We calculate type-level posteriors as follows:",
        "This combination rule connects the token-centered CRF with the type-centered graph.",
        "Other ways of combining the token marginals, such as using weights derived from the entropies of marginals, might be worth investigating.",
        "We now use our similarity graph (Section 3) to smooth the type-level marginals by minimizing the following convex objective:",
        "uev,veN(i) uev",
        "where q = {q1, q2,... q|V |}.",
        "The setting of the hyperparameters ß and v will be discussed in Section 6, N(u) is the set of neighbors of node u, and ru is the empirical marginal label distribution for tri-gram u in the labeled data.",
        "We use a squared loss to penalize neighboring nodes that have different label distributions: | qu additionally regularizing the label distributions towards the uniform distribution U over all possible labels Y.",
        "It can be shown that the above objective is convex in q.",
        "Our graph propagation objective can be seen as a multi-class generalization of the quadratic cost criterion (Bengio et al., 2007).",
        "The first term in the above objective requires that we respect the information in our labeled data.",
        "The second term is the graph smoothness regularizer which requires that the qi's be smooth with respect to the graph.",
        "In other words, if Wuv is large, then qu and qv should be close in the squared-error sense.",
        "This implies that vertices u and v are likely to have similar marginals over POS tags.",
        "The last term is a regularizer and encourages all type marginals to be uniform to the extent that is allowed by the first two terms.",
        "If a unlabeled vertex does not have a path to any labeled vertex, this term ensures that the converged marginal for this vertex will be uniform over all tags, ensuring that our algorithm performs at least as well as a standard self-training based algorithm, as we will see later.",
        "While the objective in Equation 2 admits a closed form solution, it involves inverting a matrix of order | V | and thus we use instead the simple iterative update given by",
        "qur)(y) = where",
        "where m is the iteration index and ö is the indicator function that returns 1 if and only if the condition is true.",
        "The iterative procedure starts with qu0)(y) = qu(y) as given in the previous section.",
        "In all our experiments we run 10 iterations of the above algorithm, and we denote the type marginals at completion by qu(y).",
        "Given the type marginals computed in the previous step, we interpolate them with the original CRF token marginals.",
        "This interpolation between type and token marginals encourages similar n-grams to have similar posteriors, while still allowing n-grams in different sentences to differ in their posteriors.",
        "For each unlabeled sentence i and word position j in it, we calculate the following interpolated tag marginal:",
        "where a is a mixing coefficient which reflects the relative confidence between the original posteriors from the CRF and the smoothed posteriors from the graph.",
        "We discuss how we set a in Section 6.",
        "The interpolated marginals summarize all the information obtained so far about the tag distribution at each position.",
        "However, if we were to use them on their own to select the most likely POS tag sequence, the first-order tag dependencies modeled by the CRF would be mostly ignored.",
        "This happens because the type marginals obtained from the graph after label propagation will have lost most of the sequence information.",
        "To enforce the first-order tag dependencies we therefore use Viterbi decoding over the combined interpolated marginals and the CRF transition potentials to compute the best POS tag sequence for each unlabeled sentence.",
        "We refer to these 1-best transcripts as y*, i G Du.",
        "Now that we have successfully labeled the unlabeled target domain data, we can use it in conjunction with the source domain labeled data to retrain the CRF:",
        "Ai+i =argmin V logp(yi^A^) where n and 7 are hyper-parameters whose setting we discuss in Section 6.",
        "Given the new CRF parameters A we loop back to step 1 (Section 4.1) and iterate until convergence.",
        "It is important to note that every step of our algorithm is convex, although their combination clearly is not."
      ]
    },
    {
      "heading": "5. Related Work",
      "text": [
        "Our work differs from previous studies of and Yates, 2009) for improving POS tagging in several ways.",
        "First, our algorithm can be generalized to other structured semi-supervised learning problems, although POS tagging is our motivating task and test application.",
        "Unlike III (2007), we do not require target domain labeled data.",
        "While the SCL algorithm (Blitzer et al., 2006) has been evaluated without target domain labeled data, that evaluation was to some extent transductive in that the target test data (unlabeled) was included in the unsupervised stage of SCL training that creates the structural correspondence between the two domains.",
        "We mentioned already the algorithm of Altun et al.",
        "(2005), which is unlikely to scale up because its dual formulation requires the inversion of a matrix whose size depends on the graph size.",
        "Gupta et al.",
        "(2009) also constrain similar trigrams to have similar POS tags by forming cliques of similar tri-grams and maximizing the agreement score over these cliques.",
        "Computing clique agreement potentials however is NP-hard and so they propose approximation algorithms that are still quite complex computationally.",
        "We achieve similar effects by using our simple, scalable convex graph regularization framework.",
        "Further, unlike other graph-propagation algorithms (Alexandrescu and Kirchhoff, 2009), our approach is inductive.",
        "While one might be able to make inductive extensions of transductive approaches (Sindhwani et al., 2005), these usually require extensive computational resources at test time."
      ]
    },
    {
      "heading": "6. Experiments and Results",
      "text": [
        "We use the Wall Street Journal (WSJ) section of the Penn Treebank as our labeled source domain training set.",
        "We follow standard setup procedures for this task and train on sections 00-18, comprising of 38,219 POS-tagged sentences with a total of 912,344 words.",
        "To evaluate our domain-adaptation approach, we consider two different target domains: questions and biomedical data.",
        "Both target domains are relatively far from the source domain (newswire), making this a very challenging task.",
        "The QuestionBank (Judge et al., 2006), provides an excellent corpus consisting of 4,000 questions that were manually annotated with POS tags and parse trees.",
        "We used the first half as our development set and the second half as our test set.",
        "Questions are difficult to tag with WSJ-trained taggers primarily because the word order is very different than that of the mostly declarative sentences in the training data.",
        "Additionally, the unknown word rate is more than twice as high as on the in-domain development set (7.29% vs. 3.39%).",
        "As our unla-beled data, we use a set of 10 million questions collected from anonymized Internet search queries.",
        "These queries were selected to be similar in style and length to the questions in the QuestionBank.",
        "As running the CRF over 10 million sentences can be rather cumbersome and probably unnecessary, we randomly select 100,000 of these queries and treat this as Du.",
        "Because the graph nodes and the features used in the similarity function are based on n-grams, data sparsity can be a serious problem, and we therefore use the entire unlabeled data set for graph construction.",
        "We estimate the mutual information-based features for each trigram type over all the 10 million questions, and then construct the graph over only the set of trigram types that actually occurs in the 100,000 random subset and the WSJ training set.",
        "For our second target domain, we use the Penn BioTreebank (PennBioIE, 2005).",
        "This corpus consists of 1,061 sentences that have been manually annotated with POS tags.",
        "We used the first 500 sentences as a development set and the remaining 561 sentences as our final test set.",
        "The high unknown word rate (23.27%) makes this corpus very difficult to tag.",
        "Furthermore, the POS tag set for this data is a superset of the Penn Treebank's, including the two new tags HYPH (for hyphens) and AFX (for common post-modifiers of biomedical entities such as genes).",
        "These tags were introduced due to the importance of hyphenated entities in biomedical text, and are used for 1.8% of the words in the test set.",
        "Any tagger trained only on WSJ text will automatically predict wrong tags for those words.",
        "For unla-beled data we used 100,000 sentences that were chosen by searching MEDLINE for abstracts pertaining to cancer, in particular genomic variations and mutations (Blitzer et al., 2006).",
        "Since we did not have access to additional unlabeled data, we used the same set of sentences as target domain unlabeled data, Du.",
        "The graph here was constructed over the 100,000 un-labeled sentences and the WSJ training set.",
        "Finally, we remind the reader that we did not use label information for graph construction in either corpus.",
        "Our baseline supervised CRF is competitive with state-of-the-art discriminative POS taggers (Toutanova et al., 2003; Shen et al., 2007), achieving 97.17% on the WSJ development set (sections 1921).",
        "We use a fairly standard set of features, including word identity, suffixes and prefixes and detectors",
        "when, etc.",
        "), and have between 30 and 160 characters.",
        "for special characters such as dashes and digits.",
        "We do not use of observation-dependent transition features.",
        "Both supervised and semi-supervised models are regularized with a squared ^2-norm regularizer with weight set to 0.01.",
        "In addition to the supervised baseline trained exclusively on the WSJ, we also consider a semi-supervised self-trained baseline (\"Self-trained CRF\" in Table 2).",
        "In this approach, we first train a supervised CRF on the labeled data and then do semi-supervised training without label propagation.",
        "This is different from plain self-training because it aggregates the posteriors over tokens into posteriors over types.",
        "This aggregation step allows instances of the same trigram in different sentences to share information and works better in practice than direct self-training on the output of the supervised CRF.",
        "The data set obtained concatenating the WSJ training set with the 10 million questions had about 20 million trigram types.",
        "Of those, only about 1.1 million trigram types occurred in the WSJ training set or in the 100,000 sentence sub-sample.",
        "For the biomedical domain, the graph had about 2.2 million trigrams.",
        "For all our experiments we set hyperparameters as follows: for graph propagation, ß = 0.5, v = 0.01, for Viterbi decoding mixing, a = 0.6, for CRF re-training, n = 0.001, 7 = 0.01.",
        "These parameters were chosen based on development set performance.",
        "All CRF objectives were optimized using L-BFGS (Bertsekas, 2004).",
        "Table 2 shows the results for both domains.",
        "For the question corpus, the supervised CRF performs at only 85% on the development set.",
        "While it is almost impossible to improve in-domain tagging accuracy and tagging is therefore considered a solved problem by many, these results clearly show that the problem is far from solved.",
        "Self-training improves over the baseline by about 0.6% on the development set.",
        "However the gains from self-training are more modest (0.2%) on the evaluation (test) set.",
        "Our approach is able to provide a more solid improvement of about 3% absolute over the supervised baseline and about 2% absolute over the self-trained system on the question development set.",
        "Unlike self-training, on the question evaluation set, our approach provides about 3% absolute improvement over the supervised baseline.",
        "For the biomedical data, while the performances of our approach and self-training are statistically indistinguishable on the development set, we see modest gains of about 0.5% absolute on the evaluation set.",
        "On the same data, we see that our approach provides about 1.4% absolute improvement over the supervised baseline."
      ]
    },
    {
      "heading": "7. Analysis & Conclusion",
      "text": [
        "The results suggest that our proposed approach provides higher gains relative to self-training on the question data than on the biomedical corpus.",
        "We hypothesize that this caused by sparsity in the graph generated from the biomedical dataset.",
        "For the questions graph, the PMI statistics were estimated over 10 million sentences while in the case of the biomedical dataset, the same statistics were computed over just 100,000 sentences.",
        "We hypothesize that the lack of well-estimated features in the case of the biomedical dataset leads to a sparse graph.",
        "To verify the above hypothesis, we measured the percentage of trigrams that occur in the target domain (unlabeled) data that do not have any path to a trigram in the source domain data, and the average minimum path length between a trigram in the target data and a trigram in the source data (when such a path exists).",
        "The results are shown in Table 3.",
        "For the biomedical data, close to 50% of the trigrams from the target data do not have a path to a trigram from the source data.",
        "Even when such a path exists, the average path length is about 22.",
        "On",
        "Questions",
        "Bio",
        "Dev",
        "Eval",
        "Dev",
        "Eval",
        "Supervised CRF",
        "84.8",
        "83.8",
        "86.5",
        "86.2",
        "Self-trained CRF",
        "85.4",
        "84.0",
        "87.5",
        "87.1",
        "Semi-supervised CRF",
        "87.6",
        "86.8",
        "87.5",
        "87.6",
        "Table 3: Analysis of the graphs constructed for the two datasets discussed in Section 6.",
        "Unlabeled trigrams occur in the target domain only.",
        "Labeled trigrams occur at least once in the WSJ training data.",
        "the other hand, for the question corpus, only about 12% of the target domain trigrams are disconnected, and the average path length is about 9.",
        "These results clearly show the sparse nature of the biomedical graph.",
        "We believe that it is this sparsity that causes the graph propagation to not have a more noticeable effect on the final performance.",
        "It is noteworthy that making use of even such a sparse graph does not lead to any degradation in results, which we attribute to the choice of graph-propagation regular-izer (Section 4.3).",
        "We presented a simple, scalable algorithm for training structured prediction models in a semi-supervised manner.",
        "The approach is based on using as a regularizer a nearest-neighbor graph constructed over trigram types.",
        "Our results show that the approach not only scales to large datasets but also produces significantly improved tagging accuracies.",
        "Questions",
        "Bio",
        "% of unlabeled trigrams not connected to any labeled trigrams",
        "12.4",
        "46.8",
        "average path length between an unlabeled trigram and its nearest labeled trigram",
        "9.4",
        "22.4"
      ]
    }
  ]
}
