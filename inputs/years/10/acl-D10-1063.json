{
  "info": {
    "authors": [
      "Mark Hopkins",
      "Greg Langmead"
    ],
    "book": "EMNLP",
    "id": "acl-D10-1063",
    "title": "SCFG Decoding Without Binarization",
    "url": "https://aclweb.org/anthology/D10-1063",
    "year": 2010
  },
  "references": [
    "acl-D09-1007",
    "acl-J07-2003",
    "acl-N06-1033",
    "acl-N09-1026",
    "acl-P02-1040",
    "acl-P07-1019"
  ],
  "sections": [
    {
      "text": [
        "Mark Hopkins and Greg Langmead",
        "SDL Language Weaver, Inc. 6060 Center Drive, Suite 150 Los Angeles, CA 90045",
        "Conventional wisdom dictates that synchronous context-free grammars (SCFGs) must be converted to Chomsky Normal Form (CNF) to ensure cubic time decoding.",
        "For arbitrary SCFGs, this is typically accomplished via the synchronous binarization technique of (Zhang et al., 2006).",
        "A drawback to this approach is that it inflates the constant factors associated with decoding, and thus the practical running time.",
        "(DeNero et al., 2009) tackle this problem by defining a superset of CNF called Lexical Normal Form (LNF), which also supports cubic time decoding under certain implicit assumptions.",
        "In this paper, we make these assumptions explicit, and in doing so, show that LNF can be further expanded to a broader class of grammars (called \"scope-3\") that also supports cubic-time decoding.",
        "By simply pruning non-scope-3 rules from a GHKM-extracted grammar, we obtain better translation performance than synchronous bi-narization."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "At the heart of bottom-up chart parsing (Younger, 1967) is the following combinatorial problem.",
        "We have a context-free grammar (CFG) rule (for instance, S – NP VP PP) and an input sentence of length n (for instance, \"on the fast jet ski of mr smith\").",
        "During chart parsing, we need to apply the rule to all relevant subspans of the input sentence.",
        "See Figure 1.",
        "For this particular rule, there are (n+) application contexts, i.e. ways to choose the subspans.",
        "Since the asymptotic running time of chart parsing is at least linear in this quantity, it will take",
        "choice point choice choice choice",
        "Figure 1: A demonstration of application contexts.",
        "There are application contexts for the CFG rule \"S – NP VP PP\", where n is the length of the input sentence.",
        "at least O((n~+^ ) = O(n) time if we include this rule in our grammar.",
        "Fortunately, we can take advantage of the fact that any CFG has an equivalent representation in Chomsky Normal Form (CNF).",
        "In CNF, all rules have the form X – Y Z or X – x, where x is a terminal and X, Y, Z are nonterminals.",
        "If a rule has the form X – Y Z, then there are only (n+) application contexts, thus the running time of chart parsing is O^n+^ ) = O(n) when applied to CNF grammars.",
        "A disadvantage to CNF conversion is that it increases both the overall number of rules and the overall number of nonterminals.",
        "This inflation of the \"grammar constant\" does not affect the asymptotic runtime, but can have a significant impact on the performance in practice.",
        "For this reason, (DeN-",
        "on",
        "the",
        "fast",
        "jet",
        "NP",
        "VP",
        "PP",
        "NP",
        "VP",
        "PP",
        "NP",
        "VP",
        "PP",
        "NP",
        "VP",
        "PP",
        "choice point choice point",
        "Figure 2 A demonstration of application contexts for rules with lexical anchors.",
        "There are O(n) application contexts for CFG rule \"S – the NPB of NNP\", and O(n ) application contexts for CFG rule \"S – the JJ NPB of NNP\", if we assume that the input sentence has length n and contains no repeated words.",
        "ero et al., 2009) provide a relaxation of CNF called Lexical Normal Form (LNF).",
        "LNF is a superclass of CNF that also allows rules whose right-hand sides have no consecutive nonterminals.",
        "The intuition is that the terminals provide anchors that limit the applicability of a given rule.",
        "For instance, consider the rule NP – the NPB of NNP.",
        "See Figure 2.",
        "Because the terminals constrain our choices, there are only two different application contexts.",
        "The implicit assumption is that input sentences will not repeat the same word more than a small constant number of times.",
        "If we make the explicit assumption that all words of an input sentence are unique, then there are O(n) application contexts for a \"no consecutive nonterminals\" rule.",
        "Thus under this assumption, the running time of chart parsing is still O(n) when applied to LNF grammars.",
        "But once we make this assumption explicit, it becomes clear that we can go even further than LNF and still maintain the cubic bound on the runtime.",
        "Consider the rule NP – the JJ NPB of NNP.",
        "This rule is not LNF, but there are still only O(n) application contexts, due to the anchoring effect of the terminals.",
        "In general, for a rule of the form X – 7, there are at most O(np) application contexts, where p is the number of consecutive nonterminal pairs in the string X 7• X (where X is an arbitrary nonterminal).",
        "We refer to p as the scope of a rule.",
        "Thus chart parsing runs in time O(nscope(G)), where scope(G) is the maximum scope of any of the rules in CFG G. Specifically, any scope-3 grammar can be decoded in cubic time.",
        "Like (DeNero et al., 2009), the target of our interest is synchronous context-free grammar (SCFG) decoding with rules extracted using the GHKM algorithm (Galley et al., 2004).",
        "In practice, it turns out that only a small percentage of the lexical rules in our system have scope greater than 3.",
        "By simply removing these rules from the grammar, we can maintain the cubic running time of chart parsing without any kind of binarization.",
        "This has three advantages.",
        "First, we do not inflate the grammar constant.",
        "Second, unlike (DeNero et al., 2009), we maintain the synchronous property of the grammar, and thus can integrate language model scoring into chart parsing.",
        "Finally, a system without binarized rules is considerably simpler to build and maintain.",
        "We show that this approach gives us better practical performance than a mature system that binarizes using the technique of (Zhang et al., 2006)."
      ]
    },
    {
      "heading": "2. Preliminaries",
      "text": [
        "Assume we have a global vocabulary of symbols, containing the reserved substitution symbol 0.",
        "Define a sentence as a sequence of symbols.",
        "We will typically use space-delimited quotations to represent example sentences, e.g. \"the fast jet ski\" rather than (the, fast, jet, ski).",
        "We will use the dot operator to represent the concatenation of sentences, e.g. \"the fast\" • \"jet ski\" = \"the fast jet ski\".",
        "Define the rank of a sentence as the count of its 0 symbols.",
        "We will use the notation SUB(s,s1 ,...,Sk) to denote the substitution of k sentences s1,...,sk into a k-rank sentence s. For instance, if s = \"the 0 0 of 0\", then SUB(s, \"fast\", \"jet ski\", \"mr smith\") = \"the fast jet ski of mr smith\".",
        "To refer to a subsentence, define a span as a pair [a, b] of nonnegative integers such that a < b.",
        "For a sentence s = (s1, s2,sn) and a span [a, b] such that b < n, define s^j = (sa+i,s6).",
        "on",
        "the",
        "fast",
        "jet",
        "ski",
        "of",
        "mr",
        "smith",
        "the",
        "NPB",
        "of",
        "NNP",
        "the",
        "NPB",
        "of",
        "NNP",
        "choice point",
        "on",
        "the",
        "fast",
        "jet",
        "ski",
        "of",
        "mr",
        "smith",
        "the",
        "JJ",
        "NPB",
        "of",
        "NNP",
        "the",
        "JJ",
        "NPB",
        "of",
        "NNP",
        "the",
        "JJ",
        "NPB",
        "of",
        "NNP",
        "the",
        "JJ",
        "NPB",
        "of",
        "NNP",
        "JJ -> fast NN -> jet ski NNP -> mr smith",
        "Figure 3 An example CFG derivation (above) and an example SCFG derivation (below).",
        "Both derive the sentence sub(\"on 0\", sub( \"the 0 0 of 0\", \"fast\", \"jet ski\", \"mr smith\") ) = \"on the fast jet ski of mr smith\".",
        "The SCFG derivation simultaneously derives the auxiliary sentence \"sur le jet ski vite de m smith\"."
      ]
    },
    {
      "heading": "3. Minimum Derivation Cost",
      "text": [
        "Chart parsing solves a problem which we will refer to as Minimum Derivation Cost.",
        "Because we want our results to be applicable to both CFG decoding and SCFG decoding with an integrated language model, we will provide a somewhat more abstract formulation of chart parsing than usual.",
        "In Figure 3, we show an example of a CFG derivation.",
        "A derivation is a tree of CFG rules, constructed so that the preconditions (the RHS nonterminals) of any rule match the postconditions (the LHS nonterminal) of its child rules.",
        "The purpose of a derivation is to derive a sentence, which is obtained through recursive substitution.",
        "In the example, we substitute \"fast\", \"jet ski\", and \"mr smith\" into the lexical pattern \"the 0 0 of 0\" to obtain \"the fast jet ski of mr smith\".",
        "Then we substitute this result into the lexical pattern \"on 0\" to obtain \"on the fast jet ski of mr smith\".",
        "The cost of a derivation is simply the sum of the base costs of its rules.",
        "Thus the cost of the CFG derivation in Figure 3 is C1 + C2 + C3 + C4 + C5, where C1 is the base cost of rule \"PP – on NP\", etc.",
        "Notice that this cost can be distributed locally to the nodes of the derivation (Figure 4).",
        "An SCFG derivation is similar to a CFG deriva-",
        "Figure 4 The cost of the CFG derivation in Figure 3 is C1 + C2 + C3 + C4 + C5, where C1 is the base cost of rule \"PP – on NP\", etc.",
        "Notice that this cost can be distributed locally to the nodes of the derivation.",
        "tion, except that it simultaneously derives two sentences.",
        "For instance, the SCFG derivation in Figure 3 derives the sentence pair ( \"on the fast jet ski of mr smith\", \"sur le jet ski vite de m smith\" ).",
        "In machine translation, often we want the cost of the SCFG derivation to include a language model cost for this second sentence.",
        "For example, the cost ofthe SCFG derivation in Figure 3 might be C1+C2+C3+ C4+C5+LM (sur le)+LM (le jet) +LM (jet ski) + LM(ski de) + LM(de m) + LM(m smith), where LM is the negative log of a 2-gram language model.",
        "This new cost function can also be distributed locally to the nodes of the derivation, as shown in Figure 5.",
        "However, in order to perform the local computations, we need to pass information (in this case, the LM boundary words) up the tree.",
        "We refer to this extra information as carries.",
        "Formally, define a carry as a sentence of rank 0.",
        "In order to provide a chart parsing formulation that applies to both CFG decoding and SCFG decoding with an integrated language model, we need abstract definitions of rule and derivation that capture the above concepts of pattern, postcondition, preconditions, cost, and carries.",
        "Define a rule as a tuple (k, s*, X, n, r, c), where k is a nonnegative integer called the rank, s* is a rank-k",
        "postcondition preconditions postcondition preconditions rank",
        "Figure 5 The cost of the SCFG derivation in Figure 3 (with an integrated language model score) can also be distributed to the nodes of the derivation, but to perform the local computations, information must be passed up the tree.",
        "We refer to this extra information as a carry.",
        "sentence called the pattern , X is a symbol called the postcondition, n is a k-length sentence called the preconditions, r is a function (called the carry function) that maps a k-length list of carries to a carry, and c is a function (called the cost function) that maps a k-length list of carries to a real number.",
        "Figure 6 shows a CFG and an SCFG rule, deconstructed according to this definition.",
        "Note that the CFG rule has trivial cost and carry functions that map everything to a constant.",
        "We refer to such rules as simple.",
        "We will use post(r) to refer to the postcondition of rule r, and pre(r, i) to refer to the ith precondition of rule r.",
        "Finally, define a grammar as a finite set of rules.",
        "A grammar is simple if all its rules are simple.",
        "For a grammar R, define deriv(R) as the smallest set that contains every tuple (r, 51,ök) satisfying the following conditions",
        "Figure 6 Deconstruction of a CFG rule (left) and SCFG rule (right) according to the definition of rule in Section 3.1.",
        "The carry function of the SCFG rule computes boundary words for a 2-gram language model.",
        "In the cost functions, C is a real number and LM returns the negative log of a language model query.",
        "• r G R is a k-rank rule",
        "• pre(r, i) = post(r) for all 1 < i < k, where riis the first element of tuple",
        "An R-derivation is an element of deriv(R).",
        "Consider a derivation ö = (r,ö1,...,ök), where rule r = (k,s*,X, n, r, c).",
        "Define the following properties",
        "In words, we say that derivation ö derives sentence sent(ö).",
        "If for some span a of a particular sentence s, it holds that sent(ö) = sa, then we will say that ö is a derivation over span a.",
        "The Minimum Derivation Cost problem is the following.",
        "Given a set R of rules and an input sentence",
        "pattern",
        "the 0 0 of 0",
        "carry function",
        "r( \"\" , \"\" , \"\" ) = \"\"",
        "cost function",
        "c( \"\" , \"\" , \"\" ) = C",
        "pattern",
        "the 0 0 of 0",
        "carry function",
        "r( \"u*v\" , \"w*x\" , \"y*z\" )",
        "= \"le * z\"",
        "cost function",
        "C( \"u*v\" , \"W*X\" , \"y*z\" )",
        "= C + LM(w|le) + LM(u|x) + LM(de|v) + LM(y|de)",
        "Figure 7 An application context for the pattern \"the 0 0 of0\" andthe sentence \"onthe fastjetski ofmrsmith\".",
        "s, find the minimum cost of any R-derivation that derives s. In other words, compute",
        "MinDCost(R, s) = min cost(ö)"
      ]
    },
    {
      "heading": "4. Application Contexts",
      "text": [
        "Chart parsing solves Minimum Derivation Cost via dynamic programming.",
        "It works by building derivations over increasingly larger spans of the input sentence s. Consider just one of these spans a.",
        "How do we build a derivation over that span?",
        "Recall that a derivation takes the form (r,ö1,...,ök).",
        "Given the rule r and its pattern s*, we need to choose the subderivations öi such that sub(s*, sent(ö1),sent(ök)) = sa.",
        "To do so, we must match the pattern to the span, so that we know which subspans we need to build the subderivations over.",
        "Figure 7 shows a matching of the pattern \"the 0 0 of 0\" to span [1,8] of the sentence \"on the fast jet ski of mr smith\".",
        "It tells us that we can build a derivation over span [1, 8] by choosing this rule and subderivations over subspans [2, 3], [3, 5], and [6, 8].",
        "We refer to these matchings as application contexts.",
        "Formally, given two sentences s* and s of respective lengths m and n, define an (s*,s)-context as an monotonically increasing sequence (xo,x1, ...,xm) of integers between 0 and n such that for all i",
        "The context shown in Figure 7 is (1, 2, 3, 5, 6, 8).",
        "Use cxt(s*,s) to denote the set of all (s*,s)-contexts.",
        "An (s*, s)-context x = (x0, x1,xm) has the following properties",
        "Moreover, define varspans(x;s*,s) as the subsequence of subspans(x; s*,s) including only [xi-1,xi] suchthat s*i-1i] = 0.",
        "For the context x shown in Figure 7",
        "An application context x G cxt(s*, s) tells us that we can build a derivation over span(x) by choosing a rule with pattern s* and subderivations over each span in varspans(x; s*, s)."
      ]
    },
    {
      "heading": "5. Chart Parsing Algorithm",
      "text": [
        "We are now ready to describe the chart parsing algorithm.",
        "Consider a span a of our input sentence s and assume that we have computed and stored all derivations over any subspan of a.",
        "A naive way to compute the minimum cost derivation over span a is to consider every possible derivation 1.",
        "Choose arule r = (k,s*,X, n, r,c).",
        "2.",
        "Choose an application context x G cxt(s*, s) such that span(x; s*, s) = a.",
        "3.",
        "For each subspan ai G varspans(x; s*,s), choose a subderivation öi such that post(öi) =",
        "pre(r, i).",
        "The key observation here is the following.",
        "In order to score such a derivation, we did not actually need to know each subderivation in its entirety.",
        "We merely needed to know the following information about it (a) the subspan that it derives, (b) its postcondition, (c) its carry.",
        "on",
        "the",
        "fast",
        "jet",
        "ski",
        "of",
        "mr",
        "smith",
        "the",
        "0",
        "0",
        "of",
        "0",
        "1.",
        "Choose arule r = (k,s*,X, n, r,c).",
        "2.",
        "Choose an application context x G cxt(s*, s) such that span(x; s*, s) = a.",
        "Chart parsing takes advantage of the above observation to avoid building all possible derivations.",
        "Instead it groups together derivations that share a common subspan, postcondition, and carry, and records only the minimum cost for each equivalence class.",
        "It records this cost in an associative map referred to as the chart.",
        "Specifically, assume that we have computed and stored the minimum cost of every derivation class (a',X',7/), where X' is a postcondition, 7' is a carry, and a' is a proper subspan of a.",
        "Chart parsing computes the minimum cost of every derivation class (a, X, 7) by adapting the above naive method as follows",
        "3.",
        "For each subspan ai G varspans(x; s*,s), choosea derivation class (ai, Xi, 7i) fromthe chart such that Xi = pre(r, i)."
      ]
    },
    {
      "heading": "4.. Update 3 the cost of derivation class",
      "text": [
        "where chart[ai, Xi, 7i] refers to the stored cost of derivation class (ai, Xi, 7i).",
        "By iteratively applying the above method to all subspans of size 1, 2, etc., chart parsing provides an efficient solution for the Minimum Derivation Cost problem."
      ]
    },
    {
      "heading": "6. Runtime Analysis",
      "text": [
        "At the heart of chart parsing is a single operation the updating of a value in the chart.",
        "The running time is linear in the number of these chart updates.",
        "The typical analysis counts the number of chart updates per span.",
        "Here we provide an alternative analysis that counts the number of chart updates per rule.",
        "This provides us with a finer bound with practical implications.",
        "Let r be a rule with rank k and pattern s*.",
        "Consider the chart updates involving rule r. There is (potentially) an update for every choice of (a) span, (b) application context, and (c) list of k derivation classes.",
        "If we let C be the set of possible carries, then this means there are at most |cxt(s*, s)| • |C|kupdates involving rule r. If we are doing beam decoding (i.e. after processing a span, the chart keeps only the B items of lowest cost), then there are at most |cxt(s*, s)| • Bk updates.",
        "We can simplify the above by providing an upper bound for |cxt(s*,s)|.",
        "Define an ambiguity as the sentence \"0 0\", and define scope(s*) as the number of ambiguities in the sentence \"0\" -s*- \"0\".",
        "The following bound holds Lemma 1.",
        "Assume that a zero-rank sentence s does not contain the same symbol more than once.",
        "Then |cxt(s*,s)| < |s|scope(s*).",
        "Proof.",
        "Suppose s* and s have respective lengths m and n. Consider (x0, x1,xm) G cxt(s*,s).",
        "Let / be the set of integers i between 1 and m such that s* = 0 and let 1+ be the set of integers i between 0 and m – 1 such that s*+1 = 0.",
        "If i G /, then we know the value of xi, namely it is the unique integer j such that sj = s*.",
        "Similarly, if i G / +, then the value of xi must be the unique integer j such that sj = s*+1.",
        "Thus the only nondetermined elements of context xi are those for which i G 1U /+.",
        "Hence",
        "Hence, under the assumption that the input sentence s does not contain the same symbol more than once, then there are at most |s|scope(s*) • |£|k chart updates involving a rule with pattern s*.",
        "For a rule r with pattern s*, define scope(r) = scope(s*).",
        "For a grammar R, define scope(R) = maxreRscope(r) and rank(R) = maxreR rank(r).",
        "Given a grammar R and an input sentence s, the above lemma tells us that chart parsing makes",
        "O(|s|scope(R) • |c|rank(R)) chart updates.",
        "If we restrict ourselves to beam search, than chart parsing makes O(|s|scope(R)) chart updates.",
        "In practice, it will not be true that each input sentence contains only unique symbols, but it is not too far removed from the practical reality of many use cases, for which relatively few symbols repeat themselves in a given sentence.",
        "The above lemma can also be relaxed to assume only that there is a constant upper bound on the multiplicity of a symbol in the input sentence.",
        "This does not affect the O-bound on the number of chart updates, as long as we further assume a constant limit on the length of rule patterns."
      ]
    },
    {
      "heading": "7. Scope Reduction",
      "text": [
        "From this point of view, CNF binarization can be viewed as a specific example of scope reduction.",
        "Suppose we have a grammar R of scope p. See Figure 8.",
        "If we can find a grammar R of scope p < p which is \"similar\" to grammar R, then we can decode in O(np) rather than O(np) time.",
        "We can frame the problem by assuming the following parameters• a grammar R",
        "• a desired scope p",
        "• a loss function A that returns a (non-negative real-valued) score for any two grammars R and R; if A(R, R) = 0, then the grammars are considered to be equivalent",
        "A scope reduction method with loss A finds a grammar R such that scope(R) < p and A(R, R) = A.",
        "A scope reduction method is lossless when its loss is 0.",
        "In the following sections, we will use the loss function where s is a fixed input sentence.",
        "Observe that if A(R, R) = 0, then the solution to the Minimum",
        "Figure 8 The \"scope reduction\" problem.",
        "Given a grammar of large scope, find a similar grammar of reduced scope.",
        "Derivation Cost problem is the same for both R and",
        "A rule r is CNF if its pattern is \"0 0\" or \"x\", where x is any non-substitution symbol.",
        "A grammar is CNF if all of its rules are CNF.",
        "Note that the maximum scope of a CNF grammar is 3.",
        "CNF binarization is a deterministic process that maps a simple grammar to a CNF grammar.",
        "Since binarization takes subcubic time, we can decode with any grammar R in O(n) time by converting R to CNF grammar R, and then decoding with R. This is a lossless scope reduction method.",
        "What if grammar R is not simple?",
        "For SCFG grammars, (Zhang et al., 2006) provide a scope reduction method called synchronous binarization with quantifiable loss.",
        "Synchronous binarization selects a \"binarizable\" subgrammar R' of grammar R, and then converts R' into a CNF grammar R. The cost and carry functions of these new rules are constructed such that the conversion from R' to R is a lossless scope reduction.",
        "Thus the total loss of the method is |MinDCost(R, s) – MinDCost(R', s)|.",
        "Fortunately, they find in practice that R' usually contains the great majority of the rules of R, thus they",
        "AE Lexical ^*CE Lexical «^AE Nonlexical ^CE Nonlexical",
        "but not LNF or CNF.",
        "assert that this loss is negligable.",
        "A drawback of their technique is that the resulting CNF grammar contains many more rules and postconditions than the original grammar.",
        "These constant factors do not impact asymptotic performance, but do impact practical performance.",
        "Concerned about this inflation of the grammar constant, (DeNero et al., 2009) consider a superset of CNF called Lexical Normal Form (LNF).",
        "A rule is LNF if its pattern does not contain an ambiguity as a proper subsentence (recall that an ambiguity was defined to be the sentence \"0 0\").",
        "Like CNF, the maximum scope of an LNF grammar is 3.",
        "In the worst case, the pattern s* is \"0 0\", in which case there are three ambiguities in the sentence \"0\" •s^",
        "\"0\".",
        "(DeNero et al., 2009) provide a lossless scope reduction method that maps a simple grammar to an LNF grammar, thus enabling cubic-time decoding.",
        "Their principal objective is to provide a scope reduction method for SCFG that introduces fewer postconditions than (Zhang et al., 2006).",
        "However unlike (Zhang et al., 2006), their method only addresses simple grammars.",
        "Thus they cannot integrate LM scoring into their decoding, requiring them to rescore the decoder output with a variant of cube growing (Huang and Chiang, 2007).",
        "Figure 10: Breakdown of rules by scope (average per sentence in our test sets).",
        "In practice, most of the lexical rules applicable to a given sentence (95% for Arabic-English and 85% for Chinese-English) are scope 3 or less.",
        "To exercise the power of the ideas presented in this paper, we experimented with a third (and very easy) scope reduction method called scope pruning.",
        "If we consider the entire space of scope-3 grammars, we see that it contains a much richer set of rules than those permitted by CNF or LNF.",
        "See Figure 9 for examples.",
        "Scope pruning is a lossy scope reduction method that simply takes an arbitrary grammar and prunes all rules with scope greater than 3.",
        "By not modifying any rules, we preserve their cost and carry functions (enabling integrated LM decoding), without increasing the grammar constant.",
        "The practical question is: how many rules are we typically pruning from the original grammar?",
        "We experimented with two pretrained syntax-based machine translation systems with rules extracted via the GHKM algorithm (Galley et al., 2004).",
        "The first was an Arabic-English system, with rules extracted from 200 million words of parallel data from the NIST 2008 data collection, and with a 4-gram language model trained on 1 billion words of monolingual English data from the LDC Giga-word corpus.",
        "We evaluated this system's performance on the NIST 2008 test corpus, which consists of 1357 Arabic sentences from a mixture of newswire and web domains, with four English reference translations.",
        "The second system was a Chinese-",
        "a 00",
        "a b 0 0 c",
        "00 a",
        "0a 00b",
        "a 00 b",
        "a 0b 00",
        "0a 00",
        "00a 0b",
        "00a 0",
        "000a b",
        "000 a",
        "a 000b",
        "a 000",
        "a 0 0 b 0 c",
        "a b 00",
        "a 0000b",
        "00a b",
        "a 00 b c 00 d",
        "a 00b 0",
        "a 0000 b 0 c 0 d",
        "a 0 0 b c",
        "a 00b 00c 00d",
        "Arabic-English",
        "Chinese-English",
        "Figure 11: Speed-quality tradeoffcurves comparing thebaseline scope reductionmethod ofsynchronous binarization (dark gray diamonds) with scope-3 pruning (light gray squares).",
        "English system, with rules extracted from 16 million words of parallel data from the mainland-news domain of the LDC corpora, and with a 4-gram language model trained on monolingual English data from the AFP and Xinhua portions of the LDC Gi-gaword corpus.",
        "We evaluated this system's performance on the NIST 2003 test corpus, which consists of 919 Chinese sentences, with four English reference translations.",
        "For both systems, we report BLEU scores (Papineni et al., 2002) on untokenized, recapitalized output.",
        "In practice, how many rules have scope greater than 3?",
        "To answer this question, it is useful to distinguish between lexical rules (i.e. rules whose patterns contain at least one non-substitution symbol) and non-lexical rules.",
        "Only a subset of lexical rules are potentially applicable to a given input sentence.",
        "Figure 10 shows the scope profile of these applicable rules (averaged over all sentences in our test sets).",
        "Most of the lexical rules applicable to a given sentence (95% for Arabic-English, 85% for Chinese-English) are scope 3 or less.",
        "Note, however, that scope pruning also prunes a large percentage ofnon-lexical rules.",
        "Figure 11 compares scope pruning with the baseline technique of synchronous binarization.",
        "To generate these speed-quality tradeoff curves, we decoded the test sets with 380 different beam settings.",
        "We then plotted the hull of these 380 points, by eliminating any points that were dominated by another (i.e. had better speed and quality).",
        "We found that this simple approach to scope reduction produced a better speed-quality tradeoff than the much more complex synchronous binarization."
      ]
    },
    {
      "heading": "8. Conclusion",
      "text": [
        "In this paper, we made the following contributions:",
        "• We provided an abstract formulation of chart parsing that generalizes CFG decoding and SCFG decoding with an integrated LM.",
        "• We framed scope reduction as a first-class abstract problem, and showed that CNF binarization and LNF binarization are two specific solutions to this problem, each with their respective advantages and disadvantages.",
        "• We proposed a third scope reduction technique called scope pruning, and we showed that it can outperform synchronous CNF binarization for particular use cases.",
        "Moreover, this work gives formal expression to the extraction heuristics of hierarchical phrase-based translation (Chiang, 2007), whose directive not to extract SCFG rules with adjacent nonterminals can be viewed as a preemptive pruning of rules with scope greater than 2 (more specifically, the pruning of non-LNF lexical rules).",
        "In general, this work provides a framework in which different approaches to tractability-focused grammar construction can be compared and discussed.",
        "Kishore Papineni, Salim Roukos, Todd Ward, and Wei-Jing Zhu.",
        "2002.",
        "Bleu: a method for automatic evaluation of machine translation.",
        "In Proceedings of 40th Annual Meeting of the Association for Computational Linguistics, pages 311-318.",
        "Daniel Younger.",
        "1967.",
        "Recognition and parsing of context-free languages in time n. Information and Control, 10(2):189-208.",
        "Hao Zhang, Liang Huang, Daniel Gildea, and Kevin Knight.",
        "2006.",
        "Synchronous binarization for machine translation.",
        "In Proceedings ofthe Human Language Technology Conference ofthe NAACL, Main Conference, pages 256-263."
      ]
    }
  ]
}
