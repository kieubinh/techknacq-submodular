{
  "info": {
    "authors": [
      "Chris Dyer"
    ],
    "book": "Human Language Technologies: the 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics",
    "id": "acl-N10-1033",
    "title": "Two monolingual parses are better than one (synchronous parse)",
    "url": "https://aclweb.org/anthology/N10-1033",
    "year": 2010
  },
  "references": [
    "acl-D08-1023",
    "acl-J07-2003",
    "acl-J97-3002",
    "acl-N09-1049",
    "acl-P07-1019",
    "acl-P08-1012",
    "acl-P09-1104",
    "acl-P95-1022",
    "acl-W06-3119"
  ],
  "sections": [
    {
      "text": [
        "Two monolingual parses are better than one (synchronous parse)*",
        "UMIACS Laboratory for Computational Linguistics and Information Processing",
        "redpony AT umd.edu",
        "We describe a synchronous parsing algorithm that is based on two successive monolingual parses of an input sentence pair.",
        "Although the worst-case complexity of this algorithm is and must be 0(n) for binary SCFGs, its average-case runtime is far better.",
        "We demonstrate that for a number of common synchronous parsing problems, the two-parse algorithm substantially outperforms alternative synchronous parsing strategies, making it efficient enough to be utilized without resorting to a pruned search."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Synchronous context free grammars (SCFGs) generalize monolingual context-free grammars to generate strings concurrently in pairs of languages (Lewis and Stearns, 1968) in much the same way that finite state transducers (FSTs) generalize finite state automata (FSAs).",
        "Synchronous parsing is the problem of finding the best derivation, or forest of derivations, of a source and target sentence pair (f, e) under an SCFG, Q?",
        "Solving this problem is necessary for several applications, for example, optimizing how well an SCFG translation model fits parallel training data.",
        "Wu (1997) describes a bottom-up (9(n) synchronous parsing algorithm for ITGs, a binary SCFG with a restricted form.",
        "For general grammars, the situation is even worse: the problem has been shown to be NP-hard (Satta and Peserico, 2005).",
        "Even if we restrict ourselves to binary ITGs, the",
        "*This work was supported in part by the GALE program of DARPA, Contract No.",
        "HR0011-06-2-001.",
        "The author wishes to thank Philip Rensik, Adam Lopez, Phil Blunsom, and Jason Eisner for helpful discussions.",
        "(9(n) runtime makes large-scale learning applications infeasible.",
        "The usual solution is to use a heuristic search that avoids exploring edges that are likely (but not guaranteed) to be low probability (Zhang et al., 2008; Haghighi et al., 2009).",
        "In this paper, we derive an alternative synchronous parsing algorithm starting from a conception of parsing with SCFGs as a composition of binary relations.",
        "This enables us to factor the synchronous parsing problem into two successive monolingual parses.",
        "Our algorithm runs more efficiently than 0(n) with many grammars (including those that required using heuristic search with other parsers), making it possible to take advantage of synchronous parsing without developing search heuristics; and the SCFGs are not required to be in a normal form, making it possible to easily parse with more complex SCFG types."
      ]
    },
    {
      "heading": "2. Synchronous parsing",
      "text": [
        "Before presenting our algorithm, we review the 0(n) synchronous parser for binary ITGs.",
        "Wu (1997) describes a bottom-up synchronous parsing algorithm that can be understood as a generalization of the CKY algorithm.",
        "CKY defines a table consisting of n cells, with each cell corresponding to a span [i, j] in the input sentence; and the synchronous variant defines a table in 4 dimensions, with cells corresponding to a source span [s, t] and a target span [u,v].",
        "The bottom of the chart is initialized first, and pairs of items are combined from bottom to top.",
        "Since combining items from the n cells involves considering two split points (one source, one target), it is not hard to see that this algorithm runs in time 0(n).",
        "Generalizing the algorithm to higher rank grammars is possible (Wu, 1997), as is converting a grammar to a weakly equivalent binary form in some cases (Huang et al., 2009).",
        "We motivate an alternative conception of the synchronous parsing problem as follows.",
        "It has long been appreciated that monolingual parsing computes the intersection of an FSA and a CFG (Bar-Hillel et al., 1961; van Noord, 1995).",
        "That is, if S is an FSA encoding some sentence s, intersection of S with a CFG, Q, results in a parse forest which contains all and only derivations of s, that is L(S) D L(G) £ {{s}, 0}.",
        "Crucially for our purposes, the resulting parse forest is also itself a CFG.",
        "Figure 1 illustrates, giving two equivalent representations of the forest SnQ, once as a directed hypergraph and once as a CFG.",
        "While S D G appears similar to Q, the non-terminals (NTs) of the resulting CFG are a cross product of pairs of states from S and NTs from Ç.",
        "DT – a NN – forest NN – »• tree PRN – *-/",
        "S.",
        "Figure 1: A CFG, Q, an FSA, S, encoding a sentence, and two equivalent representations of the parse forest S n Q, (a) as a directed hypergraph and (b) as a CFG.",
        "When dealing with SCFGs, rather than intersection, parsing computes a related operation, composition.",
        "The standard MT decoding-by-parsing task can be understood as computing the composition of an FST, F, which encodes the source sentence f with the SCFG, Q, representing the translation model.",
        "The result is the translation forest, F o Q, which encodes all translations of f licensed by the translation model.",
        "While Q can generate a potentially infinite set of strings in the source and target languages, F o Q generates only f in the source language (albeit with possibly infinitely many derivations), but any number of different strings in the target language.",
        "It is not hard to see that a second composition operation of an FST, E, encoding the target string e with the e-side of FoQ (again using a monolingual parsing algorithm), will result in a parse forest that exactly derives (f, e), which is the goal of synchronous composition.",
        "Figure 2 shows an example.",
        "In F o Q o E the NTs (nodes) are the cross product of pairs of states from E, the NTs from Q, and pairs of states in F.",
        "Thus, synchronous parsing is the task of computing F o Q o E. Since composition is associative, we can compute this quantity either as (F o Q) o E or F o (Q o E).",
        "Alternatively, we can use an algorithm that performs 3-way composition directly.",
        "The two-parse algorithm refers to performing a synchronous parse by computing either (F o Q) o E or F o (Q o E).",
        "Each composition operation is carried out using a standard monolingual parsing algorithm, such as Earley's or CKY.",
        "In the experiments below, since we use e-free grammars, we use a variant of CKY for unrestricted CFGs (Chiang, 2007).",
        "Once the first composition is done, the resulting parse forest must be converted into a CFG representation that the second parser can utilize.",
        "This is straightforward to do: each node becomes a unique non-terminal symbol, with its incoming edges corresponding to different ways of rewriting it.",
        "Tails of edges are non-terminal variables in the RHS of these rewrites.",
        "A single bottom-up traversal of the forest is sufficient to perform the conversion.",
        "Since",
        "'intersection is a special case of composition where the input and output labels on the transducers are identical (Mohri, 2009).",
        "Figure 2: An SCFG, g, two FSAs, S and F, and two equivalent representations of F o g. The synchronous parse forest of the pair {ab, cd) with g is given under F o goE.",
        "our parser operates more efficiently with a deter-minized grammar, we left-factor the grammar during this traversal as well.",
        "Analysis.",
        "Monolingual parsing runs in worst case time, where n is the length of the input being parsed and \\Q\\ is a measure of the size of the grammar (Graham et al., 1980).",
        "Since the grammar term is constant for most typical parsing applications, it is generally not considered carefully; however, in the two-parse algorithm, the size of the grammar term for the second parse is not \\Q\\ but IF o QI, which clearly depends on the size of the input F; and so understanding the impact of this term is key to understanding the algorithm's run-time.",
        "If G is an e-free SCFG with non-terminals N and maximally two NTs in a rule's right hand side, and n is the number of states in F (corresponding to the number of words in the f in a sentence pair (f, e)), then the number of nodes in the parse forest F o Q will be 0(|iV| • n).",
        "This can be shown easily since by stipulation, we are able to use CKY+ to perform the parse, and there will be maximally as many nodes in the forest as there are cells in the CKY chart times the number of NTs.",
        "The number of edges will be 0(|iV| ■ n), which occurs when every node can be derived from all possible splits.",
        "This bound on the number of edges implies that |Fo Q\\ e 0(n).Therefore, the worst case runtime of the two-parse algorithm is 0{\\N\\-n-n + \\Ç\\-n) = 0{\\N\\-n), the same as the bound on the ITG algorithm.",
        "We note that while the ITG algorithm requires that the SCFGs be rank-2 and in a normal form, the two-parse algorithm analysis holds as long as the grammars are rank-2 and e-free."
      ]
    },
    {
      "heading": "3. Experiments",
      "text": [
        "We now describe two different synchronous parsing applications, with different classes of SCFGs, and compare the performance of the two-parse algorithm with that of previously used algorithms.",
        "Phrasal ITGs.",
        "Here we compare performance of the two-parse algorithm and the (9(n) ITG parsing algorithm on an Arabic-English phrasal ITG alignment task.",
        "We used a variant of the phrasal ITG described by Zhang et al.",
        "(2008).",
        "Figure 3 plots the average runtime of the two algorithms as a function of the Arabic sentence length.",
        "The two-parse approach is far more efficient.",
        "In total, aligning the 80k sentence pairs in the corpus completed in less than 4 hours with the two-parse algorithm but required more than 1 week with the baseline algorithm.",
        "\"Hiero\" grammars.",
        "An alternative approach to computing a synchronous parse forest is based on cube pruning (Huang and Chiang, 2007).",
        "While more commonly used to integrate a target m-gram LM during decoding, Blunsom et al.",
        "(2008), who required synchronous parses to discriminatively train",
        "How tight these bounds are depends on the ambiguity in the grammar w.r.t.",
        "the input: to generate n edges, every item in every cell must be derivable by every combination of its sub-spans.",
        "Most grammars are substantially less ambiguous.",
        "Figure 3: Average synchronous parser runtime (in seconds) as a function of Arabic sentence length (in words).",
        "an SCFG translation model, repurposed this algorithm to discard partial derivations during translation of f if the derivation yielded a target m-gram not found in e (p.c.).",
        "We replicated their BTEC Chinese-English baseline system and compared the speed of their 'cube-parsing' technique and our two-parse algorithm.",
        "The SCFG used here was extracted from a word-aligned corpus, as described in Chiang (2007).",
        "The following table compares the average per sentence synchronous parse time."
      ]
    },
    {
      "heading": "4. Discussion",
      "text": [
        "Thinking of synchronous parsing as two composition operations has both conceptual and practical benefits.",
        "The two-parse strategy can outperform both the ITG parsing algorithm (Wu, 1997), as well as the 'cube-parsing' technique (Blunsom et al., 2008).",
        "The latter result points to a connection with recent work showing that determinization of edges before LM integration leads to fewer search errors during decoding (Iglesias et al., 2009).",
        "Our results are somewhat surprising in light of work showing that 3-way composition algorithms for FSTs operate far more efficiently than performing successive pairwise compositions (Allauzen and Mohri, 2009).",
        "This is certainly because the 3-way algorithm used here (the ITG algorithm) does an exhaustive search over all nA span pairs without awareness of any top-down constraints.",
        "This suggests that faster composition algorithms that incorporate top-down filtering may still be discovered.",
        "Algorithm",
        "avg.",
        "run-time (sec)",
        "Blunsom et al.",
        "(2008)",
        "7.31",
        "this work",
        "0.20"
      ]
    }
  ]
}
