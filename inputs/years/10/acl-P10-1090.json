{
  "info": {
    "authors": [
      "Min Zhang",
      "Hui Zhang",
      "Haizhou Li"
    ],
    "book": "ACL",
    "id": "acl-P10-1090",
    "title": "Convolution Kernel over Packed Parse Forest",
    "url": "https://aclweb.org/anthology/P10-1090",
    "year": 2010
  },
  "references": [
    "acl-J05-1004",
    "acl-J87-1004",
    "acl-P06-1006",
    "acl-P06-1104",
    "acl-P06-2010",
    "acl-W04-3212"
  ],
  "sections": [
    {
      "text": [
        "Min Zhang Hui Zhang Haizhou Li",
        "Institute for Infocomm Research A-STAR, Singapore",
        "{mzhang,vishz,hli}@i2r.a-star.edu.sg",
        "This paper proposes a convolution forest kernel to effectively explore rich structured features embedded in a packed parse forest.",
        "As opposed to the convolution tree kernel, the proposed forest kernel does not have to commit to a single best parse tree, is thus able to explore very large object spaces and much more structured features embedded in a forest.",
        "This makes the proposed kernel more robust against parsing errors and data sparseness issues than the convolution tree kernel.",
        "The paper presents the formal definition of convolution forest kernel and also illustrates the computing algorithm to fast compute the proposed convolution forest kernel.",
        "Experimental results on two NLP applications, relation extraction and semantic role labeling, show that the proposed forest kernel significantly outperforms the baseline of the convolution tree kernel."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Parse tree and packed forest of parse trees are two widely used data structures to represent the syntactic structure information of sentences in natural language processing (NLP).",
        "The structured features embedded in a parse tree have been well explored together with different machine learning algorithms and proven very useful in many NLP applications (Collins and Duffy, 2002; Moschitti, 2004; Zhang et al., 2007).",
        "A forest (Tomita, 1987) compactly encodes an exponential number of parse trees.",
        "In this paper, we study how to effectively explore structured features embedded in a forest using convolution kernel (Haussler, 1999).",
        "As we know, feature-based machine learning methods are less effective in modeling highly structured objects (Vapnik, 1998), such as parse tree or semantic graph in NLP.",
        "This is due to the fact that it is usually very hard to represent structured objects using vectors of reasonable dimensions without losing too much information.",
        "For example, it is computationally infeasible to enumerate all subtree features (using subtree a feature) for a parse tree into a linear feature vector.",
        "Kernel-based machine learning method is a good way to overcome this problem.",
        "Kernel methods employ a kernel function, that must satisfy the properties of being symmetric and positive, to measure the similarity between two objects by computing implicitly the dot product of certain features of the input objects in high (or even infinite) dimensional feature spaces without enumerating all the features (Vapnik, 1998).",
        "Many learning algorithms, such as SVM (Vapnik, 1998), the Perceptron learning algorithm (Rosenblatt, 1962) and Voted Perceptron (Freund and Schapire, 1999), can work directly with kernels by replacing the dot product with a particular kernel function.",
        "This nice property of kernel methods, that implicitly calculates the dot product in a high-dimensional space over the original representations of objects, has made kernel methods an effective solution to modeling structured objects in NLP.",
        "In the context of parse tree, convolution tree kernel (Collins and Duffy, 2002) defines a feature space consisting of all subtree types of parse trees and counts the number of common subtrees as the syntactic similarity between two parse trees.",
        "The tree kernel has shown much success in many NLP applications like parsing (Collins and Duffy, 2002), semantic role labeling (Moschitti, 2004; Zhang et al., 2007), relation extraction (Zhang et al., 2006), pronoun resolution (Yang et al., 2006), question classification (Zhang and Lee, 2003) and machine translation (Zhang and Li, 2009), where the tree kernel is used to compute the similarity between two NLP application instances that are usually represented by parse trees.",
        "However, in those studies, the tree kernel only covers the features derived from single 1-",
        "IN DT NN in the bank",
        "PP IN DT NN in the bank",
        "PP IN DT NN in",
        "PP IN DT NN the bank",
        "PP IN DT NN the",
        "PP IN DT NN in bank",
        "PP IN DT NN in the",
        "PP IN DT NN",
        "best parse tree.",
        "This may largely compromise the performance of tree kernel due to parsing errors and data sparseness.",
        "To address the above issues, this paper constructs a forest-based convolution kernel to mine structured features directly from packed forest.",
        "A packet forest compactly encodes exponential number of n-best parse trees, and thus containing much more rich structured features than a single parse tree.",
        "This advantage enables the forest kernel not only to be more robust against parsing errors, but also to be able to learn more reliable feature values and help to solve the data sparseness issue that exists in the traditional tree kernel.",
        "We evaluate the proposed kernel in two real NLP applications, relation extraction and semantic role labeling.",
        "Experimental results on the benchmark data show that the forest kernel significantly outperforms the tree kernel.",
        "The rest of the paper is organized as follows.",
        "Section 2 reviews the convolution tree kernel while section 3 discusses the proposed forest kernel in details.",
        "Experimental results are reported in section 4.",
        "Finally, we conclude the paper in section 5."
      ]
    },
    {
      "heading": "2. Convolution Kernel over Parse Tree",
      "text": [
        "Convolution kernel was proposed as a concept of kernels for discrete structures by Haussler (1999) and related but independently conceived ideas on string kernels first presented in (Watkins, 1999).",
        "The framework defines the kernel function between input objects as the convolution of \"sub-kernels\", i.e. the kernels for the decompositions (parts) of the input objects.",
        "The parse tree kernel (Collins and Duffy, 2002) is an instantiation of convolution kernel over syntactic parse trees.",
        "Given a parse tree, its features defined by a tree kernel are all of its subtree types and the value of a given feature is the number of the occurrences of the subtree in the parse tree.",
        "Fig.",
        "1 illustrates a parse tree with all of its 11 subtree features covered by the convolution tree kernel.",
        "In the tree kernel, a parse tree T is represented by a vector of integer counts of each subtree type (i.e., subtree regardless of its ancestors, descendants and span covered):",
        "where # subtreetypei(T) is the occurrence number of the ith subtree type in T. The tree kernel counts the number of common subtrees as the syntactic similarity between two parse trees.",
        "Since the number of subtrees is exponential with the tree size, it is computationally infeasible to directly use the feature vector ((T) .",
        "To solve this computational issue, Collins and Duffy (2002) proposed the following tree kernel to calculate the dot product between the above high dimensional vectors implicitly.",
        "= Z#subtreetypei(T1) • #subtreetypei(T2) where N1 and N2 are the sets of nodes in trees T1 and T2, respectively, and Isubtree.",
        "(n) is a function that is 1 iff the subtreetypei occurs with root at node n and zero otherwise, and A(n1;n2) is the number of the common subtrees rooted at n1 and",
        "A(n1, n2 ) can be computed by the following recursive rules:",
        "a) A Forest f",
        "John saw the bank c) A Parse Tree T1",
        "I I John saw",
        "d) A Parse Tree T2",
        "Figure 2.",
        "An example of a packed forest, a hyper-edge and two parse trees covered by the packed forest where nc(n1 ) is the child number of n1, ch(nj) is the jth child of node n and 2(0< 2<1) is the decay factor in order to make the kernel value less variable with respect to the subtree sizes (Collins and Duffy, 2002).",
        "The recursive Rule 3 holds because given two nodes with the same children, one can construct common subtrees using these children and common subtrees of further offspring.",
        "The time complexity for computing this kernel is O(\\ N1\\ • | N21).",
        "As discussed in previous section, when convolution tree kernel is applied to NLP applications, its performance is vulnerable to the errors from the single parse tree and data sparseness.",
        "In this paper, we present a convolution kernel over packed forest to address the above issues by exploring structured features embedded in a forest."
      ]
    },
    {
      "heading": "3. Convolution Kernel over Forest",
      "text": [
        "In this section, we first illustrate the concept of packed forest and then give a detailed discussion on the covered feature space, fractional count, feature value and the forest kernel function itself.",
        "Informally, a packed parse forest, or (packed) forest in short, is a compact representation of all the derivations (i.e. parse trees) for a given sentence under context-free grammar (Tomita, 1987; Billot and Lang, 1989; Klein and Manning, 2001).",
        "It is the core data structure used in natural language parsing and other downstream NLP applications, such as syntax-based machine translation (Zhang et al., 2008; Zhang et al., 2009a).",
        "In parsing, a sentence corresponds to exponential number of parse trees with different tree probabilities, where a forest can compact all the parse trees by sharing their common subtrees in a bottom-up manner.",
        "Formally, a packed forest F can be described as a triple:",
        "where Fis the set of non-terminal nodes, E is the set of hyper-edges and S is a sentence represented as an ordered word sequence.",
        "A hyper-edge e is a group of edges in a parse tree which connects a father node and its all child nodes, representing a CFG rule.",
        "A non-terminal node in a forest is represented as a \"label [start, end]\", where the \"label\" is its syntax category and \"[start, end]\" is the span of words it covers.",
        "As shown in Fig. 2, these two parse trees (T1 and T2) can be represented as a single forest by sharing their common subtrees (such as NP[3,4] and PP[5,7]) and merging common non-terminal nodes covering the same span (such as VP[2,7], where there are two hyper-edges attach to it).",
        "Given the definition of forest, we introduce the concepts of inside probability ß(. )",
        "and outside probability a(. )",
        "that are widely-used in parsing (Baker, 1979; Lari and Young, 1990) and are also to be used in our kernel calculation.",
        "e is a hyper – edge \\ attached to v \\",
        "ci[Pi,ai]is a leaf node of e",
        "e is a hyper – I edge and v \\ is its one \\ leaf node ci[pi,qt is a \\ children node J of e except v /",
        "where v is a forest node, S[p] is the pth word of input sentence S, P(v – S[p]) is the probability of the CFG rule v – S[p], root(.)",
        "returns the root node of input structure, [pt, qt] is a sub-span of [p, q], being covered by ct, and P (e) is the PCFG probability of e. From these definitions, we can see that the inside probability is total probability of generating words S[p, q] from non-terminal node v[p, q] while the outside probability is the total probability of generating node v[p, q] and words outside S[p, q] from the root of forest.",
        "The inside probability can be calculated using dynamic programming in a bottom-up fashion while the outside probability can be calculated using dynamic programming in a top-to-down way.",
        "In this subsection, we first define the feature space covered by forest kernel, and then define the forest kernel function.",
        "The forest kernel counts the number of common subtrees as the syntactic similarity between two forests.",
        "Therefore, in the same way as tree kernel, its feature space is also defined as all the possible subtree types that a CFG grammar allows.",
        "In a forest kernel, forest F is represented by a vector offractional counts of each subtree type (subtree regardless of its ancestors, descendants and span covered):",
        "# subtreetypeJF)) = (#subtreetypel(n-bestparse trees), ..., (1) # subtreetypen(n-bestparse trees)) where # subtreetypei(F) is the occurrence number of the ith subtree type (subtreetypei) in forest F, i.e., a n-best parse tree lists with a huge n.",
        "Although the feature spaces of the two kernels are the same, their object spaces (tree vs. forest) and feature values (integer counts vs. fractional counts) differ very much.",
        "A forest encodes exponential number of parse trees, and thus containing exponential times more subtrees than a single parse tree.",
        "This ensures forest kernel to learn more reliable feature values and is also able to help to address the data sparseness issues in a better way than tree kernel does.",
        "Forest kernel is also expected to yield more non-zero feature values than tree kernel.",
        "Furthermore, different parse tree in a forest represents different derivation and interpretation for a given sentence.",
        "Therefore, forest kernel should be more robust to parsing errors than tree kernel.",
        "In tree kernel, one occurrence of a subtree contributes 1 to the value of its corresponding feature (subtree type), so the feature value is an integer count.",
        "However, the case turns out very complicated in forest kernel.",
        "In a forest, each of its parse trees, when enumerated, has its own probability.",
        "So one subtree extracted from different parse trees should have different fractional count with regard to the probabilities of different parse trees.",
        "Following the previous work (Char-niak and Johnson, 2005; Huang, 2008), we define the fractional count of the occurrence of a subtree in a parse tree tt as",
        "c(subtree, tt) \\P(subtree, tt \\f, s) otherwise if subtree g tiotherwise",
        "where we have P(subtree, tt\\f, s) = P(tt\\f, s) if subtree G tt.",
        "Then we define the fractional count of the occurrence of a subtree in a forest f as where Isubtree is a binary function that is 1 iif the subtree G tt and zero otherwise.",
        "Obviously, it needs exponential time to compute the above fractional counts.",
        "However, due to the property of forest that compactly represents all the parse trees, the posterior probability of a subtree in a forest, P(subtree\\f,s), can be easily computed in an Inside-Outside fashion as the product of three parts: the outside probability of its root node, the probabilities of parse hyper-edges involved in the subtree, and the inside probabilities of its leaf nodes (Lari and Young, 1990; Mi and Huang, 2008).",
        "eGsubtree vGleaf (subtree )",
        "where a(. )",
        "and ß(.)",
        "denote the outside and inside probabilities.",
        "They can be easily obtained using the equations introduced at section 3.1.",
        "Given a subtree, we can easily compute its fractional count (i.e. its feature value) directly using eq.",
        "(3) and (4) without the need of enumerating each parse trees as shown at eq.",
        "(2) .",
        "Nonetheless, it is still computationally infeasible to directly use the feature vector <p(F) (see eq.",
        "(1)) by explicitly enumerating all subtrees although its fractional count is easily calculated.",
        "In the next subsection, we present the forest kernel that implicitly calculates the dot-product between two <p(F)s in a polynomial time.",
        "The forest kernel counts the fractional numbers of common subtrees as the syntactic similarity between two forests.",
        "We define the forest kernel function Kf (fa, f2) in the following way.",
        "subtree lGfi subtree 2Gf2",
        "• Ieq(^r) is a binary function that is 1 iif the input two subtrees are identical (i.e. they have the same typology and node labels) and zero otherwise;",
        "• c(/) is the fractional count defined at",
        "• N1 and N2 are the sets of nodes in forests fa and fa ;",
        "• A (v1, v2 ) returns the accumulated value of products between each two fractional counts of the common subtrees rooted at v1 and v2, i.e.,",
        "It has been proven in parsing literatures (Baker, 1979; Lari and Young, 1990) that eq.",
        "(3) defined by Inside-Outside probabilities is exactly to compute the sum of those parse tree probabilities that cover the subtree of being considered as defined at eq.",
        "(2).",
        "We next show that A (v1, v2 ) can be computed recursively in a polynomial time as illustrated at Algorithm 1.",
        "To facilitate discussion, we temporarily ignore all fractional counts in Algorithm 1.",
        "Indeed, Algorithm 1 can be viewed as a natural extension of convolution kernel from over tree to over forest.",
        "In forest, a node can root multiple hyper-edges and each hyper-edge is independent to each other.",
        "Therefore, Algorithm 1 iterates each hyper-edge pairs with roots at v1 and v2(line 3-4), and sums over (eq.",
        "(7) at line 9) each recursively-accumulated sub-kernel scores of subtree pairs extended from the hyper-edge pair (e1, e2 ) (eq.",
        "(6) at line 8).",
        "Eq.",
        "(7) holds because the hyper-edges attached to the same node are independent to each other.",
        "Eq.",
        "(6) is very similar to the Rule 3 of tree kernel (see section 2) except its inputs are hyper-edges and its further expansion is based on forest nodes.",
        "Similar to tree kernel (Collins and Duffy, 2002), eq.",
        "(6) holds because a common subtree by extending from (e1, e2) can be formed by taking the hyper-edge (e1,e2), together with a choice at each of their leaf nodes of simply taking the non-terminal at the leaf node, or any one of the common subtrees with root at the leaf node.",
        "Thus there are",
        "(1 + A (leaf (ex, j), leaf(e2,y'))) possible choices at the jth leaf node.",
        "In total, there are A (e1, e2) (eq.",
        "(6)) common subtrees by extending from (e1, e2) and A (v1, v2) (eq.",
        "(7)) common subtrees with root at (v1, v2 ).",
        "Obviously A (v1, v2 ) calculated by Algorithm 1 is a proper convolution kernel since it simply counts the number of common subtrees under the root (v1, v2).",
        "Therefore, Kf(f1, f2) defined at eq.",
        "(5) and calculated through A (v1, v2) is also a proper convolution kernel.",
        "From eq.",
        "(5) and Algorithm 1, we can see that each hyper-edge pair (e1,e2) is only visited at most one time in computing the forest kernel.",
        "Thus the time complexity for computing Kf(fa,f2) is 0(\\E1\\ • \\E2\\) , where E1 and E2 are the set of hyper-edges in forests f1 and f2, respectively.",
        "Given a forest and the best parse trees, the number of hyper-edges is only several times (normally <=3 after pruning) than that of tree nodes in the parse tree.",
        "of encoding Mn – 1 parse trees at most (Zhang et al., 2009b).",
        "Algorithm 1.",
        "Input:",
        "A, fi- two packed forests",
        "v-i, V2 : any two nodes of fa and fa",
        "Notation:",
        "nl(e1 ): number of leaf node of e1 leaf(e-i, j): the jth leaf node of e1"
      ]
    },
    {
      "heading": "3.. for each hyper-edge e 1 attached to v 1 do",
      "text": []
    },
    {
      "heading": "4.. for each hyper-edge e 2 attached to v 2 do",
      "text": []
    },
    {
      "heading": "6.. goto line 3",
      "text": []
    },
    {
      "heading": "7.. else do",
      "text": []
    },
    {
      "heading": "10.. end if",
      "text": []
    },
    {
      "heading": "11.. end for",
      "text": []
    },
    {
      "heading": "12.. end for",
      "text": [
        "Same as tree kernel, forest kernel is running more efficiently in practice since only two nodes with the same label needs to be further processed (line 2 of Algorithm 1).",
        "Now let us see how to integrate fractional counts into forest kernel.",
        "According to Algorithm 1 (eq.",
        "(7)), we have (e1/e2 are attached to v1/v2, respectively)",
        "Recall eq.",
        "(4), a fractional count consists of outside, inside and subtree probabilities.",
        "It is more straightforward to incorporate the outside and subtree probabilities since all the subtrees with roots at (v1, v2 ) share the same outside probability and each hyper-edge pair is only visited one time.",
        "Thus we can integrate the two probabilities into A (v1, v2) as follows.",
        "where, following tree kernel, a decay factor A(0 < A < 1) is also introduced in order to make the kernel value less variable with respect to the subtree sizes (Collins and Duffy, 2002).",
        "It functions like multiplying each feature value by Xslzet, where sizet is the number of hyper-edges in subtree^..",
        "The inside probability is only involved when a node does not need to be further expanded.",
        "The integer 1 at eq.",
        "(6) represents such case.",
        "So the inside probability is integrated into eq.",
        "(6) by replacing the integer 1 as follows.",
        "where in the last expression the two outside probabilities a(leaf(e1,j)) and a(leaf(e2,j)) are removed.",
        "This is because leaf(e1, j) and leaf(e2, j) are not roots of the subtrees of being explored (only outside probabilities of the root of a subtree should be counted in its fractional count), and A (leaf(e1, j), leaf(e2, j)) already contains the two outside probabilities of leaf(e1,j) and leaf(e2,j).",
        "Referring to eq.",
        "(3), each fractional count needs to be normalized by aß(root(f)).",
        "Since aß(root(f)) is independent to each individual fractional count, we do the normalization outside the recursive function A (e1, e2).",
        "Then we can re-formulize eq.",
        "(5) as",
        "Finally, since the size of input forests is not constant, the forest kernel value is normalized using the following equation.",
        "From the above discussion, we can see that the proposed forest kernel is defined together by eqs.",
        "representation of trees in forest and the recursive nature of the kernel function, the introduction of fractional counts and normalization do not change the convolution property and the time complexity of the forest kernel.",
        "Therefore, the forest kernel Kf(f1, f2) is still a proper convolution kernel with quadratic time complexity.",
        "To the best of our knowledge, this is the first work to address convolution kernel over packed parse forest.",
        "Convolution tree kernel is a special case of the proposed forest kernel.",
        "From feature exploration viewpoint, although theoretically they explore the same subtree feature spaces (defined recursively by CFG parsing rules), their feature values are different.",
        "Forest encodes exponential number of trees.",
        "So the number of subtree instances extracted from a forest is exponential number of times greater than that from its corresponding parse tree.",
        "The significant difference of the amount of subtree instances makes the parameters learned from forests more reliable and also can help to address the data sparseness issue.",
        "To some degree, forest kernel can be viewed as a tree kernel with very powerful back-off mechanism.",
        "In addition, forest kernel is much more robust against parsing errors than tree kernel.",
        "Aiolli et al.",
        "(2006; 2007) propose using Direct Acyclic Graphs (DAG) as a compact representation of tree kernel-based models.",
        "This can largely reduce the computational burden and storage requirements by sharing the common structures and feature vectors in the kernel-based model.",
        "There are a few other previous works done by generalizing convolution tree kernels (Kashima and Koyanagi, 2003; Moschitti, 2006; Zhang et al., 2007).",
        "However, all of these works limit themselves to single tree structure from modeling viewpoint in nature.",
        "From a broad viewpoint, as suggested by one reviewer of the paper, we can consider the forest kernel as an alternative solution proposed for the general problem of noisy inference pipelines (eg.",
        "speech translation by composition of FSTs, machine translation by translating over 'lattices' of segmentations (Dyer et al., 2008) or using parse tree info for downstream applications in our cases) .",
        "Following this line, Bunescu (2008) and Finkel et al.",
        "(2006) are two typical related works done in reducing cascading noisy.",
        "However, our works are not overlapped with each other as there are two totally different solutions for the same general problem.",
        "In addition, the main motivation of this paper is also different from theirs.",
        "Experiments",
        "Forest kernel has a broad application potential in NLP.",
        "In this section, we verify the effectiveness of the forest kernel on two NLP applications, semantic role labeling (SRL) (Gildea, 2002) and relation extraction (RE) (ACE, 2002-2006).",
        "In our experiments, SVM (Vapnik, 1998) is selected as our classifier and the one vs. others strategy is adopted to select the one with the largest margin as the final answer.",
        "In our implementation, we use the binary SVMLight (Joachims, 1998) and borrow the framework of the Tree Kernel Tools (Moschitti, 2004) to integrate our forest kernel into the SVMLight.",
        "We modify Charniak parser (Charniak, 2001) to output a packed forest.",
        "Following previous forest-based studies (Charniak and Johnson, 2005), we use the marginal probabilities of hyper-edges (i.e., the Viterbi-style inside-outside probabilities and set the pruning threshold as 8) for forest pruning.",
        "Given a sentence and each predicate (either a target verb or a noun), SRL recognizes and maps all the constituents in the sentence into their corresponding semantic arguments (roles, e.g., A0 for Agent, A1 for Patient ...) of the predicate or non-argument.",
        "We use the CoNLL-2005 shared task on Semantic Role Labeling (Carreras and Marquez, 2005) for the evaluation of our forest kernel method.",
        "To speed up the evaluation process, the same as Che et al.",
        "(2008), we use a subset of the entire training corpus (WSJ sections 02-05 of the entire sections 02-21) for training, section 24 for development and section 23 for test, where there are 35 roles including 7 Core (A0-A5, AA), 14 Adjunct (AM-) and 14 Reference (R-) arguments.",
        "The state-of-the-art SRL methods (Carreras and Marquez, 2005) use constituents as the labeling units to form the labeled arguments.",
        "Due to the errors from automatic parsing, it is impossible for all arguments to find their matching constituents in the single 1-best parse trees.",
        "Statistics on the training data shows that 9.78% of arguments have no matching constituents using the Charniak parser (Charniak, 2001), and the number increases to 11.76% when using the Collins parser (Collins, 1999).",
        "In our method, we break the limitation of 1-best parse tree and regard each span rooted by a single forest node (i.e., a sub-forest with one or more roots) as a candidate argument.",
        "This largely reduces the unmatched arguments from 9.78% to 1.31% after forest pruning.",
        "However, it also results in a very large amount of argument candidates that is 5.6 times as many as that from 1-best tree.",
        "Fortunately, after the preprocessing stage of argument pruning (Xue and Palmer, 2004), although the amount of unmatched argument increases a little bit to 3.1%, its generated total candidate amount decreases substantially to only 1.31 times of that from 1-best parse tree.",
        "This clearly shows the advantages of the forest-based method over tree-based in SRL.",
        "The best-reported tree kernel method for SRL1) , proposed by Che et al.",
        "(2006), is adopted as our baseline kernel.",
        "We implemented the Khybridin tree case ( KT-hybrid , using tree kernel to compute Kpath and Kcs ) and in forest case (KF-hybrid , using tree kernel to compute Kpathand Kcs ).",
        "Table 1 shows that the forest kernel significantly outperforms (j test with p=0.01) the tree kernel with an absolute improvement of 2.32 (73.7671.42) percentage in F-Score, representing a relative error rate reduction of 8.19% (2.32/(100-71.64)).",
        "This convincingly demonstrates the advantage of the forest kernel over the tree kernel.",
        "It suggests that the structured features represented by subtree are very useful to SRL.",
        "The performance improvement is mainly due to the fact that forest encodes much more such structured features and the forest kernel is able to more effectively capture such structured features than the tree kernel.",
        "Besides F-Score, both precision and recall also show significantly improvement (x test with p=0.01).",
        "The reason for recall improvement is mainly due to the lower rate of unmatched argument (3.1% only) with only a little bit overhead (1.31 times) (see the previous discussion in this section).",
        "The precision improvement is mainly attributed to fact that we use sub-forest to represent argument instances, rather than subtree used in tree kernel, where the sub-tree is only one tree encoded in the sub-forest.",
        "SRL and thus makes the amounts of positive and negative training instances (arguments) more balanced.",
        "We apply the same pruning strategies to forest plus our heuristic rules to prune out some of the arguments with span overlapped with each other and those arguments with very small inside probabilities, depending on the numbers of candidates in the span.",
        "Kpath and Kcs are two standard convolution tree kernels to describe predicate-argument path substructures and argument syntactic substructures, respectively.",
        "Precision",
        "Recall",
        "F-Score",
        "^T-hybrid (Tree)",
        "76.02",
        "67.38",
        "71.44",
        "^F-hybrid (Forest)",
        "79.06",
        "69.12",
        "73.76",
        "As a subtask of information extraction, relation extraction is to extract various semantic relations between entity pairs from text.",
        "For example, the sentence \"Bill Gates is chairman and chief software architect of Microsoft Corporation\" conveys the semantic relation \"EMPLOY-MENT.executive\" between the entities \"Bill Gates\" (person) and \"Microsoft Corporation\" (company).",
        "We adopt the method reported in Zhang et al.",
        "(2006) as our baseline method as it reports the state-of-the-art performance using tree kernel-based composite kernel method for RE.",
        "We replace their tree kernels with our forest kernels and use the same experimental settings as theirs.",
        "We carry out the same fivefold cross validation experiment on the same subset of ACE 2004 data (LDC2005T09, ACE 2002-2004) as that in Zhang et al.",
        "(2006).",
        "The data contain 348 documents and 4400 relation instances.",
        "In SRL, constituents are used as the labeling units to form the labeled arguments.",
        "However, previous work (Zhang et al., 2006) shows that if we use complete constituent (MCT) as done in SRL to represent relation instance, there is a large performance drop compared with using the path-enclosed tree (PT).",
        "By simulating PT, we use the minimal fragment of a forest covering the two entities and their internal words to represent a relation instance by only parsing the span covering the two entities and their internal words.",
        "Table 2 compares the performance of the forest kernel and the tree kernel on relation extraction.",
        "We can see that the forest kernel significantly outperforms (x test with p=0.05) the tree kernel by 1.1 point of F-score.",
        "This further verifies the effectiveness of the forest kernel method for modeling NLP structured data.",
        "In summary, we further observe the high precision improvement that is consistent with the SRL experiments.",
        "However, the recall improvement is not as significant as observed in SRL.",
        "This is because unlike SRL, RE has noun-matching issues in generating relation instances.",
        "Moreover, we find that the performance improvement in RE is not as good as that in SRL.",
        "Although we know that performance is task-dependent, one of the possible reasons is that SRL tends to be long-distance grammatical structure-related while RE is local and semantic-related as observed from the two experimental benchmark data."
      ]
    },
    {
      "heading": "5. Conclusions and Future Work",
      "text": [
        "Many NLP applications have benefited from the success of convolution kernel over parse tree.",
        "Since a packed parse forest contains much richer structured features than a parse tree, we are motivated to develop a technology to measure the syntactic similarity between two forests.",
        "To achieve this goal, in this paper, we design a convolution kernel over packed forest by generalizing the tree kernel.",
        "We analyze the object space of the forest kernel, the fractional count for feature value computing and design a dynamic programming algorithm to realize the forest kernel with quadratic time complexity.",
        "Compared with the tree kernel, the forest kernel is more robust against parsing errors and data sparseness issues.",
        "Among the broad potential NLP applications, the problems in SRL and RE provide two pointed scenarios to verify our forest kernel.",
        "Experimental results demonstrate the effectiveness of the proposed kernel in structured NLP data modeling and the advantages over tree kernel.",
        "In the future, we would like to verify the forest kernel in more NLP applications.",
        "In addition, as suggested by one reviewer, we may consider rescaling the probabilities (exponentiating them by a constant value) that are used to compute the fractional counts.",
        "We can sharpen or flatten the distributions.",
        "This basically says \"how seriously do we want to take the very best derivation\" compared to the rest.",
        "However, the challenge is that we compute the fractional counts together with the forest kernel recursively by using the Inside-Outside probabilities.",
        "We cannot differentiate the individual parse tree's contribution to a fractional count on the fly.",
        "One possible solution is to do the probability rescaling off-line before kernel calculation.",
        "This would be a very interesting research topic of our future work.",
        "Precision",
        "Recall",
        "Zhang et al.",
        "(2006):Tree",
        "68.6",
        "59.3",
        "Ours: Forest",
        "70.3",
        "60.0"
      ]
    }
  ]
}
