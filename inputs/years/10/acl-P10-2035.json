{
  "info": {
    "authors": [
      "Kotaro Kitagawa",
      "Kumiko Tanaka-Ishii"
    ],
    "book": "Proceedings of the ACL 2010 Conference Short Papers",
    "id": "acl-P10-2035",
    "title": "Tree-Based Deterministic Dependency Parsing – An Application to Nivre’s Method – ",
    "url": "https://aclweb.org/anthology/P10-2035",
    "year": 2010
  },
  "references": [
    "acl-C04-1010",
    "acl-C08-1046",
    "acl-C96-1058",
    "acl-D07-1101",
    "acl-D08-1059",
    "acl-E06-1011",
    "acl-J08-4003",
    "acl-P05-1012",
    "acl-P08-1068",
    "acl-W02-2016"
  ],
  "sections": [
    {
      "text": [
        "Tree-Based Deterministic Dependency Parsing – An Application to Nivre's Method – ",
        "Kotaro Kitagawa Kumiko Tanaka-Ishii",
        "Nivre's method was improved by enhancing deterministic dependency parsing through application of a tree-based model.",
        "The model considers all words necessary for selection of parsing actions by including words in the form of trees.",
        "It chooses the most probable head candidate from among the trees and uses this candidate to select a parsing action.",
        "In an evaluation experiment using the Penn Treebank (WSJ section), the proposed model achieved higher accuracy than did previous deterministic models.",
        "Although the proposed model's worst-case time complexity is O(n), the experimental results demonstrated an average parsing time not much slower than O(n)."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Deterministic parsing methods achieve both effective time complexity and accuracy not far from those of the most accurate methods.",
        "One such deterministic method is Nivre's method, an incremental parsing method whose time complexity is linear in the number of words (Nivre, 2003).",
        "Still, deterministic methods can be improved.",
        "As a specific example, Nivre's model greedily decides the parsing action only from two words and their locally relational words, which can lead to errors.",
        "In the field of Japanese dependency parsing, Iwatate et al.",
        "(2008) proposed a tournament model that takes all head candidates into account in judging dependency relations.",
        "This method assumes backward parsing because the Japanese dependency structure has a head-final constraint, so that any word's head is located to its right.",
        "Here, we propose a tree-based model, applicable to any projective language, which can be considered as a kind of generalization of Iwatate's idea.",
        "Instead of selecting a parsing action for two words, as in Nivre's model, our tree-based model first chooses the most probable head candidate from among the trees through a tournament and then decides the parsing action between two trees.",
        "Global-optimization parsing methods are another common approach (Eisner, 1996; McDonald et al., 2005).",
        "Koo et al.",
        "(2008) studied semi-supervised learning with this approach.",
        "Hybrid systems have improved parsing by integrating outputs obtained from different parsing models (Zhang and Clark, 2008).",
        "Our proposal can be situated among global-optimization parsing methods as follows.",
        "The proposed tree-based model is deterministic but takes a step towards global optimization by widening the search space to include all necessary words connected by previously judged head-dependent relations, thus achieving a higher accuracy yet largely retaining the speed of deterministic parsing."
      ]
    },
    {
      "heading": "2. Deterministic Dependency Parsing",
      "text": [
        "A dependency parser receives an input sentence x = w\\,w2,... ,wn and computes a dependency graph G = (W,A).",
        "The set of nodes W = [w0,wi,..., wn} corresponds to the words of a sentence, and the node wo is the root of G. A is the set of arcs (wi, wj ), each of which represents a dependency relation where wi is the head and wj is the dependent.",
        "In this paper, we assume that the resulting dependency graph for a sentence is well-formed and projective (Nivre, 2008).",
        "G is well-formed if and only if it satisfies the following three conditions of being single-headed, acyclic, and rooted.",
        "An incremental dependency parsing algorithm was first proposed by (Covington, 2001).",
        "After studies taking data-driven approaches, by (Kudo and Matsumoto, 2002), (Yamada and Matsumoto, 2003), and (Nivre, 2003), the deterministic incremental parser was generalized to a state transition system in (Nivre, 2008).",
        "Nivre's method applying an arc-eager algorithm works by using a stack of words denoted as a, for a buffer ß initially containing the sentence x. Parsing is formulated as a quadruple (S, Ts, sinit, St), where each component is defined as follows:",
        "• S is a set of states, each of which is denoted as (a, ß, A) £ S.",
        "• Ts is a set of transitions, and each element of Ts is a function ts : S – > S.",
        "state.",
        "• St is a set of terminal states.",
        "Syntactic analysis generates a sequence of optimal transitions ts provided by an oracle o : S – Ts, applied to a target consisting ofthe stack's top element wi and the first element wj in the buffer.",
        "The oracle is constructed as a classifier trained on treebank data.",
        "Each transition is defined in the upper block of Table 1 and explained as follows:",
        "Left-Arc Make wj the head of wi and pop wi, where wi is located at the stack top (denoted as a\\wi), when the buffer head is wj (denoted as wj \\ß).",
        "Right-Arc Make wi the head of wj, and push wj.",
        "Reduce Pop wi, located at the stack top.",
        "Shift Push the word wj, located at the buffer head, onto the stack top.",
        "The method explained thus far has the following drawbacks.",
        "Locality of Parsing Action Selection",
        "The dependency relations are greedily determined, so when the transition Right-Arc adds a dependency arc (wi,wj), a more probable head of wj located in the stack is disregarded as a candidate.",
        "Features Used for Selecting Reduce",
        "The features used in (Nivre and Scholz, 2004) to define a state transition are basically obtained from the two target words wi and wj, and their related words.",
        "These words are not sufficient to select Reduce, because this action means that wj has no dependency relation with any word in the stack.",
        "Preconditions",
        "When the classifier selects a transition, the resulting graph satisfies well-formedness and projectiv-ity only under the preconditions listed in Table 1.",
        "Even though the parsing seems to be formulated as a four-class classifier problem, it is in fact formed of two types of three-class classifiers.",
        "Solving these problems and selecting a more suitable dependency relation requires a parser that considers more global dependency relations."
      ]
    },
    {
      "heading": "3. Tree-Based Parsing Applied to Nivre's Method",
      "text": [
        "Tree-based parsing uses trees as the procedural elements instead of words.",
        "This allows enhancement of previously proposed deterministic models such as (Covington, 2001; Yamada and Matsumoto, 2003).",
        "In this paper, we show the application of tree-based parsing to Nivre's method.",
        "The parser is formulated as a state transition system (S, Ts, sinit, St), similarly to Nivre's parser, but a and ß for a state s = (a,ß,A) £ S denote a stack of trees and a buffer of trees, respectively.",
        "A tree ti £ T is defined as the tree rooted by the word wi, and the initial state is sinit = ([t0], [ti,... ,tn], (f>), which is formed from the input sentence x.",
        "The state transitions Ts are decided through the following two steps.",
        "1.",
        "Select the most probable head candidate (MPHC): For the tree ti located at the stack top, search for and select the MPHC for wj, which is the root word of tj located at the buffer head.",
        "This procedure is denoted as a",
        "Transition",
        "Precondition",
        "Nivre's Method",
        "Left-Arc Right-Arc Reduce Shift",
        "(a\\wi,wj\\ß, A) (a\\wi,wj\\ß,A) (a\\wi,ß, A) (a,wj\\ß,A)",
        "== (a,wj\\ß,A U{(wj,wi)}) == (a\\wi\\wj,ß,A U {(wi,wj)}) = (a,ß,A) = (a\\wj ,ß,A)",
        "i = 0 A -3wk (wk, wi) £ A 3wk (wk,wi) £ A",
        "Proposed Method",
        "Left-Arc",
        "Right-Arc",
        "Shift",
        "(a\\ti,tj\\ß,A) == (a\\ti,tj\\ß,A) == (a,tj\\ß,A) =",
        "■ (a,tj\\ß,A U{(wj ,wi)})",
        "■ (a\\ti,ß,A U {(mphc(ti,tj),wj)}) ■(a\\tj ,ß,A)",
        "i = 0",
        "most probable head candidate head candidates",
        "Wj I with I",
        "the telescope",
        "Figure 1 : Example of a tournament.",
        "function mphc(U,tj), and its details are explained in §3.2.",
        "2.",
        "Select a transition: Choose a transition, by using an oracle, from among the following three possibilities (explained in detail in §3.3):",
        "Left-Arc Make Wj the head of Wi and pop ti, where U is at the stack top (denoted as a\\ti, with the tail being a), when the buffer head is tj (denoted as tj\\ß).",
        "Right-Arc Make the MPHC the head of Wj, and pop the MPHC.",
        "Shift Push the tree tj located at the buffer head onto the stack top.",
        "These transitions correspond to three possibilities for the relation between ti and tf (1) a word of U is a dependent of a word of tj ; (2) a word of tj is a dependent of a word of U; or (3) the two trees are not related.",
        "The formulations of these transitions in the lower block of Table 1 correspond to Nivre's transitions of the same name, except that here a transition is applied to a tree.",
        "This enhancement from words to trees allows removal of both the Reduce transition and certain preconditions.",
        "By using mphc(ti, tj), a word located far from Wj (the head of tj) can be selected as the head candidate in U.",
        "This selection process decreases the number of errors resulting from greedy decision considering only a few candidates.",
        "Various procedures can be considered for implementing mphc(ti, tj).",
        "One way is to apply the tournament procedure to the words in ti.",
        "The tournament procedure was originally introduced for parsing methods in Japanese by (Iwatate et al.,",
        "robot The biped separately robot sold The biped separately his company",
        "2008).",
        "Since the Japanese language has the head-final property, the tournament model itself constitutes parsing, whereas for parsing a general projective language, the tournament model can only be used as part of a parsing algorithm.",
        "Figure 1 shows a tournament for the example of \"with,\" where the word \"watched\" finally wins.",
        "Although only the words on the left-hand side of tree tj are searched, this does not mean that the tree-based method considers only one side of a dependency relation.",
        "For example, when we apply the tree-based parsing to Yamada's method, the search problems on both sides are solved.",
        "To implement mphc(ti,tj), a binary classifier is built to judge which of two given words is more appropriate as the head for another input word.",
        "This classifier concerns three words, namely, the two words I (left) and r (right) in ti, whose appropriateness as the head is compared for the dependent Wj.",
        "All word pairs of I and r in ti are compared repeatedly in a \"tournament,\" and the survivor is regarded as the MPHC of Wj.",
        "The classifier is generated through learning of training examples for all U and Wj pairs, each of which generates examples comparing the true head and other (inappropriate) heads in U.",
        "Table 2 lists the features used in the classifier.",
        "Here, lex(X) and pos(X) mean the surface form and part of speech of X, respectively.",
        "Xle^ means the dependents of X located on the left-hand side of X, while Xr%9ht means those on the right.",
        "Also, Xhead means the head of X.",
        "The feature design concerns three additional words occurring after Wj, as well, denoted as Wj+\\,Wj+2,Wj+s.",
        "A transition is selected by a three-class classifier after deciding the MPHC, as explained in §3.1.",
        "Table 1 lists the three transitions and one precon-",
        "pos(lhead), pos(lleft), pos(lright)_ pos(rhead), pos(rlef t), pos(rright) pos(MPHC), lex(MPHC) pos(MPHChead), pos(MPHClef t), pos(MPHCright) lex(MPHChead), lex(MPHClef t), lex(MPHCright)",
        "dition.",
        "The transition Shift indicates that the target trees ti and tj have no dependency relations.",
        "The transition Right-Arc indicates generation of the dependent-head relation between wj and the result of mphc(ti, tj), i.e., the MPHC for wj.",
        "Figure 2 shows an example of this transition.",
        "The transition Left-Arc indicates generation of the dependency relation in which wj is the head of wi.",
        "While Right-Arc requires searching for the MPHC in ti, this is not the case for Left-Arc.",
        "The key to obtaining an accurate tree-based parsing model is to extend the search space while at the same time providing ways to narrow down the space and find important information, such as the MPHC, for proper judgment of transitions.",
        "The three-class classifier is constructed as follows.",
        "The dependency relation between the target trees is represented by the three words wi, MPHC, and wj.",
        "Therefore, the features are designed to incorporate these words, their relational words, and the three words next to wj.",
        "Table 3 lists the exact set of features used in this work.",
        "Since this transition selection procedure presumes selection of the MPHC, the result of mphc(ti, tj) is also incorporated among the features."
      ]
    },
    {
      "heading": "4. Evaluation",
      "text": [
        "In our experimental evaluation, we used Yamada's head rule to extract unlabeled dependencies from the Wall Street Journal section of a Penn Treebank.",
        "Sections 2-21 were used as the training data, and section 23 was used as the test data.",
        "This test data",
        "• tt and tk became the target, and Shift was selected.",
        "• tk and tj became the target, and Left-Arc was selected.",
        "The first phase precisely indicates that wt and wk are unrelated.",
        "was used in several other previous works, enabling mutual comparison with the methods reported in those works.",
        "The SVMlight package was used to build the support vector machine classifiers.",
        "The binary classifier for MPHC selection and the three-class classifier for transition selection were built using a cubic polynomial kernel.",
        "The parsing speed was evaluated on a Core2Duo (2.53 GHz) machine.",
        "We measured the ratio of words assigned correct heads to all words (accuracy), and the ratio of sentences with completely correct dependency graphs to all sentences (complete match).",
        "In the evaluation, we consistently excluded punctuation marks.",
        "Table 4 compares our results for the proposed method with those reported in some previous works using equivalent training and test data.",
        "The first column lists the four previous methods and our method, while the second through fourth columns list the accuracy, complete match accuracy, and time complexity, respectively, for each method.",
        "Here, we obtained the scores for the previous works from the corresponding articles listed in the first column.",
        "Note that every method used different features, which depend on the method.",
        "The proposed method achieved higher accuracy than did the previous deterministic models.",
        "Although the accuracy of our method did not reach that of (McDonald and Pereira, 2006), the scores were competitive even though our method is deterministic.",
        "These results show the capability of the tree-based approach in effectively extending the search space.",
        "Such extension of the search space also concerns the speed of the method.",
        "Here, we compare its computational time with that of Nivre's method.",
        "We reimplemented Nivre's method to use SVMs with cubic polynomial kernel, similarly to our",
        "Nivre's Method Proposed Method",
        "method.",
        "Figure 3 shows plots of the parsing times for all sentences in the test data.",
        "The average parsing time for our method was 8.9 sec, whereas that for Nivre's method was 7.9 sec.",
        "Although the worst-case time complexity for Nivre's method is O(n) and that for our method is O(n), worst-case situations (e.g., all words having heads on their left) did not appear frequently.",
        "This can be seen from the sparse appearance ofthe upper bound in the second figure."
      ]
    },
    {
      "heading": "5. Conclusion",
      "text": [
        "We have proposed a tree-based model that decides head-dependency relations between trees instead of between words.",
        "This extends the search space to obtain the best head for a word within a deterministic model.",
        "The tree-based idea is potentially applicable to various previous parsing methods; in this paper, we have applied it to enhance Nivre's method.",
        "Our tree-based model outperformed various deterministic parsing methods reported previously.",
        "Although the worst-case time complexity of our method is O(n), the average parsing time is not much slower than O(n).",
        "Accuracy",
        "Complete",
        "Time",
        "Global vs.",
        "Learning",
        "match",
        "complexity",
        "deterministic",
        "method",
        "McDonald & Pereira (2006)",
        "91.5",
        "42.1",
        "O(n)",
        "global",
        "MIRA",
        "McDonald et al.",
        "(2005)",
        "90.9",
        "37.5",
        "O(n)",
        "global",
        "MIRA",
        "Yamada & Matsumoto (2003)",
        "90.4",
        "38.4",
        "O(n)",
        "deterministic",
        "support vector machine",
        "Goldberg & Elhadad (2010)",
        "89.7",
        "37.5",
        "O (n log n)",
        "deterministic",
        "structured perceptron",
        "Nivre (2004)",
        "87.1",
        "30.4",
        "O(n)",
        "deterministic",
        "memory based learning",
        "Proposed method",
        "91.3",
        "41.7",
        "O(n)",
        "deterministic",
        "support vector machine"
      ]
    }
  ]
}
