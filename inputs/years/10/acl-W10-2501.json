{
  "info": {
    "authors": [
      "Zoltán Fülöp",
      "Andreas Maletti",
      "Heiko Vogler"
    ],
    "book": "Proceedings of the 2010 Workshop on Applications of Tree Automata in Natural Language Processing",
    "id": "acl-W10-2501",
    "title": "Preservation of Recognizability for Synchronous Tree Substitution Grammars",
    "url": "https://aclweb.org/anthology/W10-2501",
    "year": 2010
  },
  "references": [
    "acl-C90-3001",
    "acl-C90-3045",
    "acl-E06-1048",
    "acl-J08-3004",
    "acl-P01-1067",
    "acl-W05-1506"
  ],
  "sections": [
    {
      "text": [
        "Zoltan Fülöp Andreas Maletti Heiko Vogler",
        "Szeged, Hungary Tarragona, Spain Dresden, Germany",
        "We consider synchronous tree substitution grammars (STSG).",
        "With the help of a characterization of the expressive power of S TS G in terms of weighted tree bimor-phisms, we show that both the forward and the backward application of an Stsg preserve recognizability of weighted tree languages in all reasonable cases.",
        "As a consequence, both the domain and the range of an STSG without chain rules are recognizable weighted tree languages."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The syntax-based approach to statistical machine translation (Yamada and Knight, 2001) becomes more and more competitive in machine translation, which is a subfield of natural language processing (NLP).",
        "In this approach the full parse trees of the involved sentences are available to the translation model, which can base its decisions on this rich structure.",
        "In the competing phrase-based approach (Koehn et al., 2003) the translation model only has access to the linear sentence structure.",
        "There are two major classes of syntax-based translation models: tree transducers and synchronous grammars.",
        "Examples in the former class are the top-down tree transducer (Rounds, 1970; Thatcher, 1970), the extended top-down tree transducer (Arnold and Dauchet, 1982; Galley et al., 2004; Knight and Graehl, 2005; Graehl et al., 2008; Maletti et al., 2009), and the extended multi bottom-up tree transducer (Lilin, 1981; Engelfriet et al., 2009; Maletti, 2010).",
        "The latter class contains the syntax-directed transduc-tions of Lewis II and Stearns (1968), the generalized syntax-directed transductions (Aho and Ullman, 1969), the synchronous tree substitution grammar (STSG) by Schabes (1990) and the synchronous tree adjoining grammar (STAG) by",
        "Abeille et al.",
        "(1990) and Shieber and Schabes (1990).",
        "The first bridge between those two classes were established in (Martin and Vere, 1970).",
        "Further comparisons can be found in (Shieber, 2004) for STSG and in (Shieber, 2006) for STAG.",
        "One of the main challenges in NLP is the ambiguity that is inherent in natural languages.",
        "For instance, the sentence \"I saw the man with the telescope\" has several different meanings.",
        "Some of them can be distinguished by the parse tree, so that probabilistic parsers (Nederhof and Satta, 2006) for natural languages can (partially) achieve the disambiguation.",
        "Such a parser returns a set of parse trees for each input sentence, and in addition, each returned parse tree is assigned a likelihood.",
        "Thus, the result can be seen as a mapping from parse trees to probabilities where the impossible parses are assigned the probability 0.",
        "Such mappings are called weighted tree languages, of which some can be finitely represented by weighted regular tree grammars (Alexandrakis and Bozapalidis, 1987).",
        "Those weighted tree languages are recognizable and there exist algorithms (Huang and Chiang, 2005) that efficiently extract the k-best parse trees (i.e., those with the highest probability) for further processing.",
        "In this paper we consider synchronized tree substitution grammars (STSG).",
        "To overcome a technical difficulty we add (grammar) nonterminals to them.",
        "Since an S TS G often uses the nonterminals of a context-free grammar as terminal symbols (i.e., its derived trees contain both terminal and nonterminal symbols of the context-free grammar), we call the newly added (grammar) nonterminals of the Stsg states.",
        "Substitution does no longer take place at synchronized nonterminals (of the context-free grammar) but at synchronized states (one for the input and one for the output side).",
        "The states themselves will not appear in the final derived trees, which yields that it is sufficient to assume that only identical states are synchronized.",
        "Under those conventions a rule of an Stsg has the form q – (s,t,V, a) where q is a state, a G R>0 is the rule weight, s is an input tree that can contain states at the leaves, and t is an output tree that can also contain states.",
        "Finally, the synchronization is defined by V, which is a bijection between the state-labeled leaves of s and t. We require that V only relates identical states.",
        "The rules of an Stsg are applied in a stepwise manner.",
        "Here we use a derivation relation to define the semantics of an Stsg.",
        "It can be understood as the synchronization of the derivation relations of two regular tree grammars (Gecseg and Steinby, 1984; Gecseg and Steinby, 1997) where the synchronization is done on nonterminals (or states) in the spirit of syntax-directed transductions (Lewis II and Stearns, 1968).",
        "Thus each sentential form is a pair of (nonterminal-) connected trees.",
        "An S ts g G computes a mapping rg, called its weighted tree transformation, that assigns a weight to each pair of input and output trees, where both the input and output tree may not contain any state.",
        "This transformation is obtained as follows: We start with two copies of the initial state that are synchronized.",
        "Given a connected tree pair (£, (), we can apply the rule q – (s, t, V, a) to each pair of synchronized states q.",
        "Such an application replaces the selected state q in £ by s and the corresponding state q in ( by t. All the remaining synchronized states and the synchronized states of V remain synchronized.",
        "The result is a new connected tree pair.",
        "This step charges the weight a.",
        "The weights of successive applications (or steps) are multiplied to obtain the weight of the derivation.",
        "The weighted tree transformation rg assigns to each pair of trees the sum of all weights of derivations that derive that pair.",
        "Shieber (2004) showed that for every classical unweighted Stsg there exists an equivalent bi-morphism (Arnold and Dauchet, 1982).",
        "The converse result only holds up to deterministic rela-belings (Gecseg and Steinby, 1984; Gecseg and Steinby, 1997), which remove the state information from the input and output tree.",
        "It is this difference that motivates us to add states to Stsg.",
        "We generalize the result of Shieber (2004) and prove that every weighted tree transformation that is computable by an Stsg can also be computed by a weighted bimorphism and vice versa.",
        "Given an Stsg and a recognizable weighted tree language p of input trees, we investigate under which conditions the weighted tree language obtained by applying G to p is again recognizable.",
        "In other words, we investigate under which conditions the forward application of G preserves recognizability.",
        "The same question is investigated for backward application, which is the corresponding operation given a recognizable weighted tree language of output trees.",
        "Since Stsg are symmetric (i.e., input and output can be exchanged), the results for backward application can be obtained easily from the results for forward application.",
        "Our main result is that forward application preserves recognizability if the Stsg G is output-productive, which means that each rule of G contains at least one output symbol that is not a state.",
        "Dually, backward application preserves recognizability if G is input-productive, which is the analogous property for the input side.",
        "In fact, those results hold for weights taken from an arbitrary commutative semiring (Hebisch and Weinert, 1998; Golan, 1999), but we present the results only for probabilities."
      ]
    },
    {
      "heading": "2. Preliminary definitions",
      "text": [
        "In this contribution we will work with ranked trees.",
        "Each symbol that occurs in such a tree has a fixed rank that determines the number of children of nodes with this label.",
        "Formally, let S be a ranked alphabet, which is a finite set S together with a mapping rk^ : S – N that associates a rank rks(a) with every a G S. We let Sk = {a G S | rks(a) = k} be the set containing all symbols in S that have rank k. A S-tree indexed by a set Q is a tree with nodes labeled by elements of S U Q, where the nodes labeled by some a G S have exactly rks(a) children and the nodes with labels ofQ have no children.",
        "Formally, the set Ts(Q) of (term representations of) S-trees indexed by a set Q is the smallest set T such that",
        "tl, ■ ■ ■ ,tk G T.We generally write a instead of a() for all a G S0.",
        "We frequently work with the set pos(t) of positions of a S-tree t, which is defined as follows.",
        "If t G Q, then pos(t) = {e}, and if t = a(t1,..., tk), then pos(t) = {e} U {iw | 1 < i < k,w G pos(tj)} .",
        "Thus, each position is a finite (possibly empty) sequence of natural numbers.",
        "Clearly, each position designates a node of the tree, and vice versa.",
        "Thus we identify nodes with positions.",
        "As usual, a leaf is a node that has no children.",
        "The set of all leaves of t is denoted by lv(t).",
        "Clearly, lv(t) ç pos(t).",
        "The label of a position w G pos(t) is denoted by t(w).",
        "Moreover, for every A ç S U Q, let pos^(t) = {w G pos(t) | t(w) G A} and lvA(t) = pos^(t) n lv(t) be the sets of positions and leaves that are labeled with an element of A, respectively.",
        "Let t G Ts (Q) and wi,...,wk G lvg(t) be k (pairwise) different leaves.",
        "We write t[w1 – t1;..., wk – tk] or just t[wi – ti | 1 < i < k] with ti,..., tk G Te(q) for the tree obtained from t by replacing, for every 1 < i < k, the leaf wi with the tree ti.",
        "For the rest of this paper, let S and A be two arbitrary ranked alphabets.",
        "To avoid consistency issues, we assume that a symbol a that occurs in both S and A has the same rank in S and A; i.e., rks(a) = rkA(a).",
        "A deterministic relabeling is a mapping r : S – A such that r(a) G Ak for every a G Sk.",
        "For a tree s G Ts, the relabeled tree r(s) G Ta is such that pos(r(s)) = pos(s) and (r(s))(w) = r(s(w)) for every w G pos(s).",
        "The class of tree transformations computed by deterministic relabelings is denoted by dREL.",
        "A tree language (over S) is a subset of Ts.",
        "Correspondingly, a weighted tree language (over S) is a mapping p : Ts – R>0.",
        "A weighted tree transformation (over S and A) is a mapping t : Ts x Ta – R>0.",
        "Its inverse is the weighted tree transformation t : Ta x Ts – R>0, which is defined by t-i(t, s) = t(s, t) for every t G Ta and s G Ts."
      ]
    },
    {
      "heading": "3. Synchronous tree substitution grammars with states",
      "text": [
        "Let Q be a finite set of states with a distinguished initial state qS G Q.",
        "A connected tree pair is a tuple (s,t, V,a) where s G TE(Q), t G Ta(Q), and a G R>0.",
        "Moreover, V : 1vq(s) – lvg(t) is a bijective mapping such that s(u) = t(v) for every (u, v) G V. We will often identify V with its graph.",
        "Intuitively, a connected tree pair (s, t, V, a) is a pair of trees (s, t) with a weight a such that each node labeled by a state in s has a corresponding node in t, and vice versa.",
        "Such a connected tree pair (s, t, V, a) is input-productive and output-productive if s G Q and t G Q, respectively.",
        "Let Conn denote the set of all connected tree pairs that use the index set Q.",
        "Moreover, let Connp ç Conn contain all connected tree pairs that are input-or output-productive.",
        "A synchronous tree substitution grammar G (with states) over S, A, and Q (for short: Stsg), is a finite set of rules of the form q – (s, t, V, a) where q Q and ( s, t, V, a) Connp.",
        "We call a rule q – ( s, t, V, a) a q-rule, of which q and ( s, t, V, a) are the left-hand and right-hand side, respectively, and a is its weight.",
        "The Stsg G is input-productive (respectively, output-productive) if each of its rules is so.",
        "To simplify the following development, we assume (without loss of generality) that two different q-rules differ on more than just their weight.",
        "To make sure that we do not account essentially the same derivation twice, we have to use a deterministic derivation mode.",
        "Since the choice is immaterial, we use the leftmost derivation mode for the output component t of a connected tree pair (s, t, V, a).",
        "For every (s, t, V, a) Conn such that V = 0, the leftmost output position is the pair (w,w;) G V, where w' is the leftmost (i.e., the lexicographically smallest) position of 1vq (t).",
        "Next we define derivations.",
        "The derivation relation induced by G is the binary relation =>g over Conn such that if and only if the leftmost output position of £ is ( w, w') Viand there exists a rule such that• a2 = ai • a.",
        "A sequence D = G Connn is a• £i =>q for every 1 < i < n – 1.",
        "The set of all such derivations is denoted by DQ (s,t,V,a).",
        "tQ (s,t,V )= a.",
        "!Formally, q -+ (s, t, V,a) e G and q -+ (s, t, V,b) e G implies a = b.",
        "Finally, the weighted tree transformation computed by G is the weighted tree transformation tq : Ts x TA – M>o with tq(s, t) = rQS (s, t, 0) for every s G Ts and t G Ta.",
        "As usual, we call two Stsg equivalent if they compute the same weighted tree transformation.",
        "We observe that every Stsg is essentially a linear, nondeleting weighted extended top-down (or bottom-up) tree transducer (Arnold and Dauchet, 1982; Graehl et al., 2008; Engelfriet et al., 2009) without (both-sided) epsilon rules, and vice versa.",
        "easily be checked that tq(s,t) = 6.3.2.3.3s = a(a(a, a), a) and t = a(a, a(a, a)).",
        "Moreover, tq (s, s) = tq (s,t).",
        "If rg (s,t, 0) = 0 with q G {e, o}, then s and t have the same number ofa-labeled leaves.",
        "This number is odd ifq = o, otherwise it is even.",
        "Moreover, at every position w G pos(s), the left and right subtrees s1 and s2are interchanged in s and t (due to V in the rules P1, P2, P5, P6) except if s1 and s2 contain an even and odd number, respectively, ofa-labeled leaves.",
        "In the latter case, the subtrees can be interchanged or left unchanged (both with probability 1 /6)."
      ]
    },
    {
      "heading": "4. Recognizable weighted tree languages",
      "text": [
        "Next, we recall weighted regular tree grammars (Alexandrakis and Bozapalidis, 1987).",
        "To keep the presentation simple, we identify Wrtg with particular Stsg, in which the input and the output components are identical.",
        "More precisely, a weighted regular tree grammar over S and Q (for short: Wrtg) is an Stsg g over S, S, and Q where each rule has the form q – (s,s, id, a) where id is the suitable (partial) identity mapping.",
        "It follows that s g/ Q, which yields that we do not have chain rules.",
        "In the rest of this paper, we will specify a rule q - (s, s, id, a) of a Wrtg simply by q – s. For every q g Q, we define the weighted tree language pQ : Ts(Q) – R>0 generated by G from q by pQ(s) = rQ(s, s, idiVQ(s)) for every s g Ts(Q), where idlVQ(s) is the identity on 1vq(s).",
        "Moreover, the weighted tree language pq : Ts – R>0 generated by G is defined by Pq (s) = pgs (s) for every s g Ts.",
        "A weighted tree language p : Ts – R>0 is recognizable if there exists a Wrtg g such that p = pq .",
        "We note that our notion of recognizability coincides with the classical one (Alexandrakis and Bozapalidis, 1987; Fulop and Vogler, 2009).",
        "Example 2.",
        "We consider the Wrtg k over the input alphabet S = {a, a} and P = {p, q} with qS = q, rk(a) = 2, and rk(a) = 0.",
        "The Wrtg k contains the following rules:",
        "Let s g Ts be such that pK(s) = 0.",
        "Then s is a thin tree with zigzag shape; i.e., there exists n > 1 such that pos(s) contains exactly the positions:",
        "0 < i < l,ßyrJ.",
        "The integer n can be understood as the length of a derivation that derives s from q.",
        "Some example trees with their weights are displayed in Figure 2.",
        "o-",
        "(a(o,e),a(e,o), V, 1/3)",
        "(Pi)",
        "o-",
        "+ (a(e,o),a(o,e), V, 1/6)",
        "(P2)",
        "o-",
        "+ (a(e,o),a(e,o), id, 1/6)",
        "(P3)",
        "o-",
        "(a, a, 0, 1/3)",
        "(P4)",
        "e-",
        "■+(a(e,e),a(e,e),V, 1/2)",
        "(P5)",
        "e-",
        "■+(a(o,o),a(o,o),V, 1/2)",
        "(P6)",
        "Proposition 3.",
        "For every Wrtg G there is an equivalent Wrtg G' in normal form, in which the right-hand side ofevery rule contains exactly one symbol ofS.",
        "Proof.",
        "We can obtain the statement by a trivial extension to the weighted case of the approach used in Lemma II.3.4 of (Gecseg and Steinby, 1984) and Section 6 of (Gecseg and Steinby, 1997).",
        "□"
      ]
    },
    {
      "heading": "5. Stsg and weighted bimorphisms",
      "text": [
        "In this section, we characterize the expressive power of Stsg in terms of weighted bimorphisms.",
        "This will provide a conceptually clear pattern for the construction in our main result (see Theorem 6) concerning the closure of recognizable weighted tree languages under forward and backward application.",
        "For this we first recall tree homomorphisms.",
        "Let r and S be two ranked alphabets.",
        "Moreover, let h : r – Ts x (N*)* be a mapping such that h(Y) = (s, u1,..., uk) for every 7 G rk where s G Ts and all leaves G lv(s) are pairwise different.",
        "The mapping h induces the (linear and complete) tree homomorphism h : Tr – Ts, which is defined by h(7(d1,...,dfc)) = s[u1 – d1,...,ufc – 4] for every 7 G rk and , G Tr with",
        "h(7) = (s, u1,..., uk) and d* = h(d*) for every 1 < i < k. Moreover, every (linear and complete) tree homomorphism is induced in this way.",
        "In the rest of this paper we will not distinguish between h and h and simply write h instead of h. The homomorphism h is order-preserving if u1 < • • • < uk for every 7 G rk where h(7) = (s, u1,..., uk).",
        "Finally, we note that every r G dREL can be computed by a order-preserving tree homomorphism.",
        "A weighted bimorphism B over S and A consists of a Wrtg over r and P and two tree ho-",
        "(hin, hout)",
        "momorphisms",
        "hm : Tr – Ts and hout : Tr – Ta .",
        "The bimorphism B computes the weighted tree transformation rB : Ts x Ta – R>0 with for every s G Ts and t G TA.",
        "Without loss of generality, we assume that every bimorphism B is presented by an Wrtg K in normal form and an order-preserving output homomorphism hout.",
        "Next, we prepare the relation between S tsg and weighted bimorphisms.",
        "Let G be an Stsg over S, A, and Q.",
        "Moreover, let B be a weighted bimorphism over S and A consisting of (i) K over r and P in normal form, (ii) hin, and (iii) order-preserving hout.",
        "We say that G and B are related if Q = P and there is a bijection 6 : G – K such that, for every rule P G G with P = (q – (s, t, V, a)) and 6(p) = (p 7(P1,... ,Pk)) we have",
        "1.",
        "For every derivation D G Dg (s, t, 0, a) with q G Q, s G Ts, t G TA, a G R>0, there exists d G Tr and a derivation D' G Dg(d, d, 0, a) such that hin(d) = s and hout(d) = t.",
        "2.",
        "For every d G Tr and D' G Dg (d,d, 0,a) with q G Q and a G R>0, there exists a derivation D G Dg(hin(d), hout(d), 0, a).",
        "3.",
        "The mentioned correspondence on derivations is a bijection.",
        "Given an Stsg G, we can easily construct a weighted bimorphism B such that G and B are related, and vice versa.",
        "Hence, Stsg and weighted bimorphisms are equally expressive, which generalizes the corresponding characterization result in the unweighted case by Shieber (2004), which we will state after the introduction of Stsg j.",
        "Classical synchronous tree substitution grammars (Stsg j) do not have states.",
        "An Stsg j can be seen as an Stsg by considering every substitution site (i.e., each pair of synchronised nonterminals) as a state.",
        "We illustrate this by means of an example here.",
        "Let us consider the Stsg j G with the following rules:",
        "• (B(a), D(ß)) with weight 0.4.",
        "The substitution sites are marked with j.",
        "Any rule with root A can be applied to a substitution site Aj.",
        "An equivalent Stsg G' has the rules:",
        "where V = {(2,1)} and V' = {(2,2)}.",
        "It is easy to see that G and G' are equivalent.",
        "Let S = {7,7', 7'', a, ß} where 7,7', 7'' G S1and a, ß G S0 (and 7' = 7'' and a = ß).",
        "We write 7m(t) with t G Ts for the tree 7^ • • 7(t) • • • ) containing m occurrences of 7 above t. Stsg j have a certain locality property, which yields that Stsgj cannot compute transformations like for every s, t G Ts.",
        "The non-local feature is the correspondence between the symbols 7' and a (in the first alternative) and the symbols 7'' and ß (in the second alternative).",
        "An Stsg that computes r is presented in Figure 4.",
        "Theorem 4.",
        "Let r be a weighted tree transformation.",
        "Then the following are equivalent.",
        "1. t is computable by an Stsg.",
        "2. t is computable by a weighted bimorphism.",
        "3.",
        "There exists a Stsg j G and deterministic re-labelings r1 and r2 such that",
        "T (s,t)= £ TQ (s',t') .",
        "The inverse of an STSG computable weighted tree transformation can be computed by an STSG.",
        "Formally, the inverse of the STSG G is the STSG where V-1 is the inverse of V. Then tq-1 = rQ\"."
      ]
    },
    {
      "heading": "6. Forward and backward application",
      "text": [
        "Let us start this section with the definition of the concepts of forward and backward application of a weighted tree transformation r : Ts x Ta – R>0to weighted tree languages p : Ts – R>0 and 0 : Ta – R>0.",
        "We will give general definitions first and deal with the potentially infinite sums later.",
        "The forward application of r to p is the weighted tree language r(p) : Ta – R>0, which is defined for every t G Ta by",
        "Dually, the backward application of r to 0 is the weighted tree language r-1(0) : Ts – R>0, which is defined for every s G Ts by",
        "In general, the sums in Equations (1) and (2) can be infinite.",
        "Let us recall the important property that makes them finite in our theorems.",
        "Proposition 5.",
        "For every input-productive (resp., output-productive) Stsg g and every tree s g Ts(resp., t g Ta), there exist only finitely many trees t g TA (respectively, s g Ts) such that",
        "TQ (s,t) =0.",
        "Proofsketch.",
        "If g is input-productive, then each derivation step creates at least one input symbol.",
        "Consequently, any derivation for the input tree s can contain at most as many steps as there are nodes (or positions) in s. Clearly, there are only finitely many such derivations, which proves the statement.",
        "Dually, we can obtain the statement for output-productive Stsg.",
        "□",
        "In the following, we will consider forward applications tq (p) where g is an output-productive STSG and p is recognizable, which yields that (1) is well-defined by Proposition 5.",
        "Similarly, we consider backward applications r-where g is input-productive and 0 is recognizable, which again yields that (2) is well-defined by Proposition 5.",
        "The question is whether tq (p) and r-(0) qi qi q2 q2 qi qi q2 q2 q2 – ß – ß are again recognizable.",
        "To avoid confusion, we occasionally use angled parentheses as in (p, q) instead of standard parentheses as in (p, q).",
        "Moreover, for ease of presentation, we identify the initial state qS with (qS, qS).",
        "Theorem 6.",
        "Let G be an Stsg over S, A, and Q.",
        "Moreover, let p : Ts – R>0 and 0 : Ta – R>0be recognizable weighted tree languages.",
        "1.",
        "If G is output-productive, then tq(p) is recognizable.",
        "2.",
        "If G is input-productive, then r-(0) is recognizable.",
        "Proof.",
        "For the first item, let K be a WRTG over S and P such that p = pK.",
        "Without loss of generality, we suppose that K is in normal form.",
        "Intuitively, we take each rule q – (s, t, V, a) of G and run the WRTG K with every start state p on the input side s of the rule.",
        "In this way, we obtain a weight b.",
        "The WRTG will reach the state leaves of s in certain states, which we then transfer to the linked states in t to obtain t'.",
        "Finally, we remove the input side and obtain a rule (p, q) – t' for the WRTG L that represents the forward application.",
        "We note that the same rule of L might be constructed several times.",
        "If this happens, then we replace the several copies by one rule whose weight is the sum of the weights of all copies.",
        "As already mentioned the initial state is (qS, qS).",
        "Clearly, this approach is inspired (and made reasonable) by the bimorphism characterization.",
        "We can take the Hadamard product of the WRTG of the bimorphism with the inverse image of pk under its input homomorphism.",
        "Then we can simply project to the output side.",
        "Our construction performs those three steps at once.",
        "The whole process is illustrated in Figure 5.",
        "Formally, we construct the WRTG L over A and P x Q with the following rules.",
        "Let p G P, q G Q, and t' G Ta(P x Q).",
        "Then (p, q) – t' is a rule in L', where",
        "This might create infinitely many rules in L', but clearly only finitely many will have a weight different from 0.",
        "Thus, we can obtain the finite rule set L by removing all rules with weight 0.",
        "The main statement to prove is the following: for every t G Ta(Q) with lvg(t) = {v1,..., vfc}, p,p1,... ,pfc G P, and q G Q which yields = p<?S,9S>(t)= p£(t) .",
        "In the second item G is input-productive.",
        "Then G-is output-productive and r-(0) = tq-1 (0).",
        "Hence the first statement proves that r-(0) is recognizable.",
        "□",
        "Example 7.",
        "As an illustration of the construction in Theorem 6, let us apply the Stsg G of Example 1 to the WRTG K over S and P = {p, qS, qa} and the following rules:",
        "In fact, K is in normal form and is equivalent to the WRTG ofExample 2.",
        "Using the construction in the proofofTheorem 6 we obtain the WRTG L over S and P x Q with Q = { e, o}.",
        "We will only",
        "Figure 5: Illustration of the construction in the proof of Theorem 6 using the Wrtg K of Example 7: some example rule (left), run of K on the input side of the rule (middle), and resulting rule (right).",
        "show rules of L that contribute to pL.",
        "To the right ofeach rule we indicate from which state ofK and which rule ofG the rule was constructed.",
        "The initial state of L is (qs, o).",
        "It is easy to see that every t G Ts such that pL(t) = 0 is thin, which means that |pos(t) n Nn| < 2 for every n G N."
      ]
    },
    {
      "heading": "7. Domain and range",
      "text": [
        "Finally, let us consider the domain and range of a weighted tree transformation r : Ts x Ta – R>0.",
        "Again, we first give general definitions and deal with the infinite sums that might occur in them later.",
        "The domain dom(r) of r and the range range(r) of r are defined by for every s G Ts and t G TA.",
        "Obviously, the domain dom(r) is the range range(r-) of the inverse of r. Moreover, we can express the domain dom(r) of r as the backward application twhere 1 is the weighted tree language that assigns the weight 1 to each tree.",
        "Note that 1 is recognizable for every ranked alphabet.",
        "We note that the sums in Equations (3) and (4) might be infinite, but for input-productive (respectively, output-productive) Stsg G the domain dom(rq) (respectively, the range range(rq)) are well-defined by Proposition 5.",
        "Using those observations and Theorem 6 we can obtain the following statement.",
        "Corollary 8.",
        "Let G be an Stsg.",
        "If G is input-productive, then dom(rq) is recognizable.",
        "Moreover, if G is output-productive, then range(rq) is recognizable.",
        "Proof.",
        "These statements follow directly from Theorem 6 with the help of the observation that",
        "Conclusion",
        "We showed that every output-productive Stsg preserves recognizability under forward application.",
        "Dually, every input-productive Stsg preserves recognizability under backward application.",
        "We presented direct and effective constructions for these operations.",
        "Special cases of those constructions can be used to compute the domain of an input-productive Stsg and the range of an output-productive Stsg.",
        "Finally, we presented a characterization of the power of Stsg in terms of weighted bimorphisms."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "Zoltan FUlOp and Heiko Vogler were financially supported by the TAMOP-4.2.2/08/1/2008-0008 program of the Hungarian National Development Agency.",
        "Andreas Maletti was financially supported by the Ministerio de Educacion y Ciencia (MEC) grant JDCI-2007-760."
      ]
    }
  ]
}
