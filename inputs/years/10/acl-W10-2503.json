{
  "info": {
    "authors": [
      "Andreas Maletti",
      "Giorgio Satta"
    ],
    "book": "Proceedings of the 2010 Workshop on Applications of Tree Automata in Natural Language Processing",
    "id": "acl-W10-2503",
    "title": "Parsing and Translation Algorithms Based on Weighted Extended Tree Transducers",
    "url": "https://aclweb.org/anthology/W10-2503",
    "year": 2010
  },
  "references": [
    "acl-D09-1005",
    "acl-H05-1101",
    "acl-J08-3004",
    "acl-N04-1014",
    "acl-N06-1033",
    "acl-P06-2036"
  ],
  "sections": [
    {
      "text": [
        "Andreas Maletti*",
        "Departement de Filologies Romàniques Universität Rovira i Virgili Tarragona, Spain",
        "This paper proposes a uniform framework for the development of parsing and translation algorithms for weighted extended (top-down) tree transducers and input strings.",
        "The asymptotic time complexity of these algorithms can be improved in practice by exploiting an algorithm for rule factorization in the above transducers."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "In the field of statistical machine translation, considerable interest has recently been shown for translation models based on weighted tree transducers.",
        "In this paper we consider the so-called weighted extended (top-down) tree transducers (WXTTs for short).",
        "WXTTs have been proposed by Graehl and Knight (2004) and Knight (2007) and are rooted in similar devices introduced earlier in the formal language literature (Arnold and Dauchet, 1982).",
        "WXTTs have enough expressivity to represent hierarchical syntactic analyses for natural language sentences and can directly model most of the elementary operations that rule the process of translation between natural languages (Knight, 2007).",
        "Furthermore, the use of weights and internal states allows the encoding of statistical parameters that have recently been shown to be extremely useful in discriminating likely translations from less plausible ones.",
        "For an WXTT M, the parsing problem is traditionally defined for a pair of trees t and u and requires as output some representation of the set of all computations of M that map t into u.",
        "Similarly, the translation problem for M is defined for an input tree t and requires as output some representation of the set of all computations of M mapping t",
        "* Financially supported by the Ministerio de Educacion y Ciencia (MEC) grant JDCI-2007-760.",
        "into any other tree.",
        "When we deal with natural language processing applications, however, parsing and translation are most often represented on the basis of input strings rather than trees.",
        "Some tricks are then applied to map the problem back to the case of input trees.",
        "As an example in the context of machine translation, let w be some input string to be translated.",
        "One can intermediately construct a tree automaton Mw that recognizes the set of all possible trees that have w as yield with internal nodes from the input alphabet of M. This automaton Mw is further transformed into a tree transducer implementing a partial identity translation.",
        "This transducer is then composed with M (relational composition) to obtain a transducer that represents all translations of w. This is usually called the 'cascaded' approach.",
        "In contrast with the cascaded approach above, which may be rather inefficient, we investigate a more direct technique for both parsing and translation of strings based on WXTTs.",
        "We do this by extending to WXTTs the well-known BAR-HILLEL construction defined for context-free grammars (Bar-Hillel et al., 1964) and for weighted context-free grammars (Nederhof and Satta, 2003).",
        "We then derive computational complexity results for parsing and translation of input strings on the basis of WXTTs.",
        "Finally, we develop a novel factorization algorithm for WXTTs that, in practical applications, can reduce the asymptotic complexity for such problems."
      ]
    },
    {
      "heading": "2. Preliminary definitions",
      "text": [
        "Let • be an associative binary operation on a set S. If S contains an element 1 such that 1s = s = s • 1 for every s G S, then (S, •, 1) is a monoid.",
        "Such a monoid (S, •, 1) is commutative if the identity si • s2 = s2 • si holds for all si, s2 G S. A commutative semiring (S, +, •, 0,1) is an algebraic structure such that:",
        "monoids,• • distributes over + (from both sides), and",
        "• s • 0 = 0 = 0 • s for every s G S.",
        "From now on, let (S, +, •, 0,1) be a commutative semiring.",
        "An alphabet is a finite set of symbols.",
        "A weighted string automaton [WSA] (Schützenberger, 1961; Eilenberg, 1974) is a system N = (P, T, J, v, F) where",
        "• P and T are alphabets of states and input symbols, respectively,",
        "• J, F : P – S assign initial and final weights, respectively, and",
        "• v : P x T x P – S assigns a weight to each transition.",
        "The transition weight mapping v can be understood as square matrices v( ,7, •) G SPxP for every y G T. The WSA N is deterministic if",
        "• for every p G P and 7 G T there exists at most one p G P such that v(p, 7, p') = 0.",
        "We now proceed with the semantics of N. We will define the initial algebra semantics here; alternative, equivalent definitions of the semantics exist (Sakarovitch, 2009).",
        "Let w G T* be an input string, 7 G T, and p,p G P be two states.",
        "We extend v to a mapping hv : P x T* x P – S recursively as follows:",
        "Consequently, for all p,p G P and u,w G T*.",
        "Then the matrix hv (;7i ••• 7k, •) equals v (•, 71, •) •... • v (;7k, •).",
        "Thus, if the semiring operations can be performed in constant time and access to v(p, 7, q) is in constant time for every p,q G P, then for every w G T* we can compute the matrix hv(^,w, •) in time O(|w| • |P|) because it can be computed by |w| – 1 matrix multiplications.",
        "The WSA N computes the map N : T* – S, which is defined for every w G T* by",
        "Since we will also consider individual runs, let us recall the run semantics as well.",
        "Let w = y1 • • • 7k g T* be an input string of length k. Then any mapping r : [0, k] – P is a run of N on w, where [0, k] denotes the set of integers between (inclusive) 0 and k. A run can be understood as a vector of states and thus we sometimes write ri instead of r(i).",
        "The weight of such a run r, denoted by wtN (r), is defined by wtN(r) = i\\ki=l v(ri-i,7i, n).",
        "Then for every p, p' G P and w G T* ."
      ]
    },
    {
      "heading": "3. Weighted extended tree transducers",
      "text": [
        "Next, we move to tree languages, for which we need to introduce some additional notation.",
        "Let S be a ranked alphabet, that is, an alphabet whose symbols have a unique associated arity.",
        "We write Sk to denote the set of all k-ary symbols in S. We use the special nullary symbol e g S0 to syntactically represent the empty string e. The set of S-trees indexed by a set V, denoted by T^(V), is the smallest set satisfying both of the following conditions:",
        "• for every v G V, the single node labeled v, written v, is a tree of T^(V),",
        "• for every a g Sk and ti,... ,tk g T^(V), the tree with a root node labeled a and trees ti,...,tk as its k children, written a(ti,...,tk ), belongs to TS(V ).",
        "Throughout this paper we sometimes write a() as just a.",
        "In the following, let t g T^(V).",
        "The set of positions Pos(t) ç N* of a tree t g TS(V ) is recursively defined as follows:",
        "for every v g V, a g Sk, and ti,... ,tk g T^(V ) where t = a(ti, .",
        ".",
        ".",
        ", tk).",
        "The label of t at position w g Pos(t) is denoted by t(w).",
        "The size of the tree t g Ts is defined as |t| = |Pos(t)|.",
        "For every w g Pos(t) the subtree of t that is rooted at w is denoted by subt(w); i.e., for every a G Sk, t]_,... ,tk G Ts(V), 1 < i < k, and w G Pos(ti).",
        "Finally, the set of variables var(t) is given by var(t) = {v G V | 3w G Pos(t) : t(w) = v} .",
        "If for every v G var(t) there exists exactly one w G Pos(t) such that t(w) = v, then t is linear.",
        "We use the fixed sets X = {xi | i > 1} and Y = {Vi,j | 1 < i < j} of formal variables and the subsets Xk = {xi | 1 < i < k} and Yk = {yij | 1 < i < j < k} for every k > 0.",
        "Note that Xo = 0.",
        "For every H ç So U X U Y, the H-yield of t is recursively defined by ydH(t) = t if t G H \\{e}, ydH (t) =ydH (ti ) ••• ydH (tk ) if t = a(ti,... ,tk) with a G Sk and k > 1, and ydH (t) = e otherwise.",
        "If H = S0 U X U Y, then we also omit the index and just write yd(t).",
        "Let l G Ts(V ) and 9 : V – TS(V ).",
        "Then l9 denotes the result obtained from l by replacing every occurrence of v G V by 9(v).",
        "The k-fold application is denoted by l9k.",
        "If l9k = l9k+ for some k > 0, then we denote l9k by l9*.",
        "In addition, if V = Xk, then we write l[9(xi),..., 9(xk)] instead of l9.",
        "We write Cs(Xk) for the subset of those trees of Ts(Xk) such that every variable of x G Xk occurs exactly once in it.",
        "Given t G Ts(X), we write dec(t) for the set• Q is an alphabet of states,",
        "• S and A are ranked alphabets of input and output symbols, respectively,",
        "• I : Q – S assigns initial weights, and",
        "• R is a finite set of rules of the form (q,l) – (qi • •• qk ,r) with q,qi, ...,qk G Q, l G Cs(Xk) and r G Ca(Xk), and s G S such that {l, r} ç X.",
        "Let us discuss the final restriction imposed on the rules of a WXTT.",
        "Essentially, it disallows rules of the form (q, xi) – – (q', xi) with q,q' G Q and s G S. Such pure epsilon rules only change the state and charge a cost.",
        "However, they can yield infinite derivations (and with it infinite products and sums) and are not needed in our applications.",
        "The WXTT M is standard if ydX(r) = xi • • • xk for every (q, l) – – (qi • • • qk,r) G R. This restriction enforces that the order of the variables is fixed on the right-hand side r, but since the order is arbitrary in the left-hand side l (and the names of the variables are inconsequential), it can be achieved easily without loss of generality.",
        "If there are several rules that differ only in the naming of the variables, then their weights should be added to obtain a single standard rule.",
        "To keep the presentation simple, we also construct nonstandard WXTTs in the sequel.",
        "However, we implicitly assume that those are converted into standard WXTTs.",
        "The semantics of a standard WXTT is inspired by the initial-algebra semantics for classical weighted top-down and bottom-up tree transducers (Fülöp and Vogler, 2009) [also called top-down and bottom-up tree series transducers by En-gelfriet et al.",
        "(2002)].",
        "Note that our semantics is equivalent to the classical term rewriting semantics, which is presented by Graehl and Knight fact, we will present an equivalent semantics based on runs later.",
        "Let M = (Q, S, A, I, R) be a WXTT.",
        "We present a definition that is more general than immediately necessary, but the generalization will be useful later on.",
        "For every n G N, pi,...,pn G Q, and L ç R, we define the mapping hpL-pn : Ts(Xn) x TA(Xn) – SQ by hPL \" Pn (xi, xi)Pi = 1 for every 1 < i < n and for all remaining t G Ts(Xn), u G TA(Xn), and q G Q.",
        "Note that for each nonzero summand in (1) one of the decompositions dec(t) and dec(u) must be proper (i.e., either l / X or r G X).",
        "This immediately yields that the sum is finite and the recursion well-defined.",
        "The transformation computed by M, also denoted by M, is the mapping M : Ts x Ta – S, which is defined by M(t,u) = Y,qeQ I(q)^hn(t,u)q for every t G Tsand u G Ta.",
        "Let us also introduce a run semantics for the WXTT (Q, S, A,I,R).",
        "The rank of a rule p = (q, l) – (qi • • • qk, r) G R, denoted by rk(p), is rk(p) = k. This turns R into a ranked alphabet.",
        "The input state of p is in(p) = q, the ith output state is outi(p) = qi for every 1 < i < k, and the weight of p is wt(p) = s. A tree r G Tr(X) is called run if in(r(wi)) = outi(r(w)) for every wi G Pos(r) and 1 < i < rk(r(w)) such that r(wi) G R. The weight of a run r G Tr(X) is ni(p(ri,..., rk)) = lMn),..., ni(rfc)] n2(p(ri,... ,rk)) = r[n2(ri),... ,n2(rk)] .",
        "We obtain the weighted tree transformation for every t g Ts and u g Ta as follows",
        "M(t,u)= I(in(r(e))) • wt(r) .",
        "This approach is also called the bimorphism approach (Arnold and Dauchet, 1982) to tree transformations."
      ]
    },
    {
      "heading": "4. Input and output restrictions of WXTT",
      "text": [
        "In this section we will discuss the Bar-Hillel construction for the input and the output part of a WXTT M. This construction essentially restricts the input or output of the WXTT M to the string language recognized by a WSA N. Contrary to (direct or inverse) application, this construction is supposed to yield another WXTT.",
        "More precisely, the constructed WXTT should assign to each translation (t, u) the weight assigned to it by M multiplied by the weight assigned by N to the yield of t (or u if the output is restricted).",
        "Since our WXTTs are symmetric, we will actually only need one construction.",
        "Let us quickly establish the mentioned symmetry statement.",
        "Essentially we just have to exchange left-and right-hand sides and redistribute the states in those left-and right-hand sides accordingly.",
        "WXTT.",
        "Theorem 1.",
        "There exists a WXTT M' such that M '(u, t) = M (t, u) for every t g Ts and u g Ta.",
        "Proof.",
        "Let M' = (Q, A, E, I, R') be the WXTT such that",
        "R' = {(q,r) – (w,l) | (q,l) – (w,r) G R} .",
        "With the symmetry established, we now only need to present the Bar-Hillel construction for either the input or output side.",
        "Without loss of generality, let us assume that M is standard.",
        "We then choose the output side here because the order of variables is fixed in it.",
        "Note that we sometimes use the angled parentheses '(' and ')' instead of parentheses for clarity.",
        "Definition 2.",
        "Let N = (P, r, J, v, F) be a WSA - si = hv (pi ,wi,pi) for every 0 < i < k.",
        "Let p = (q,l) (qi ••• qk, r) G R. The size of p is |p| = |l| + |r|.",
        "The size and rank of the WXTT M are |M| = EpeR|p| and rk(M) = maxpeR rk(p), respectively.",
        "Finally, the maximal output yield length of M, denoted by len(M), is the maximal length of yd(r) for all rules (q,l) (qi ••• qk, r) G R.",
        "The size and rank of Prod(M, N) are in O(|M| • |P|2rk(M)+) and rk(M), respectively.",
        "We can compute Prod(M, N) in time O(|R| • len(M) • |P|2rk(M)+).",
        "if n is deterministic, then the size of Prod(M, N) is in O(|M| • |P|rk(Mand the required time is in O(|R| • len(M) • |P|rk(MNext, let us prove that our Bar-Hillel construction is actually correct.",
        "Theorem 3.",
        "Let M and N be as in Definition 2, and let M' = Prod(M,N).",
        "Then M'(t,u) = M(t,u) • N(yd(u)) for every t G Tsand u G Ta.",
        "It should be clear that M'(u, t) = M(t, u) for every t G Ts and u G Ta.",
        "□ for every t g Ts, u g Ta, q g Q, and p,p' g P. Now we can prove the main statement as follows:",
        "p,p'eP qeQ",
        "for every t g Ts and u g Ta.",
        "□",
        "Note that the typical property of many Bar-Hillel constructions, namely that a run of M and a run of N uniquely determine a run of Prod(M, N) and vice versa, does not hold for our construction.",
        "In fact, a run of M and a run of N uniquely determine a run of Prod(M, N), but the converse does not hold.",
        "We could modify the construction to enable this property at the expense of an exponential increase in the number of states of Prod(M, N).",
        "However, since those relations are important for our applications, we explore the relation between runs in some detail here.",
        "To simplify the discussion, we assume, without loss of generality, that M is standard and s = s'for every two rules (q,l) – (w,r) g R and (q, l) – (w, r) g R. Moreover, we assume the symbols of Definition 2.",
        "For every r' g Tr' (X), we let base(r') denote the run obtained from r' by replacing each symbol by just (q, l) – (qi • • • qk, r) g R. Thus, we replace a rule (which is a symbol) of R' by the underlying rule of R. We start with a general lemma, which we believe to be self-evident.",
        "Lemma4.",
        "Let r' g TR' and n = |yd(n2(r'))|.",
        "Then wtM' (r') = wtM(base(r'))^r€R„ wtN(r) where R'' is a nonempty subset of {r: [0,n] – P | in(r'(e)) = (ro,q,r„)}.",
        "Let us assume that N is trim (i.e., all states are reachable and co-reachable) and unambiguous.",
        "In this case, for every y1 • • • Yk g r* and p, p' g P there is at most one successful run r : [0, k] – P such that",
        "• ro = p and rk = p'.",
        "This immediately yields the following corollary.",
        "Corollary 5 (of Lemma 4).",
        "Let N be trim and unambiguous.",
        "For every r' G TR' we have for some r : [0, n] – P with n = |yd(n2(r'))|.",
        "We now turn to applications of the product construction.",
        "We first consider the translation problem for an input string w and a WXTT M. We can represent w as a trim and unambiguous WSA Nwthat recognizes the language { w} with weight of 1 on each transition (which amounts to ignoring the weight contribution of Nw ).",
        "Then the input product transducer Mw = Prod(Nw, M) provides a compact representation of the set of all computations of M that translate the string w. From Corollary 5 we have that the weights of these computations are also preserved.",
        "Thus,",
        "Mw (Ts x Ta) = E(t)„)eTExTA Mw (t,u) is the weight of the set of string translations of w.",
        "As usual in natural language processing applications, we can exploit appropriate semirings and compute several useful statistical parameters through Mw(Ts x Ta), as for instance the highest weight of a computation, the inside probability and the rule expectations; see (Li and Eisner, 2009) for further discussion.",
        "One could also construct in linear time the range tree automaton for Mw, which can be interpreted as a parsing forest with all the weighted trees assigned to translations of w under M. If we further assume that M is unambiguous, then Mw will also have this property, and we can apply standard techniques to extract from Mw the highest score computation.",
        "In machine translation applications, the unambiguity assumption is usually met, and avoids the so-called 'spurious' ambiguity, that is, having several computations for an individual pair of trees.",
        "The parsing problem for input strings w and u can be treated in a similar way, by restricting M both to the left and to the right."
      ]
    },
    {
      "heading": "5. Rule factorization",
      "text": [
        "As already discussed, the time complexity of the product construction is an exponential function of the rank of the transducer.",
        "Unfortunately, it is not possible in the general case to cast a",
        "WXTT into a normal form such that the rank is bounded by some constant.",
        "This is also expected from the fact that the translation problem for subclasses of WXTTs such as synchronous context-free grammars is NP-hard (Satta and Peserico, 2005).",
        "Nonetheless, there are cases in which a rank reduction is possible, which might result in an improvement of the asymptotical runtime of our construction.",
        "Following the above line, we present here a linear time algorithm for reducing the rank of a WXTT under certain conditions.",
        "Similar algorithms for tree-based transformation devices have been discussed in the literature.",
        "Nesson et al.",
        "(2008) consider synchronous tree adjoining grammars; their algorithm is conceptually very similar to ours, but computationally more demanding due to the treatment of adjunction.",
        "Following that work, we also demand here that the new WXTT 'preserves' the recursive structure of the input WXTT, as formalized below.",
        "Galley et al.",
        "(2004) algorithm also behaves in linear time, but deals with the different problem of tree to string translation.",
        "Rank reduction algorithms for string-based translation devices have also been discussed by Zhang et al.",
        "(2006) and Gildea et al.",
        "(2006).",
        "Recall that M = (Q, E, A, I, R) is a standard WXTT.",
        "Let M' = (Q', E, A, I', R') be a WXTT with Q Ç Q'.",
        "Then M' is a structure-preserving factorization of M if",
        "• hRV\"Pn (t,u)q = hR\"'Pn (t,u)q for every q,Pi,...,Pn G Q, t G Tx(Xn), and u G TA (Xn).",
        "In particular, we have hR' (t, u)q = hR(t, u)q for n = 0.",
        "Consequently, M' and M are equivalent because",
        "= J2 I(q) • hR(t,u)q = M(t,u) .",
        "Note that the relation 'is structure-preserving factorization of' is reflexive and transitive, and thus, a pre-order.",
        "Moreover, in a ring (actually, additively cancellative semirings are sufficient) it is also antisymmetric, and consequently, a partial order.",
        "Informally, a structure-preserving factorization of M consists in a set of new rules that can be composed to provide the original rules and preserve their weights.",
        "We develop an algorithm for finding a structure-preserving factorization by decomposing each rule as much as possible.",
        "The algorithm can then be iterated for all the rules in the WXTT.",
        "The idea underlying our algorithm is very simple.",
        "Let p = (q,l) – (ql • • • qk, r) G R be an original rule.",
        "We look for subtrees l' and r' of l and r, respectively, suchthat var(l') = var(r' ).",
        "The condition that var(l') = var(r') is derived from the fact that hR'\"*(l',r')q = 0 if var(l') = var(r').",
        "We then split p into two new rules by 'excising' subtrees l' and r' from l and r, respectively.",
        "In the remaining trees the 'excised' trees are replaced with some fresh variable.",
        "The tricky part is the efficient computation of the pairs (wi,wr), since in the worst case the number of such pairs is in 6(|l| • |r|), and naive testing of the condition var(l') = var(r') takes time O(rk(p)).",
        "Let us start with the formal development.",
        "Recall the doubly-indexed set Y = | 1 < i < j}.",
        "Intuitively speaking, the variable will represent the set {%i,...,xj}.",
        "With this intuition in mind, we define the mapping vars : TS(X U Y) – as follows:",
        "for every i, j G N with i < j, a G Ek, and ti,...,tk G TS(X U Y).",
        "Clearly, vars(t) can be computed in time O(|t|), which also includes the computation of vars(u) for every subtree u of t. In addition, vars(t)3 = |var(t)| for all linear t G TS(X).",
        "Finally, if t G Tj](X), then vars(t)1 and vars(t)2 are the minimal and maximal index i G N such that Xi G var(t), respectively (they are oo and 0, respectively, if var(t) = 0).",
        "For better readability, we use minvar(t) and maxvar(t) for vars(t)1 and vars(t)2, respectively.",
        "Let p = (q, l) – >■ (q1 • • • qk, r) G R be an original rule.",
        "In the following, we will use minvar(t), maxvar(t), and |var(t)| freely for all subtrees t of l and r and assume that they are precomputed, which can be done in time O(|p|).",
        "Moreover, we will freely use the test ' var(t) = var(u)' for subtrees t and u of l and r, respectively.",
        "This test can be performed in constant time [disregarding the time needed to precompute vars(t) and vars(u)] by the equivalent test",
        "• |var(u)| = maxvar(u) – minvar(u) + 1.",
        "Our factorization algorithm is presented in Algorithm 1.",
        "Its first two parameters hold the left-and right-hand side (l, r), which are to be decomposed.",
        "The third and fourth parameter should initially be x1.",
        "To simplify the algorithm, we assume that it is only called with left-and right-hand sides that (i) contain the same variables and (ii) contain at least two variables.",
        "These conditions are ensured by the algorithm for the recursive calls.",
        "The algorithm returns a decomposition of (l, r) in the form of a set D Ç TS(X U Y) x Ta(X U Y) such that var(l') = var(r') for every (l', r') G D. Moreover, all such l' and r' are linear.",
        "Finally, the pairs in D can be composed (by means of point-wise substitution at the variables of Y) to form the original pair (l, r).",
        "Before we move on to formal properties of Algorithm 1, let us illustrate its execution on an example.",
        "Example 6.",
        "We work with the left-hand side l = a(x1, a(x3, x2)) and the right-hand side r = y(a(x1, Y(a(x2,x3)))).",
        "Then |var(l)| > 2 and var(l) = var(r).",
        "Let us trace the call Decompose(l , r, x1 , x1 ).",
        "The condition in line 1 is clearly false, so we proceed with line 3.",
        "The condition is true for i = 1 , so we continue with Decompose(l, a(x1, y(a(x2, x3))), x1, y(x1)).",
        "This time neither the condition in line 1 nor the condition in line 3 are true.",
        "In line 6, j is set to 1 and we initialize r' = x1 and r'2 = Y(a(x2, x3)).",
        "Moreover, the array h is initialized to h(1) = 1, h(2) = 2, and h(3) = 2.",
        "Now let us discuss the main loop starting in line 12 in more detail.",
        "First, we consider i = 1 .",
        "Since l = x , the condition in line 13 is fulfilled and we set l' = x1 and proceed with the next iteration (i = 2).",
        "This time the condition of line 13 is false because l2 = a(x3, x2) and var(l2) = var(rh(2)) = var(r2) = {x2,x3}.",
        "Consequently, j is set to 2 and l2 = r2 = y2)3.",
        "Next, Decompose(a(x3, x2), Y(a(x2, x3)), x1, x1) is processed.",
        "Let us suppose that it generates the set D. Then we return",
        "DU {(a(x1,3/2,3),Y(a(x1,3/2,3)))} .",
        "Finally, let us quickly discuss how the set D is obtained.",
        "Since the condition in line 3 is true, we have to evaluate the recursive call Decompose(a(x3, x2), a(x2, x3), x1, y(x1)).",
        "Now, j = 2, h(2) = 1, and h(3) = 2.",
        "Moreover, r1' = x2 and r2' = x3.",
        "In the main loop starting in line 12, the condition of line 13 is always fulfilled, which yields that l1' = x3 and l2' = x2.",
        "Thus, we return {(a(x3,x2),Y(a(x2,x3)))}, which is exactly the input because decomposition completely failed.",
        "Thus, the overall decomposition ofl and r is which, when the second pair is substituted (point-wise) for //^3 in the first pair, yields exactly (l, r).",
        "Informally, the rules are obtained as follows from D. If all variables occur in a pair (l', r') G D, then the left-hand side is assigned to the original input state.",
        "Furthermore, for every variable /jij we introduce a new fresh state q^, whereas the variable xi is associated to qi.",
        "In this way, we determine the states in the right-hand side.",
        "Formally, let p = (q,l) – (q1 ••• qk, r) be the original rule and D be the result of Decompose(l , r, x1 , x1 ) of Algorithm 1.",
        "In addition, for every 1 < i < j < k, let qAiJ be a new state such that qA^k = q.",
        "Let",
        "QP = {q, q1,..., qk} u {qp>i>j 11 < i < j < k} .",
        "Then for every (l', r') G D we obtain the rule for every 1 < I < n. The rules obtained in this fashion are collected in Rp.",
        "The WXTT dec(M) is dec(M) = (Q', E, A, I', R') where Algorithm 1 Decompose(1, r, l', r') computing the decomposition of linear l g Ts(Xk) and r g TA(Xk) with var(l) = var(r) and |var(l)| > 2.",
        "li rj yminvar(ii) ,maxvar(ii )",
        "18: D = DU Decompose(li,rj ,xi,xi)",
        "{p G R | rk(p) < 2} U (J RP .",
        "To measure the success of the factorization, we introduce the following notion.",
        "The degree of M, denoted by deg(M), is the minimal rank of all structure-preserving factorizations M' of M; i.e., deg(M) = min rk(M') .",
        "M' a structure-preserving factorization of M",
        "Then the goal of this section is the efficient computation of a structure-preserving factorization M' of M such that rk(M') = deg(M).",
        "Theorem 7.",
        "The WXTT dec(M) is a structure-preserving factorization of M such that rk(dec(M)) = deg(M).",
        "Moreover, dec(M) can be computed in time O(|M|).",
        "Proof.",
        "Let us only discuss the runtime complexity shortly.",
        "Clearly, Decompose(l , r, x1 , x1 ) should be called once for each rule (q,l) – (q1 ••• qk, r) G R. In lines 1^ the structure of l and r is inspected and the properties var(li) = var(l) and var(ri) = var(r) are tested in constant time.",
        "Mind that we precomputed vars(l) and vars(r), which can be done in linear time in the size of the rule.",
        "Then each subtree ri is considered in lines 7-10 in constant time.",
        "Finally, we consider all direct input subtrees li in lines 12-18.",
        "The tests involving the variables are all performed in constant time due to the preprocessing step that computes vars(l) and vars(r).",
        "Moreover, at most one recursive call to Decompose is generated for each input subtree ti.",
        "So if we implement the union in lines 18 and 19 by a constant-time operation (such as list concatenation, which can be done since it is trivially a disjoint union), then we obtain the linear time-complexity.",
        "□"
      ]
    },
    {
      "heading": "6. Concluding remarks",
      "text": [
        "In this paper we have shown how to restrict computations of WXTTs to given input and output WSA, and have discussed the relevance of this technique for parsing and translation applications over input strings, resulting in the computation of translation forests and other statistical parameters of interest.",
        "We have also shown how to factorize transducer rules, resulting in an asymptotic reduction in the complexity for these algorithms.",
        "In machine translation applications transducers usually have very large sets of rules.",
        "One should then specialize the restriction construction in such a way that the number of useless rules for Prod(Nw, M) is considerably reduced, resulting in a more efficient construction.",
        "This can be achieved by grounding the construction of the new rules by means of specialized strategies, as usually done for parsing based on context-free grammars; see for instance the parsing algorithms by Younger (1967) or by Earley (1970).",
        "if r = S(ri,... ,rn) and there exists i e N is such thatvar(rt) = var(r) then for all 1 < i < n do while j < maxvar(ri) do"
      ]
    }
  ]
}
