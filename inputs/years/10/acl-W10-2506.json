{
  "info": {
    "authors": [
      "Matthias Büchse",
      "Daniel Geisler",
      "Torsten Stüber",
      "Heiko Vogler"
    ],
    "book": "Proceedings of the 2010 Workshop on Applications of Tree Automata in Natural Language Processing",
    "id": "acl-W10-2506",
    "title": "n-Best Parsing Revisited",
    "url": "https://aclweb.org/anthology/W10-2506",
    "year": 2010
  },
  "references": [
    "acl-J03-1006",
    "acl-J99-4004",
    "acl-N06-1045",
    "acl-P02-1038",
    "acl-P09-1067",
    "acl-P09-1108",
    "acl-W05-1506",
    "acl-W09-3801"
  ],
  "sections": [
    {
      "text": [
        "n-Best Parsing Revisited*",
        "Matthias Büchse and Daniel Geisler and Torsten Stüber and Heiko Vogler",
        "Faculty of Computer Science Technische Universität Dresden 01062 Dresden",
        "{buechse,geisler,stueber,vogler}@tes.inf.tu-dresden.de",
        "We derive and implement an algorithm similar to (Huang and Chiang, 2005) for finding the n best derivations in a weighted hypergraph.",
        "We prove the correctness and termination of the algorithm and we show experimental results concerning its runtime.",
        "Our work is different from the aforementioned one in the following respects: we consider labeled hypergraphs, allowing for tree-based language models (Maletti and Satta, 2009); we specifically handle the case of cyclic hypergraphs; we admit structured weight domains, allowing for multiple features to be processed; we use the paradigm of functional programming together with lazy evaluation, achieving concise algorithmic descriptions."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "In statistical natural language processing, probabilistic models play an important role which can be used to assign to some input sentence a set of analyses, each carrying a probability.",
        "For instance, an analysis can be a parse tree or a possible translation.",
        "Due to the ambiguity of natural language, the number of analyses for one input sentence can be very large.",
        "Some models even assign an infinite number of analyses to an input sentence.",
        "In many cases however, the set of analyses can in fact be represented in a finite and compact way.",
        "While such a representation is space-efficient, it may be incompatible with subsequent operations.",
        "In these cases a finite subset is used as an approximation, consisting of n best analyses, i. e. n analyses with highest probability.",
        "For example, this approach has the following two applications.",
        "(1) Reranking: when log-linear models (Och and Ney, 2002) are employed, some features may",
        "* This research was financially supported by DFG VO 1101/5-1.",
        "not permit an efficient evaluation during the computation of the analyses.",
        "These features are computed using individual analyses from said approximation, leading to a reranking amongst them.",
        "(2) Spurious ambiguity: many models produce analyses which may be too fine-grained for further processing (Li et al., 2009).",
        "As an example, consider context-free grammars, where several leftmost derivations may exist for the same terminal string.",
        "The weight of the terminal string is obtained by summing over these derivations.",
        "The n best leftmost derivations may be used to approximate this sum.",
        "In this paper, we consider the case where the finite, compact representation has the form of a weighted hypergraph (with labeled hyperedges) and the analyses are derivations of the hypergraph.",
        "This covers many parsing applications (Klein and Manning, 2001), including weighted deductive systems (Goodman, 1999; Nederhof, 2003), and also applications in machine translation (May and Knight, 2006).",
        "In the nomenclature of (Huang and Chiang, 2005), which we adopt here, a derivation of a hypergraph is a tree which is obtained in the following way.",
        "Starting from some node, an ingoing hy-peredge is picked and recorded as the label of the root of the tree.",
        "Then, for the subtrees, one continues with the source nodes of said hyperedge in the same way.",
        "In other words, a derivation can be understood as an unfolding of the hypergraph.",
        "The n-best-derivations problem then amounts to finding n derivations which are best with respect to the weights induced by the weighted hypergraph.",
        "Among others, weighted hypergraphs with labeled hyperedges subsume the following two concepts.",
        "(I) probabilistic context-free grammars (pcfgs).",
        "'Note that this problem is different from the n-best-hyperpaths problem described by Nielsen et al.",
        "(2005), as already argued in (Huang and Chiang, 2005, Section 2).",
        "In this case, nodes correspond to nonterminals, hyperedges are labeled with productions, and the derivations are exactly the abstract syntax trees (ASTs) of the grammar (which are closely related the parse trees).",
        "Note that, unless the pcfg is unambiguous, a given word may have several corresponding ASTs, and its weight is obtained by summing over the weights of the ASTs.",
        "Hence, the n best derivations need not coincide with the n best words (cf. application (2) above).",
        "(II) weighted tree automata (wta) (Alexandrakis and Bozapalidis, 1987; Berstel and Reutenauer, 1982; Ésik and Kuich, 2003; Fülöp and Vogler, 2009).",
        "These automata serve both as a tree-based language model and as a data structure for the parse forests obtained from that language model by applying the Bar-Hillel construction (Maletti and Satta, 2009).",
        "It is well known that context-free grammars and tree automata are weakly equivalent (Thatcher, 1967; Ésik and Kuich, 2003).",
        "However, unlike the former formalism, the latter one has the ability to model non-local dependencies in parse trees.",
        "In the case of wta, nodes correspond to states, hyperedges are labeled with input symbols, and the derivations are exactly the runs of the automaton.",
        "Since, due to ambiguity, a given tree may have several accepting runs, the n best derivations need not coincide with the n best trees.",
        "As for the pcfgs, this is an example of spurious ambiguity, which can be tackled as indicated by application (2) above.",
        "Alternatively, one can attempt to find an equivalent deterministic wta (May and Knight, 2006; Büchse et al., 2009).",
        "Next, we briefly discuss four known algorithms which solve the n-best-derivations problem or subproblems thereof.",
        "• The Viterbi algorithm solves the 1-best-derivation problem for acyclic hypergraphs.",
        "It is based on a topological sort of the hypergraph.",
        "• Knuth (1977) generalizes Dijkstra's algorithm (for finding the single-source shortest paths in a graph) to hypergraphs, thus solving the case n = 1 even if the hypergraph contains cycles.",
        "Knuth assumes the weights to be real numbers, and he requires weight functions to be monotone and superior in order to guarantee that a best derivation exists.",
        "(The superiority property corresponds to Dijkstra's requirement that edge weights – or, more generally, cycle weights – are nonnegative.)",
        "best-derivations problem can be solved efficiently by first solving the 1-best-derivation problem and then extending that solution in a lazy manner.",
        "Huang and Chiang assume weighted unlabeled hypergraphs with weights computed in the reals, and they require the weight functions to be monotone.",
        "Moreover they assume that the 1-best-derivation problem be solved using the Viterbi algorithm, which implies that the hypergraph must be acyclic.",
        "However they conjecture that their second phase also works for cyclic hypergraphs.",
        "• Pauls and Klein (2009) propose a variation of the algorithm of Huang and Chiang (2005) in which the 1-best-derivation problem is computed via an A*-based exploration of the 1-best charts.",
        "In this paper, we also present an algorithm for solving the n-best-derivations problem.",
        "Ultimately it uses the same algorithmic ideas as the one of Huang and Chiang (2005); however, it is different in the following sense:",
        "1. we consider labeled hypergraphs, allowing for wta to be used in parsing;",
        "2. we specifically handle the case of cyclic hypergraphs, thus supporting the conjecture of Huang and Chiang; for this we impose on the weight functions the same requirements as Knuth and use his algorithm;",
        "3. by using the concept of linear pre-orders (and not only linear orders on the set of reals) our approach can handle structured weights such as vectors over frequencies, probabilities, and reals;",
        "4. we present our algorithm in the framework of functional programming (and not in that of imperative programming); this framework allows to decribe algorithms in a more abstract and concise, yet natural way;",
        "5. due to the lazy evaluation paradigm often found in functional programming, we obtain the laziness on which the algorithm of Huang and Chiang (2005) is based for free;",
        "6. exploiting the abstract level of description (see point 4) we are able to prove the correctness and termination of our algorithm.",
        "At the end of this paper, we will discuss experiments which have been performed with an implementation of our algorithm in the functional programming language Haskell."
      ]
    },
    {
      "heading": "2. The n-best-derivations problem",
      "text": [
        "In this section, we state the n-best-derivations problem formally, and we give a comprehensive example.",
        "First, we introduce some basic notions.",
        "Trees and hypergraphs The definition of ranked trees commonly used in formal tree language theory will serve us as the basis for defining derivations.",
        "A ranked alphabet is a finite set E (of symbols) where every symbol carries a rank (a nonnegative integer).",
        "By E(fc) we denote the set of those symbols having rank k. The set of trees over E, denoted by Tjj, is the smallest set T such that for every k G N, a G and 6,---,6 e T, also <t(£i,...,&) G T; for <r G E<°) we abbreviate crQ by a.",
        "For every A; G N, a G E(fc) and subsets Tu...,Tk ç Tr we define the top-concatenation (with a) a(T\\,...,Tk) = M6, • • • ,6) I 6 e Ti,... ,6 G Tfc}.",
        "A Yj-hypergraph is a pair iï = (V, E?)",
        "where V is a finite set (of vertices or nodes) and £7 Ç x E x V is a finite set (of hyperedges) such that for every (v\\... vk, a, v) G E we have that a G j](fc).",
        "We interpret E as a ranked alphabet where the rank of each edge is carried over from its label in E. The family (Hv \\ v G V) ofderivations of H is the smallest family (Pv \\ v G V) of subsets of Te such that e(Pvl,..., PVk) ç P„ for every e = (vi.",
        "..vk,a,v) G £.",
        "for every j G {2,..., 1} and vl occurs It is called acyclic if it is not cyclic.",
        "Example 1 Consider the ranked alphabet E =",
        "• E = {{e, a, 1), {e, ß, 1), (1,7,1), (11, a, 0), (1,7,0)}.",
        "A graphical representation of this hypergraph is shown in Fig. 1.",
        "Note that this hypergraph is cyclic because of the edge (1,7,1).",
        "We indicate the derivations of H, assuming that ei,..., e5 are the edges in E in the order given above:",
        "Figure 1 : Hypergraph of Example 1.",
        "• H0 = eA(Hi,Hi) U e5(Hi) where, e.g., e±{Hi,Hi) is the top-concatenation of Hi, Hi with e4, and thus",
        "e4(ei, e3(ei)), e4(e3(ei), ei),... } .",
        "Next we give an example of ambiguity in hypergraphs with labeled hyperedges.",
        "Suppose that E contains an additional hyperedge e% = (0,7,0).",
        "Then Hq would contain the derivations ee(e5(ei)) and e5(e3(ei)), which describe the same E-tree, viz. 7(7(0;)) (obtained by the node-wise projection to the second component).",
        "□ In the sequel, let H = (V, E) be a Y-hypergraph.",
        "Ordering Usually an ordering is induced on the set of derivations by means of probabilities or, more generally, weights.",
        "In the following, we will abstract from the weights by using a binary relation ^ directly on derivations, where we will interpret the fact {1 ^ (2 as \"{1 is better than or equal to {2\" Example 2 (Ex.",
        "1 contd.)",
        "First we show how an ordering is induced on derivations by means of weights.",
        "To this end, we associate an operation over the set R of reals with every hyperedge (respecting its arity) by means of a mapping 6:",
        "The weight h(£) of a tree £ G Te is obtained by interpreting the symbols at each node using 6, e. g. Me3(e2)) = tf(e3)(tf(e2)()) = 0(e2)() + 1 = 4.",
        "Then the natural order < on R induces the binary relation -< over Te as follows: for every",
        "6,6 e TE we let 6 3 6 iff M6) < M6), meaning that trees with smaller weights are considered better.",
        "(This is, e. g., the case when calculating probabilités in the image of – logo;.)",
        "Note",
        "that we could just as well have defined ^ with the inverted order.",
        "Since addition is commutative, we obtain for every 6,6 e TE that /i(e4(6,6)) = ^(e4(6,6)) and thus e4(6,6) 3 e4(6,6) and vice versa.",
        "Thus, for two different trees (e4(6,6) and e4(6, 6)) having the same weight, ^ should not prefer any of them.",
        "That is, ^ need not be antisymmetric.",
        "As another example, the mapping 6 could assign to each symbol an operation over real-valued vectors, where each component represents one feature of a log-linear model such as frequencies, probabilities, reals, etc.",
        "Then the ordering could be defined by means of a linear combination of the feature weights.",
        "□",
        "We use the concept of a linear pre-order to capture the orderings which are obtained this way.",
        "Let S be a set.",
        "A pre-order (on S) is a binary relation -< Ç S x S such that (i) s ^ s for every seS (reflexivity) and (ii) S\\ ^ s2 and s2 ^ S3 implies S\\ ^ S3 for every Si,s2,S3 G S (transitivity).",
        "A pre-order -< is called linear if s\\ ^ s2or s2 -< si for every si, s2 G S*.",
        "For instance, the binary relation ^ on Te as defined in Ex.",
        "2 is a linear pre-order.",
        "We will restrict our considerations to a class of linear pre-orders which admit efficient algorithms.",
        "For this, we will always assume a linear pre-order ^ with the following two properties (cf. Knuth (1977)).",
        "CP (compatibility) For every pair e(6,... , 6)> e(£, •••,&) e TE with 6 3 ei, 6 3 Cfc we have that e(6,---,6) ^ e(£,...,&).",
        "It is easy to verify that the linear pre-order ^ of Ex.",
        "2 has the aforementioned properties.",
        "In the sequel, let ~^be a linear pre-order on Te fulfilling SP and CP.",
        "Before we state the n-best-derivations problem formally, we define the operation minra, which maps every subset T of Te to the set of all sequences of n best elements of T. To this end, let T ç TE and n < \\T\\.",
        "We define minra(T) to be the set of all sequences (6, • • •, 6) S Tra of pairwise distinct elements such that 6 ^ ... ^ 6 and for every { G T \\ {6, ■ ■ ■, 6} we have 6 ^ £.",
        "For every n > |T| we set minra(T) = min|T|(T).",
        "In addition, we set min<ra(T) = U?=o m^ni(T).",
        "n-best-derivations problem The n-best-derivations problem amounts to the following.",
        "Given a S-hypergraph H = (V, E), a vertex v G V, and a linear pre-order -< on Tg fulfilling SP and CP, compute an element of minn(Hv)."
      ]
    },
    {
      "heading": "3. Functional Programming",
      "text": [
        "We will describe our main algorithm as a functional program.",
        "In essence, such a program is a system of (recursive) equations that defines several functions (as shown in Fig. 2).",
        "As a consequence the main computational paradigm for evaluating the application (f a) of a function f to an argument a is to choose an appropriate defining equation f x = r and then evaluate (f a) to r ' which is obtained from r by substituting every occurrence of x by a.",
        "We assume a lazy (and in particular, call-by-need) evaluation strategy, as in the functional programming language Haskell.",
        "Roughly speaking, this amounts to evaluating the arguments of a function only as needed to evaluate the its body (i. e. for branching).",
        "If an argument occurs multiple times in the body, it is evaluated only once.",
        "We use Haskell notation and functions for dealing with lists, i. e. we denote the empty list by [] and list construction by x:xs (where an element x is prepended to a list xs), and we use the functions head (line 01), tail (line 02), and take (lines 03 and 04), which return the first element in a list, a list without its first element, and a prefix of a list, respectively.",
        "In fact, the functions shown in Fig. 2 will be used in our main algorithm (cf.",
        "Fig.",
        "4).",
        "Thus, we explain the functions merge (lines 05-07) and e(li,... ,1k) (lines 08-10) a bit more in detail.",
        "The merge function takes a set C of pairwise disjoint lists of derivations, each one in ascending order with respect to ^, and merges them into ~ Standard Haskell functions: list deconstructors, take operation ~ merge operation (lists in £ should be disjoint) ~ top concatenation (lj if j<i one list with the same property (as known from the merge sort algorithm).",
        "Note that the minimum used in line 07 is based on the linear pre-order ^.",
        "For this reason, it need not be uniquely determined.",
        "However, in an implementation this function is deterministic, depending on the the data structures.",
        "The function e(li,...,lfc) implements the top-concatenation with e on lists of derivations.",
        "It is defined for every e = (v\\... Vk, cr, v) G E and takes lists li, ..., lfc of derivations, each in ascending order as for merge.",
        "The resulting list is also in ascending order."
      ]
    },
    {
      "heading": "4. Algorithm",
      "text": [
        "In this section, we develop our algorithm for solving the n-best-derivations problem.",
        "We begin by motivating our general approach, which amounts to solving the 1-best-derivation problem first and then extending that solution to a solution of the n-best-derivations problem.",
        "It can be shown that for every m > n, the set mmn(Hv) is equal to the set of all prefixes of length n of elements of mmm(Hv).",
        "According to this observation, we will develop a function p mapping every v G V to a (possibly infinite) list such that the prefix of length n is in mmn(Hv) for every n. Then, by virtue of lazy evaluation, a solution to the n-best-derivations problem can be obtained by evaluating the term take n (p v) where take is specified in lines 03-04 of Fig. 2.",
        "Thus, what is left to be done is to specify p appropriately.",
        "Consider the following provisional specification of p:",
        "where the functions merge and e(li,... ,1^) are specified in lines 05-07 and lines 08-10 of Fig. 2, respectively.",
        "This specification models exactly the trivial equation for every v G V, where the union and the top-concatenation have been implemented for lists via the functions merge and e(li,... ,1^).",
        "This specification is adequate if H is acyclic.",
        "For cyclic hypergraphs however, it can not even solve the 1-best-derivation problem.",
        "To illustrate this, we consider the hypergraph of Ex.",
        "2 and cal-",
        "= minjhead ei(),head e2(), e3(head (p 1))}.",
        "Note that the infinite regress occurs because the computation of the head element head (pi) depends on itself.",
        "This leads us to the idea of \"pulling\" this head element (which is the solution to the 1-best-derivation problem) \"out\" of the merge in (f).",
        "Applying this idea to our particular example, we reach the following equation for p 1 :",
        "because e2 is the best derivation in Hi.",
        "Then, in order to evaluate merge we have to compute",
        "minjhead ei(),head e3(p 1)} = min{ei, e3(head (p 1))} = min{ei, e3(e2)}.",
        "Since h(ei) = fo(e3(e2)) = 4, we can choose any of them, say ei, and continue:",
        "Generalizing this example, the function p could be specified as follows:",
        "where b 1 evaluates the 1-best derivation in Hi and exp \"somehow\" calculates the next best derivations.",
        "In the following subsection, we elaborate this approach.",
        "First, we develop an algorithm for solving the 1-best-derivation problem.",
        "Using SP and CP, it can be shown that for every v £ V such that Hv / 0 there is a minimal derivation in Hv which does not contain any subderivation in Hv (apart from itself).",
        "In other words, it is not necessary to consider cycles when solving the 1-best-derivation problem.",
        "We can exploit this knowledge in a program by keeping a set U of visited nodes, taking care not to consider edges which lead us back to those nodes.",
        "Consider the following function:",
        "where U' = U U {v}",
        "The argument U is the set of visited nodes.",
        "The term b v 0 evaluates to a minimal element of Hv, or to min 0 if Hv = 0.",
        "The problem of this divide-and-conquer (or top-down) approach is that managing a separate set U for every recursive call incurs a big overhead in the computation.",
        "This overhead can be avoided by using a dynamic programming (or bottom-up) approach where each node is visited only once, and nodes are visited in the order of their respective best derivations.",
        "To be more precise, we maintain a family (Pv \\ v G V) of already found best derivations (where Pv G min<i(i?î)) and initially empty) and a set C of candidate derivations, where candidates for all vertices are considered at the same time.",
        "In each iteration, a minimal candidate with respect to ^ is selected.",
        "This candidate is then declared the best derivation of its respective node.",
        "The following lemma shows that the bottom-up approach is sound.",
        "Lemma 3 Let (Pv \\ v G V) be a family such that Pv G min<i(i?î)).",
        "We define Then (i) for every £ G lXevp„=0tnere zs a£' G C such that £' ■< £, and (ii) for every v G V and £ G C n Hv the following implication holds: if i < i' far every £' G C, then { G mmi(Hv).",
        "An algorithm based on this lemma is shown in Fig. 3.",
        "Its key function iter uses the notion of accumulating parameters.",
        "The parameter q is a mapping corresponding to the family (Pv \\ v G V) of the lemma, i. e., q v = Pv; the parameter c is a set corresponding to C. We begin in line 01 with the function qO mapping every vertex to the empty list.",
        "According to the lemma, the candidates then consist of the miliary edges.",
        "As long as there are candidates left (line 04), in a recursive call of iter the parameter q is updated with the newly found pair (v, [£]) of vertex v and (list of) best derivation £ (expressed by Require X-hypergraph H = (V,E), linear pre-order -< fulfilling SP and CP.",
        "Ensure b v G mini(^) for every v G V such that if b v == [e(£i,..., for some e = (v\\ ... Vk, a, v) G E, then b Vj == [£J for every i G {1,... , k}."
      ]
    },
    {
      "heading": "05. where",
      "text": [
        "q// (v, [£] ) ) and the candidate set is recomputed accordingly.",
        "When the candidate set is exhausted (line 03), then q is returned.",
        "Correctness and completeness of the algorithm follow from Statements (ii) and (i) of Lemma 3, respectively.",
        "Now we show termination.",
        "In every iteration a new next best derivation is determined and the candidate set is recomputed.",
        "This set only contains candidates for vertices v G V such that q v == [].",
        "Hence, after at most \\V\\ iterations the candidates must be depleted, and the algorithm terminates.",
        "We note that the algorithm is very similar to that of Knuth (1977).",
        "However, in contrast to the latter, (i) it admits Hv = 0 for some v G V and (ii) it computes some minimal derivation instead of the weight of some minimal derivation.",
        "Runtime According to the literature, the runtime of Knuth's algorithm is in 0(\\E\\ ■ \\og\\V\\) (Knuth, 1977).",
        "This statement relies on a number of optimizations which are beyond our scope.",
        "We just sketch two optimizations: (i) the candidate set can be implemented in a way which admits obtaining its minimum in 0(log|C|), and (ii) for the computation of candidates, each edge needs to be considered only once during the whole run of the algorithm.",
        "Being able to solve the 1-best-derivation problem, we can now refine our specification of p. The refined algorithm is given in Fig. 4; for the functions not given there, please refer to Fig. 3 (function b) and to Fig. 2 (functions merge, tail, and the top-concatenation).",
        "In particular, line 02 of Fig. 4 shows the general way of \"pulling out\" the head element as it was indicated in Section 4.1 via an example.",
        "We also remark that the definition of the top-concatenation (lines 08-09 of Fig. 2) corresponds to the way in which mult^fc was sped up in Fig. 4 of (Huang and Chiang, 2005).",
        "Theorem 4 The algorithm in Fig. 4 is correct with respect to its require/ensure specification and it terminates for every input.",
        "Proof (Sketch).",
        "We indicate how induction on n can be used for the proof.",
        "If n = 0, then the statement is trivially true.",
        "Let n > 0.",
        "If b v == [], then the statement is trivially true as well.",
        "Now we consider the converse case.",
        "To this end, we use the following three auxiliary statements.",
        "(3) take n (tail 1) = tail (take (n+1) 1).",
        "Using these statements, line 04 of Fig. 2, and line 02 of Fig. 4, we are able to \"pull\" the take of take n (p v) \"into\" the right-hand side of p v, ultimately yielding terms of the form take n (p Vj) in the first line of the merge application and take (n-1) (p in the second one.",
        "Then we can show the following statement by induction on m (note that the n is still fixed from the outer induction): for every m G N we have that if the tree in b v has at most height m, then take n (p v) G minn (fi\",,).",
        "To this end, we use the following two auxiliary statements.",
        "(4) For every sequence of pairwise disjoint subsets Pi,...,Pfc ç \\JveV Hv, sequence of natural numbers ni,...,nfc G N, and lists h G",
        "minni(Pi), lk G min„fc(Pfc) such that",
        "nj > n for every j G {ï,...,k} we have that take n (merge {h,.",
        ".., lk}) G min„(PiU.. .UPfc).",
        "lk G min„(Pfc) we have that take n e(Zi, ...,/&) G min„(e(Pi,... ,Pfc)).",
        "Using these statements, it remains to show that {e(£i, •••,&)} o minn_i((e(ü\"^,... ,HVk) \\ {e(a...,6)}) U [je,^e'(Hv,,...,Hv,k)) Ç mmn(Hv) where b v = [e(£i,..., £fc)] and o denotes language concatenation.",
        "This can be shown by using the definition of min„.",
        "Termination of the algorithm now follows from the fact that every finite prefix of p v is well defined.",
        "■ Require E-hypergraph H = (V, E), linear pre-order ■< fulfilling SP and CP.",
        "Ensure (take n (p v)) G minn(Hv) for every v G V and n G N.",
        "if b v == [e(£i, •••,&)] Figure 4: Algorithm solving the n-best-derivations problem.",
        "We have implemented the algorithm (consisting of Figs.",
        "3 and 4 and the auxiliary functions of Fig. 2) in Haskell.",
        "The implementation is rather straightforward except for the following three points.",
        "(1) Weights: we assume that ^ is defined by means of weights (cf. Ex.",
        "2), and that comparing these weights is in 0(1) (which often holds because of limited precision).",
        "Hence, we store with each derivation its weight so that comparison according to ^ is in 0(1) as well.",
        "(2) Memoization: we use a memoization technique to ensure that no derivation occurring in p v is computed twice.",
        "(3) Merge: the merge operation deserves some consideration because it is used in a nested fashion, yielding trees of merge applications.",
        "This leads to an undesirable runtime complexity because these trees need not be balanced.",
        "Thus, instead of actually computing the merge in p and in the top-concatenation, we just return a data structure describing what should be merged.",
        "That data structure consists of a best element and a list of lists of derivations to be merged (cf. lines 06 and 09 in Fig. 2).",
        "We use a higher-order function to manage these data structures on a heap, performing the merge in a nonnested way.",
        "Runtime Here we consider the n-best part of the algorithm, i. e. we assume the computation of the mapping b to take constant time.",
        "Note however that due to memoization, b is only computed once.",
        "Then the runtime complexity of our implementation is in 0(\\E\\ + \\ V\\ n ■ log(|i£| +n)).",
        "This can be seen as follows.",
        "By line 02 in Fig. 4, the initial heaps in the higher-order merge described under (3) have a total of \\E\\ elements.",
        "Building these heaps is thus in 0(|_E|).",
        "By line 09 in Fig. 2, each newly found derivation spawns at most as many new candidates",
        "Table 1 : Experimental results on the heap as the maximum rank in E. We assume this to be constant.",
        "Moreover, at most n derivations are computed for each node, that is, at most \\V\\-n in total.",
        "Hence, the size of the heap of a node is in 0(\\E\\ + n).",
        "For each derivation we compute, we have to pop the minimal element off the heap (cf. line 07 in Fig. 2), which is in 0(log(|I?| +n)), and we have to compute the union of the remaining heap with the newly spawned candidates, which has the same complexity.",
        "We give another estimate for the total number of derivations computed by the algorithm, which is based on the following observation.",
        "When popping a new derivation £ off the heap, new next best candidates are computed.",
        "This involves computing at most as many new derivations as the number of nodes of £, because for each hyperedge occurring in £ we have to consider the next best alternative.",
        "Since we pop off at most n elements from the heap belonging to the target node, we arrive at the estimate d ■ n, where d is the size of the biggest derivation of said node.",
        "A slight improvement of the runtime complexity can be obtained by restricting the heap size to n best elements, as argued by Huang and Chiang (2005).",
        "This way, they are able to obtain the complexity 0(\\E\\ + d - n ■ logn).",
        "We have conducted experiments on an Intel Core Duo 1200 MHz with 2 GB of RAM using a cyclic hypergraph containing 671 vertices and 12136 edges.",
        "The results are shown in Table 1.",
        "This table indicates that the runtime of the n-best part is roughly linear in n."
      ]
    }
  ]
}
