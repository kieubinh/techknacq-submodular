{
  "info": {
    "authors": [
      "Marc Dymetman",
      "Nicola Cancedda"
    ],
    "book": "Proceedings of the 4th Workshop on Syntax and Structure in Statistical Translation",
    "id": "acl-W10-3801",
    "title": "Intersecting Hierarchical and Phrase-Based Models of Translation: Formal Aspects and Algorithms",
    "url": "https://aclweb.org/anthology/W10-3801",
    "year": 2010
  },
  "references": [
    "acl-D08-1023",
    "acl-H05-1021",
    "acl-H05-1101",
    "acl-J04-4002",
    "acl-J07-2003",
    "acl-P07-2045"
  ],
  "sections": [
    {
      "text": [
        "Marc Dymetman Nicola Cancedda",
        "Xerox Research Centre Europe",
        "We address the problem of constructing hybrid translation systems by intersecting a Hiero-style hierarchical system with a phrase-based system and present formal techniques for doing so.",
        "We model the phrase-based component by introducing a variant of weighted finite-state automata, called cr-automata, provide a self-contained description of a general algorithm for intersecting weighted synchronous context-free grammars with finite-state automata, and extend these constructs to cr-automata.",
        "We end by briefly discussing complexity properties of the presented algorithms."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Phrase-based (Och and Ney, 2004; Koehn et al., 2007) and Hierarchical (Hiero-style) (Chiang, 2007) models are two mainstream approaches for building Statistical Machine Translation systems, with different characteristics.",
        "While phrase-based systems allow a direct capture of correspondences between surface-level lexical patterns, but at the cost of a simplistic handling of re-ordering, hierarchical systems are better able to constrain re-ordering, especially for distant language pairs, but tend to produce sparser rules and often lag behind phrase-based systems for less distant language pairs.",
        "It might therefore make sense to capitalize on the complementary advantages of the two approaches by combining them in some way.",
        "This paper attempts to lay out the formal prerequisites for doing so, by developing techniques for intersecting a hierarchical model and a phrase-based model.",
        "In order to do so, one first difficulty has to be overcome: while hierarchical systems are based on the mathematically well-understood formalism of weighted synchronous CFG's, phrase-based systems do not correspond to any classical formal model, although they are loosely connected to weighted finite state transducers, but crucially go beyond these by allowing phrase re-orderings.",
        "One might try to address this issue by limiting a priori the amount of re-ordering, in the spirit of (Kumar and Byrne, 2005), which would allow to approximate a phrase-based model by a standard transducer, but this would introduce further issues.",
        "First, limiting the amount of reordering in the phrase-based model runs contrary to the underlying intuitions behind the intersection, namely that the hierarchical model should be mainly responsible for controlling re-ordering, and the phrase-based model mainly responsible for lexical choice.",
        "Second, the transducer resulting from the operation could be large.",
        "Third, even if we could represent the phrase-based model through a finite-state transducer, intersecting this transducer with the synchronous CFG would actually be intractable in the general case, as we indicate later.",
        "We then take another route.",
        "For a fixed source sentence x, we show how to construct an automaton that represents all the (weighted) target sentences that can be produced by applying the phrase based model to x.",
        "However, this \"cr-automaton\" is non-standard in the sense that each transition is decorated with a set of source sentence tokens and that the only valid paths are those that do not traverse two sets containing the same token (in other words, valid paths cannot \"consume\" the same source token twice).",
        "The reason we are interested in c automata is the following.",
        "First, it is known that intersecting a synchronous grammar simultaneously with the source sentence x and a (standard) target automaton results in another synchronous grammar; we provide a self-contained description of an algorithm for performing this intersection, in the general weighted case, and where x is generalized to an arbitrary source automaton.",
        "Second, we extend this algorithm to c -automata.",
        "The resulting weighted synchronous grammar represents, as in Hiero, the \"parse forest\" (or \"hypergraph\") of all weighted derivations (that is of all translations) that can be built over x, but where the weights incorporate knowledge of the phrase-based component; it can therefore form the basis of a variety of dynamic programming or sampling algorithms (Chiang, 2007; Blunsom and Osborne, 2008), as is the case with standard Hiero-type representations.",
        "While in the worst case the intersected grammar can contain an exponential number of nonterminals, we argue that such combinatorial explosion will not happen in practice, and we also briefly indicate formal conditions under which it will not be allowed to happen.",
        "2 Intersecting weighted synchronous CFG's with weighted automata",
        "We assume that the notions of weighted finite-state automaton [W-FSA] and weighted synchronous grammar [W-SCFG] are known (for short descriptions see (Mohri et al., 1996) and (Chiang, 2006)), and we consider:",
        "1.",
        "A W-SCFG G, with associated source grammar Gs (resp.",
        "target grammar Gt); the terminals of Gs (resp.",
        "Gt) vary over the source vocabulary Vs (resp.",
        "target vocabulary Vt).",
        "2.",
        "A W-FSA As over the source vocabulary Vs, with initial state s# and final state s$.",
        "3.",
        "A W-FSA At over the target vocabulary Vt, with initial state t# and final state t$.",
        "The grammar G defines a weighted synchronous language LG over (Vs, Vt), the automaton As a weighted language Ls over Vs, and the automaton At a weighted language Lt over Vt. We then define the intersection language L' between these three languages as the synchronous language denoted L = Ls fnl LG fnl Lt over (Vs, Vt) such that, for any pair (x, y) of a source and a target sentence, the weight L(x,y) is defined by L'(x,y) = Ls(x) • LG(x,y) • Lt(y), where Ls(x), LG(x,y), Lt(y) are the weights associated to each of the component languages.",
        "It is natural to ask whether there exists a synchronous grammar G generating the language L', which we will now show to be the case.Our approach is inspired by the construction in (Bar-Hillel et al., 1961) for the intersection of a CFG and an FSA and the observation in (Lang, 1994) relating this construction to parse forests, and also partially from (Satta, 2008), although, by contrast to that work, our construction, (i) is done simultaneously rather than as the sequence of intersecting As with G, then the resulting grammar with At, (ii) handles weighted formalisms rather than non-weighted ones.",
        "We will describe the construction of G' based on an example, from which the general construction follows easily.",
        "Consider a W-SCFG grammar G for translating between French and English, with initial nonterminal S, and containing among others the following rule:",
        "where the source and target right-hand sides are separated by a slash symbol, and where 9 is a non-negative real weight (interpreted multiplicatively) associated with the rule.",
        "Now let's consider the following \"rule scheme\":",
        "This scheme consists in an \"indexed\" version of the original rule, where the bottom indices sicorrespond to states of As (\"source states\"), and the top indices ti to states of A* (\"target states\").",
        "The nonterminals are associated with two source and two target indices, and for the same nonterminal, these four indices have to match across the source and the target RHS's of the rule.",
        "As for the original terminals, they are replaced by \"indexed terminals\", where source (resp.",
        "target) terminals have two source (resp.",
        "target) indices.",
        "The source indices appear sequentially on the source RHS of the rule, in the pattern so, Si,Si,S2,S2 ...sm-i,sm, with the nonterminal on the LHS receiving source indices s0and sm, and similarly the target indices appear sequentially on the target RHS of the rule, in the pattern t0,t1,t1,t2,t2 ... tn-1, tn, with the nonterminal on the LHS receiving target indices t0and tn.",
        "To clarify, the operation of associating indices to terminals and nonterminals can be decomposed into three steps:",
        "soNs4 – so Asi si manques2 S2a S3 S3BS4 /",
        "where the first two steps corresponds to handling the source and target indices separately, and the third step then assembles the indices in order to get the same four indices on the two copies of each RHS nonterminal.",
        "The rule scheme (2) now generates a family of rules, each of which corresponds to an arbitrary instantiation of the source and target indices to states of the source and target automata respectively.",
        "With every such rule instantiation, we associate a weight 9' which is defined as:",
        "si s-termsi+i tj t-termtj+",
        "where the first product is over the indexed source terminals si s-termsi+1, the second product over the indexed target terminals *j t-term*j+ ; 9As (si; s-term, si+1) is the weight of the transition (si, s-term, si+1) according to As, and similarly for 9At (tj, t-term, tj+1).",
        "In these products, it may happen that 9as (si, s-term, si+1) is null (and similarly for A*), and in such a case, the corresponding rule instantiation is considered not to be realized.",
        "Let us consider the multiset of all the weighted rule instantiations for (1) computed in this way, and for each rule in the collection, let us \"forget\" the indices associated to the terminals.",
        "In this way, we obtain a collection of weighted synchronous rules over the vocabularies Vs and V, but where each nonterminal is now indexed by four states.",
        "When we apply this procedure to all the rules of the grammar G, we obtain a new weighted synchronous CFG G', with start symbol s## S*$, for which we have the following Fact, of which we omit the proof for lack of space.",
        "Fact 1.",
        "The synchronous language Lqi associated with G' is equal to L = Ls fnl LG fnl L*.",
        "The grammar G' that we have just constructed does fulfill the goal of representing the bilateral intersection that we were looking for, but it has a serious defect: most of its nonterminals are improductive, that is, can never produce a bi-sentence.",
        "If a rule refers to such an improductive nonterminal, it can be eliminated from the grammar.",
        "This is the analogue for a SCFG of the classical operation of reduction for CFG's; while, conceptually, we could start from G' and perform the reduction by deleting the many rules containing improductive nonterminals, it is equivalent but much more efficient to do the reverse, namely to incrementally add the productive nonterminals and rules of G' starting from an initially empty set of rules, and by proceeding bottom-up starting from the terminals.",
        "We do not detail this process, which is relatively straightforward.",
        "A note on intersecting SCFGs with transducers Another way to write Ls fnl LG fff L* is as the intersection (Ls x L*) n LG.",
        "(Ls x L*) can be seen as a rational language (language generated by a finite state transducer) of an especially simple form over Vs x V .",
        "It is then natural to ask whether our previous construction can be generalized to the intersection of G with an arbitrary finite-state transducer.",
        "However, this is not the case.",
        "Deciding the emptiness problem for the intersection between two finite state transducers is already undecidable, by reduction to Post's Correspondence problem (Berstel, 1979, p. 90) and we have extended the proof of this fact to show that intersection between a synchronous CFG and a finite state transducer also has an un-decidable emptiness problem (the proof relies on the fact that a finite state transducer can be simulated by a synchronous grammar).",
        "A fortiori, this intersection cannot be represented through an (effectively constructed) synchronous CFG."
      ]
    },
    {
      "heading": "3. Phrase-based models and a -automata",
      "text": [
        "Let Vs be a source vocabulary, V a target vocabulary.",
        "Let x = x1,..., xM be a fixed sequence of words over a certain source vocabulary Vs. Let us denote by z a token in the sequence x, and by Z the set of the M tokens in x.",
        "A a-automaton over x has the general form of a standard weighted automaton over the target vocabulary, but where the edges are also decorated with elements of P (Z ), the powerset of Z (see Fig. 1).",
        "An edge in the a-automaton between two states q and q' then carries a label of the form (a, ß), where a G P (Z) and ß G V* (note that here we do not allow ß to be the empty string e).",
        "A path from the initial state of the automaton to its final state is defined to be valid iff each token of x appears in exactly one label of the path, but not necessarily in the same order as in x.",
        "As usual, the output associated with the path is the ordered sequence of target labels on that path, and the weight of the path is the product of the weights on its edges.",
        "a-automata and phrase-based translation",
        "A mainstream phrase-based translation system such as Moses (Koehn et al., 2007) can be accounted for in terms of a-automata in the following way.",
        "To simplify exposition, we assume that the language model used is a bigram model, but any n-gram model can be accommodated.",
        "Then, given a source sentence x, decoding works by attempting to construct a sequence of phrase-pairs of the form (x1; y1 ),(xk, yk) such that each xi corresponds to a contiguous subsequence of tokens of x, the xi's do not overlap and completely cover x, but may appear in a different order than that of x; the output associated with the sequence is simply the concatenation of all the y^s in that sequence.",
        "The weight associated with the sequence of phrase-pairs is then the product (when we work with probabilities rather than log-probabilities) of the weight of each (xi+1, in the context of the previous (xi; which consists in the product of several elements: (i) the \"out-of-context\" weight of the phrase-pair (xi+1, as determined by its features in the phrase table, (ii) the language model probability of finding yi+1 following yi, (iii) the contextual weight of (xi+1, ) relative to (xi,y/i) corresponding to the distorsion cost of \"jumping\" from the token sequence xi to the token sequence xi+1 when these two sequences may not be consecutive in x.",
        "Such a model can be represented by a a-automaton, where each phrase-pair (x, y) – for",
        "Figure 1 : On the top: a er-automaton with two valid paths shown.",
        "Each box denotes a state corresponding to a phrase pair, while states internal to a phrase pair (such as tell and tcl2) are not boxed.",
        "Above each transition we have indicated the corresponding target word, and below it the corresponding set of source tokens.",
        "We use a terminal symbol $ to denote the end of sentence both on the source and on the target.",
        "The solid path corresponds to the output these totally corrupt lawyers are finished, the dotted path to the output these brown avocadoes are cooked.",
        "Note that the source tokens are not necessarily consumed in the order given by the source, and that, for example, there exists a valid path generating these are totally corrupt lawyers finished and moving according to h – y r – y tell – s tcl2 – y tel – y f; Note, however, that this does not mean that if a biphrase such as (marrons avocats, avocado chestnuts) existed in the phrase table, it would be applicable to the source sentence here: because the source words in this biphrase would not match the order of the source tokens in the sentence, the biphrase would not be included in the a-automaton at all.",
        "On the bottom: The target W-FSA automaton At associated with the cr-automaton, where we are ignoring the source tokens (but keeping the same weights).",
        "x a sequence of tokens in x and (x, y) an entry in the global phrase table – is identified with a state of the automaton and where the fact that the phrase-pair (x, y') = ((x1,...,xk),(yi,...,yi)) follows (x, y) in the decoding sequence is modeled by introducing I \"internal\" transitions with labels (a,yi), (0,2/2), (0,2/z), where a = {x\\,Xk}, and where the first transition connects the state (x,y) to some unique \"internal state\" qi, the second transition the state q\\ to some unique internal state q2, and the last transition qk to the state (x, y')- Thus, a state (x', y') essentially encodes the previous phrase-pair used during decoding, and it is easy to see that it is possible to account for the different weights associated with the phrase-based model by weights associated to the transitions of the cr-automaton.",
        "Example Let us consider the following French source sentence x: ces avocats marrons sont cuits (idiomatic expression for these totally corrupt lawyers are finished).",
        "Let's assume that the phrase table contains the following phrase pairs:",
        "totally corrupt lawyers) r: (sont, are) k: (cuits, cooked) f: (cuits, finished).",
        "An illustration of the corresponding cr-automaton SA is shown at the top of Figure 1, with only a few transitions made explicit, and with no weights shown.",
        "code the two previous phrase-pairs used during decoding, it is possible in principle to account for a trigram language model, and similarly for higher-order LMs.",
        "This is similar to implementing n-gram language models by automata whose states encode the n – 1 words previously generated."
      ]
    },
    {
      "heading": "4. Intersecting a synchronous grammar with a a -automaton",
      "text": [
        "Intersection of a W-SCFG with a cr-automaton If SA is a cr-automaton over input x, with each valid path in SA we associate a weight in the same way as we do for a weighted automaton.",
        "For any target word sequence in Vt* we can then associate the sum of the weights of all valid paths outputting that sequence.",
        "The weighted language Lsa,x over V obtained in this way is called the language associated with SA.",
        "Let G be a W-SCFG over Vs, Vt, and let us denote by Lgjx the weighted language over Vs, Vt corresponding to the intersection {x} fffl G fnl Vt*, where {x} denotes the language giving weight 1 to x and weight 0 to other sequences in Vs*, and Vt* denotes the language giving weight 1 to all sequences in Vt*.",
        "Note that non-null bi-sentences in Lgjx have their source projection equal to x and therefore Lgjx can be identified with a weighted language over Vt.",
        "The intersection of the languages Lsa,xand Lgjx is denoted by Lsa,x fff Lgjx.",
        "Example Let us consider the following W-SCFG (where again, weights are not explicitly shown, and where we use a terminal symbol $ to denote the end of a sentence, a technicality needed for making the grammar compatible with the SA automaton of Figure 1):",
        "NP – ces NA/ these A N",
        "A – marrons / brown",
        "A – marrons / totally corrupt",
        "A – cuits / finished",
        "N – avocats / avocadoes",
        "N – avocats / lawyers",
        "It is easy to see that, for instance, the sentences: these brown avocadoes are cooked $, these brown avocadoes are finished $, and these totally corrupt lawyers are finished $ all belong to the intersection Lsa,x ff Lgjx, while the sentences these avocadoes brown are cooked $, totally corrupt lawyers are finished these $ belong only to Lsa,x.",
        "Building the intersection We now describe how to build a W-SCFG that represents the intersection Lsa,x fff LGjX.",
        "We base our explanations on the example just given.",
        "A Relaxation of the Intersection At the bottom of Figure 1, we show how we can associate an automaton At with the c automaton SA: we simply \"forget\" the source-sides of the labels carried by the transitions, and retain all the weights.",
        "As before, note that we are only showing a subset of the transitions here.",
        "All valid paths for SA map into valid paths for At (with the same weights), but the reverse is not true because some valid At paths can correspond to traversals of SA that either consume several time the same source token or do not consume all source tokens.",
        "For instance, the sentence these brown avocadoes brown are $ belongs to the language of At, but cannot be produced by SA.",
        "Let's however consider the intersection {x} fffl G f At, where, with a slight abuse of notation, we have notated { x} the \"degenerate\" automaton representing the sentence x, namely the automaton (with weights on all transitions equal to 1):",
        "This is a relaxation of the true intersection, but one that we can represent through a W-SCFG, as we know from section 2.",
        "This being noted, we now move to the construction of the full intersection.",
        "The full intersection We discussed in section 2 how to modify a synchronous grammar rule in order to produce the indexed rule scheme (2) in order to represent the bilateral intersection of the grammar with two automata.",
        "Let us redo that construction here, in the case of our example",
        "W-SCFG, ofthe targetautomaton represented on thebottomofFigure 1, andofthe source automaton {x}.",
        "The construction is then done in three steps:",
        "t0theseti tiAt2 t2Nt3 t0theseti",
        "In order to adapt that construction to the case where we want the intersection to be with a c -automaton, what we need to do is to further specialize the nonterminals.",
        "Rather than specializing a nonterminal X in the form SXS,, we specialize it in the form: SxS/'ct , where a represents a set of source tokens that correspond to \"collecting\" the source tokens in the c automaton along a path connecting the states t and t'.",
        "We then proceed to define a new rule scheme associated to our rule, which is obtained as before in three steps, as follows.",
        "NP ces N A /",
        "these A N toNPt3 _ ces NA/",
        "The only difference with our previous technique is in the addition of the c 's to the top indices.",
        "Let us focus on the second step of the annotation process:",
        "toNPt3'CTo3 _ ces NA/",
        "Conceptually, when instanciating this scheme, the tj's may range over all possible states of the a-automaton, and the over all subsets of the source tokens, but under the following constraints: the RHS a's (here aoi,ai2,a23) must be disjoint and their union must be equal to the a on the LHS (here a03).",
        "Additionally, a a associated with a target terminal (as a01 here) must be equal to the token set associated to the transition that this terminal realizes between a-automaton states (here, this means that a0i must be equal to the token set {ces} associated with the transition between t0, t1 labelled with 'these').",
        "If we perform all these instantiations, compute their weights according to equation (3), and finally remove the indices associated with terminals in the rules (by adding the weights of the rules only differing by the indices of terminals, as done previously), we obtain a very large \"raw\" grammar, but one for which one can prove direct counterpart of Fact 1.",
        "Let us call, as before G' the raw W-SCFG obtained, its start symbol being S## S?/\"\", with a„H the set of all source tokens in x.",
        "Fact 2.",
        "The synchronous language Lg, associated with G' is equal to ({x}, LSA'X fff Lg,x).",
        "The grammar that is obtained this way, despite correctly representing the intersection, contains a lot of useless rules, this being due to the fact that many nonterminals can not produce any output.",
        "The situation is wholly similar to the case of section 2, and the same bottom-up techniques can be used for activating nonterminals and rules bottom-up.",
        "The algorithm is illustrated in Figure 2, where we have shown the result of the process of activating in turn the nonterminals (abbreviated by) N1, A1, A2, NP1, VP1, S1.",
        "As a consequence of these activations, the original grammar rule NP _ ces N A /these A N (for instance) becomes instantiated as the rule:",
        "#ikT ptci'{ce S'Ovocat S'marron s }",
        "Figure 2: Building the intersection.",
        "The bottom of the figure shows some active non-terminals associated with the source sequence, at the top these same non-terminals associated with a sequence of transitions in the cr-automaton, corresponding to the target sequence these totally corrupt lawyers are finished $.",
        "To avoid cluttering the drawing, we have used the abbreviations shown on the right.",
        "Note that while Al only spans marrons in the bottom chart, it is actually decorated with the source token set {avocats, marrons): such a \"disconnect\" between the views that the W-SCFG and the cr-automaton have of the source tokens is not ruled out.",
        "that is, after removal of the indices on terminals:",
        "these hj±tcl2'{avocats'marrons} tci2^td,(H",
        "Note that while the nonterminal *d2N*d'^ by itself consumes no source token (it is associated with the empty token set), any actual use of this nonterminal (in this specific rule or possibly in some other rule using it) does require traversing the internal node tcl2 and therefore all the internal nodes \"belonging\" to the biphrase tel (because otherwise the path from # to $ would be disconnected); in particular this involves consuming all the tokens on the source side of tel, including 'avocats'.",
        "Complexity considerations The bilateral intersection that we defined between a W-SCFG and two W-FSA's in section 2 can be shown to be of polynomial complexity in the sense that it takes polynomial time and space relative to the sum of the sizes of the two automata and of the grammar to construct the (reduced) intersected grammar G', under the condition that the grammar right-hand sides have length bounded by a constant P",
        "The situation here is different, because the construction of the intersection can in principle introduce nonterminals indexed not only by states of the automata, but also by arbitrary subsets of source tokens, and this may lead in extreme cases to an exponential number of rules.",
        "Such problems however can only happen in situations where, in a nonterminal *x*,,<j, the set a is allowed to contain tokens that are \"unrelated\" to the token set {personnes} appearing between s and s' in the source automaton.",
        "An illustration of such a situation is given by the following example.",
        "Suppose that the source sen-",
        "If this condition is removed, and for the simpler case where the source (resp.",
        "target) automaton encodes a single sentence x (resp.",
        "y), (Satta and Peserico, 2005) have shown that the problem of deciding whether (x, y) is recognized by G is NP-hard relative to the sum of the sizes.",
        "A consequence is then that the grammar G' cannot be constructed in polynomial time unless P = NP.",
        "tence contains the two tokens personnes and gens between positions i,i + 1 and j, j + 1 respectively, with i and j far from each other, that the phrase table contains the two phrase pairs (personnes,persons) and (gens,people), but that the synchronous grammar only contains the two rules X – personnes/people and Y – gens/persons, with these phrases and rules exhausting the possibilities for translating gens and personnes; Then the intersected grammar will contain such nonterminals as tiXti_+\\aens^ and rjYj_+{persannes\\ where in the first case the token set {gens} in the first nonterminal is unrelated to the tokens appearing between i,i + 1, and similarly in the second case.",
        "Without experimentation on real cases, it is impossible to say whether such phenomena would empirically lead to combinatorial explosion or whether the synchronous grammar would sufficiently constrain the phrase-base component (whose reordering capabilities are responsible in fine for the potential NP-hardness of the translation process) to avoid it.",
        "Another possible approach is to prevent a priori a possible combinatorial explosion by adding formal constraints to the intersection mechanism.",
        "One such constraint is the following: disallow introduction of tXj 'a when the symmetric difference between a and the set of tokens between positions i and j in the source sentence has cardinality larger than a small constant.",
        "Such a constraint could be interpreted as keeping the SCFG and phrasebase components \"in sync\", and would be better adapted to the spirit of our approach than limiting the amount of reordering permitted to the phrase-based component, which would contradict the reason for using a hierarchical component in the first place."
      ]
    },
    {
      "heading": "5. Conclusion",
      "text": [
        "Intersecting hierarchical and phrase-based models of translation could allow to capitalize on complementarities between the two approaches.",
        "Thus, one might train the hierarchical component on corpora represented at the part-of-speech level (or at a level where lexical units are abstracted into some kind of classes) while the phrase-based component would focus on translation of lexical material.",
        "The present paper does not have the ambition to demonstrate that such an approach would improve translation performance, but only to provide some formal means for advancing towards that goal."
      ]
    }
  ]
}
