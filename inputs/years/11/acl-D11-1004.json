{
  "info": {
    "authors": [
      "Michel Galley",
      "Chris Quirk"
    ],
    "book": "EMNLP",
    "id": "acl-D11-1004",
    "title": "Optimal Search for Minimum Error Rate Training",
    "url": "https://aclweb.org/anthology/D11-1004",
    "year": 2011
  },
  "references": [
    "acl-C04-1072",
    "acl-C08-1074",
    "acl-D07-1055",
    "acl-D07-1080",
    "acl-D08-1024",
    "acl-D08-1076",
    "acl-D08-1088",
    "acl-D09-1006",
    "acl-E06-1038",
    "acl-J07-2003",
    "acl-N09-2006",
    "acl-P02-1038",
    "acl-P02-1040",
    "acl-P03-1021",
    "acl-P05-1012",
    "acl-P05-1034",
    "acl-P06-1096",
    "acl-P06-2101",
    "acl-P07-2045",
    "acl-P08-2010",
    "acl-P09-1019",
    "acl-W05-1506",
    "acl-W08-0304",
    "acl-W09-0424"
  ],
  "sections": [
    {
      "text": [
        "Microsoft Research Redmond, WA 98052, USA",
        "Microsoft Research",
        "Redmond, WA 98052, USA",
        "Minimum error rate training is a crucial component to many state-of-the-art NLP applications, such as machine translation and speech recognition.",
        "However, common evaluation functions such as BLEU or word error rate are generally highly non-convex and thus prone to search errors.",
        "In this paper, we present LP-MERT, an exact search algorithm for minimum error rate training that reaches the global optimum using a series of reductions to linear programming.",
        "Given a set of N-best lists produced from S input sentences, this algorithm finds a linear model that is globally optimal with respect to this set.",
        "We find that this algorithm is polynomial in N and in the size of the model, but exponential in S. We present extensions of this work that let us scale to reasonably large tuning sets (e.g., one thousand sentences), by either searching only promising regions of the parameter space, or by using a variant of LP-MERT that relies on a beam-search approximation.",
        "Experimental results show improvements over the standard Och algorithm."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Minimum error rate training (MERT) – also known as direct loss minimization in machine learning – is a crucial component in many complex natural language applications such as speech recognition (Chou et al., 1993; Stolcke et al., 1997; Juang et al., 1997), statistical machine translation (Och, 2003; Smith and Eisner, 2006; Duh and Kirchhoff, 2008; Chiang et al., 2008), dependency parsing (McDonald et al., 2005), summarization (McDonald, 2006), and phonetic alignment (McAllester et al., 2010).",
        "MERT directly optimizes the evaluation metric under which systems are being evaluated, yielding superior performance (Och, 2003) when compared to a likelihood-based discriminative method (Och and Ney, 2002).",
        "In complex text generation tasks like SMT, the ability to optimize BLEU (Papineni et al., 2001), TER (Snover et al., 2006), and other evaluation metrics is critical, since these metrics measure qualities (such as fluency and adequacy) that often do not correlate well with task-agnostic loss functions such as log-loss.",
        "While competitive in practice, MERT faces several challenges, the most significant of which is search.",
        "The unsmoothed error count is a highly non-convex objective function and therefore difficult to optimize directly; prior work offers no algorithm with a good approximation guarantee.",
        "While much of the earlier work in MERT (Chou et al., 1993; Juang et al., 1997) relies on standard convex optimization techniques applied to non-convex problems, the Och algorithm (Och, 2003) represents a significant advance for MERT since it applies a series of special line minimizations that happen to be exhaustive and efficient.",
        "Since this algorithm remains inexact in the multidimensional case, much of the recent work on MERT has focused on extending Och's algorithm to find better search directions and starting points (Cer et al., 2008; Moore and Quirk, 2008), and on experimenting with other derivative-free methods such as the Nelder-Mead simplex algorithm (Nelder and Mead, 1965; Zens et al., 2007; Zhao and Chen, 2009).",
        "In this paper, we present LP-MERT, an exact search algorithm for N best optimization that exploits general assumptions commonly made with MERT, e.g., that the error metric is decomposable by sentence.",
        "While there is no known optimal algorithm to optimize general non-convex functions, the unsmoothed error surface has a special property that enables exact search: the set of translations produced by an SMT system for a given input is finite, so the piecewise-constant error surface contains only a finite number of constant regions.",
        "As in Och (2003), one could imagine exhaustively enumerating all constant regions and finally return the best scoring one – Och does this efficiently with each one-dimensional search – but the idea doesn't quite scale when searching all dimensions at once.",
        "Instead, LP-MERT exploits algorithmic devices such as lazy enumeration, divide-and-conquer, and linear programming to efficiently discard partial solutions that cannot be maximized by any linear model.",
        "Our experiments with thousands of searches show that LP-MERT is never worse than the Och algorithm, which provides strong evidence that our algorithm is indeed exact.",
        "In the appendix, we formally prove that this search algorithm is optimal.",
        "We show that this algorithm is polynomial in N and in the size of the model, but exponential in the number of tuning sentences.",
        "To handle reasonably large tuning sets, we present two modifications of LP-MERT that either search only promising regions of the parameter space, or that rely on a beam-search approximation.",
        "The latter modification copes with tuning sets of one thousand sentences or more, and outperforms the Och algorithm on a WMT 2010 evaluation task.",
        "This paper makes the following contributions.",
        "To our knowledge, it is the first known exact search algorithm for optimizing task loss on N-best lists in general dimensions.",
        "We also present an approximate version of LP-MERT that offers a natural means of trading speed for accuracy, as we are guaranteed to eventually find the global optimum as we gradually increase beam size.",
        "This trade-off may be beneficial in commercial settings and in large-scale evaluations like the NIST evaluation, i.e., when one has a stable system and is willing to let MERT run for days or weeks to get the best possible accuracy.",
        "We think this work would also be useful as we turn to more human involvement in training (Zaidan and Callison-Burch, 2009), as MERT in this case is intrinsically slow."
      ]
    },
    {
      "heading": "2. Unidimensional MERT",
      "text": [
        "Let f f = fi... ff denote the S input sentences of our tuning set.",
        "For each sentence fs, let Cs = es>1... es>N denote a set of N candidate translations.",
        "For simplicity and without loss of generality, we assume that N is constant for each index s. Each input and output sentence pair (fs, es n) is weighted by a linear model that combines model parameters w = w1 ...wd S RD with D feature functions h1(f, e, ~)... hD(f, e, ~), where ~ is the hidden state associated with the derivation from f to e, such as phrase segmentation and alignment.",
        "Furthermore, let hsn S RD denote the feature vector representing the translation pair (fs, es>n).",
        "In MERT, the goal is to minimize an error count E(r, e) by scoring translation hypotheses against a set of reference translations rf suming as in Och (2003) that error count is additively decomposable by sentence – i.e., E(rf, ef ) = J2s E(rs, es) – this results in the following optimization problem:",
        "The quality of this approximation is dependent on how accurately the N-best lists represent the search space of the system.",
        "Therefore, the hypothesis list is iteratively grown: decoding with an initial parameter vector seeds the N-best lists; next, parameter estimation and N-best list gathering alternate until the search space is deemed representative.",
        "The crucial observation of Och (2003) is that the error count along any line is a piecewise constant function.",
        "Furthermore, this function for a single sentence may be computed efficiently by first finding the hypotheses that form the upper envelope of the model score function, then gathering the error count for each hypothesis along the range for which it is optimal.",
        "Error counts for the whole corpus are simply the sums of these piecewise constant functions, leading to an efficient algorithm for finding the global optimum of the error count along any single direction.",
        "Such a hill-climbing algorithm in a non-convex space has no optimality guarantee: without a perfect direction finder, even a globally-exact line search may never encounter the global optimum.",
        "Coordinate ascent is often effective, though conjugate direction set finding algorithms, such as Powell's method (Powell, 1964; Press et al., 2007), or even random directions may produce better results (Cer et al., 2008).",
        "Random restarts, based on either uniform sampling or a random walk (Moore and Quirk, 2008), increase the likelihood of finding a good solution.",
        "Since random restarts and random walks lead to better solutions and faster convergence, we incorporate them into our baseline system, which we refer to as 1D-MERT."
      ]
    },
    {
      "heading": "3. Multidimensional MERT",
      "text": [
        "Finding the global optimum of Eq.",
        "1 is a difficult task, so we proceed in steps and first analyze the case where the tuning set contains only one sentence.",
        "This gives insight on how to solve the general case.",
        "With only one sentence, one of the two summations in Eq.",
        "1 vanishes and one can exhaustively enumerate the N translations e1>n (or en for short) to find the one that yields the minimal task loss.",
        "The only difficulty with S = 1 is to know for each translation en whether its feature vector h1n (or hn for short) can be maximized using any linear model.",
        "As we can see in Fig. 1(a), some hypotheses can be maximized (e.g., h1, h2, and h4), while others (e.g., h3and h5) cannot.",
        "In geometric terminology, the former points are commonly called extreme points, and the latter are interior points.",
        "The problem of exactly optimizing a single N-best list is closely related to the convex hull problem in computational geometry, for which generic solvers such as the QuickHull algorithm exist (Eddy, 1977; Bykat, 1978; Barber et al., 1996).",
        "A first approach would be to construct the convex hull conv(h1 ... hN) of the N-best list, then identify the point on the hull with lowest loss (h1 in Fig. 1) and inally compute an optimal weight vector using hull points that share common facets with the",
        "Figure 1: N-best list (hi... hN) with associated losses (here, TER scores) for a single input sentence, whose convex hull is displayed with dotted lines in (a).",
        "For effective visualization, our plots use only two features (D = 2).",
        "While we can find a weight vector that maximizes h1 (e.g., the w in (b)), no linear model can possibly maximize any of the points strictly inside the convex hull.",
        "optimal feature vector (h2 and h4).",
        "Unfortunately, this doesn't quite scale even with a single N-best list, since the best known convex hull algorithm runs in O(NVD/2J+) time (Barber et al., 1996).",
        "Algorithms presented in this paper assume that D is unrestricted, therefore we cannot afford to build any convex hull explicitly.",
        "Thus, we turn to linear programming (LP), for which we know algorithms (Karmarkar, 1984) that are polynomial in the number of dimensions and linear in the number of points, i.e., O(NT), where T = D .",
        "To check if point hi is extreme, we really only need to know whether we can define a half-space containing all points h1... hN, with hi lying on the hyperplane delimiting that halfspace, as shown in Fig. 1(b) for h1 .",
        "Formally, a vertex hi is optimal with respect to arg maxi{wThi) if and only if the following constraints hold:",
        "wThj < y, for each j = i",
        "w is orthogonal to the hyperplane deining the halfspace, and the intercept y deines its position.",
        "The above equations represent a linear program (LP), which can be turned into canonical form maximize cT w subject to Aw < b by substituting y with wThi in Eq.",
        "3, by deining (where hj;d is the d-th element of hj), and by setting b = (0,..., 0)T = 0.",
        "The vertex hi is extreme if and only if the LP solver inds a non-zero vector w satisfying the canonical system.",
        "To ensure that w is zero only when hi is interior, we set c = hi – hM, where hM is a point known to be inside the hull (e.g., the centroid of the N-best list).",
        "In the remaining of this section, we use this LP formulation in function LlNOPTIMIZER(hi; h1 ... hN), which returns the weight vector w maximizing hi, or which returns 0 if hi is interior to conv(h1... hN).",
        "We also use conv (hi; h1... hN) to denote whether hi is extreme with respect to this hull.",
        "Algorithm 1: LP-MERT (for S = 1).",
        "input : sent.-level feature vectors H = {h1... hN} input : sent.-level task losses E1... EN, where",
        "En := E(n, ei,n) output : optimal weight vector w"
      ]
    },
    {
      "heading": "1. begin",
      "text": [
        "> sort N-best list by increasing losses:",
        "3 for n – 1 to N do",
        "> find w maximizing in-th element:",
        "4 w – LinOptimizer(hin ; H)"
      ]
    },
    {
      "heading": "6. J return w",
      "text": []
    },
    {
      "heading": "7. return 0",
      "text": [
        "An exact search algorithm for optimizing a single N-best list is shown above.",
        "It lazily enumerates feature vectors in increasing order of task loss, keeping only the extreme ones.",
        "Such a vertex hj is known to be on the convex hull, and the returned vector w maximizes it.",
        "In Fig. 1, it would first run LINOPTIMIZER on h3, discard it since it is interior, and finally accept the extreme point h1 .",
        "Each execution of LINOPTI-MIZER requires O(NT) time with the interior point",
        "Figure 2: Running times to exactly optimize N-best lists with an increasing number of dimensions.",
        "To determine which feature vectors were on the hull, we use either linear programming (Karmarkar, 1984) or one of the most efficient convex hull computation tools (Barber et al., 1996).",
        "method of (Karmarkar, 1984), and since the main loop may run O(N) times in the worst case, time complexity is O(NT).",
        "Finally, Fig. 2 empirically demonstrates the effectiveness of a linear programming approach, which in practice is seldom affected by D.",
        "We now extend LP-MERT to the general case, in which we are optimizing multiple sentences at once.",
        "This creates an intricate optimization problem, since the inner summations over n = 1 .",
        ".",
        ".",
        "N in Eq.",
        "1 can't be optimized independently.",
        "For instance, the optimal weight vector for sentence s = 1 may be suboptimal with respect to sentence s = 2.",
        "So we need some means to determine whether a selection m = m(1)... m(S) G M = [1, N]S of feature vectors h1m(1) ... hS m(S) is extreme, that is, whether we can find a weight vector that maximizes each hs m(s).",
        "Here is a reformulation of Eq.",
        "1 that makes this condition on extremity more explicit:",
        "y",
        "Quic",
        "<Hi",
        "jjj",
        "-|",
        "LP",
        ">",
        "L",
        "/",
        "j",
        "/",
        "/",
        "/",
        "/",
        "J",
        "<",
        "•-H",
        "1 – 1",
        "__",
        "_",
        "_",
        "_",
        ", i",
        "I – ■",
        "i – I",
        "I – i",
        "i – I",
        "-",
        "/",
        "One naive approach to address this optimization problem is to enumerate all possible combinations among the S distinct N-best lists, determine for each combination m whether h[m] is extreme, and return the extreme combination with lowest total loss.",
        "It is evident that this approach is optimal (since it follows directly from Eq.",
        "4), but it is prohibitively slow since it processes O(NS) vertices to determine whether they are extreme, which thus requires O(NST) time per LP optimization and O(NST) time in total.",
        "We now present several improvements to make this approach more practical.",
        "In the naive approach presented above, each LP computation to evaluate conv (h[m]; H) requires O(NST) time since H contains NS vertices, but we show here how to reduce it to O(NST) time.",
        "This improvement exploits the fact that we can eliminate the majority of the NS points of H, since only S(N – 1) +1 are really needed to determine whether h[m] is extreme.",
        "This is best illustrated using an example, as shown in Fig. 3.",
        "Both h1;1 and h2;1 in (a) and (b) are extreme with respect to their own N-best list, and we ask whether we can find a weight vector that maximizes both h1;1 and h21.",
        "The algorithmic trick is to geometrically translate one of the two N-best lists so that h1;1 = h/2 1, where h/2 1 is the translation of h/2 1.",
        "Then we use linear programming with the new set of 2N – 1 points, as shown in (c), to determine whether h1;1 is on the hull, in which case the answer to the original question is yes.",
        "In the case of the combination of h1;1 and h2 2, we see in (d) that the combined set of points prevents the maximization h1;1, since this point is clearly no longer on the hull.",
        "Hence, the combination (h1;1 ,h2;2) cannot be maximized using any linear model.",
        "This trick generalizes to S > 2.",
        "In both (c) and (d), we used S(N – 1) + 1 points instead of NS to determine whether a given point is extreme.",
        "We show in the appendix that this simplification does not sacrifice optimality.",
        "Now that we can determine whether a given combination is extreme, we must next enumerate candidate combinations to find the combination that has lowest task loss among all of those that are extreme.",
        "Since the number of feature vector combinations is O(NS), exhaustive enumeration is not a reasonable",
        "Figure 3: Given two N-best lists, (a) and (b), we use linear programming to determine which hypothesis combinations are extreme.",
        "For instance, the combination hi i and h2j1 is extreme (c), while h11 and h2j2 is not (d).",
        "option.",
        "Instead, we use lazy enumeration to process combinations in increasing order of task loss, which ensures that the first extreme combination for s = 1... S that we encounter is the optimal one.",
        "An S-ary lazy enumeration would not be particularly efficient, since the runtime is still O(NS) in the worst case.",
        "LP-MERT instead uses divide-and-conquer and binary lazy enumeration, which enables us to discard early on combinations that are not extreme.",
        "For instance, if we find that (h1;1,h2)2) is interior for sentences s = 1, 2, the divide-and-conquer branch for s = 1... 4 never actually receives this bad combination from its left child, thus avoiding the cost of enumerating combinations that are known to be interior, e.g., (h.!,!,]^, ha^h^).",
        "The LP-MERT algorithm for the general case is shown as Algorithm 2.",
        "It basically only calls a recursive divide-and-conquer function (GetNextBest) for sentence range 1 .",
        ".",
        ".",
        "S. The latter function uses binary lazy enumeration in a manner similar to (Huang and Chiang, 2005), and relies on two global variables: I and L. The first of these, I, is used to memoize the results of calls to GetNextBest; given a range of sentences and a rank n, it stores the nth best combination for that range of sentences.",
        "The global variable L stores hypotheses combination matrices, one matrix for each range of sentences (s, t) as shown in"
      ]
    },
    {
      "heading": "1. begin",
      "text": [
        "Combinations checked:",
        "Combinations discarded:",
        "Function GetNextBest(H,E,s,t)",
        "Figure 4: LP-MERT minimizes loss (TER) on four sentences.",
        "O(N) translation combinations are possible, but the LP-MERT algorithm only tests two full combinations.",
        "Without divide-and-conquer – i.e., using 4-ary lazy enumeration – ten full combinations would have been checked unnecessarily.",
        "Algorithm 2: LP-MERT",
        "where sent.-level costs ESj„ := E(rs, es_„) output : optimal weight vector w and its loss L > sort N-best lists by increasing losses:",
        "> find best hypothesis combination for 1... S :",
        "Fig.",
        "4, to determine which combination to try next.",
        "The function ExpandFrontier returns the indices of unvisited cells that are adjacent (right or down) to visited cells and that might correspond to the next best hypothesis.",
        "Once no more cells need to be added to the frontier, LP-MERT identifies the lowest loss combination on the frontier (BestInFrontier), and uses LP to determine whether it is extreme.",
        "To do so, it first generates an LP using Combine, a function that implements the method described in Fig. 3.",
        "If the LP offers no solution, this combination is ignored.",
        "LP-MERT iterates until it finds a cell entry whose combination is extreme.",
        "Regarding ranges of length one (s = t), lines 3-10 are similar to Algorithm 1 for S = 1, but with one difference: GetNextBest may be called multiple times with the same argument s, since the first output of GetNextBest might not be extreme when combined with other feature vectors.",
        "Lines 3-10 of GetNextBest handle this case efficiently, since the algorithm resumes at the (n + 1)-th",
        "input : sentence range (s, t) output : h* : current best extreme vertex output : H* : constraint vertices output : L: task loss of h* > Losses of partial hypotheses:",
        "2 if s = t then > n is the index where we left off last time: n – NbRows(L) Hs – {hSj1... hsjn} repeat",
        "w – LlNOPTIMIZER(hs_iri; Hs)",
        "element of the N-best list (where n is the position where the previous execution left off).",
        "We can see that a strength of this algorithm is that inconsistent combinations are deleted as soon as possible, which allows us to discard fruitless candidates en masse.",
        "We will see in section 5 that our exact algorithm is often too computationally expensive in practice to be used with either a large number of sentences or a large number of features.",
        "We now present two",
        "input : H, H': constraint vertices input : h, h': extreme vertices, wrt.",
        "H and H'",
        "approaches to make LP-MERT more scalable, with the downside that we may allow search errors.",
        "In the first case, we make the assumption that we have an initial weight vector w0 that is a reasonable approximation of W, where w0 may be obtained either by using a fast MERT algorithm like 1D-MERT, or by reusing the weight vector that is optimal with respect to the previous iteration of MERT.",
        "The idea then is to search only the set of weight vectors that satisfy cos(W, w0) > t, where t is a threshold on cosine similarity provided by the user.",
        "The larger the t, the faster the search, but at the expense of more search errors.",
        "This is implemented with two simple changes in our algorithm.",
        "First, LinOptimizer sets the objective vector c = w0.",
        "Second, if the output W originally returned by LinOptimizer does not satisfy cos(w, w0) > t, then it returns 0.",
        "While this modification of our algorithm may lead to search errors, it nevertheless provides some theoretical guarantee: our algorithm finds the global optimum if it lies within the region defined by cos(w, w0) > t.",
        "The second method is a beam approximation of LP-MERT, which normally deals with linear programs that are increasingly large in the upper branches of GetNextBest's recursive calls.",
        "The main idea is to prune the output of Combine (line 26) by model score with respect to wbest, where wbest is our current best model on the entire tuning set.",
        "Note that beam pruning can discard h* (the current best extreme vertex), in which case LinOptimizer returns 0. wbest is updated as follows: each time we produce a new non-zero w, run wbest – w if w has a lower loss than wbest on the entire tuning set.",
        "The idea of using a beam here is similar to using cosine similarity (since wbest constrains the search towards a promising region), but beam pruning also helps reduce LP optimization time and thus enables us to explore a wider space.",
        "Since wbest often improves during search, it is useful to run multiple iterations of LP-MERT until wbest doesn't change.",
        "Two or three iterations suffice in our experience.",
        "In our experiments, we use a beam size of 1000."
      ]
    },
    {
      "heading": "4. Experimental Setup",
      "text": [
        "Our experiments in this paper focus on only the application of machine translation, though we believe that the current approach is agnostic to the particular system used to generate hypotheses.",
        "Both phrase-based systems (e.g., Koehn et al.",
        "(2007)) and syntax-based systems (e.g., Li et al.",
        "(2009), Quirk et al.",
        "(2005)) commonly use MERT to train free parameters.",
        "Our experiments use a syntax-directed translation approach (Quirk et al., 2005): it first applies a dependency parser to the source language data at both training and test time.",
        "Multi-word translation mappings constrained to be connected subgraphs of the source tree are extracted from the training data; these provide most lexical translations.",
        "Partially lexi-calized templates capturing reordering and function word insertion and deletion are also extracted.",
        "At runtime, these mappings and templates are used to construct transduction rules to convert the source tree into a target string.",
        "The best transduction is sought using approximate search techniques (Chiang, 2007).",
        "Each hypothesis is scored by a relatively standard set of features.",
        "The mappings contain five features: maximum-likelihood estimates of source given target and vice versa, lexical weighting estimates of source given target and vice versa, and a constant value that, when summed across a whole hypothesis, indicates the number of mappings used.",
        "For each template, we include a maximum-likelihood estimate of the target reordering given the source structure.",
        "The system may fall back to templates that mimic the source word order; the count of such templates is a feature.",
        "Likewise we include a feature to count the number of source words deleted by templates, and a feature to count the number of target words inserted by templates.",
        "The log probability of the target string according to a language models is also a feature; we add one such feature for each language model.",
        "We include the number of target words as features to balance hypothesis length.",
        "For the present system, we use the training data of WMT 2010 to construct and evaluate an English-to-",
        "Figure 5: Line graph of sorted differences in BLEUn4r1[%] scores between LP-MERT and 1D-MERT on 1000 tuning sets of size S = 2,4, 8.",
        "The highest differences for S = 2,4,8 are respectively 23.3, 19.7, 13.1.",
        "German translation system.",
        "This consists of approximately 1.6 million parallel sentences, along with a much larger monolingual set of monolingual data.",
        "We train two language models, one on the target side of the training data (primarily parliamentary data), and the other on the provided monolingual data (primarily news).",
        "The 2009 test set is used as development data for MERT, and the 2010 one is used as test data.",
        "The resulting system has 13 distinct features."
      ]
    },
    {
      "heading": "5. Results",
      "text": [
        "The section evaluates both the exact and beam version of LP-MERT.",
        "Unless mentioned otherwise, the number of features is D = 13 and the N-best list size is 100.",
        "Translation performance is measured with a sentence-level version of BLEU-4 (Lin and Och, 2004), using one reference translation.",
        "To enable legitimate comparisons, LP-MERT and 1D-MERT are evaluated on the same combined N-best lists, even though running multiple iterations of MERT with either LP-MERT or 1D-MERT would normally produce different combined N-best lists.",
        "We use WMT09 as tuning set, and WMT10 as test set.",
        "Before turning to large tuning sets, we first evaluate exact LP-MERT on data sizes that it can easily handle.",
        "Fig.",
        "5 offers a comparison with 1D-MERT, for which we split the tuning set into 1,000 overlapping subsets for S = 2, 4, 8 on a combined N-best after five iterations of MERT with an average of 374 translation per sentence.",
        "The figure shows that LP-MERT never underperforms 1D-MERT in any of the 3,000 experiments, and this almost certainly confirms that",
        "Table 1: Number of tested combinations for the experiments of Fig. 5.",
        "LP-MERT with S = 8 checks only 600K full combinations on average, much less than the total number of combinations (which is more than 10).",
        "Figure 6: Effect of the number of features (runtime on 1 CPU of a modern computer).",
        "Each curve represents a different number of tuning sentences.",
        "LP-MERT systematically finds the global optimum.",
        "In the case S = 1, Powell rarely makes search errors (about 15%), but the situation gets worse as S increases.",
        "For S = 4, it makes search errors in 90% of the cases, despite using 20 random starting points.",
        "some combination statistics for S up to 8 are shown in Tab.",
        "1.",
        "The table shows the speedup provided by LP-MERT is very substantial when compared to exhaustive enumeration.",
        "Note that this is using D = 13, and that pruning is much more effective with less features, a fact that is confirmed in Fig. 6.",
        "D = 13 makes it hard to use a large tuning set, but the situation improves with D = 2 .",
        ".",
        ".",
        "5.",
        "Fig.",
        "7 displays execution times when LP-MERT constrains the output w to satisfy cos(wo, w) > t, where t is on the x-axis of the figure.",
        "The figure shows that we can scale to 1000 sentences when (exactly) searching within the region defined by cos(w0, w) > .84.",
        "All these running times would improve using parallel computing, since divide-and-conquer algorithms are generally easy to parallelize.",
        "We also evaluate the beam version of LP-MERT, which allows us to exploit tuning sets of reasonable",
        "_",
        " – S=8",
        " – S=4",
        " – S=2",
        "/",
        "/",
        "A",
        "J",
        "7",
        "J",
        "---",
        "---'",
        "length",
        "tested comb.",
        "total comb.",
        "order",
        "8",
        "639,960",
        "1.33 x 10",
        "O(N )",
        "4",
        "134,454",
        "2.31 x 10",
        "O(2N)",
        "2",
        "49,969",
        "430,336",
        "O(4N)",
        "1",
        "1,059",
        "2,624",
        "O(8N)",
        "Table 2: BLEUn4r1[%] scores for English-German on WMT09 for tuning sets ranging from 32 to 1024 sentences.",
        "size.",
        "Results are displayed in Table 2.",
        "The gains are fairly substantial, with gains of 0.5 BLEU point or more in all cases where S < 512.",
        "Finally, we perform an end-to-end MERT comparison, where both our algorithm and 1D-MERT are iteratively used to generate weights that in turn yield new N-best lists.",
        "Tuning on 1024 sentences of WMT10, LP-MERT converges after seven iterations, with a BLEU score of 16.21%; 1D-MERT converges after nine iterations, with a BLEU score of 15.97%.",
        "Test set performance on the full WMT10 test set for LP-MERT and 1D-MERT are respectively 17.08% and 16.91%."
      ]
    },
    {
      "heading": "6. Related Work",
      "text": [
        "One-dimensional MERT has been very influential.",
        "It is now used in a broad range of systems, and has been improved in a number of ways.",
        "For instance, lattices or hypergraphs may be used in place of N-best lists to form a more comprehensive view of the search space with fewer decoding runs (Macherey et al., 2008; Kumar et al., 2009; Chatterjee and Cancedda, 2010).",
        "This particular refinement is orthogonal to our approach, though.",
        "We expect to extend LP-MERT to hypergraphs in future work.",
        "Exact search may be challenging due to the computational complexity of the search space (Leusch et al., 2008), but approximate search should be feasible.",
        "Other research has explored alternate methods of gradient-free optimization, such as the downhill-simplex algorithm (Nelder and Mead, 1965; Zens search space is different than that of Och's algorithm, it still relies on one-dimensional line searches to reflect, expand, or contract the simplex.",
        "Therefore, it suffers the same problems of one-dimensional MERT: feature sets with complex non-linear interactions are difficult to optimize.",
        "LP-MERT improves on these methods by searching over a larger subspace of parameter combinations, not just those on a single line.",
        "We can also change the objective function in a number of ways to make it more amenable to optimization, leveraging knowledge from elsewhere in the machine learning community.",
        "Instance re-weighting as in boosting may lead to better parameter inference (Duh and Kirchhoff, 2008).",
        "Smoothing the objective function may allow differentiation and standard ML learning techniques (Och and Ney, 2002).",
        "Smith and Eisner (2006) use a smoothed objective along with deterministic annealing in hopes of finding good directions and climbing past locally optimal points.",
        "Other papers use margin methods such as MIRA (Watanabe et al., 2007; Chiang et al., 2008), updated somewhat to match the MT domain, to perform incremental training of potentially large numbers of features.",
        "However, in each of these cases the objective function used for training no longer matches the final evaluation metric."
      ]
    },
    {
      "heading": "7. Conclusions",
      "text": [
        "Our primary contribution is the first known exact search algorithm for direct loss minimization on N-best lists in multiple dimensions.",
        "Additionally, we present approximations that consistently outperform standard one-dimensional MERT on a competitive machine translation system.",
        "While Och's method of MERT is generally quite successful, there are cases where it does quite poorly.",
        "A more global search such as LP-MERT lowers the expected risk of such poor solutions.",
        "This is especially important for current machine translation systems that rely heavily on MERT, but may also be valuable for other textual applications.",
        "Recent speech recognition systems have also explored combinations of more acoustic and language models, with discriminative training of 5-10 features rather than one million (Loof et al., 2010); LP-MERT could be valuable here as well.",
        "/",
        "r – n",
        " – '",
        "V",
        "J",
        "/",
        "*^ – ",
        "/y",
        ">",
        "s",
        "■ – ■",
        "__-i",
        "!=*",
        "32",
        "64",
        "128",
        "256",
        "512",
        "1024",
        "1D-MERT",
        "22.93",
        "20.70",
        "18.57",
        "16.07",
        "15.00",
        "15.44",
        "our work",
        "25.25",
        "22.28",
        "19.86",
        "17.05",
        "15.56",
        "15.67",
        "+2.32",
        "+1.59",
        "+1.29",
        "+0.98",
        "+0.56",
        "+0.23",
        "The one-dimensional algorithm of Och (2003) has been subject to study and refinement for nearly a decade, while this is the first study of multidimensional approaches.",
        "We demonstrate the potential of multidimensional approaches, but we believe there is much room for improvement in both scalability and speed.",
        "Furthermore, a natural line of research would be to extend LP-MERT to compact representations of the search space, such as hypergraphs.",
        "There are a number of broader implications from this research.",
        "For instance, LP-MERT can aid in the evaluation of research on MERT.",
        "This approach supplies a truly optimal vector as ground truth, albeit under limited conditions such as a constrained direction set, a reduced number of features, or a smaller set of sentences.",
        "Methods can be evaluated based on not only improvements over prior approaches, but also based on progress toward a global optimum."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "We thank Xiaodong He, Kristina Toutanova, and three anonymous reviewers for their valuable suggestions.",
        "In this appendix, we prove that LP-MERT (Algorithm 2) is exact.",
        "As noted before, the naïve approach of solving Eq.",
        "4 is to enumerate all O(Ns) hypotheses combinations in M, discard the ones that are not extreme, and return the best scoring one.",
        "LP-MERT relies on algorithmic improvements to speed up this approach, and we now show that none of them affect the optimality of the solution.",
        "Divide-and-conquer.",
        "Divide-and-conquer in Algorithm 2 discards any partial hypothesis combination h[m(j)... m(k)] if it is not extreme, even before considering any extension h[m(i)... m(j)... m(k)... m(l)].",
        "This does not sacrifice optimality, since if conv(h; H) is false, then conv(h; H U G) is false for any set G. Proof: Assume conv(h; H) is false, so h is interior to H. By definition, any interior point h can be written as a linear combination of other points: h = J2i with Vi(h G H, hi = h, Ai > 0) and J2i Ai = 1 This same combination of points also demonstrates that h is interior to H U G, thus conv(h; H U G) is false as well.",
        "Sparse hypothesis combination.",
        "We show here that the simplification of linear programs in Section 3.1.1 from size O(Ns) to size O(NS) does not change the value of conv(h; H).",
        "More specifically, this means that linear optimization of the output of the Combine method at lines 26-27 of function GetNextBest does not introduce any error.",
        "Let (gi... gjy) and (hi... hV) be two N-best lists to be combined, then:",
        "Proof: To prove this equality, it suffices to show that: (1) if gu + hv is interior wrt.",
        "the first conv binary predicate in the above equation, then it is interior wrt.",
        "the second conv, and (2) if gu+hv is interior wrt.",
        "the second conv, then it is interior wrt.",
        "the first conv.",
        "Claim (1) is evident, since the set of points in the first conv is a subset of the other set of points.",
        "Thus, we only need to prove (2).",
        "We first geometrically translate all points by – gu -hv.",
        "Since gu+hv is interior wrt.",
        "the second conv, we can write:",
        "where |Ai}1<i<U+V values are computed from {Ai,j}i<i<U,i<j<V as follows: Ai = J2j Ai,j, i G [1, U] and AU+j.",
        "= J2i Aij,j G ].",
        "Since the interior point is 0, Ai values can be scaled so that they sum to 1 (necessary condition in the definition of interior points), which proves that the following predicate is false:",
        "i=i j=i which is equivalent to stating that the following is false:",
        "conv gu + hv; (gi + hv) U (gu + hj)"
      ]
    }
  ]
}
