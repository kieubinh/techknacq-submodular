{
  "info": {
    "authors": [
      "Andre Martins",
      "Noah A. Smith",
      "Mario Figueiredo",
      "Pedro Aguiar"
    ],
    "book": "EMNLP",
    "id": "acl-D11-1022",
    "title": "Dual Decomposition with Many Overlapping Components",
    "url": "https://aclweb.org/anthology/D11-1022",
    "year": 2011
  },
  "references": [
    "acl-D07-1101",
    "acl-D08-1008",
    "acl-D08-1017",
    "acl-D10-1125",
    "acl-J07-2003",
    "acl-P05-1022",
    "acl-P08-1109",
    "acl-P09-1039",
    "acl-P10-1001",
    "acl-P10-1110",
    "acl-P11-1048",
    "acl-P11-1049",
    "acl-P11-1060",
    "acl-W06-2920",
    "acl-W08-2102",
    "acl-W09-1801"
  ],
  "sections": [
    {
      "text": [
        "André F. T. Martins*f Noah A. Smith* Pedro M. Q. Aguiar* Mario A. T. Figueiredof",
        "* School of Computer Science, Carnegie Mellon University, Pittsburgh, PA 15213, USA *Instituto de Sistemas e Robotica, Instituto Superior Tecnico, Lisboa, Portugal ^Instituto de Telecomunicacoes, Instituto Superior Tecnico, Lisboa, Portugal {afm,nasmith}@cs.cmu.edu, aguiar@isr.ist.utl.pt, mtf@lx.it.pt",
        "Dual decomposition has been recently proposed as a way of combining complementary models, with a boost in predictive power.",
        "However, in cases where lightweight decompositions are not readily available (e.g., due to the presence of rich features or logical constraints), the original subgradient algorithm is inefficient.",
        "We sidestep that difficulty by adopting an augmented Lagrangian method that accelerates model consensus by regularizing towards the averaged votes.",
        "We show how first-order logical constraints can be handled efficiently, even though the corresponding subproblems are no longer combinatorial, and report experiments in dependency parsing, with state-of-the-art results."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The last years have witnessed increasingly accurate models for syntax, semantics, and machine translation (Chiang, 2007; Finkel et al., 2008; Petrov and Klein, 2008; Smith and Eisner, 2008; Martins et al., 2009a; Johansson and Nugues, 2008; Koo et al., 2010).",
        "The predictive power of such models stems from their ability to break locality assumptions.",
        "The resulting combinatorial explosion typically demands some form of approximate decoding, such as sampling, heuristic search, or variational inference.",
        "In this paper, we focus on parsers built from linear programming relaxations, the so-called \"turbo parsers\" (Martins et al., 2009a; Martins et al., 2010).",
        "Rush et al.",
        "(2010) applied dual decomposition as a way of combining models which alone permit efficient decoding, but whose combination is intractable.",
        "This results in a relaxation of the original problem that is elegantly solved with the subgradient algorithm.",
        "While this technique has proven quite effective in parsing (Koo et al., 2010; Auli and Lopez, 2011) as well as machine translation (Rush and Collins, 2011), we show here that its success is strongly tied to the ability of finding a \"good\" decomposition, i.e., one involving few overlapping components (or slaves).",
        "With many components, the subgradient algorithm exhibits extremely slow convergence (cf.",
        "Fig.",
        "2).",
        "Unfortunately, a lightweight decomposition is not always at hand, either because the problem does not factor in a natural way, or because one would like to incorporate features that cannot be easily absorbed in few tractable components.",
        "Examples include features generated by statements in first-order logic, features that violate Markov assumptions, or history features such as the ones employed in transition-based parsers.",
        "To tackle the kind of problems above, we adopt DD-ADMM (Alg.",
        "1), a recently proposed algorithm that accelerates dual decomposition (Martins et al., 2011).",
        "DD-ADMM retains the modularity of the subgradient-based method, but it speeds up consensus by regularizing each slave subproblem towards the averaged votes obtained in the previous round (cf. Eq.",
        "14).",
        "While this yields more involved subproblems (with a quadratic term), we show that exact solutions can still be efficiently computed for all cases of interest, by using sort operations.",
        "As a result, we obtain parsers that can handle very rich features, do not require specifying a decomposition, and can be heavily parallelized.",
        "We demonstrate the success of the approach by presenting experiments in dependency parsing with state-of-the-art results."
      ]
    },
    {
      "heading": "2. Background",
      "text": [
        "Let x G X be an input object (e.g., a sentence), from which we want to predict a structured output y G Y (e.g., a parse tree).",
        "The output set Y is assumed too large for exhaustive search to be tractable.",
        "We assume to have a model that assigns a score f (y) to each candidate output, based on which we predict",
        "Designing the model must obey certain practical considerations.",
        "If efficiency is the major concern, a simple model is usually chosen so that Eq.",
        "1 can be solved efficiently, at the cost of limited expressive power.",
        "If we care more about accuracy, a model with richer features and more involved score functions may be designed.",
        "Decoding, however, will be more expensive, and approximations are often necessary.",
        "A typical source of intractability comes from the combinatorial explosion inherent in the composition of two or more tractable models (Bar-Hillel et al., 1964; Tromble and Eisner, 2006).",
        "Recently, Rush et al.",
        "(2010) have proposed a dual decomposition framework to address NLP problems in which the global score decomposes as f (y) = f1(z1) + f2(z2), where z1 and z2 are two overlapping \"views\" of the output, so thatEq.",
        "1 becomes:",
        "arc consecutive siblings grandparent s.t.",
        "z1 ~ z2.",
        "h m all siblings h m s head bigram",
        "directed path",
        "Above, the notation z1 ~ z2 means that z1 and z2 \"agree on their overlaps,\" and an isomorphism Y ^ {{z1,z2) G Y1 x Y2 | z1 ~ z2} is assumed.",
        "We next formalize these notions and proceed to compositions of an arbitrary number of models.",
        "Of special interest is the unexplored setting where this number is very large and each component very simple.",
        "A crucial step in the design of structured predictors is that of decomposing outputs into parts (Taskar et al., 2003).",
        "We assume the following setup:",
        "Basic parts.",
        "We let R be a set of basic parts, such that each element y G Y can be identified with a subset of R. The exact meaning of a \"basic part\" is problem dependent.",
        "For example, in dependency parsing, R can be the set of all possible dependency arcs (see Fig. 1); in phrase-based parsing, it can be the set of possible spans; in sequence labeling, it can be the set of possible labels at each position.",
        "Our only assumption is that we can \"read out\" y from the basic parts it contains.",
        "For convenience, we represent y as a binary vector, y = (y(r))reR, where y(r) = 1 if part r belongs to y, and 0 otherwise.",
        "Decomposition.",
        "We generalize the decomposition in Eq.",
        "2 by considering sets Y1, ■ ■ ■, Ys for S > 2.",
        "Figure 1: Parts used by our parser.",
        "Arcs are the basic parts: any dependency tree can be \"read out\" from the arcs it contains.",
        "Consecutive siblings and grandparent parts introduce horizontal and vertical Markovization (McDonald et al., 2006; Carreras, 2007).",
        "We break the horizontal Markov assumption via all siblings parts and the vertical one through parts which indicate a directed path between two words.",
        "Inspired by transition-based parsers, we also adopt head bigram parts, which look at the heads attached to consecutive words.",
        "Finally, we follow Martins et al.",
        "(2009a) and have parts which indicate if an arc is non-projective (i.e., if it spans words that do not descend from its head).",
        "Each Ys is associated with its own set of parts Rs, in the same sense as above; we represent the elements of Ys as binary vectors zs = (zs(r))reRs.",
        "Examples are vectors indicating a tree structure, a sequence, or an assignment of variables to a factor, in which case it may happen that only some binary vectors are legal.",
        "Some parts in Rs are basic, while others are not.",
        "We denote by Rs = Rs n R the subset of the ones that are.",
        "In addition, we assume that:",
        "• Each zs G Ys is completely defined by its entries indexed by elements of Rs, from which we can guess the ones in Rs \\ RRs.",
        "This implies that each y G Y has a unique decomposition (z1, ■ ■ ■, zs).",
        "Fig.",
        "1 shows several parts used in dependency parsing models; in phrase-based parsing, these could be spans and production rules anchored in the surface string; in sequence labeling, they can be unigram, bigram, and trigram labels.",
        "Global consistency.",
        "We want to be able to read out y G Y by \"gluing\" together the components (z1, ■ ■ ■, zs).",
        "This is only meaningful if they are \"globally consistent,\" a notion which we make precise.",
        "Two components zs G Ys and zt G Yt are said to be consistent (denoted zs ~ zt) if they agree on their overlaps, i.e., if zs(r) = zt(r), Vr G Rs n Rt.",
        "A complete assignment (z1, ■ ■ ■, zs ) is globally consistent if all pairs of components are consistent.",
        "This is equivalent to the existence of a witness vector (u(r))reR suchthatzs(r) = u(r),Vs,r G Rs.",
        "With this setup, assuming that the score function decomposes as f(z) = ss=1 fs(zs), the decoding problem (which extends Eq.",
        "2 for S > 2) becomes:",
        "We call the equality constraints expressed in the last line the \"agreement constraints.\"",
        "It is these constraints that complicate the problem, which would otherwise be exactly separable into S subproblems.",
        "The dual decomposition method (Komodakis et al., 2007; Rush et al., 2010) builds an approximation by dualizing out these constraints, as we describe next.",
        "We describe dual decomposition in a slightly different manner than Rush et al.",
        "(2010): we will first build a relaxation of P (called P'), in which the entire approximation is enclosed.",
        "Then, we dualize P yielding problem D. In the second step, the duality gap is zero, i.e., P' and D are equivalent.",
        "Relaxation.",
        "For each s G {1, ■ ■ ■, S} we consider the convex hull of Ys,",
        "We have that Y s = Zs n Z|Rs|; hence, problem P (Eq.",
        "3) is equivalent to one in which each Ys is replaced by Zs and the z-variables are constrained to be integer.",
        "By dropping the integer constraints, we obtain the following relaxed problem:",
        "If the score functions fs are convex, P' becomes a convex program (unlike P, which is discrete); being a relaxation, it provides an upper bound of P.",
        "Lagrangian.",
        "Introducing a Lagrange multiplier As(r) for each agreement constraint in Eq.",
        "5, one obtains the Lagrangian function and the dual problem (the master) where the gs(As) are the solution values of the following subproblems (the slaves):",
        "maximize fs(zs)+£ RAs(r)zs(r) w.r.t.",
        "gle factor in a factor graph (Smith and Eisner, 2008), or to a entire subgraph enclosing several factors (Koo et al., 2010), or even to a formula in Markov logic (Richardson and Domingos, 2006).",
        "In these examples, the basic parts may correspond to individual variable-value pairs.",
        "Solving the dual.",
        "Why is the dual formulation D (Eqs.",
        "7-8) more appealing than P' (Eq.",
        "5)?",
        "The answer is that the components 1, ■ ■ ■, S are now decoupled, which makes things easier provided each slave subproblem (Eq.",
        "8) can be solved efficiently.",
        "In fact, this is always a concern in the mind of the model's designer when she chooses a decomposition (the framework that we describe in §3, in some sense, alleviates her from this concern).",
        "If the score functions are linear, i.e., of the form fs(zs) = EreRs #s(r)zs(r) for some vector 0s = ($s(r))reRs, then Eq.",
        "8 becomes a linear program, for which a solution exists at a vertex of Zs (which in turn is an element of Y s).",
        "Depending on the structure of the problem, Eq.",
        "8 may be solved by brute force, dynamic programming, or specialized combinatorial algorithms (Rush et al., 2010; Koo et al., 2010; Rush and Collins, 2011).",
        "Applying the projected subgradient method (Ko-modakis et al., 2007; Rush et al., 2010) to the master problem (Eq.",
        "7) yields a remarkably simple algorithm, which at each round t solves the subproblems in Eq.",
        "8 for s = 1,... ,S, and then gathers these solutions (call them zfs+1) to compute an \"averaged\" vote for each basic part, where ö(r) = |{s : r G Rs}| is the number of components which contain part r. An update of the Lagrange variables follows, where r}t is a stepsize.",
        "Intuitively, the algorithm pushes for a consensus among the slaves (Eq.",
        "9), via an adjustment of the Lagrange multipliers which takes into consideration deviations from the average (Eq.",
        "10).",
        "The subgradient method is guaranteed to converge to the solution of D (Eq.",
        "7), for suitably chosen stepsizes (Shor, 1985; Bertsekas et al., 1999); it also provides a certificate of optimality in case the relaxation is tight (i.e., P = D) and the exact solution has been found.",
        "However, convergence is slow when S is large (as we will show in the experimental section), and no certificates are available when there is a relaxation gap (P < P').",
        "In the next section, we describe the DD-ADMM algorithm (Martins et al., 2011), which does not have these drawbacks and shares a similar simplicity."
      ]
    },
    {
      "heading": "3. Alternating Directions Method",
      "text": [
        "There are two reasons why subgradient-based dual decomposition is not completely satisfying:",
        "• it may take a long time to reach a consensus;",
        "• it puts all its resources in solving the dual problem D, and does not attempt to make progress in the primal P', which is closer to our main concern.",
        "Taking a look back at the relaxed primal problem P' (Eq.",
        "5), we see that any primal feasible solution must satisfy the agreement constraints.",
        "This suggests that penalizing violations of these constraints could speed up consensus.",
        "Augmented Lagrangian.",
        "By adding a penalty term to Eq.",
        "6, we obtain the augmented Lagrangian function (Hestenes, 1969; Powell, 1969):",
        "where the parameter p > 0 controls the intensity of the penalty.",
        "Augmented Lagrangian methods are well-known in the optimization community (see, e.g., Bertsekas et al.",
        "(1999), §4.2).",
        "They alternate updates to the A-variables, while seeking to maximize Ap with respect to z and u.",
        "In our case, however, this joint maximization poses difficulties, since the penalty term couples the two variables.",
        "The alternating directions method of multipliers (ADMM), coined by Gabay and Mercier (1976) and Glowinski and Marroco (1975), sidesteps this issue by performing alternate maximizations, followed by an update of the Lagrange multipliers as in Eq.",
        "10.",
        "Recently, ADMM has attracted interest, being applied in a variety of problems; see the recent book by Boyd et al.",
        "(2011) for an overview.",
        "As derived in the App.",
        "A, the u-updates in Eq.",
        "13 have a closed form, which is precisely the averaging operation performed by the subgradient method (Eq.",
        "9).",
        "We are left with the problem of computing the z-updates.",
        "Like in the subgradient approach, the maximization in Eq.",
        "12 can be separated into S independent slave subproblems, which now take the form:",
        "maximize /s(zs) + EreJi As(r)zs(r)",
        "-fEreRs (zs(r) - ut(r)) (14) w.r.t.",
        "zs G Zs (x).",
        "Comparing Eq.",
        "8 and Eq.",
        "14, we observe that the only difference is the presence in the latter of a quadratic term which regularizes towards the previous averaged votes ut(r).",
        "Because of this term, the solution of Eq.",
        "14 for linear score functions may not be at a vertex (in contrast to the subgradient method).",
        "We devote §4 to describing exact and efficient ways of solving the problem in Eq.",
        "14 for important, widely used slaves.",
        "Before going into details, we mention another advantage of ADMM over the subgradient algorithm: it knows when to stop.",
        "Primal and dual residuals.",
        "Recall that the sub-gradient method provides optimality certificates when the relaxation is tight (P = P') and an exact solution of P has been found.",
        "While this is good enough when tight relaxations are frequent, as in the settings explored by Rush et al.",
        "(2010), Koo et al.",
        "(2010), and Rush and Collins (2011), it is hard to know when to stop when a relaxation gap exists.",
        "We would like to have similar guarantees concerning the relaxed primal P'.",
        "A general weakness of subgradient algorithms is that they do not have this capacity, and so are usually stopped by specifying a maximum number of iterations.",
        "In contrast, ADMM allows to keep track of primal and dual residuals (Boyd et al., 2011).",
        "This allows providing certificates not only for the exact solution of P (when the relaxation is tight), but also to terminate when a near optimal solution of the relaxed problem P' has been found.",
        "The primal residual rp measures the amount by which the agreement constraints are violated:",
        "the dual residual rlD is the amount by which a dual optimality condition is violated (see Boyd et al.",
        "(2011), p.18, for details).",
        "It is computed via:",
        "Our stopping criterion is thus that these two residuals are below a threshold, e.g., 1 x 10-3.",
        "The complete algorithm is depicted as Alg.",
        "1.",
        "As stated in Algorithm 1 ADMM-based Dual Decomposition",
        "1: input: score functions (/s(.",
        "))f=1, parameters p, n, thresholds eP and eD.",
        "4: repeat 12: output: relaxed primal and dual solutions u, z, A"
      ]
    },
    {
      "heading": "4. Solving the Subproblems",
      "text": [
        "In this section, we address the slave subproblems of DD-ADMM (Eq.",
        "14).",
        "We show how these subproblems can be solved efficiently for several important cases that arise in NLP applications.",
        "Throughout, we assume that the score functions /s are linear, i.e., they can be written as /s(zs) = Y,reRs &s(r)zs(r).",
        "This is the case whenever a linear model is used, in which case 9s(r) = j^T)w ' r), where w is a weight vector and r) is a feature vector.",
        "It is also the scenario studied in previous work in dual decomposition (Rush et al., 2010).",
        "Under this assumption, and discarding constant terms, the slave subproblem in Eq.",
        "14 becomes:",
        "J2 0s(r)zs(r) - PJ2 (r) - «s(r)).",
        "Pereira (2007) and Martins et al.",
        "(2009b) for details.",
        "where as(r) = ut(r)+p_i(0s(r)+As(r)).",
        "Since Zsis a polytope, Eq.",
        "17 is a quadratic program, which can be solved with a general purpose solver.",
        "However, that does not exploit the structure of Zs and is inefficient when |Rs | is large.",
        "We next show that for many cases, a closed-form solution is available and can be computed in O(|Rs|) time, up to log factors.",
        "Pairwise Factors.",
        "This is the case where Rpair = {ri,r2,r12}, where ri and r2 are basic parts and ri2 is their conjunction, i.e., we have YPAIR = {(zi,z2,zi2) | zi2 = zi A z2}.",
        "This factor is useful to make conjunctions of variables participate in the score function (see e.g. the grandparent, sibling, and head bigram parts in Fig. 1).",
        "The convex hull of Y pair is the polytope Zpair = {(zi,z2,zi2) G and has a closed form solution (see App.",
        "B).",
        "Uniqueness Quantification and xor.",
        "Many problems involve constraining variables to take a single value: for example, in dependency parsing, a modifier can only take one head.",
        "This can be expressed as the statement 3!y : Q(y) in first-order logic, or as a one-hot xor factor in a factor graph (Smith and Eisner, 2008; Martins et al., 2010).",
        "In this case, RXOR = {ri,..., rn}, and",
        "Yxor = {(zi,...,zn ) G {0, 1}n | £n=i zt = 1}.",
        "The convex hull of Yxor is Zxor = {(zi, ..., zn) G [0,1]n | 5^n=i zi = 1}.",
        "Assume for the sake of simplicity that all parts in RXOR are basic.",
        "Up to a constant, the slave subproblem becomes:",
        "s-t Er zi = 1.",
        "This is the problem of projecting onto the probability simplex, which can be done in O(n log n) time via a sort operation (see App.",
        "C).",
        "Existential Quantification and OR.",
        "Sometimes, only existence is required, not necessarily uniqueness.",
        "This can be expressed with disjunctions, existential quantifiers in first-order logic (3y : Q(y)), or as a OR factor.",
        "In this case, ROR = {ri,..., rn},",
        "s.t.",
        "YTi zi > 1.",
        "We derive a procedure in App.",
        "D to compute this projection in O(n log n) runtime, also with a sort.",
        "Negations.",
        "The two cases above can be extended to allow some of their inputs to be negated.",
        "By a change of variables in Eqs.",
        "19-20 it is possible to reuse the same black box that solves those problems.",
        "The procedure is as follows:",
        "1.",
        "For i = 1,..., n, set ai = 1 - ai if the ith variable is negated, and ai = ai otherwise.",
        "2.",
        "Obtain (zi,..., zn) as the solution of Eqs.",
        "19 or 20 providing (ai,..., an) as input.",
        "3.",
        "For i = 1,..., n, set zi = 1 - zi if the ith variable is negated, and zi = zi otherwise.",
        "The ability to handle negated variables adds a great degree of flexibility.",
        "From DeMorgan's laws, we can now handle conjunctions and implications (since f\\n=i == is equivalent to Logical Variable Assignments.",
        "All previous examples involve taking a group of existing variables and defining a constraint.",
        "Alternatively, we may want to define a new variable which is the result of an operation involving other variables.",
        "For example, := 3!y : y).",
        "This corresponds to the XOR-WITH-OUTPUT factor in Martins et al.",
        "(2010).",
        "Interestingly, this can be expressed as a xor where is negated (i.e., either holds or exactly one y satisfies y), but not both).",
        "Table 1: First-order logic formulae underlying our dependency parser.",
        "The basic parts are the predicate variables arc(h, m) (indicating an arc linking head h to modifier m), path(a, d) (indicating a directed path from ancestor a to descendant d), nextsibl(h, m, s) (indicating that (h, m) and (h, s) are consecutive siblings), nonproj (h, m) (indicating that (h, m) is a non-projective arc), as well as the auxiliary variables flow(h, m, d) (indicating that arc (h, m) carries flow to d), and lastsibl(h, m, k) (indicating that, up to position k, the last seen modifier of h occurred at position m).",
        "The non-basic parts are the pairwise factors sibl(h, m, s), grand(g, h, m), and bigram(b, h, m); as well as each logical formula.",
        "Columns 3 – 4 indicate the number of parts of each kind, and the time complexity for solving each subproblem.",
        "For a sentence of length n, there are O(n ) parts and the total complexity is O(n log n).",
        "s.t.",
        "zo > J2i=i Zi; zo < Zj, Vi = 1,..., n.",
        "The problem in Eq.",
        "21 is more involved than the ones in Eqs.",
        "19-20.",
        "Yet, there is still an efficient procedure with runtime O(n log n) (see App.",
        "E).",
        "By using the result above for negated variables, we are now endowed with a procedure for many other cases, such that and-with-output and formulas with universal quantifiers (e.g., := Vy : y)).",
        "Up to a log-factor, the runtimes will be linear in the number of predicates.",
        "Larger Slaves.",
        "The only disadvantage of DD-ADMM in comparison with the subgradient algorithm is that there is not an obvious way of solving the subproblem in Eq.",
        "14 exactly for large combinatorial factors, such as the T RE E constraint in dependency parsing, or a sequence model.",
        "Hence, our method seems to be more suitable for decompositions which involve \"simple slaves,\" even if their number is large.",
        "However, this does not rule out the possibility of using this method otherwise.",
        "Eckstein and Bertsekas (1992) show that the ADMM algorithm may still converge when the Z-updates are inexact.",
        "Hence the method may still work ifthe slaves are solved numerically up to some accuracy.",
        "we defer this to future investigation."
      ]
    },
    {
      "heading": "5. Experiments: Dependency Parsing",
      "text": [
        "We used 14 datasets with non-projective dependencies from the CoNLL-2006 and CoNLL-2008 shared tasks (Buchholz and Marsi, 2006; Surdeanu et al., 2008).",
        "We also used a projective English dataset derived from the Penn Treebank by applying the standard head rules of Yamada and Matsumoto (2003).",
        "We did not force the parser to output projective trees or unique roots for any of the datasets; everything is learned from the data.",
        "We trained by running 10 iterations of the cost-augmented MiRA algorithm (Crammer et al., 2006) with LP-relaxed decoding, as in Martins et al.",
        "(2009b).",
        "Following common practice (Charniak and Johnson, 2005; Carreras et al., 2008), we employed a coarse-to-fine procedure to prune away unlikely candidate arcs, as described by Koo and Collins (2010).",
        "To ensure valid parse trees at test time, we rounded fractional solutions as described in Martins et al.",
        "(2009a) (yet, solutions were integral most of the time).",
        "# Slaves",
        "Runtime",
        "Description",
        "Tree",
        "3!h : arc(h, m), m = 0",
        "flow(h, m, k) => arc(h, m)",
        "path(m, d) := 3!h : flow(h, m,d), m = 0",
        "path(h, d) := 3!m : flow(h, m, d)",
        "path(0,m) := true, flow(h,m, m) := true",
        "O(n) O(n) O(n) O(n)",
        "O(n log n) O(1)",
        "O(n log n) O(n log n)",
        "Each non-root word has a head Only active arcs may carry flow",
        "Paths and flows are consistent (see Martins et al.",
        "(2010))",
        "All siblings",
        "sibl(h, m, s) := arc(h, m) A arc(h, s)",
        "O(n)",
        "O(1)",
        "By definition",
        "Grandp.",
        "grand(g, h, m) := arc(g, h) A arc(h, m)",
        "o(n)",
        "O(1)",
        "By definition",
        "Head Bigram",
        "bigram(b, h, m) := arc(b, m – 1) A arc(h, m), m = 0",
        "o(n)",
        "O(1)",
        "By definition",
        "Consec.",
        "Sibl.",
        "lastsibl(h, m, m) := arc(h, m) 3!m G [h, k] : lastsibl(h, m, k) lastsibl(h, m, k) := lastsibl(h, m, k +1)",
        "© nextsibl(h, m, k + 1) arc(h, m) := 3!s G [h, m] : nextsibl(h, s, m)",
        "O(n)",
        "O(n) O(n)",
        "O(n log n) O(1)",
        "O(n log n)",
        "Head automaton model (see supplementary material)",
        "Nonproj.",
        "Arc",
        "nonproj(h, m) := arc(h, m) A 3k G [h, m] : – path(h, k)",
        "o(n)",
        "O(n log n)",
        "By definition",
        "The parts used in our full model are the ones depicted in Fig. 1.",
        "Note that a subgradient-based method could handle some of those parts efficiently (arcs, consecutive siblings, grandparents, and head bigrams) by composing arc-factored models, head automata, and a sequence labeler.",
        "However, no lightweight decomposition seems possible for incorporating parts for all siblings, directed paths, and non-projective arcs.",
        "Tab.",
        "1 shows the first-order logical formulae that encode the constraints in our model.",
        "Each formula gives rise to a subproblem which is efficiently solvable (see §4).",
        "By ablating some of rows of Tab.",
        "1 we recover known methods:",
        "• Resorting to the tree and consecutive sibling formulae gives one of the models in Koo et al.",
        "(2010), with the same linear relaxation (a proof of this fact is included in App.",
        "F);",
        "• Resorting to tree, all siblings, grandparent, and non-projective arcs, recovers a multi-commodity flow configuration proposed by Martins et al.",
        "(2009a); the relaxation is also the same.",
        "The experimental results are shown in Tab.",
        "2.",
        "For comparison, we include the best published results for each dataset (at the best of our knowledge), among transition-based parsers (Nivre et al., 2006; Huang and Sagae, 2010), graph-based parsers (McDonald et al., 2006; Koo and Collins, 2010), hybrid methods (Nivre and McDonald, 2008; Martins et al., 2008), and turbo parsers (Martins et al., 2010; Koo et al., 2010).",
        "Our full model achieved the best reported scores for 7 datasets.",
        "The last two columns show a consistent improvement (with the exceptions of Chinese and Arabic) when using the full set of features over a second order model with grandparent and consecutive siblings, which is our reproduction of the model of Koo et al.",
        "(2010).",
        "Table 2: Unlabeled attachment scores, excluding punctuation.",
        "In the second column, [Ma08] denotes Martins et al.",
        "(2008), [KC10] is Koo and Collins (2010), [Ma10] is Martins et al.",
        "(2010), and [Ko10] is Koo et al.",
        "(2010).",
        "In columns 3 – 4, \"Full\" is our full model, and \"G+CS\" is our reproduction of the model of Koo et al.",
        "(2010), i.e., the same as \"Full\" but with all features ablated excepted for grandparents and consecutive siblings.",
        "Table 3: Feature ablation experiments.",
        "AF is an arc-factored model; +G+CS adds grandparent and consecutive siblings; +AS adds all-siblings; +NP adds non-projective arcs; Full adds the bigram and directed paths.",
        "Feature ablation and error analysis.",
        "We conducted a simple ablation study by training several models on the English PTB with different sets of features.",
        "Tab.",
        "3 shows the results.",
        "As expected, performance keeps increasing as we use models with greater expressive power.",
        "We show some concrete examples in App.",
        "G of sentences that the full model parsed correctly, unlike less expressive models.",
        "Convergence speed and optimality.",
        "Fig.",
        "2 compares the performance of DD-ADMM and the subgradient algorithms in the validation section of the PTB.",
        "For the second order model, the subgradient method has more slaves than in Koo et al.",
        "(2010): it has a slave imposing the TREE constraint (whose subproblems consists on finding a minimum spanning tree) and several for the all-sibling parts, yielding an average number of 310.5 and a maximum of 4310 slaves.",
        "These numbers are still manageable, and we observe that a \"good\" UAS is achieved relatively quickly.",
        "The ADMM method has many more slaves due to the multicommodity flow constraints (average 1870.8, maximum 65446), yet it attains optimality sooner, as can be observed in the right plot.",
        "For the full model, the subgradient-based method becomes extremely slow, and the UAS score severely degrades (after 1000 iterations it is 2% less than the one obtained with the ADMM-based method, with very few instances having been solved to optimality).",
        "The reason is the number of slaves: in this configuration and dataset the average number of slaves per instance is 3327.4, and the largest number is 113207.",
        "On the contrary, the ADMM method keeps a robust performance, with a large fraction of optimality certificates in early iterations.",
        "Best known UAS",
        "G+CS",
        "Full",
        "Arabic",
        "80.18",
        "[Ma08]",
        "81.12",
        "81.10 (-0.02)",
        "Bulgar.",
        "92.88",
        "[Ma10]",
        "93.04",
        "93.50 (+0.46)",
        "Chinese",
        "91.89",
        "[Ma10]",
        "91.05",
        "90.62 (-0.43)",
        "Czech",
        "88.78",
        "[Ma10]",
        "88.80",
        "89.46 (+0.66)",
        "English",
        "92.57",
        "[Ko10]",
        "92.45",
        "92.68 (+0.23)",
        "Danish",
        "91.78",
        "[Ko10]",
        "91.70",
        "91.86 (+0.16)",
        "Dutch",
        "85.81",
        "[Ko10]",
        "84.77",
        "85.53 (+0.76)",
        "German",
        "91.49",
        "[Ma10]",
        "91.29",
        "91.89 (+0.60)",
        "Japane.",
        "93.42",
        "[Ma10]",
        "93.62",
        "93.72 (+0.10)",
        "Portug.",
        "93.03",
        "[Ko10]",
        "92.05",
        "92.29 (+0.24)",
        "Slovene",
        "86.21",
        "[Ko10]",
        "86.09",
        "86.95 (+0.86)",
        "Spanish",
        "87.04",
        "[Ma10]",
        "85.99",
        "86.74 (+0.75)",
        "Swedish",
        "91.36",
        "[Ko10]",
        "89.94",
        "90.16 (+0.22)",
        "Turkish",
        "77.55",
        "[Ko10]",
        "76.24",
        "76.64 (+0.40)",
        "PTB §23",
        "93.04",
        "[KC10]",
        "92.19",
        "92.53 (+0.34)",
        "AF",
        "+G+CS",
        "+AS",
        "+NP",
        "Full",
        "PTB",
        "§22",
        "91.02",
        "92.13",
        "92.32",
        "92.36",
        "92.41",
        "PTB",
        "§23",
        "91.36",
        "92.19",
        "92.41",
        "92.50",
        "92.53",
        "Runtime and caching strategies.",
        "Despite its suitability to problems with many overlapping components, our parser is still 1.6 times slower than Koo et al.",
        "(2010) (0.34 against 0.21 sec./sent.",
        "in PTB § 23), and is far beyond the speed of transition-based parsers (e.g., Huang and Sagae (2010) take 0.04 sec./sent.",
        "on the same data, although accuracy is lower, 92.1%).",
        "Our implementation, however, is not fully optimized.",
        "We next describe how considerable speed-ups are achieved by caching the subproblems, following a strategy similar to Koo et al.",
        "(2010).",
        "Fig.",
        "3 illustrates the point.",
        "After a few iterations, many variables u(r) see a consensus being achieved (i.e., u*(r) = z*+1(r), Vs) and enter an idle state: they are left unchanged by the u-update in Eq.",
        "9, and so do the Lagrange variables AS+1(r) (Eq.",
        "10).",
        "If by iteration t all variables in a subproblem s are idle, then zts+1(r) = zS(r), hence the subproblem does not need to be resolved.",
        "Fig.",
        "3 shows that",
        "Full ADMM",
        "Figure 3: Fraction of active variables, subproblems and messages along DD-ADMM iterations (full model).",
        "The number of active messages denotes the total number of variables (active or not) that participate in an active factor.",
        "Elapsed Times",
        "Figure 4: Runtimes of DD-ADMM and CPLEX on PTB § 22 (each point is a sentence).",
        "Average runtimes are 0.362 (DD-ADMM) and 0.565 sec./sent.",
        "(CPLEX).",
        "many variables and subproblems are left untouched after the first few rounds.",
        "Finally, Fig. 4 compares the runtimes of our implementation of DD-ADMM with those achieved by a state-of-the-art LP solver, CPLEX, in its best performing configuration: the simplex algorithm applied to the dual LP.",
        "We observe that DD-ADMM is faster in some regimes but slower in others.",
        "For short sentences (< 15 words), DD-ADMM tends to be faster.",
        "For longer sentences, CPLEX is quite effective as it uses good heuristics for the pivot steps in the simplex algorithm; however, we observed that it sometimes gets trapped on large problems.",
        "Note also that DD-ADMM is not fully optimized, and that it is much more amenable to parallelization than the simplex algorithm, since it is composed of many independent slaves.",
        "This suggests potentially significant speed-ups in multi-core environments."
      ]
    },
    {
      "heading": "6. Related Work",
      "text": [
        "Riedel and Clarke (2006) first formulated dependency parsing as an integer program, along with logical constraints.",
        "The multicommodity flow for-",
        "Accuracy",
        "Stopping Criteria",
        "Figure 2: UAS including punctuation (left) and fraction of optimality certificates (right) accross iterations of the subgradient and DD-ADMM algorithms, in PTB §22.",
        "\"Full\" is our full model; \"Sec Ord\" is a second-order model with grandparents and all siblings, for which the subgradient method uses a coarser decomposition with a TREE factor.",
        "Since subgradient and DD-ADMM are solving the same problems, the solid lines (as the dashed ones) would meet in the limit, however subgradient converges very slowly for the full model.",
        "The right plot shows optimality certificates for both methods, indicating that an exact solution of P has been found; for DD-ADMM we also plot the fraction of instances that converged to an accurate solution of P' (primal and dual residuals < 10-3) and hence can be stopped.",
        "mulation was introduced by Martins et al.",
        "(2009a), along with some of the parts considered here.",
        "Koo et al.",
        "(2010) proposed a subgradient-based dual decomposition method that elegantly combines head automata with maximum spanning tree algorithms; these parsers, as well as the loopy belief propagation method of Smith and Eisner (2008), are all instances of turbo parsers (Martins et al., 2010).",
        "DD-ADMM has been proposed and theoretically analyzed by Martins et al.",
        "(2011) for problems representable as factor graphs.",
        "The general ADMM method has a long-standing history in optimization (Hestenes, 1969; Powell, 1969; Glowinski and Mar-roco, 1975; Gabay and Mercier, 1976; Boyd et al., 2011).",
        "Other methods have been recently proposed to accelerate dual decomposition, such as Jojic et al.",
        "(2010) and Meshi and Globerson (2011) (the latter applying ADMM in the dual rather than the primal).",
        "While our paper shows limitations of the subgradient method when there are many overlapping components, this method may still be advantageous over ADMM in problems that are nicely decomposable, since it often allows reusing existing combinatorial machinery.",
        "Yet, the scenario we consider here is realistic in NLP, where we often have to deal with not-lightly-decomposable constrained problems (e.g., exploiting linguistic knowledge)."
      ]
    },
    {
      "heading": "7. Conclusion",
      "text": [
        "We have introduced new feature-rich turbo parsers.",
        "Since exact decoding is intractable, we solve an LP relaxation through a recently proposed consensus algorithm, DD-ADMM, which is suitable for problems with many overlapping components.",
        "We study the empirical runtime and convergence properties of DD-ADMM, complementing the theoretical treatment in Martins et al.",
        "(2011).",
        "DD-ADMM compares favourably against the subgradient method in several aspects: it is faster to reach a consensus, it has better stopping conditions, and it works better in non-lightweight decompositions.",
        "While its slave subproblems are more involved, we derived closed-form solutions for many cases of interest, such as first-order logic formulas and combinatorial factors.",
        "DD-ADMM may be useful in other frameworks involving logical constraints, such as the models for compositional semantics presented by Liang et al.",
        "(2011).",
        "Non-logical constraints may also yield efficient subproblems, e.g., the length constraints in summarization and compression (Clarke and Lapata, 2008; Martins and Smith, 2009; Berg-",
        "Kirkpatrick et al., 2011).",
        "Finally, DD-ADMM can be adapted to tighten its relaxations towards exact decoding, as in Sontag et al.",
        "(2008) and Rush and Collins (2011).",
        "We defer this for future work."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We thank all reviewers for their comments, Eric Xing for helpful discussions, and Terry Koo and Sasha Rush for answering questions about their parser and for providing code.",
        "A. M. was supported by a FCT/ICTI grant through the CMU-Portugal Program, and by Priberam.",
        "This work was partially supported by the FET programme (EU FP7), under the SIMBAD project (contract 213250).",
        "N. S. was supported by NSF CAREER IIS-1054319.",
        "f/:::::::::::",
        " – ADMM Full",
        " – Subgrad Full",
        "...... ADMM Sec Ord",
        "...... Subgrad Sec Ord",
        "- ADMM Full (Tol<0.001)",
        "- ADMM Full (Exact) -",
        " – Subgrad Full (Exact)",
        "...... ADMM Sec Ord (Tol<0.001)",
        "...... ADMM Sec Ord (Exact) \"",
        "...... Subgrad Sec Ord (Exact)"
      ]
    }
  ]
}
