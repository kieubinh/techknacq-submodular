{
  "info": {
    "authors": [
      "Zhenghua Li",
      "Min Zhang",
      "Wanxiang Che",
      "Ting Liu",
      "Wenliang Chen",
      "Haizhou Li"
    ],
    "book": "EMNLP",
    "id": "acl-D11-1109",
    "title": "Joint Models for Chinese POS Tagging and Dependency Parsing",
    "url": "https://aclweb.org/anthology/D11-1109",
    "year": 2011
  },
  "references": [
    "acl-C10-1019",
    "acl-C10-1080",
    "acl-C10-1135",
    "acl-C96-1058",
    "acl-D07-1022",
    "acl-D07-1098",
    "acl-D07-1101",
    "acl-D08-1059",
    "acl-E06-1011",
    "acl-J08-4003",
    "acl-N07-1051",
    "acl-N09-1037",
    "acl-N09-1046",
    "acl-P03-1056",
    "acl-P05-1012",
    "acl-P05-1022",
    "acl-P07-1096",
    "acl-P08-1043",
    "acl-P08-1101",
    "acl-P08-1102",
    "acl-P09-1055",
    "acl-P09-1058",
    "acl-P10-1001",
    "acl-P10-1110",
    "acl-P10-1113",
    "acl-W02-1001",
    "acl-W08-2121",
    "acl-W09-1201",
    "acl-W96-0213"
  ],
  "sections": [
    {
      "text": [
        "Part-of-speech (POS) is an indispensable feature in dependency parsing.",
        "Current research usually models POS tagging and dependency parsing independently.",
        "This may suffer from error propagation problem.",
        "Our experiments show that parsing accuracy drops by about 6% when using automatic POS tags instead of gold ones.",
        "To solve this issue, this paper proposes a solution by jointly optimizing POS tagging and dependency parsing in a unique model.",
        "We design several joint models and their corresponding decoding algorithms to incorporate different feature sets.",
        "We further present an effective pruning strategy to reduce the search space of candidate POS tags, leading to significant improvement of parsing speed.",
        "Experimental results on Chinese Penn Treebank 5 show that our joint models significantly improve the state-of-the-art parsing accuracy by about 1.5%.",
        "Detailed analysis shows that the joint method is able to choose such POS tags that are more helpful and discriminative from parsing viewpoint.",
        "This is the fundamental reason of parsing accuracy improvement."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "In dependency parsing, features consisting of part-of-speech (POS) tags are very effective, since pure lexical features lead to severe data sparseness problem.",
        "Typically, POS tagging and dependency parsing are modeled in a pipelined way.",
        "However, the pipelined method is prone to error propagation, especially for Chinese.",
        "Due to the lack of morphological features, Chinese POS tagging is even harder than other languages such as English.",
        "The state-of-the-art accuracy of Chinese POS tagging is about 93.5%, which is much lower than that of English (about 97% (Collins, 2002)).",
        "Our experimental results show that parsing accuracy decreases by about 6% on Chinese when using automatic POS tagging results instead of gold ones (see Table 3 in Section 5).",
        "Recent research on dependency parsing usually overlooks this issue by simply adopting gold POS tags for Chinese data (Duan et al., 2007; Zhang and Clark, 2008b; Huang and Sagae, 2010).",
        "In this paper, we address this issue by jointly optimizing POS tagging and dependency parsing.",
        "Joint modeling has been a popular and effective approach to simultaneously solve related tasks.",
        "Recently, many successful joint models have been proposed, such as joint tokenization and POS tagging (Zhang and Clark, 2008a; Jiang et al., 2008;",
        "Kruengkrai et al., 2009), joint lemmatization and POS tagging (Toutanova and Cherry, 2009), joint tokenization and parsing (Cohen and Smith, 2007; Goldberg and Tsarfaty, 2008), joint named entity recognition and parsing (Finkel and Manning, 2010) .",
        "Note that the aforementioned \"parsing\" all refer to constituent parsing.",
        "As far as we know, there are few successful models for jointly solving dependency parsing and other tasks.",
        "Being facilitated by Conference on Computational Natural Language Learning (CoNLL) 2008 and 2009 shared tasks, several joint models of dependency parsing and SRL have been proposed.",
        "Nevertheless, the top-ranked systems all adopt pipelined approaches (Surdeanu et al., 2008;",
        "Hajic et al., 2009).",
        "Theoretically, joint modeling of POS tagging and dependency parsing should be helpful to the two individual tasks.",
        "On the one hand, syntactic information can help resolve some POS ambiguities which are difficult to handle for the sequential POS tagging models.",
        "On the other hand, more accurate POS tags should further improve dependency parsing.",
        "For joint POS tagging and dependency parsing, the major issue is to design effective decoding algorithms to capture rich features and efficiently search out the optimal results from a huge hypothesis space.",
        "In this paper, we propose several dynamic programming (DP) based decoding algorithms for our joint models by extending existing parsing algorithms.",
        "We also present effective pruning techniques to speed up our decoding algorithms.",
        "Experimental results on Chinese Penn Treebank show that our joint models can significantly improve the state-of-the-art parsing accuracy by about 1.5%.",
        "The remainder of this paper is organized as follows.",
        "Section 2 describes the pipelined method, including the POS tagging and parsing models.",
        "Section 3 discusses the joint models and the decoding algorithms, while Section 4 presents the pruning techniques.",
        "Section 5 reports the experimental results and error analysis.",
        "We review previous work closely related to our method in Section 6, and conclude this paper in Section 7."
      ]
    },
    {
      "heading": "2. The Baseline Pipelined Method",
      "text": [
        "Given an input sentence x = w\\...wn, we denote its POS tag sequence by t = t\\...tn, where ti G T, 1 < i < n, and T is the POS tag set.",
        "A dependency tree is denoted by d = {(h, m) : 0 < h < n, 0 < m < n}, where (h, m) represents a dependency wh – wm whose head word (or father) is wh and modifier (or child) is wm.",
        "wo is an artificial root token which is used to simplify the formalization of the problem.",
        "The pipelined method treats POS tagging and dependency parsing as two cascaded problems.",
        "First, an optimal POS tag sequence t is determined.",
        "t = arg maxScorepos(x, t) t",
        "Then, an optimal dependency tree d is determined based on x and t.",
        "d = arg max Scoresyn(x, t, d)",
        "POS tagging is a typical sequence labeling problem.",
        "Many models have been successfully applied to sequence labeling problems, such as maximum-entropy (Ratnaparkhi, 1996), conditional random fields (CRF) (Lafferty et al., 2001) and perceptron (Collins, 2002).",
        "We use perceptron to build our POS tagging baseline for two reasons.",
        "Firstly, as a linear model, perceptron is simple, fast, and effective.",
        "It is competitive to CRF in tagging accuracy but requires much less training time (Shen et al., 2007).",
        "Secondly, perceptron has been successfully applied to dependency parsing as well (Koo and Collins, 2010).",
        "In this paper, perceptron is used in all models including the POS tagging model, the dependency parsing models and the joint models.",
        "In a perceptron, the score of a tag sequence is where fpos(x, t) refers to the feature vector and wposis the corresponding weight vector.",
        "For POS tagging features, we follow the work of Zhang and Clark (2008a).",
        "Three feature sets are considered: POS unigram, bigram and trigram features.",
        "For brevity, we will refer to the three sets as wi ti, ti-i ti and ti_2 ti-i ti.",
        "Given wpos, we adopt the Viterbi algorithm to get the optimal tagging sequence.",
        "Recently, graph-based dependency parsing has gained more and more interest due to its state-of-the-art accuracy.",
        "Graph-based dependency parsing views the problem as finding the highest scoring tree from a directed graph.",
        "Based on dynamic programming decoding, it can efficiently find an optimal tree in a huge search space.",
        "In a graph-based model, the score of a dependency tree is factored into scores of small parts (subtrees).",
        "ScoreSyn(x, t, d) where p is a scoring part which contains one or more dependencies in the dependency tree d. Figure 1 shows different types of scoring parts used in current graph-based models.",
        "dependency sibling grandparent grand-sibling tri-sibling",
        "Figure 1: Different types of scoring parts used in current graph-based models (Koo and Collins, 2010).",
        "Eisner (1996) proposes an O(n) decoding algorithm for dependency parsing.",
        "Based on the algorithm, McDonald et al.",
        "(2005) propose the first-order model, in which the scoring parts only contains dependencies.",
        "The second-order model of McDonald and Pereira (2006) incorporates sibling parts and also needs O(n) parsing time.",
        "The second-order model of Carreras (2007) incorporates both sibling and grandparent parts, and needs O(n) parsing time.",
        "However, the grandparent parts are restricted to those composed of outermost grandchildren.",
        "Koo and Collins (2010) propose efficient decoding algorithms of O(n) for third-order models.",
        "In their paper, they implement two versions of third-order models, Model 1 and Model 2 according to their naming.",
        "Model 1 incorporates only grand-sibling parts, while Model 2 incorporates both grand-sibling and tri-sibling parts.",
        "Their experiments on English and Czech show that Model 1 and Model 2 obtain nearly the same parsing accuracy.",
        "Therefore, we use Model 1 as our third-order model in this paper.",
        "We use three versions of graph-based dependency parsing models.",
        "• The first-order model (O1): the same with McDonald et al.",
        "(2005).",
        "• The second-order model (O2): the same with Model 1 in Koo and Collins (2010), but without using grand-sibling features.",
        "• The third-order model (O3): the same with",
        "Model 1 in Koo and Collins (2010).",
        "We adopt linear models to define the score of a dependency tree.",
        "For the third-order model, the score of a dependency tree is represented as:",
        "For the first-and second-order models, the above formula is modified by deactivating extra parts.",
        "For parsing features, we follow standard practice for graph-based dependency parsing (McDonald, 2006; Carreras, 2007; Koo and Collins, 2010).",
        "Since these features are highly related with our joint decoding algorithms, we summarize the features as follows.",
        "• Dependency Features, fdep(x, t, h, m)",
        "- Unigram Features: whth dir, wmtm dir - Bigram Features: whth wmtm dir dist - In Between Features: th tb tm dir dist - Surrounding Features:",
        "th-l th th+l tm-l tm tm+l dir dist",
        "Wh th Ws ts Wm tm dir",
        "• Grandparent Features, fgrd(x, t,g,h,m) Wg tg Wh th Wm tm dir gdir",
        "• Grand-sibling Features, fgsib(x, t, g, h, s, m) Wg tg Wh th Ws ts Wm tm dir gdir",
        "where b denotes an index between h and m; dir and dist are the direction and distance of (h, m); gdir is the direction of (g, h).",
        "We also use backoff features by generalizing from very specific features over word forms, POS tags, directions and distances to less sparse features over just POS tags or considering fewer nodes.",
        "To avoid producing too many sparse features, at most two word forms are used at the same time in sibling, grandparent and grand-sibling features, while POS tags are used instead for other nodes; meanwhile, at most four POS tags are considered at the same time for surrounding features."
      ]
    },
    {
      "heading": "3. Joint Models",
      "text": [
        "In the joint method, we aim to simultaneously solve the two problems.",
        "Under the linear model, the score of a tagged dependency tree is:",
        "where fpos©syn(.)",
        "means the concatenation of fpos(.)",
        "and fsyn(.).",
        "Under the joint model, the weights of POS and syntactic features, wpos®syn, are simultaneously learned.",
        "We expect that POS and syntactic features can interact each other to determine an optimal joint result.",
        "Similarly to the baseline dependency parsing models, we define the first-, second-, and third-order joint models according to the syntactic features contained in fsyn(.",
        ").",
        "In the following, we propose two versions ofjoint models which can capture different feature sets and have different complexity.",
        "The crucial problem for the joint method is to design effective decoding algorithms to capture rich features and efficiently search out the optimal results from a huge hypothesis space.",
        "Eisner (2000) describes a preliminary idea to handle polysemy by extending parsing algorithms.",
        "Based on this idea, we extend decoding algorithms of McDonald et al.",
        "(2005) and Koo and Collins (2010), and propose two DP based decoding algorithms for our joint models of version 1.",
        "Figure 2: The DP structures and derivations of the first-order decoding algorithm of joint models of version 1.",
        "We omit symmetric right-headed versions for brevity.",
        "Trapezoids denote incomplete spans.",
        "Triangles denote complete spans.",
        "Solid circles denote POS tags of the corresponding indices.",
        "The decoding algorithm of O1: As shown in Figure 2, the first-order joint decoding algorithm utilizes two types of dynamic programming structures.",
        "(1) Incomplete spans consist of a dependency and the region between the head and modifier; (2) Complete spans consist of a headword and its descendants on one side.",
        "Each span is recursively created by combining two smaller and adjacent spans in a bottom-up fashion.",
        "The pseudo codes are given in Algorithm 1.",
        "I(i,j)(ti,tj) denotes an incomplete span from i to j whose boundary POS tags are ti and tj.",
        "C(i J)(ti tj ) refers to a complete span from i to j whose boundary POS tags are ti and tj.",
        "Conversely, I(j;i)(tj ,ti) and C(jti)(t. ti) represent spans of the other direction.",
        "Note that in these notations the first argument index always refers to the head of the span.",
        "Line 6 corresponds to the derivation in Figure 2-(a).",
        "Scorejoint(x,ti,tr,tr+i,tj,p – )}) captures the joint features invented by this combination, where p – {(i, j)} means that the newly observed scoring part is the dependency (i, j).",
        "The syntactic features, denoted by fsyn(x, ti, tj, i, j), can only incorporate syntactic unigram and bigram features.",
        "The surrounding and in between features are unavailable, because the context POS tags, such as tb and ti-1, are not contained in the DP strucAlgorithm 1 The first-order joint decoding algorithm of version 1",
        "< span width < initialization < span start index < span end index",
        "end for end for",
        "tures.",
        "Therefore, we adopt pseudo surrounding and in between features by simply fixing the context POS tags as the single most likely ones (McDonald, 2006).",
        "Taking the in between features as an example, we use ti 4 tj dir dist instead, where tb is the 1-best tag determined by the baseline POS tagger.",
        "The POS features, denoted by fpos(x, ti; tr, tr+1; tj ), can only incorporate all POS unigram and bigram features.",
        "Similarly, we use pseudo POS trigram features such as fr_1 tr tr+1.",
        "Line 8 corresponds to the derivation in Figure 2-(b).",
        "Since this combination invents no scoring part (p – 0), Scorejoint(x, ti, tr, tj ,p – 0) is only composed of POS features.",
        "Line 7 and Line 9 create spans in the opposite direction, which can be analogously illustrated.",
        "The space and time complexity of the algorithm are respectively O(nq) and O(nq), where q – |T|.",
        "The decoding algorithm of O2 & O3: Figure 3 illustrates the second-and third-order decoding algorithm of joint models of version 1.",
        "A new kind of span, named the sibling span, is used to capture sibling structures.",
        "Furthermore, each span is augmented with a grandparent-index to capture both grandparent and grand-sibling structures.",
        "It is straightforward to derive the pseudo codes of the al-",
        "not incorporated here to avoid double counting.",
        "Figure 3: The DP structures and derivations of the second-and third-order joint decoding algorithm of version 1.",
        "For brevity, we elide the right-headed and right-grandparented versions.",
        "Rectangles represent sibling spans.",
        "Figure 4: The DP structures and derivations of the firstorder joint decoding algorithm of version 2.",
        "We omit the right-headed version for brevity.",
        "r + 2 = j.",
        "Note that wi ti, wj tj and ti tj (if i = j",
        "gorithm from Figure 3.",
        "We omit them due to space limitation.",
        "Pseudo surrounding, in between and POS trigram features are used due to the same reason as above.",
        "The space and time complexity of the algorithm are respectively O(nq) and O(nq).",
        "To further incorporate genuine syntactic surrounding and POS trigram features in the DP structures, we extend the algorithms of joint models of version 1, and propose our joint models of version 2.",
        "The decoding algorithm of O1: Figure 4 illustrates the first-order joint decoding algorithm of version 2.",
        "Compared with the structures in Figure 2, each span is augmented with the POS tags surrounding the boundary indices.",
        "These context POS tags enable Scorejoint(.)",
        "in line 6-9 of Algorithm 1 to capture the syntactic surrounding and POS trigram features, but also require enumeration of POS tags over more indices.",
        "For brevity, we skip the pseudo codes which can be easily derived from Algorithm 1.",
        "The space and time complexity of the algorithm are respectively O(n q) and O(nq).",
        "The decoding algorithm of O2 & O3: Using the same idea as above, the second-and third-order joint decoding algorithms of version 2 can be derived based on Figure 3.",
        "Again, we omit both its DP structures and pseudo codes for the sake of brevity.",
        "Its space and time complexity are respectively O(nq) and O(nq).",
        "In between features, which should be regarded as non-local features in the joint situation, still cannot be incorporated in our joint models of version 2.",
        "Again, we adopt the pseudo version.",
        "Based on the above illustration, we can see that joint models of version 1 are more efficient with regard to the number of POS tags for each word, but fail to incorporate syntactic surrounding features and POS trigram features in the DP structures.",
        "On the contrary, joint models of version 2 can incorporate both aforementioned feature sets, but have higher complexity.",
        "These two versions of models will be thoroughly compared in the experiments."
      ]
    },
    {
      "heading": "4. Pruning Techniques",
      "text": [
        "In this section, we introduce two pruning strategies to constrain the search space of our models due to their high complexity.",
        "The time complexity of the joint decoding algorithm is unbearably high with regard to the number of candidate POS tags for each word (q – |T|).",
        "We find that it would be extremely time-consuming even when we only use two most likely POS tags for each word (q – 2) even for joint models of version 1.",
        "To deal with this problem, we propose a pruning method that can effectively reduce the POS tag space based on a probabilistic tagging model.",
        "We adopt a conditional log-linear model (Lafferty et al., 2001), which defines a conditional distribution of a POS tag sequence t given x:",
        "ewpos*fpos(x,t)",
        "y ewpos Apos(x,t,)",
        "We use the same feature set fpos defined in Section 2.1, and adopt the exponentiated gradient algorithm to learn the weight vector wpos (Collins et al., 2008).",
        "The marginal probability of tagging a word wi as t is which can be efficiently computed using the forward-backward algorithm.",
        "We define pmaxi(x) to be the highest marginal probability of tagging the word wi:",
        "We then define the allowable candidate POS tags of the word wi to be where At is the pruning threshold.",
        "7i(x) is used to constrain the POS search space by replacing T in Algorithm 1.",
        "The parsing time grows quickly for the second-and third-order models (both baseline and joint) when the input sentence gets longer (O(n)).",
        "Following Koo and Collins (2010), we eliminate unlikely dependencies using a form of coarse-to-fine pruning (Charniak and Johnson, 2005; Petrov and Klein, 2007).",
        "On the development set, 68.87% of the dependencies are pruned, while the oracle dependency accuracy is 99.77%.",
        "We use 10-fold cross validation to do pruning on the training set."
      ]
    },
    {
      "heading": "5. Experiments",
      "text": [
        "We use the Penn Chinese Treebank 5.1 (CTB5) (Xue et al., 2005).",
        "Following the setup of Duan et al.",
        "Sagae (2010), we split CTB5 into training (secs 001815 and 1001-1136), development (secs 886-931 and 1148-1151), and test (secs 816-885 and 11371147) sets.",
        "We use the head-finding rules of Zhang and Clark (2008b) to turn the bracketed sentences into dependency structures.",
        "We use the standard tagging accuracy to evaluate POS tagging.",
        "For dependency parsing, we use word accuracy (also known as dependency accuracy), root accuracy and complete match rate (all excluding punctuation) .",
        "For the averaged training, we train each model for 15 iterations and select the parameters that perform best on the development set.",
        "Figure 5 shows the distribution of words with different number of candidate POS tags and the k-best oracle tagging accuracy under different At.",
        "To avoid dealing with words that have many candidate POS tags, we further apply a hard criterion that the decoding algorithms only consider top k candidate POS tags.",
        "To find the best At, we train and evaluate the second-order joint model of version 1 on the training and development sets pruned with different At (top k = 5).",
        "We adopt the second-order joint model of version 1 because of its efficiency compared with the third-order models and its capability of capturing rich features compared with the first-order models.",
        "The results are shown in Table 1.",
        "The model",
        "Table 1: Performance of the second-order joint model of version 1 with different pruning threshold At (top k = 5) on the development set.",
        "\"Acc.\"",
        "means the tagging accuracy.",
        "\"Speed\" refers to the parsing speed (the number of sentences processed per second).",
        "with At – 0.1 obtains the highest tagging accuracy, which is much higher than that of both At – 0.01 and At – 0.001.",
        "However, its parsing accuracy is inferior to the other two.",
        "At – 0.01 produces slightly better parsing accuracy than At – 0.001, and is twice faster.",
        "Finally, we choose At – 0.01 due to the efficiency factor and our priority over the parsing accuracy.",
        "Then we do experiments to find an optimal top k. Table 2 shows the results.",
        "We decide to choose k – 3 since it leads to best parsing accuracy.",
        "From Table 1 and 2, we can have an interesting finding: it seems that the harder we filter the POS tag space, the higher tagging accuracy we get.",
        "In other words, giving the joint model less flexibility of choosing POS tags leads to better tagging performance.",
        "Due to time limitation, we do not tune At and k for other joint models.",
        "Instead, we simply adopt At – 0.01 and top k – 3.",
        "Table 3 shows the final results on the test set.",
        "We list a few state-of-the-art results in the bottom.",
        "Duan07 refers to the results of Duan et al.",
        "(2007).",
        "They enhance the transition-based parsing model with",
        "*",
        "> – ",
        "//",
        "-k-0",
        "1",
        "01 001",
        "1",
        "u 0",
        "-b-0",
        "J",
        "At",
        "word",
        "root",
        "compl.",
        "acc.",
        "speed",
        "0.1",
        "81.53",
        "76.88",
        "30.00",
        "94.17",
        "2.5",
        "0.01",
        "81.83",
        "76.62",
        "30.62",
        "93.16",
        "1.2",
        "0.001",
        "81.73",
        "77.38",
        "30.50",
        "93.41",
        "0.5",
        "Table 3: Final results on the test set.",
        "\"Gold POS\" means that gold POS tags are used as input by the pipelined parsing models; while \"Auto POS\" means that the POS tags are generated by the baseline POS tagging model.",
        "Table 2: Performance of the second-order joint model of version 1 with different top k (At = 0.01) on the development set.",
        "the beam search.",
        "H&S10 refers to the results of Huang and Sagae (2010).",
        "They greatly expand the search space of the transition-based model by merging equivalent states with dynamic programming.",
        "Z&C08 refers to the results of Zhang and Clark (2008b).",
        "They use a hybrid model to combine the advantages of both graph-based and transition-based models.",
        "We also do experiments with two publicly available and widely-used parsers, MSTParser and MaltParser.",
        "MSTParser1 refers to the first-order graph-based model of McDonald et al.",
        "(2005), while MSTParser2 is the second-order model of McDonald and Pereira (2006).",
        "MaltParser is a transition-based parsing system.",
        "It integrates a number of classification algorithms and transition strategies.",
        "We adopt the support vector machine classifier and the arc-standard strategy (Nivre, 2008).",
        "We can see that when using gold tags, our pipelined second-and third-order parsing models achieve best parsing accuracy, which is even higher than the hybrid model of Zhang and Clark (2008b).",
        "It is a little surprising that the second-order model slightly outperforms the third-order one.",
        "This may be possible, since Koo and Collins (2010) shows that the third-order model outperforms the second-order one by only 0.32% on English and 0.07% on Czech.",
        "In addition, we only use basic third-order features.",
        "Both joint models of version 1 and 2 can consistently and significantly improve the parsing accuracy by about 1.5% for all first-, second-and third-order cases.",
        "Accidentally, the parsing accuracy of the second-order joint model of version 2 is lower",
        "Syntactic Metrics",
        "Tagging Accuracy",
        "Parsing Speed",
        "word",
        "root",
        "compl.",
        "all-word",
        "known",
        "unknown",
        "Sent/Sec",
        "O3",
        "80.79",
        "75.84",
        "29.11",
        "92.80",
        "93.88",
        "76.80",
        "0.3",
        "Joint Models V2",
        "O2",
        "80.49",
        "75.49",
        "28.24",
        "92.68",
        "93.77",
        "76.27",
        "0.6",
        "Ol",
        "77.37",
        "68.64",
        "23.09",
        "92.96",
        "94.05",
        "76.64",
        "2.0",
        "O3",
        "80.69",
        "75.90",
        "29.06",
        "92.89",
        "93.96",
        "76.80",
        "0.5",
        "Joint Models V1",
        "O2",
        "80.74",
        "75.80",
        "28.24",
        "93.08",
        "94.11",
        "77.53",
        "1.7",
        "Ol",
        "77.38",
        "69.69",
        "22.62",
        "93.20",
        "94.23",
        "77.76",
        "8.5",
        "O3",
        "79.29",
        "74.65",
        "27.24",
        "2.0",
        "O2",
        "79.03",
        "74.70",
        "27.19",
        "5.8",
        "Auto POS",
        "Ol",
        "75.68",
        "68.06",
        "21.10",
        "93.51",
        "94.36",
        "80.78",
        "17.4",
        "MSTParser2",
        "77.95",
        "72.04",
        "25.50",
        "4.1",
        "MSTParserl",
        "75.84",
        "68.55",
        "21.36",
        "5.2",
        "MaltParser",
        "75.24",
        "65.92",
        "23.19",
        "2.6",
        "O3",
        "86.00",
        "77.59",
        "34.02",
        "-",
        "O2",
        "86.18",
        "78.58",
        "34.07",
        "-",
        "O1",
        "82.24",
        "70.10",
        "26.02",
        "-",
        "MSTParser2",
        "85.24",
        "77.41",
        "33.19",
        "-",
        "Gold POS",
        "MSTParser1",
        "83.04",
        "71.49",
        "27.59",
        "100.0",
        "100.0",
        "100.0",
        "-",
        "MaltParser",
        "82.62",
        "69.34",
        "29.06",
        "-",
        "H&S10",
        "85.20",
        "78.32",
        "33.72",
        "-",
        "Z&C08 single",
        "84.33",
        "76.73",
        "32.79",
        "-",
        "Z&C08 hybrid",
        "85.77",
        "76.26",
        "34.41",
        "-",
        "Duan07",
        "83.88",
        "73.70",
        "32.70",
        "-",
        "top k",
        "word",
        "root",
        "compl.",
        "acc.",
        "speed",
        "2",
        "81.46",
        "76.12",
        "30.50",
        "93.51",
        "2.7",
        "3",
        "82.11",
        "76.75",
        "29.75",
        "93.31",
        "1.7",
        "4",
        "81.75",
        "76.62",
        "30.38",
        "93.25",
        "1.4",
        "5",
        "81.83",
        "76.62",
        "30.62",
        "93.16",
        "1.2",
        "Table 4: Error analysis of POS tagging.",
        "# means the error number of the corresponding pattern made by the baseline tagging model.",
        "4- and t mean the error number reduced or increased by the joint model.",
        "than that of its counterparts by about 0.3%.",
        "More experiments and further analysis may be needed to find out the reason.",
        "The two versions of joint models performs nearly the same, which indicates that using pseudo surrounding and POS trigram features may be sufficient for the joint method on this data set.",
        "In summary, we can conclude that the joint framework is certainly helpful for dependency parsing.",
        "It is clearly shown in Table 3 that the joint method surprisingly hurts the tagging accuracy, which diverges from our discussion in Section 1.",
        "Some insights into this issue will be given in Section 5.3.",
        "Moreover, it seems that the more syntactic features the joint method incorporates (from O1 to O3), the more the tagging accuracy drops.",
        "We suspect that this is because the joint models are dominated by the syntactic features.",
        "Take the firstorder joint model as an example.",
        "The dimension of the syntactic features fsyn is about 3.5 million, while that of fpos is only about 0.5 million.",
        "The gap becomes much larger for the second-and third-order cases.",
        "Comparing the parsing speed, we can find that the pruning of POS tags is very effective.",
        "The second-order joint model of version 1 can parse 1.7 sentences per second, while the pipelined second-order parsing model can parse 5.8 sentences per second, which is rather close considering that there is a factor of q.",
        "To find out the impact of our joint models on the individual tasks, we conduct detailed error analysis through comparing the results of the pipelined second-order parsing model and the second-order joint model of version 1.",
        "Impact on POS tagging: Table 4 shows how the joint model changes the quantity of POS tagging error patterns compared with the pipelined model.",
        "An error pattern \"X – Y\" means that the focus word, whose true tag is 'X', is assigned a tag 'Y'.",
        "We choose these patterns with largest reduction or increase in the error number, and rank them in descending order of the variation.",
        "From the left part of Table 4, we can see that the joint method is clearly better at resolving tagging ambiguities like {VV, NN} and {DEG, DEC}.One common characteristic of these ambiguous pairs is that the local or even whole syntactic structure will be destructed if the wrong tag is chosen.",
        "In other words, resolving these ambiguities is critical and helpful from the parsing viewpoint.",
        "From another perspective, the joint model is capable of preferring the right tag with the help of syntactic structures, which is impossible for the baseline sequential labeling model.",
        "In contrast, pairs like {NN, NR}, {VV, VA} and {NN, JJ} only slightly influence the syntactic structure when mis-tagged.",
        "The joint method performs worse on these ambiguous pairs, as shown in the right part of Table 4.",
        "Impact on parsing: Table 5 studies the change of parsing error rates between the pipelined and joint model on different POS tag patterns.",
        "We present the most typical and prominent patterns in the table, and rank them in descending order of X's frequency of occurrence.",
        "We also show the change of proportion of different patterns, which is consistent with the results in Table 4.",
        "From the table, we can see the joint model can achieve a large error reduction (0.8~4.0%) for all the patterns \"X – X\".",
        "In other words, the joint model can do better given the correct tags than the pipelined method.",
        "For all the patterns marked by 0, except for the ambiguous pair {NN, JJ} (which we find is difficult to explain even after careful result analysis), the joint model also reduces the error rates (2.2~15.4%).",
        "As",
        "error pattern",
        "#",
        ";",
        "error pattern",
        "#",
        "t",
        "DEC – DEG",
        "237",
        "114",
        "NR – NN",
        "184",
        "100",
        "NN – VV",
        "389",
        "73",
        "NN – NR",
        "106",
        "91",
        "DEG – DEC",
        "170",
        "39",
        "NN – JJ",
        "95",
        "70",
        "VV – NN",
        "453",
        "27",
        "VA – VV",
        "29",
        "41",
        "P – VV",
        "52",
        "24",
        "JJ – NN",
        "126",
        "29",
        "P – CC",
        "39",
        "13",
        "VV – VA",
        "67",
        "10",
        "Table 5: Comparison of parsing error rates on different POS tag patterns between the pipelined and joint models.",
        "Given a pattern \"X – Y\", \"prop\" means its proportion in all occurrence of 'X' ( ^Omw^x^) )> and \"error\" refers to its parsing error rate (- coUnt(X^Y)-)•",
        "The last two columns give the absolute reduction (-) or increase (+) in proportion and error rate made by the joint model.",
        "9 marks the patterns appearing in the left part of Table 4, while 0 marks those in the right part of Table 4.",
        "discussed earlier, these patterns concern ambiguous tag pairs which usually play similar roles in syntactic structures.",
        "This demonstrates that the joint model can do better on certain tagging error patterns.",
        "For patterns marked by 9, the error rate of the joint model usually increases by large margin.",
        "However, the proportion of these patterns is substantially decreased, since the joint model can better resolve these ambiguities with the help of syntactic knowledge.",
        "In summary, we can conclude that the joint model is able to choose such POS tags that are more helpful and discriminative from parsing viewpoint.",
        "This is the fundamental reason of the parsing performance improvement."
      ]
    },
    {
      "heading": "6. Related Work",
      "text": [
        "Theoretically, Eisner (2000) proposes a preliminary idea of extending the decoding algorithm for dependency parsing to handle polysemy.",
        "Here, word senses can be understood as POS-tagged words.",
        "Koo and Collins (2010) also briefly discuss that their third-order decoding algorithm can be modified to handle word senses using the idea of Eisner (2000).",
        "In his PhD thesis, McDonald (2006) extends his second-order model with the idea of Eisner (2000) to study the impact of POS tagging errors on parsing accuracy.",
        "To make inference tractable, he uses top 2 candidate POS tags for each word based on a maximum entropy tagger, and adopts the single most likely POS tags for the surrounding and in between features.",
        "He conducts primitive experiments on English Penn Treebank, and shows that parsing accuracy can be improved from 91.5% to 91.9%.",
        "However, he finds that the model is unbearably time-consuming."
      ]
    },
    {
      "heading": "7. Conclusions",
      "text": [
        "In this paper, we have systematically investigated the issue of joint POS tagging and dependency parsing.",
        "We propose and compare several joint models and their corresponding decoding algorithms which can incorporate different feature sets.",
        "We also propose an effective POS tag pruning method which can greatly improve the decoding efficiency.",
        "The experimental results show that our joint models can significantly improve the state-of-the-art parsing accuracy by more than 1.5%.",
        "Detailed error analysis shows that the fundamental reason for the parsing accuracy improvement is that the joint method is able to choose POS tags that are helpful and discriminative from parsing viewpoint."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We thank the anonymous reviewers for their helpful comments.",
        "This work was supported by National Natural Science Foundation of China (NSFC) via grant 60803093, 60975055, the Natural Scientific Research Innovation Foundation in Harbin Institute of Technology (HIT.NSRIF.2009069) and the Fundamental Research Funds for the Central Universities (HIT.KLOF.2010064).",
        "pattern",
        "pipelined",
        "joint",
        "prop (%)",
        "error (%)",
        "prop (%)",
        "error (%)",
        "NN – NN",
        "94.6",
        "16.8",
        "-1.1",
        "-1.8",
        " – VV 9",
        "2.9",
        "55.5",
        "-0.5",
        "+15.1",
        " – NR 0",
        "0.8",
        "24.5",
        "+0.7",
        "-2.2",
        " – JJ 0",
        "0.7",
        "17.9",
        "+0.5",
        "+2.1",
        "VV – VV",
        "89.6",
        "34.2",
        "-0.3",
        "-4.0",
        " – NN 9",
        "6.6",
        "66.4",
        "-0.4",
        "+0.7",
        " – VA 0",
        "1.0",
        "38.8",
        "+0.1",
        "-15.4",
        "NR – NR",
        "91.7",
        "15.4",
        "-3.7",
        "-0.8",
        " – NN 0",
        "5.9",
        "21.7",
        "+3.2",
        "-3.7",
        "P – P",
        "92.8",
        "22.6",
        "+3.4",
        "-3.2",
        " – VV 9",
        "3.0",
        "50.0",
        "-1.4",
        "+10.7",
        " – CC 9",
        "2.3",
        "74.4",
        "-0.7",
        "+21.9",
        "JJ – JJ",
        "80.5",
        "11.2",
        "-2.8",
        "-2.0",
        " – NN 0",
        "9.8",
        "18.3",
        "+2.2",
        "+ 1.8",
        "DEG – DEG",
        "86.5",
        "11.1",
        "+2.8",
        "-3.6",
        " – DEC 9",
        "13.5",
        "61.8",
        "-3.1",
        "+37.4",
        "DEC – DEC",
        "79.7",
        "17.2",
        "+12.1",
        "-4.0",
        " – DEG 9",
        "20.2",
        "56.5",
        "-9.7",
        "+40.2"
      ]
    }
  ]
}
