{
  "info": {
    "authors": [
      "Pierluigi Crescenzi",
      "Daniel Gildea",
      "Andrea Marino",
      "Gianluca Rossi",
      "Giorgio Satta"
    ],
    "book": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies",
    "id": "acl-P11-1046",
    "title": "Optimal Head-Driven Parsing Complexity for Linear Context-Free Rewriting Systems",
    "url": "https://aclweb.org/anthology/P11-1046",
    "year": 2011
  },
  "references": [
    "acl-E09-1055",
    "acl-H05-1101",
    "acl-J09-4009",
    "acl-N06-1033",
    "acl-N07-1019",
    "acl-N09-1061",
    "acl-N10-1035",
    "acl-N10-1118",
    "acl-P06-2036",
    "acl-P08-1069",
    "acl-P87-1015",
    "acl-P97-1003"
  ],
  "sections": [
    {
      "text": [
        "Pierluigi Crescenzi Daniel Gildea Andrea Marino",
        "Dip.",
        "di Sistemi e Informatica Computer Science Dept.",
        "Dip.",
        "di Sistemi e Informatica Università di Firenze University of Rochester Universita di Firenze",
        "Dip.",
        "di Matematica Universita di Roma Tor Vergata",
        "Dip.",
        "di Ingegneria dell'Informazione Universita di Padova",
        "We study the problem of finding the best head-driven parsing strategy for Linear Context-Free Rewriting System productions.",
        "A head-driven strategy must begin with a specified righthand-side nonterminal (the head) and add the remaining nonterminals one at a time in any order.",
        "We show that it is NP-hard to find the best head-driven strategy in terms of either the time or space complexity of parsing."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Linear Context-Free Rewriting Systems (LCFRSs) (Vijay-Shankar et al., 1987) constitute a very general grammatical formalism which subsumes context-free grammars (CFGs) and tree adjoining grammars (TAGs), as well as the synchronous context-free grammars (SCFGs) and synchronous tree adjoining grammars (STAGs) used as models in machine translation.",
        "LCFRSs retain the fundamental property of CFGs that grammar nonterminals rewrite independently, but allow nonterminals to generate discontinuous phrases, that is, to generate more than one span in the string being produced.",
        "This important feature has been recently exploited by Maier and Sogaard (2008) and Kallmeyer and Maier (2010) for modeling phrase structure treebanks with discontinuous constituents, and by Kuhlmann and Satta (2009) for modeling non-projective dependency treebanks.",
        "The rules of a LCFRS can be analyzed in terms of the properties of rank and fan-out.",
        "Rank is the number of nonterminals on the right-hand side (rhs) of a rule, while fanout is the number of spans of the string generated by the nonterminal in the left-hand side (lhs) of the rule.",
        "CFGs are equivalent to LCFRSs with fanout one, while TAGs are one type of LCFRSs with fanout two.",
        "Rambow and Satta (1999) show that rank and fanout induce an infinite, two-dimensional hierarchy in terms of generative power; while CFGs can always be reduced to rank two (Chomsky Normal Form), this is not the case for LCFRSs with any fanout greater than one.",
        "General algorithms for parsing LCFRSs build a dynamic programming chart of recognized nonterminals bottom-up, in a manner analogous to the CKY algorithm for CFGs (Hopcroft and Ullman, 1979), but with time and space complexity that are dependent on the rank and fanout of the grammar rules.",
        "Whenever it is possible, binarization of LCFRS rules, or reduction of rank to two, is therefore important for parsing, as it reduces the time complexity needed for dynamic programming.",
        "This has lead to a number of binarization algorithms for LCFRSs, as well as factorization algorithms that factor rules into new rules with smaller rank, without necessarily reducing rank all the way to two.",
        "Kuhlmann and Satta (2009) present an algorithm for binarizing certain LCFRS rules without increasing their fan-out, and Sagot and Satta (2010) show how to reduce rank to the lowest value possible for LCFRS rules of fanout two, again without increasing fan-out.",
        "Gomez-Rodriguez et al.",
        "(2010) show how to factorize well-nested LCFRS rules of arbitrary fanout for efficient parsing.",
        "In general there may be a trade-off required between rank and fan-out, and a few recent papers have investigated this trade-off taking general LCFRS rules as input.",
        "Gömez-Rodriguez et al.",
        "(2009) present an algorithm for binarization of LCFRSs while keeping fanout as small as possible.",
        "The algorithm is exponential in the resulting fan-out, and Gomez-Rodriguez et al.",
        "(2009) mention as an important open question whether polynomial-time algorithms to minimize fanout are possible.",
        "Gildea (2010) presents a related method for bina-rizing rules while keeping the time complexity of parsing as small as possible.",
        "Binarization turns out to be possible with no penalty in time complexity, but, again, the factorization algorithm is exponential in the resulting time complexity.",
        "Gildea (2011) shows that a polynomial time algorithm for factorizing LCFRSs in order to minimize time complexity would imply an improved approximation algorithm for the well-studied graph-theoretic property known as treewidth.",
        "However, whether the problem of factorizing LCFRSs in order to minimize time complexity is NP-hard is still an open question in the above works.",
        "Similar questions have arisen in the context of machine translation, as the SCFGs used to model translation are also instances of LCFRSs, as already mentioned.",
        "For SCFG, Satta and Peserico (2005) showed that the exponent in the time complexity of parsing algorithms must grow at least as fast as the square root of the rule rank, and Gildea and Stefankovic (2007) tightened this bound to be linear in the rank.",
        "However, neither paper provides an algorithm for finding the best parsing strategy, and Huang et al.",
        "(2009) mention that whether finding the optimal parsing strategy for an SCFG rule is NP-hard is an important problem for future work.",
        "In this paper, we investigate the problem of rule binarization for LCFRSs in the context of head-driven parsing strategies.",
        "Head-driven strategies begin with one rhs symbol, and add one nonterminal at a time.",
        "This rules out any factorization in which two subsets of nonterminals of size greater than one are combined in a single step.",
        "Head-driven strategies allow for the techniques of lexicalization and Markovization that are widely used in (projective) statistical parsing (Collins, 1997).",
        "The statistical LCFRS parser of Kallmeyer and Maier (2010) binarizes rules head-outward, and therefore adopts what we refer to as a head-driven strategy.",
        "However, the binarization used by Kallmeyer and Maier (2010) simply proceeds left to right through the rule, without considering the impact of the parsing strategy on either time or space complexity.",
        "We examine the question of whether we can efficiently find the strategy that minimizes either the time complexity or the space complexity of parsing.",
        "While a naive algorithm can evaluate all r\\ head-driven strategies in time 0(n ■ r!",
        "), where r is the rule's rank and n is the total length of the rule's description, we wish to determine whether a polynomial-time algorithm is possible.",
        "Since parsing problems can be cast in terms of logic programming (Shieber et al., 1995), we note that our problem can be thought of as a type of query optimization for logic programming.",
        "Query optimization for logic programming is NP-complete since query optimization for even simple conjunctive database queries is NP-complete (Chandra and Merlin, 1977).",
        "However, the fact that variables in queries arising from LCFRS rules correspond to the endpoints of spans in the string to be parsed means that these queries have certain structural properties (Gildea, 2011).",
        "We wish to determine whether the structure of LCFRS rules makes efficient factorization algorithms possible.",
        "In the following, we show both the the time-and space-complexity problems to be NP-hard for head-driven strategies.",
        "We provide what is to our knowledge the first NP-hardness result for a grammar factorization problem, which we hope will aid in understanding parsing algorithms in general."
      ]
    },
    {
      "heading": "2. LCFRSs and parsing complexity",
      "text": [
        "In this section we briefly introduce LCFRSs and define the problem of optimizing head-driven parsing complexity for these formalisms.",
        "For a positive integer n, we write [n] to denote the set {1,..., n}.",
        "As already mentioned in the introduction, LCFRSs generate tuples of strings over some finite alphabet.",
        "This is done by associating each production p of a grammar with a function g that takes as input the tuples generated by the nonterminals in p's rhs, and rearranges their string components into a new tuple, possibly adding some alphabet symbols.",
        "Let V be some finite alphabet.",
        "We write V* for the set of all (finite) strings over V. For natural numbers r > 0 and f,fi,...,fr > 1, consider a funcg((x1A, .",
        ".",
        ".,Xhfl), (Xr,l, - - -,XrJr)) = OL .",
        "Here the o^j's denote variables over strings in V*, and a = (ai,..., a/) is an /-tuple of strings over g's argument variables and symbols in V. We say that g is linear, non-erasing if a contains exactly one occurrence of each argument variable.",
        "We call r and / the rank and the fanout of g, respectively, and write r(g) and f(g) to denote these quantities.",
        "Example 1 gi((xiti, £1,2)) = (^1,1^1,2) takes as input a tuple with two strings and returns a tuple with a single string, obtained by concatenating the components in the input tuple.",
        "<72((#i,i> #1,2)) = (axitib, cxipd) takes as input a tuple with two strings and wraps around these strings with symbols a, b,c,d G V. Both functions are linear, non-erasing, and we have r(g{) = r(g2) = 1, f(gi) = 1 and f(g2) = 2.",
        "□",
        "A linear context-free rewriting system is a tuple G = (Vn,Vt, P, S), where Vn and Vr are finite, disjoint alphabets of nonterminal and terminal symbols, respectively.",
        "Each A G Vn is associated with a value f(A), called its fan-out.",
        "The nonterminal S is the start symbol, with f(S) = 1.",
        "Finally, P is a set of productions of the form where A, Ah ..., Ar(g) e VN, and g : (V^)f(-Al^ x • • • x (V^)f{A^)) -, (V*)^^ is a linear, non-erasing function.",
        "Production (1) can be used to transform the r(g) string tuples generated by the nonterminals Ai,..., A-(a) into a tuple of f(A) strings generated by A.",
        "The values r(g) and f(g) are called the rank and fanout of p, respectively, written r(p) and f(p).",
        "Given that f(S) = 1, S generates a set of strings, defining the language L(G).",
        "Figure 1 : Some parsing strategies for production p in Example 3, and the associated maximum value for fan-out.",
        "Symbol © denotes the merging operation, and superscript * marks the first step in the strategy in which the highest fanout is realized.",
        "of the following bottom-up process.",
        "First, the tuple (e, e) is generated by A through ^3.",
        "We then iterate three times the application of p2 to (e,e), resulting in the tuple (ab, cd).",
        "Finally, the tuple (string) (abcd) is generated by S through application of Pi □",
        "Existing parsing algorithms for LCFRSs exploit dynamic programming.",
        "These algorithms compute partial parses of the input string w, represented by means of specialized data structures called items.",
        "Each item indexes the boundaries of the segments of w that are spanned by the partial parse.",
        "In the special case of parsing based on CFGs, an item consists of two indices, while for TAGs four indices are required.",
        "In the general case of LCFRSs, parsing of a production p as in (1) can be carried out in r(g) – 1 steps, collecting already available parses for nonterminals Ai,..., Ar(fl) one at a time, and 'merging' these into intermediate partial parses.",
        "We refer to the order in which nonterminals are merged as a parsing strategy, or, equivalently, a factorization of the original grammar rule.",
        "Any parsing strategy results in a complete parse of p, spanning f(p) = /(A) segments of w and represented by some item with 2/(A) indices.",
        "However, intermediate items obtained in the process might span more than /(A) segments.",
        "We illustrate this through an example.",
        "Example 3 Consider a linear non-erasing function As, and A2.",
        "In this case, after we have collected the first three nonterminals, we have obtained a partial parse having fanout 4, that is, an item spanning 4 segments of the input string.",
        "Alternatively, we could first merge A\\ and A4, then merge A2 and A%, and finally merge the two obtained partial parses.",
        "This strategy is slightly better, resulting in a maximum fanout of 3.",
        "Other possible strategies can be explored, displayed in Figure 1.",
        "It turns out that the best parsing strategy leads to fanout 2.",
        "□",
        "fan-out",
        "strategy",
        "4",
        "((Ai © A4) © A3)",
        "* © A2",
        "3",
        "(Ai ©A4)* ®(A2",
        "©A3)",
        "3",
        "((Ai © A2)* ©A4",
        ") © A3",
        "2",
        "((A* © A3) © A4)",
        "© Ai",
        "The maximum fanout / realized by a parsing strategy determines the space complexity of the parsing algorithm.",
        "For an input string w, items will require (in the worst-case) 2/ indices, each taking ö(| 101) possible values.",
        "This results in space complexity of ö(\\w\\f).",
        "In the special cases of parsing based on CFGs and TAGs, this provides the well-known space complexity of 0(|«;|) and 0(|«;|), respectively.",
        "It can also be shown that, if a partial parse having fanout / is obtained by means of the combination of two partial parses with fanout f\\ and f2, respectively, the resulting time complexity will be 0{\\w\\f+h+h) (Seki etal, 1991; Gildea, 2010).",
        "As an example, in the case of parsing based on CFGs, nonterminals as well as partial parses all have fanout one, resulting in the standard time complexity of 0(|«;|) of dynamic programming methods.",
        "When parsing with TAGs, we have to manipulate objects with fanout two (in the worst case), resulting in time complexity of Ö ( | w | ).",
        "We investigate here the case of general LCFRS productions, whose internal structure is considerably more complex than the context-free or the tree adjoining case.",
        "Optimizing the parsing complexity for a production means finding a parsing strategy that results in minimum space or time complexity.",
        "We now turn the above optimization problems into decision problems.",
        "In the Min Space Strat-",
        "egy problem one takes as input an LCFRS production p and an integer k, and must decide whether there exists a parsing strategy for p with maximum fanout not larger than k. In the M in Time Strategy problem one is given p and k as above and must decide whether there exists a parsing strategy for p such that, in any of its steps merging two partial parses with fanout f\\ and f2 and resulting in a partial parse with fanout /, the relation / + /1 + /2 < k holds.",
        "In this paper we investigate the above problems in the context of a specific family of linguistically motivated parsing strategies for LCFRSs, called head-driven.",
        "In a head-driven strategy, one always starts parsing a production p from a fixed nonterminal in its rhs, called the head of p, and merges the remaining nonterminals one at a time with the partial parse containing the head.",
        "Thus, under these strategies, the construction of partial parses that do not include the head is forbidden, and each parsing step involves at most one partial parse.",
        "In Figure 1, all of the displayed strategies but the one in the second line are head-driven (for different choices of the head)."
      ]
    },
    {
      "heading": "3. NP-completeness results",
      "text": [
        "For an LCFRS production p, let H be its head nonterminal, and let Ai,... ,An be all the non-head nonterminals in p's rhs, with n + 1 = r(p).",
        "A head-driven parsing strategy can be represented as a permutation 7T over the set [n], prescribing that the nonhead nonterminals in p's rhs should be merged with H in the order An^, A^^,..., A^ny Note that there are n\\ possible head-driven parsing strategies.",
        "To show that Min Space Strategy is NP-hard under head-driven parsing strategies, we reduce from the Min Cut Linear Arrangement problem, which is a decision problem over (undirected) graphs.",
        "Given a graph M = (V, E) with set of vertices V and set of edges E, a linear arrangement of M is a bijective function h from V to [n], where \\V\\ =n.",
        "The cutwidth of M at gap i G [n – 1] and with respect to a linear arrangement h is the number of edges crossing the gap between the i-th vertex and its successor:",
        "cw(M,h,i) = \\{(u,v) G E\\h(u) < i < h(v)}\\ .",
        "Figure 3: The construction used to prove Theorem 1 builds the LCFRS production p shown, when given as input the graph of Figure 2.",
        "The cutwidth of M is then defined as cw(M) = min max cw(M, h, i) .",
        "In the Min Cut Linear Arrangement problem, one is given as input a graph M and an integer k, and must decide whether cw(M) < k. This problem has been shown to be NP-complete (Gavril, 1977).",
        "Theorem 1 The M in Space Strategy problem restricted to head-driven parsing strategies is NP-complete.",
        "Proof We start with the NP-hardness part.",
        "Let M = (V,E) and k be an input instance for Min Cut Linear Arrangement, and let V = {v\\,..., vn} and E = {e\\,..., eq}.",
        "We assume there are no self loops in M, since these loops do not affect the value of the cutwidth and can therefore be removed.",
        "We construct an LCFRS production p and an integer k!",
        "as follows.",
        "Production p has a head nonterminal H and a nonhead nonterminal Ai for each vertex Vi G V. We let H generate tuples with a string component for each edge a G E. Thus, we have f(H) = q.",
        "Accordingly, we use variables XH,ei, for each G E, to denote the string components in tuples generated by H.",
        "For each Vi G V, let E(vi) ç E be the set of edges impinging on Vi, thus \\E(vi)\\ is the degree of Vi.",
        "We let Ai generate a tuple with two string components for each ej G E(vi).",
        "Thus, we have f{Ai) = 2 • \\E(vi)\\.",
        "Accordingly, we use variables XAi,ej,i and XAi,ej,r, for each ej G E(vi), to denote the string components in tuples generated by Ai (here subscripts / and r indicate left and right positions, respectively; see below).",
        "define p by A g{tH,tAl, ■ ■ ■ ,tAn) = (ai,...,aq).",
        "Here tH is the tuple of variables for H and each tAt,i G [n], is the tuple of variables for Ai.",
        "Each string cti, % G [q], is specified as follows.",
        "Let vs and vt be the endpoints of ej, with vs,Vt G V and s < t. We define ai = ^Aa,ei,lxAtfii^U^iXAs,ei,rXAt,ei,r ■",
        "Observe that whenever edge impinges on vertex Vj, then the left and right strings generated by Aj and associated with wrap around the string generated by H and associated with the same edge.",
        "Finally, we set k!",
        "= q + k.",
        "Example 4 Given the input graph of Figure 2, our reduction constructs the LCFRS production shown in Figure 3.",
        "Figure 4 gives a visualization of how the spans in this production fit together.",
        "For each edge in the graph of Figure 2, we have a group of five spans in the production: one for the head nonterminal, and two spans for each of the two nonterminals corresponding to the edge's endpoints.",
        "□",
        "Assume now some head-driven parsing strategy 7T for p. For each i G [n], we define Df to be the partial parse obtained after step i in tt, consisting of the merge of nonterminals H, An^,..., An^y Consider some edge ej = (vs, vt).",
        "We observe that for any Df that includes or excludes both nonterminals As and At, the aj component in the definition of p is associated with a single string, and therefore contributes with a single unit to the fanout of the partial parse.",
        "On the other hand, if-Df includes only one nonterminal between As and At, the aj component is associated with two strings and contributes with two units to the fanout of the partial parse.",
        "We can associate with tt a linear arrangement of M by letting /^(^(i)) = i, f°r each Vi G V. From the above observation on the fanout of Df,",
        "Figure 4: A visualization of how the spans for each nonterminal fit together in the left-to-right order defined by the production of Figure 3.",
        "we have the following relation, for every % G [n – 1] :",
        "f{Df) = q + cw(M,hn,i) .",
        "We can then conclude that M, k is a positive instance of Min Cut Linear Arrangement if and only if p, k!",
        "is a positive instance of M in Space Strategy.",
        "This proves that M in Space Strategy is NP-hard.",
        "To show that M in Space Strategy is in NP, consider a nondeterministic algorithm that, given an LCFRS production p and an integer k, guesses a parsing strategy 7r for p, and tests whether f(DJ) < k for each % G [n].",
        "The algorithm accepts or rejects accordingly.",
        "Such an algorithm can clearly be implemented to run in polynomial time.",
        "■",
        "We now turn to the M in Time Strategy problem, restricted to head-driven parsing strategies.",
        "Recall that we are now concerned with the quantity /i + Î2 + /, where f\\ is the fanout of some partial parse D, f2 is the fanout of a nonterminal A, and / is the fan out of the partial parse resulting from the merge of the two previous analyses.",
        "We need to introduce the Modified Cutwidth problem, which is a variant of the Min Cut Linear Arrangement problem.",
        "Let M = (V, E) be some graph with \\ V\\ = n, and let h be a linear arrangement for M. The modified cutwidth of M at position i G [n] and with respect to h is the number of edges crossing over the i-th vertex:",
        "mcw(M,h,i) = \\{(u,v) G E\\h(u) < i < h(v)}\\ .",
        "The modified cutwidth of M is defined as mcw(M) = min max mcw(M,h,i) .",
        "In the Modified Cutwidth problem one is given as input a graph M and an integer k, and must decide whether mcw(M) < k. The Modified Cutwidth problem has been shown to be NP-complete by Lengauer (1981).",
        "We strengthen this result below; recall that a cubic graph is a graph without self loops where each vertex has degree three.",
        "Lemma 1 The Modified Cutwidth problem restricted to cubic graphs is NP-complete.",
        "Proof The Modified Cutwidth problem has been shown to be NP-complete when restricted to graphs of maximum degree three by Makedon et al.",
        "(1985), reducing from a graph problem known as bisection width (see also Monien and Sudborough (1988)).",
        "Specifically, the authors construct a graph G' of maximum degree three and an integer k' from an input graph G = (V, E) with an even number n of vertices and an integer k, such that mcw{G') < k!",
        "if and only if the bisection width bw(G) of G is not greater than k, where",
        "with A n B = 0, A U B = V, and\\A\\ = \\B\\.",
        "The graph G has vertices of degree two and three only, and it is based on a grid-like gadget R(r,c); see Figure 5.",
        "For each vertex of G, G' includes a component i?(2n,8n+8).",
        "Moreover, G' has a component called an iï-shaped graph, containing left and right columns iî(3n,12n + 12) connected by a middle bar R(2n,12n + 9); see Figure 6.",
        "From each of the n vertex components there is a sheaf of 2n edges connecting distinct degree 2 vertices in the component to 2n distinct degree 2 vertices in",
        "Figure 5: The R(5,10) component (left), the modification of its degree 2 vertex x (middle), and the corresponding arrangement (right).",
        "the middle bar of the iï-shaped graph.",
        "Finally, for each edge (vi, Vj) of G there is an edge in G' connecting a degree 2 vertex in the component corresponding to the vertex Vi with a degree 2 vertex in the component corresponding to the vertex Vj.",
        "The integer k' is set to 3n + n + k – 1.",
        "Makedon et al.",
        "(1985) show that the modified cutwidth of R(r, c) is r – 1 whenever r > 3 and c > 4r + 8.",
        "They also show that an optimal linear arrangement for G has the form depicted in Figure 6, where half of the vertex components are to the left of the iï-shaped graph and all the other vertex components are to the right.",
        "In this arrangement, the modified cutwidth is attested by the number of edges crossing over the vertices in the left and right columns of the H-shaped graph, which is equal to where 7 denotes the number of edges connecting vertices to the left with vertices to the right of the iï-shaped graph.",
        "Thus, bw(G) < k if and only if mcw{G') < k!.",
        "All we need to show now is how to modify the components of G in order to make it cubic.",
        "Modifying the vertex components All vertices x of degree 2 of the components corresponding to a vertex in G can be transformed into a vertex of degree 3 by adding five vertices x\\,...,X5 connected as shown in the middle bar of Figure 5.",
        "Observe that these five vertices can be positioned in the arrangement immediately after x in the order #2, #5, #3, #4 (see the right part of the figure).",
        "The resulting maximum modified cutwidth can increase by 2 in correspondence of vertex X5.",
        "Since the vertices of these components, in the optimal arrangement, have modified cutwidth smaller than 2n + n + n, an increase by 2 is still smaller than the maximum modified cutwidth of the entire graph, which is 3n + 0{n).",
        "Modifying the middle bar of the H-shaped graph",
        "The vertices of degree 2 of this part of the graph can be modified as in the previous paragraph.",
        "Indeed, in the optimal arrangement, these vertices have modified cutwidth smaller than 2n + 2n + n, and an increase by 2 is still smaller than the maximum cutwidth of the entire graph.",
        "Modifying the left/right columns of the H-shaped graph We replace the two copies of component i?",
        "(3n,12n + 12) with two copies of the new component _D(3n, 24n + 16) shown in Figure 7, which is a cubic graph.",
        "In order to prove that relation (2) still holds, it suffices to show that the modified cutwidth of the component D(r, c) is still r – 1 whenever r > 3 and c = 8r + 16.",
        "We first observe that the linear arrangement obtained by visiting the vertices of D(r, c) from top to bottom and from left to right has modified cutwidth r – 1.",
        "Let us now prove that, for any partition of the vertices into two subsets V\\ and V2 with | V\\ \\, \\ V2 \\ > Ar, there exist at least r disjoint paths between vertices of V\\ and vertices of V2.",
        "To this aim, we distinguish the following three cases.",
        "• Any row has (at least) one vertex in V\\ and one vertex in V2 : in this case, it is easy to see there exist at least r disjoint paths between vertices of V\\ and vertices of V2.",
        "• There exist at least 3r 'mixed' columns, that is, columns with (at least) one vertex in V\\ and one vertex in V2.",
        "Again, it is easy to see that there exist at least r disjoint paths between vertices",
        "of V\\ and vertices of V2 (at least one path every three columns).",
        "• The previous two cases do not apply.",
        "Hence, there exists a row entirely formed by vertices of Vi (or, equivalently, of Vi).",
        "The worst case is when this row is the smallest one, that is, the one with (-c~3~1-> + 1 = 4r + 7 vertices.",
        "Since at most 3r – 1 columns are mixed, we have that at most (3r - l)(r - 2) = 3r - 7r + 2 vertices of V2 are on these mixed columns.",
        "Since IV2I > 4r, this implies that at least r columns are fully contained in V2.",
        "On the other hand, at least 4r + 7 – (3r – 1) = r + 8 columns are fully contained in Vi.",
        "If the Vi columns interleave with the ^-columns, then there exist at least 2(r – 1) disjoint paths between vertices of Viand vertices of V2.",
        "Otherwise, all the Vi-columns precede or follow all the V2-columns (this corresponds to the optimal arrangement): in this case, there are r disjoint paths between vertices of V\\ and vertices of V2.",
        "Observe now that any linear arrangement partitions the set of vertices in D(r, c) into the sets V\\, consisting of the first 4r vertices in the arrangement, and V2, consisting of all the remaining vertices.",
        "Since there are r disjoint paths connecting Viand V2, there must be at least r – 1 edges passing over every vertex in the arrangement which is assigned to a position between the (4r + l)-th and the position 4r + 1 from the right end of the arrangement: thus, the modified cutwidth of any linear arrangement of the vertices of D(r, c) is at least r – 1.",
        "We can then conclude that the original proof of Makedon et al.",
        "(1985) still applies, according to relation (2).",
        "■",
        "We can now reduce from the Modified Cutwidth problem for cubic graphs to the Min Time Strategy problem restricted to head-driven parsing strategies.",
        "Theorem 2 The Min Time Strategy problem restricted to head-driven parsing strategies is NP-complete.",
        "Proof We consider hardness first.",
        "Let M and k be an input instance of the Modified Cutwidth problem restricted to cubic graphs, where M = (V, E) and V = {vi,..., vn}.",
        "We construct an LCFRS production p exactly as in the proof of Theorem 1, with rhs nonterminals H,Ai,..., An.",
        "We also setk' = 2-k + 2-\\E\\+9.",
        "Assume now some head-driven parsing strategy it for p. After parsing step i G [n], we have a partial parse Df consisting of the merge of nonterminals H, An^,..., An^.",
        "We write tc(p, tt, i) to denote the exponent of the time complexity due to step i.",
        "As already mentioned, this quantity is defined as the sum of the fanout of the two antecedents involved in the parsing step and the fanout of its result:",
        "tc(p,7T,i) = fiDf^ + fiA^ + fiDf).",
        "Again, we associate with tt a linear arrangement h-n of M by letting h^{vn^-yj = i, for each Vi G V. As in the proof of Theorem 1, the fanout of Df is then related to the cutwidth of the linear arrangement of M at position i by f(Df) = \\E\\+cw{M,K,i) .",
        "From the proof of Theorem 1, the fanout of nonterminal A7r(j) is twice the degree of vertex , denoted by \\E{vx(i))\\- We can then rewrite the above equation in terms of our graph M:",
        "+ 2-\\E(vn{i))\\ + cw(M,h7T,i) .",
        "The following general relation between cutwidth and modified cutwidth is rather intuitive:",
        "- I#K(*))I +cw(M,K,i)\\ .",
        "Combining the two equations above we obtain:",
        "tc(p,ir,i) = 2-\\E\\+3-\\E(vn{i))\\ + + 2 • mcw(M, hj,-, i) .",
        "Because we are restricting M to the class of cubic graphs, we can write:",
        "tc(p,7T,i) = 2-\\E\\ + 9 + 2-mcw(M,h7T,i) .",
        "We can thus conclude that there exists a head-driven parsing strategy for p with time complexity not greater than 2 • \\E\\ + 9 + 2 • k = k' if and only if mcw(M) < k.",
        "The membership of Modified Cutwidth inNP follows from an argument similar to the one in the proof of Theorem 1.",
        "■",
        "We have established the NP-completeness of both the Min Space Strategy and the Min Time Strategy decision problems.",
        "It is now easy to see that the problem of finding a space-or time-optimal parsing strategy for a LCFRS production is NP-hard as well, and thus cannot be solved in polynomial (deterministic) time unless P = NP."
      ]
    },
    {
      "heading": "4. Concluding remarks",
      "text": [
        "Head-driven strategies are important in parsing based on LCFRSs, both in order to allow statistical modeling of head-modifier dependencies and in order to generalize the Markovization of CFG parsers to parsers with discontinuous spans.",
        "However, there are n\\ possible head-driven strategies for an LCFRS production with a head and n modifiers.",
        "Choosing among these possible strategies affects both the time and the space complexity of parsing.",
        "In this paper we have shown that optimizing the choice according to either metric is NP-hard.",
        "To our knowledge, our results are the first NP-hardness results for a grammar factorization problem.",
        "SCFGs and STAGs are specific instances of LCFRSs.",
        "Grammar factorization for synchronous models is an important component of current machine translation systems (Zhang et al., 2006), and algorithms for factorization have been studied by Gildea et al.",
        "(2006) for SCFGs and by Nesson et al.",
        "(2008) for STAGs.",
        "These algorithms do not result in what we refer as head-driven strategies, although, as machine translation systems improve, lexicalized rules may become important in this setting as well.",
        "However, the results we have presented in this paper do not carry over to the above mentioned synchronous models, since the fanout of these models is bounded by two, while in our reductions in Section 3 we freely use unbounded values for this parameter.",
        "Thus the computational complexity of optimizing the choice of the parsing strategy for SCFGs is still an open problem.",
        "Finally, our results for LCFRSs only apply when we restrict ourselves to head-driven strategies.",
        "This is in contrast to the findings of Gildea (2011), which show that, for unrestricted parsing strategies, a polynomial time algorithm for minimizing parsing complexity would imply an improved approximation algorithm for finding the treewidth of general graphs.",
        "Our result is stronger, in that it shows strict NP-hardness, but also weaker, in that it applies only to head-driven strategies.",
        "Whether NP-hardness can be shown for unrestricted parsing strategies is an important question for future work."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "The first and third authors are partially supported from the Italian PRIN project DISCO.",
        "The second author is partially supported by NSF grants IIS-0546554 and IIS-0910611."
      ]
    }
  ]
}
