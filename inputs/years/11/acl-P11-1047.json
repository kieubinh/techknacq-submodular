{
  "info": {
    "authors": [
      "Mark-Jan Nederhof",
      "Giorgio Satta"
    ],
    "book": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies",
    "id": "acl-P11-1047",
    "title": "Prefix Probability for Probabilistic Synchronous Context-Free Grammars",
    "url": "https://aclweb.org/anthology/P11-1047",
    "year": 2011
  },
  "references": [
    "acl-H05-1101",
    "acl-J07-2003",
    "acl-J91-3004",
    "acl-J95-2002",
    "acl-J97-3002",
    "acl-J99-1004",
    "acl-N04-1035",
    "acl-N06-1033",
    "acl-N07-1019",
    "acl-P99-1070"
  ],
  "sections": [
    {
      "text": [
        "Mark-Jan Nederhof Giorgio Satta",
        "of Information Engineering",
        "North Haugh, St Andrews, Fife via Gradenigo, 6/A",
        "KY16 9SX I-35131 Padova",
        "United Kingdom Italy",
        "markjan.nederhof@googlemail.com satta@dei.unipd.it",
        "We present a method for the computation of prefix probabilities for synchronous context-free grammars.",
        "Our framework is fairly general and relies on the combination of a simple, novel grammar transformation and standard techniques to bring grammars into normal forms."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Within the area of statistical machine translation, there has been a growing interest in so-called syntax-based translation models, that is, models that define mappings between languages through hierarchical sentence structures.",
        "Several such statistical models that have been investigated in the literature are based on synchronous rewriting or tree transduc-tion.",
        "Probabilistic synchronous context-free grammars (PSCFGs) are one among the most popular examples of such models.",
        "PSCFGs subsume several syntax-based statistical translation models, as for instance the stochastic inversion transduction grammars of Wu (1997), the statistical model used by the Hiero system of Chiang (2007), and systems which extract rules from parsed text, as in Galley et al.",
        "(2004).",
        "Despite the widespread usage of models related to PSCFGs, our theoretical understanding of this class is quite limited.",
        "In contrast to the closely related class of probabilistic context-free grammars, a syntax model for which several interesting mathematical and statistical properties have been investigated, as for instance by Chi (1999), many theoretical problems are still unsolved for the class of PSCFGs.",
        "This paper considers a parsing problem that is well understood for probabilistic context-free grammars but that has never been investigated in the context of PSCFGs, viz. the computation of prefix probabilities.",
        "In the case of a probabilistic context-free grammar, this problem is defined as follows.",
        "We are asked to compute the probability that a sentence generated by our model starts with a prefix string v given as input.",
        "This quantity is defined as the (possibly infinite) sum of the probabilities of all strings of the form vw, for any string w over the alphabet of the model.",
        "This problem has been studied by Jelinek and Lafferty (1991) and by Stolcke (1995).",
        "Prefix probabilities can be used to compute probability distributions for the next word or part-of-speech.",
        "This has applications in incremental processing of text or speech from left to right; see again (Jelinek and Lafferty, 1991).",
        "Prefix probabilities can also be exploited in speech understanding systems to score partial hypotheses in beam search (Corazza et al., 1991).",
        "This paper investigates the problem of computing prefix probabilities for PSCFGs.",
        "In this context, a pair of strings viand v2 is given as input, and we are asked to compute the probability that any string in the source language starting with prefix v1 is translated into any string in the target language starting with prefix v2.",
        "This probability is more precisely defined as the sum of the probabilities of translation pairs of the form [v1w1,v2w2], for any strings w1and w2.",
        "A special case of prefix probability for PSCFGs is the right prefix probability.",
        "This is defined as the probability that some (complete) input string w in the source language is translated into a string in the target language starting with an input prefix v.",
        "Prefix probabilities and right prefix probabilities for PSCFGs can be exploited to compute probability distributions for the next word or part-of-speech in left-to-right incremental translation, essentially in the same way as described by Jelinek and Lafferty (1991) for probabilistic context-free grammars, as discussed later in this paper.",
        "Our solution to the problem of computing prefix probabilities is formulated in quite different terms from the solutions by Jelinek and Lafferty (1991) and by Stolcke (1995) for probabilistic context-free grammars.",
        "In this paper we reduce the computation of prefix probabilities for PSCFGs to the computation of inside probabilities under the same model.",
        "Computation of inside probabilities for PSCFGs is a well-known problem that can be solved using off-the-shelf algorithms that extend basic parsing algorithms.",
        "Our reduction is a novel grammar transformation, and the proof of correctness proceeds by fairly conventional techniques from formal language theory, relying on the correctness of standard methods for the computation of inside probabilities for PSCFG.",
        "This contrasts with the techniques proposed by Jelinek and Lafferty (1991) and by Stolcke (1995), which are extensions of parsing algorithms for probabilistic context-free grammars, and require considerably more involved proofs of correctness.",
        "Our method for computing the prefix probabilities for PSCFGs runs in exponential time, since that is the running time of existing methods for computing the inside probabilities for PSCFGs.",
        "It is unlikely this can be improved, because the recognition problem for PSCFG is NP-complete, as established by Satta and Peserico (2005), and there is a straightforward reduction from the recognition problem for PSCFGs to the problem of computing the prefix probabilities for PSCFGs."
      ]
    },
    {
      "heading": "2. Definitions",
      "text": [
        "In this section we introduce basic definitions related to synchronous context-free grammars and their probabilistic extension; our notation follows Satta and Peserico (2005).",
        "Let N and E be sets of nonterminal and terminal symbols, respectively.",
        "In what follows we need to represent bijections between the occurrences of nonterminals in two strings over N U E. This is realized by annotating nonterminals with indices from an infinite set.",
        "We define i(N) = {A | A G N, t G n} and V/ = i (N) u E. For a string 7 g V/, we write index(7) to denote the set of all indices that appear in symbols in 7.",
        "Two strings 71, 72 g V/ are synchronous if each index from n occurs at most once in 71 and at most once in y2, and index(71) = index(72).",
        "Therefore 71 , 72 have the general form:",
        "where r > 0, uu,U2i G E*, Af, Ap g i(N), tj = tj for i = j, and n is a permutation of the set {1,...,r}.",
        "A synchronous context-free grammar (SCFG) is a tuple G = (N, E, P, S), where N and E are finite, disjoint sets of nonterminal and terminal symbols, respectively, S g N is the start symbol and P is a finite set of synchronous rules.",
        "Each synchronous rule has the form s : [A1 – > a1, A2 – > a2], where A1, A2 g N and where a1,a2 G V/* are synchronous strings.",
        "The symbol s is the label of the rule, and each rule is uniquely identified by its label.",
        "For technical reasons, we allow the existence of multiple rules that are identical apart from their labels.",
        "We refer to A1 – a1 and A2 – a2, respectively, as the left and right components of rule s.",
        "Example 1 The following synchronous rules implicitly define a SCFG:",
        "In each step of the derivation process of a SCFG G, two nonterminals with the same index in a pair of synchronous strings are rewritten by a synchronous rule.",
        "This is done in such a way that the result is once more a pair of synchronous strings.",
        "An auxiliary notion is that of reindexing, which is an injective function f from n to n. We extend f to V/ by letting f (A ) = A ES for A g i (N ) and f (a) = a for a g E. We also extend f to strings in V * by letting f (e) = e and f (X7) = f (X )f (7), for each X G V/ and 7 G V/.",
        "s1 :",
        "[S – ",
        "+ Am Bm, S-",
        "s2 :",
        "[A – ",
        "aAB b, A – ",
        "bA B a]",
        "S3 :",
        "[A – ",
        "ab, A – ba]",
        "S4 :",
        "[B – ",
        "-+ cBB d, B – ",
        "dB B c]",
        "S5 :",
        "[B – ",
        "cd, B – dc]",
        "Let 71 , 72 be synchronous strings in V *.",
        "The derive relation [71, 72] =>G [ô1, ô2] holds whenever there exist an index t in index(71) = index(72), a synchronous rule s : [A1 – a1, A2 – a2] in P and some reindexing f such that:",
        "(iii) 61 = 71 f («1)71, ^2 = 72f («2)72'.",
        "We also write [71, 72] ==G [61, 62] to explicitly indicate that the derive relation holds through rule s.",
        "Note that 61 , 62 above are guaranteed to be synchronous strings, because a1 and a2 are synchronous strings and because of (i) above.",
        "Note also that, for a given pair [71, 72] of synchronous strings, an index t and a rule s, there may be infinitely many choices of reindexing f such that the above constraints are satisfied.",
        "In this paper we will not further specify the choice of f.",
        "We say the pair [A1, A2] of nonterminals is linked (in G) if there is a rule of the form s : [A1 – a1, A2 – a2].",
        "The set of linked nonterminal pairs is denoted by N[2].",
        "A derivation is a sequence a = s1s2 • • • sd of synchronous rules si G P with d > 0 (a = e for d = 0) suchthat [7ü_1, 72^1] =>g [71i, 72i] for every i with 1 < i < d and synchronous strings [7h, 72i] with 0 < i < d. Throughout this paper, we always implicitly assume some canonical form for derivations in G, by demanding for instance that each step rewrites a pair of nonterminal occurrences of which the first is leftmost in the left component.",
        "When we want to focus on the specific synchronous strings being derived, we also write derivations in the form [710, 720] ==G [71d, 72d], and we write [710, 720] ==G [71d, 72d] when a is not further specified.",
        "The translation generated by a SCFG G is defined as:",
        "For w1,w2 G E*, we write D(G, [w1,w2]) to denote the set of all (canonical) derivations a such that [SB, SE ] =G [w1, w2].",
        "Analogously to standard terminology for context-free grammars, we call a SCFG reduced if every rule occurs in at least one derivation a G D(G, [w1,w2]), for some w1,w2 G E*.",
        "We assume without loss of generality that the start symbol S does not occur in the right-hand side of either component of any rule.",
        "Example 2 Consider the SCFG G from example 1.",
        "The following is a canonical derivation in G, since it is always the leftmost nonterminal occurrence in the left component that is involved in a derivation step:",
        "=g [aA s bB m ,B m bA a]",
        "==g [aaA B bbB m ,B m bbA aa]",
        "=>G [aaabbbB ,B bbbaaa] =>G [aaabbbcB^ d, dB^cbbbaaa] =G [aaabbbccdd, ddccbbbaaa]",
        "It is not difficult to see that the generated translation",
        "The size of a synchronous rule s : [A1 – a1, A2 – a2], is defined as |s| = |A1a1A2a2|.",
        "The size of G is defined as |G| = seP |s|.",
        "A probabilistic SCFG (PSCFG) is a pair G = (G, pg) where G = (N, E, P, S) is a SCFG and pg is a function from P to real numbers in [0,1].",
        "We say that G is proper if for each pair [A1, A2] G N[21 we have:",
        "Intuitively, properness ensures that where a pair of nonterminals in two synchronous strings can be rewritten, there is a probability distribution over the applicable rules.",
        "For a (canonical) derivation a = s1s2 • • • sd, we define pg (a) = FJ d=1 PG(si).",
        "For wbw2 G E *, we also define:",
        "We say a PSCFG is consistent if pG defines a probability distribution over the translation, or formally:",
        "If the grammar is reduced, proper and consistent, then also:",
        "for every pair [Ai, A2] G N[2].",
        "The proof is identical to that of the corresponding fact for probabilistic context-free grammars."
      ]
    },
    {
      "heading": "3. Effective PSCFG parsing",
      "text": [
        "1 = j then w[i, j] = e).",
        "In this section, we assume the input is the pair [ w1 , w2] of terminal strings.",
        "The task of a recognizer for SCFG G is to decide whether [wi,W2] G T(G).",
        "We present a general algorithm for solving the above problem in terms of the specification of a deduction system, following Shieber et al.",
        "(1995).",
        "The items that are constructed by the system have the form [m1,A1,m'i; m2, A2, m'2], where [A1,A2] G N[2] and where m1, m1, m2, m2 are non-negative integers such that 0 < m1 < m1 < |w1| and 0 < m2 < m2 < |w2|.",
        "Such an item can be derived by the deduction system if and only if:",
        "The deduction system has one inference rule, shown in figure 1.",
        "One of its side conditions has a synchronous rule in P of the form:",
        "Observe that, in the right-hand side of the two rule components above, nonterminals A1i and A2n-i(j), 1 < i < r, have both the same index.",
        "More precisely, A1i has index ti and A27r-i(j) has index ti' with i' = = i.",
        "Thus the nonterminals in each antecedent item in figure 1 form a linked pair.",
        "We now turn to a computational analysis of the above algorithm.",
        "In the inference rule in figure 1 there are 2(r + 1) variables that can be bound to positions in w1 , and as many that can be bound to positions in w2.",
        "However, the side conditions imply mij = mij + |uij|, for i G {1,2} and 0 < j < r, and therefore the number of free variables is only r + 1 for each component.",
        "By standard complexity analysis of deduction systems, for example following McAllester (2002), the time complexity of a straightforward implementation of the recognition algorithm is O(|P| • |w1|rmax+1 • |w2|rmax+1), where rmax is the maximum number of right-hand side nonterminals in either component of a synchronous rule.",
        "The algorithm therefore runs in exponential time, when the grammar G is considered as part of the input.",
        "Such computational behavior seems unavoidable, since the recognition problem for SCFG is NP-complete, as reported by Satta and Peserico (2005).",
        "See also Gildea and Stefankovic (2007) and Hopkins and Langmead (2010) for further analysis of the upper bound above.",
        "The recognition algorithm above can easily be turned into a parsing algorithm by letting an implementation keep track of which items were derived from which other items, as instantiations of the consequent and the antecedents, respectively, of the inference rule in figure 1.",
        "A probabilistic parsing algorithm that computes pG([w1,w2]), defined in (1), can also be obtained from the recognition algorithm above, by associating each item with a probability.",
        "To explain the basic idea, let us first assume that each item can be inferred in finitely many ways by the inference rule in figure 1.",
        "Each instantiation of the inference rule should be associated with a term that is computed by multiplying the probability of the involved rule s and the product of all probabilities previously associated with the instantiations of the antecedents.",
        "The probability associated with an item is then computed as the sum of each term resulting from some instantiation of an inference rule deriving that item.",
        "This is a generalization to PSCFG of the inside algorithm defined for probabilistic context-free grammars (Manning and Schütze, 1999), and we can show that the probability associated with item [0, S, |w1| ; 0, S, |w21] provides the desired value pG([w1,w2]).",
        "We refer to the procedure sketched above as the inside algorithm for PSCFGs.",
        "However, this simple procedure fails if there are cyclic dependencies, whereby the derivation of an item involves a proper subderivation of the same item.",
        "Cyclic dependencies can be excluded if it can m20 is greater than m2j for each j (1 < j < r).",
        "Consider again a synchronous rule s of the form in (2).",
        "We say s is an epsilon rule if r = 0 and u10 = u20 = e. We say s is a unit rule if r = 1 and u10 = uL1 = u20 = u21 = e. Similarly to context-free grammars, absence of epsilon rules and unit rules guarantees that there are no cyclic dependencies between items and in this case the inside algorithm correctly computes pG, w2]).",
        "Epsilon rules can be eliminated from PSCFGs by a grammar transformation that is very similar to the transformation eliminating epsilon rules from a probabilistic context-free grammar (Abney et al., 1999).",
        "This is sketched in what follows.",
        "We first compute the set of all nullable linked pairs of nonterminals of the underlying SCFG, that is, the set of all [Ai, A2] £ N[2] suchthat [AE, A] ==G [e, e].",
        "This can be done in linear time O(|G|) using essentially the same algorithm that identifies nullable nonterminals in a context-free grammar, as presented for instance by Sippu and Soisalon-Soininen (1988).",
        "Next, we identify all occurrences of nullable pairs [Al, A2] in the right-hand side components of a rule s, such that Al and A2 have the same index.",
        "For every possible choice of a subset U of these occurrences, we add to our grammar a new rule constructed by omitting all of the nullable occurrences in U.",
        "The probability of is computed as the probability of s multiplied by terms of the form:",
        "for every pair [Al , A2] in U.",
        "After adding these extra rules, which in effect circumvents the use ofepsilongenerating subderivations, we can safely remove all epsilon rules, with the only exception of a possible rule of the form [S – e, S – e].",
        "The translation and the associated probability distribution in the resulting grammar will be the same as those in the source grammar.",
        "One problem with the above construction is that we have to create new synchronous rules for each possible choice of subset U.",
        "In the worst case, this may result in an exponential blow-up of the source grammar.",
        "In the case of context-free grammars, this is usually circumvented by casting the rules in binary form prior to epsilon rule elimination.",
        "However, this is not possible in our case, since SCFGs do not allow normal forms with a constant bound on the length of the right-hand side of each component.",
        "This follows from a result due to Aho and Ull-man (1969) for a formalism called syntax directed translation schemata, which is a syntactic variant of",
        "SCFGs.",
        "An additional complication with our construction is that finding any of the values in (3) may involve solving a system of non-linear equations, similarly to the case of probabilistic context-free grammars; see again Abney et al.",
        "(1999), and Stolcke (1995).",
        "Approximate solution of such systems might take exponential time, as pointed out by Kiefer et al.",
        "(2007).",
        "Notwithstanding the worst cases mentioned above, there is a special case that can be easily dealt with.",
        "Assume that, for each nullable pair [Al , A2] in G we have that [A^, AEp] ==G [w^ w2] does not hold for any wL and w2 with wL = e or w2 = e. Then each of the values in (3) is guaranteed to be 1, and furthermore we can remove the instances of the nullable pairs in the source rule s all at the same time.",
        "This means that the overall construction of elimination of nullable rules from G can be implemented in linear time | G| .",
        "It is this special case that we will encounter in section 4.",
        "After elimination of epsilon rules, one can eliminate unit rules.",
        "We define Cunit([Ai, A2], [Bi, B2]) as the sum of the probabilities of all derivations deriving [Bl, B2] from [Al, A2] with arbitrary indices, or more precisely:",
        "Note that [Al, A2] may be equal to [Bl, B2] and a maybe e, in which case C unit([Ai, A2], [Bi ,B2]) is at least 1, but it may be larger if there are unit rules.",
        "Therefore Cunit([Ai, A2], [Bi,B2]) should not be seen as a probability.",
        "Consider a pair [Al , A2] G N[2] and let all unit rules with left-hand sides Al and A2 be:",
        "The values of C unit(-, •) are related by the following:",
        "where 5([AL, A2] = [Bl, B2]) is defined to be 1 if [Ai, A2] = [Bi, B2] and 0 otherwise.",
        "This forms a system of linear equations in the unknown variables Cunit(•, •).",
        "Such a system can be solved in polynomial time in the number of variables, for example using Gaussian elimination.",
        "The elimination of unit rules starts with adding a rule s' : [Al – aL, A2 – a2] for each non-unit rule s : [Bl – a1,B2 – a2] and pair [Ai,A2] suchthat C unit([Ai,A2], [Bi,B2]) > 0.",
        "We assign to the new rule s' the probability pG(s) • Cunit([Ai, A2], [Bi, B2]).",
        "The unit rules can now be removed from the grammar.",
        "Again, in the resulting grammar the translation and the associated probability distribution will be the same as those in the source grammar.",
        "The new grammar has size",
        "O(|G| ), where G is the input grammar.",
        "The time complexity is dominated by the computation of the solution of the linear system of equations.",
        "This computation takes cubic time in the number of variables.",
        "The number of variables in this case is O(|G|), which makes the running time O(|G|)."
      ]
    },
    {
      "heading": "4. Prefix probabilities",
      "text": [
        "The joint prefix probability pGrefix([v1, v2]) of a pair [vL,v2] of terminal strings is the sum of the probabilities of all pairs of strings that have vL and v2, respectively, as their prefixes.",
        "Formally:",
        "At first sight, it is not clear this quantity can be effectively computed, as it involves a sum over infinitely many choices of wL and w2.",
        "However, analogously to the case of context-free prefix probabilities (Jelinek and Lafferty, 1991), we can isolate two parts in the computation.",
        "One part involves infinite sums, which are independent of the input strings vLand v2, and can be precomputed by solving a system of linear equations.",
        "The second part does rely on vL and v2, and involves the actual evaluation of pGrefix([v1, v2]).",
        "This second part can be realized effectively, on the basis of the precomputed values from the first part.",
        "In order to keep the presentation simple, and to allow for simple proofs of correctness, we solve the problem in a modular fashion.",
        "First, we present a transformation from a PSCFG G = (G,pg), with G = (N,T,P,S), to a",
        "PSCFG Gprefix = (Gpreflx,PGpreflx), with Gprefix = (Nprefix, 17, Pprefix, S-L).",
        "The latter grammar derives all possible pairs v2] such that [v1w1, v2w2] can be derived from G, for some wL and w2.",
        "Moreover, PGpreflx([vi, V2]) = pGrefix([vi, V2]), as will be verified later.",
        "Computing PGpreflx([vi,V2]) directly using a generic probabilistic parsing algorithm for PSCFGs is difficult, due to the presence of epsilon rules and unit rules.",
        "The next step will be to transform Gpreflxinto a third grammar Gprefix by eliminating epsilon rules and unit rules from the underlying SCFG, and preserving the probability distribution over pairs of strings.",
        "Using Gprefix one can then effectively apply generic probabilistic parsing algorithms for PSCFGs, such as the inside algorithm discussed in section 3, in order to compute the desired prefix probabilities for the source PSCFG G.",
        "For each nonterminal A in the source SCFG G, the grammar Gprefix contains three nonterminals, namely A itself, A-and Ae.",
        "The meaning of A remains unchanged, whereas A-is intended to generate a string that is a suffix of a known prefix vL or v2.",
        "Nonterminals Ae generate only the empty string, and are used to simulate the generation by G of infixes of the unknown suffix wL or w2.",
        "The two left-hand sides of a synchronous rule in Gprefix can contain different combinations of nonterminals of the forms A, A-, or Ae.",
        "The start symbol of Gprefix is S .",
        "The structure of the rules from the source grammar is largely retained, except that some terminal symbols are omitted in order to obtain the intended interpretation of A-and Ae.",
        "In more detail, let us consider a synchronous rule s : [Al – aL, A2 – a2] from the source grammar, where for i G {1,2} we have:",
        "ai = UioA^ Uii",
        "-1 Air Uir",
        "The transformed grammar then contains a large number of rules, each of which is of the form s' : [Bi – ßi, B2 – ß2], where Bi – ß is of one of three forms, namely Ai – ai, Ai- – ai-or Aie – aie, where ai- and aie are explained below.",
        "The choices for i = 1 and for i = 2 are independent, so that we can have 3 * 3 = 9 kinds of synchronous rules, to be further subdivided in what follows.",
        "A unique label s' is produced for each new rule, and the probability of each new rule equals that of s.",
        "The right-hand side aie is constructed by omitting all terminals and propagating downwards the e superscript, resulting in:",
        "It is more difficult to define a}.",
        "In fact, there can be a number of choices for ai- and, for each choice, the transformed grammar contains an instance ofthe synchronous rule s' : [Bl – ßL, B2 – ß2] as defined above.",
        "The reason why different choices need to be considered is because the boundary between the known prefix viand the unknown suffix wi can occur at different positions, either within a terminal string uij or else further down in a subderivation involving Aij.",
        "In the first case, we have for some j",
        "\"1Aij Uij Aij+1 Aij+2 Air",
        "where is a choice of a prefix of Uij.",
        "In words, the known prefix ends after and, thereafter, no more terminals are generated.",
        "We demand that U'ijmust not be the empty string, unless Ai = S and j = 0.",
        "The reason for this restriction is that we want to avoid an overlap with the second case.",
        "In this second case, we have for some j (1 < j < r):",
        "U ALÜH AeAeN+I Ae\\ÜE\\ Uij-1Aij Aij+1 Aij+2 Air",
        "Here the known prefix of the input ends within a sub-derivation involving Aij, and further to the right no more terminals are generated.",
        "Example 3 Consider the synchronous rule s :",
        "[A – aB bc Cm d,D – efE F ].",
        "The first component of a synchronous rule derived from this can be one of the following eight:",
        "The second component can be one of the following six:",
        "In total, the transformed grammar will contain 8 * 6 = 48 synchronous rules derived from s. □",
        "For each synchronous rule s, the above grammar transformation produces O(|s|) left rule components and as many right rule components.",
        "This means the number of new synchronous rules is O(|s|), and the size of each such rule is O(|s|).",
        "If we sum O(|s|) for every rule s we obtain a time and space complexity of O(|G|).",
        "We now investigate formal properties of our grammar transformation, in order to relate it to prefix probabilities.",
        "We define the relation h between P and Ppreflx such that s h s' if and only if s' was obtained from s by the transformation described above.",
        "This is extended in a natural way to derivations, such that sL • • • sd h si • • • s'di if and only if d = d' and si h si for each i (1 < i < d).",
        "The formal relation between G and Gprefix is revealed by the following two lemmas.",
        "Lemma 2 For each v1, v2 G £* and derivation a' G Pp*refix Such that [Si,S}] =G'preflx [v1,v2]>",
        "The only non-trivial issue in the proof of Lemma 1 is the uniqueness of a'.",
        "This follows from the observation that the length of vL in v1w1 uniquely determines how occurrences of left components of rules in P found in a are mapped to occurrences of left components of rules in Ppreflx found in a'.",
        "The same applies to the length of v2 in v2w2 and the right components.",
        "Lemma 2 is easy to prove as the structure of the transformation ensures that the terminals that are in rules from P but not in the corresponding rules from Ppreflx occur at the end of a string vL (and v2) to form the longer string v1w1 (and v2w2, respectively).",
        "The transformation also ensures that s h s' implies pg(s)",
        "= pGpreflx (s').",
        "Therefore a h a' implies",
        "pG(a) = pGpreflx(a').",
        "By this and Lemmas 1 and 2 we may conclude:",
        "Because of the introduction of rules with left-hand sides of the form Ae in both the left and right components of synchronous rules, it is not straightforward to do effective probabilistic parsing with the grammar gpreflx.",
        "We can however apply the transformations from section 3 to eliminate epsilon rules and thereafter eliminate unit rules, in a way that leaves the derived string pairs and their probabilities unchanged.",
        "The simplest case is when the source grammar g is reduced, proper and consistent, and has no epsilon rules.",
        "The only nullable pairs of nonterminals in gpreflx will then be of the form [Ai, A2].",
        "Consider such a pair [Al, A2].",
        "Because of reduction, properness and consistency of g we have:",
        "Because ofthe structure ofthe grammar transformation by which gpreflx was obtained from g, we also have:",
        "Y PGprefix (a) =",
        "a€P* s.t.",
        "Therefore pairs of occurrences of Ai and A2 with the same index in synchronous rules of Gprefixcan be systematically removed without affecting the probability of the resulting rule, as outlined in section 3.",
        "Thereafter, unit rules can be removed to allow parsing by the inside algorithm for PSCFGs.",
        "Following the computational analyses for all of the constructions presented in section 3, and for the grammar transformation discussed in this section, we can conclude that the running time of the proposed algorithm for the computation of prefix probabilities is dominated by the running time of the inside algorithm, which in the worst case is exponential in | G| .",
        "This result is not unexpected, as already pointed out in the introduction, since the recognition problem for PSCFGs is NP-complete, as established by Satta and Peserico (2005), and there is a straightforward reduction from the recognition problem for PSCFGs to the problem of computing the prefix probabilities for PSCFGs.",
        "One should add that, in real world machine translation applications, it has been observed that recognition (and computation of inside probabilities) for SCFGs can typically be carried out in low-degree polynomial time, and the worst cases mentioned above are not observed with real data.",
        "Further discussion on this issue is due to Zhang et al.",
        "(2006)."
      ]
    },
    {
      "heading": "5. Discussion",
      "text": [
        "We have shown that the computation of joint prefix probabilities for PSCFGs can be reduced to the computation of inside probabilities for the same model.",
        "Our reduction relies on a novel grammar transformation, followed by elimination of epsilon rules and unit rules.",
        "Next to the joint prefix probability, we can also consider the right prefix probability, which is defined by:",
        "In words, the entire left string is given, along with a prefix of the right string, and the task is to sum the probabilities of all string pairs for different suffixes following the given right prefix.",
        "This can be computed as a special case of the joint prefix probability.",
        "Concretely, one can extend the input and the grammar by introducing an end-of-sentence marker $.",
        "Let G' be the underlying SCFG grammar after the extension.",
        "Then:",
        "of the target translation.",
        "This can be computed as:",
        "r – prefix",
        "Prefix probabilities and right prefix probabilities for PSCFGs can be exploited to compute probability distributions for the next word or part-of-speech in left-to-right incremental translation of speech, or alternatively as a predictive tool in applications of interactive machine translation, of the kind described by Foster et al.",
        "(2002).",
        "We provide some technical details here, generalizing to PSCFGs the approach by Jelinek and Lafferty (1991).",
        "Let G = (G, pa) be a PSCFG, with E the alphabet of terminal symbols.",
        "We are interested in the probability that the next terminal in the target translation is a g E, after having processed a prefix v1 of the source sentence and having produced a prefix v2",
        "Two considerations are relevant when applying the above formula in practice.",
        "First, the computation of parefix([v1, v2a]) need not be computed from scratch if pGrefix([v1, v2]) has been computed already.",
        "Because of the tabular nature of the inside algorithm, one can extend the table for pGrefix([v1, v2]) by adding new entries to obtain the table for pGrefix([v1, v2a]).",
        "The same holds for the computation of pGrefix([v16, v2]).",
        "Secondly, the computation of pGrefix([v1, v2a]) for all possible a g E may be impractical.",
        "However, one may also compute the probability that the next part-of-speech in the target translation is A.",
        "This can be realised by adding a rule s' : [B – b, A – ca] for each rule s : [B – b, A – a] from the source grammar, where A is a nonterminal representing a part-of-speech and ca is a (pre-)terminal specific to A.",
        "The probability of s' is the same as that of s. If G' is the underlying SCFG after adding such rules, then the required value is pG/efix([v1, v2 ca]).",
        "One variant of the definitions presented in this paper is the notion of infix probability, which is useful in island-driven speech translation.",
        "Here we are interested in the probability that any string in the source language with infix v1 is translated into any string in the target language with infix v2.",
        "However, just as infix probabilities are difficult to compute for probabilistic context-free grammars (Corazza et al., 1991; Nederhof and Satta, 2008) so (joint) infix probabilities are difficult to compute for PSCFGs.",
        "The problem lies in the possibility that a given infix may occur more than once in a string in the language.",
        "The computation of infix probabilities can be reduced to that of solving non-linear systems of equations, which can be approximated using for instance Newton's algorithm.",
        "However, such a system of equations is built from the input strings, which entails that the computational effort of solving the system primarily affects parse time rather than parsergeneration time."
      ]
    }
  ]
}
