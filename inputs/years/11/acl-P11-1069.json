{
  "info": {
    "authors": [
      "Yue Zhang",
      "Stephen Clark"
    ],
    "book": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies",
    "id": "acl-P11-1069",
    "title": "Shift-Reduce CCG Parsing",
    "url": "https://aclweb.org/anthology/P11-1069",
    "year": 2011
  },
  "references": [
    "acl-C04-1010",
    "acl-C04-1180",
    "acl-D07-1013",
    "acl-D07-1123",
    "acl-D08-1059",
    "acl-D09-1043",
    "acl-D09-1085",
    "acl-D09-1127",
    "acl-E09-1069",
    "acl-J07-3004",
    "acl-J07-4004",
    "acl-N06-2033",
    "acl-N07-1051",
    "acl-P02-1035",
    "acl-P04-1015",
    "acl-P05-1011",
    "acl-P05-1012",
    "acl-P06-2089",
    "acl-P09-2014",
    "acl-P10-1035",
    "acl-W02-1001",
    "acl-W05-1513",
    "acl-W06-2933",
    "acl-W07-1217",
    "acl-W09-3825"
  ],
  "sections": [
    {
      "text": [
        "Yue Zhang Stephen Clark",
        "Computer Laboratory Computer Laboratory",
        "ccgs are directly compatible with binary-branching bottom-up parsing algorithms, in particular cky and shift-reduce algorithms.",
        "While the chart-based approach has been the dominant approach for ccg, the shift-reduce method has been little explored.",
        "In this paper, we develop a shift-reduce ccg parser using a discriminative model and beam search, and compare its strengths and weaknesses with the chart-based C&C parser.",
        "We study different errors made by the two parsers, and show that the shift-reduce parser gives competitive accuracies compared to C&C. Considering our use of a small beam, and given the high ambiguity levels in an automatically-extracted grammar and the amount of information in the ccg lexical categories which form the shift actions, this is a surprising result."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Combinatory Categorial Grammar (ccg; Steedman (2000)) is a lexicalised theory of grammar which has been successfully applied to a range of problems in n lp, including treebank creation (Hockenmaier and Steedman, 2007), syntactic parsing (Hockenmaier, 2003; Clark and Curran, 2007), logical form construction (Bos et al., 2004) and surface realization (White and Rajkumar, 2009).",
        "From a parsing perspective, the C&C parser (Clark and Curran, 2007) has been shown to be competitive with state-of-the-art statistical parsers on a variety of test suites, including those consisting of grammatical relations (Clark and Curran, 2007), Penn Treebank phrasestructure trees (Clark and Curran, 2009), and unbounded dependencies (Rimell et al., 2009).",
        "The binary branching nature of cc g means that it is naturally compatible with bottom-up parsing algorithms such as shift-reduce and cky (Ades and Steedman, 1982; Steedman, 2000).",
        "However, the parsing work by Clark and Curran (2007), and also Hockenmaier (2003) and Fowler and Penn (2010), has only considered chart-parsing.",
        "In this paper we fill a gap in the ccg literature by developing a shift-reduce parser for ccg.",
        "Shift-reduce parsers have become popular for dependency parsing, building on the initial work ofYa-mada and Matsumoto (2003) and Nivre and Scholz (2004).",
        "One advantage ofshift-reduce parsers is that the scoring model can be defined over actions, allowing highly efficient parsing by using a greedy algorithm in which the highest scoring action (or a small number of possible actions) is taken at each step.",
        "In addition, high accuracy can be maintained by using a model which utilises a rich set of features for making each local decision (Nivre et al., 2006).",
        "Following recent work applying global discriminative models to large-scale structured prediction problems (Collins and Roark, 2004; Miyao and Tsujii, 2005; Clark and Curran, 2007; Finkel et al., 2008), we build our shift-reduce parser using a global linear model, and compare it with the chart-based C&C parser.",
        "Using standard development and test sets from CCGbank, our shift-reduce parser gives a labeled F-measure of 85.53%, which is competitive with the 85.45% F-measure of the C&C parser on recovery ofpredicate-argument dependencies from CCGbank.",
        "Hence our work shows that transition-based parsing can be successfully applied to ccg, improving on earlier attempts such as Hassan et al.",
        "(2008).",
        "Detailed analysis shows that our shift-reduce parser yields a higher precision, lower recall and higher F-score on most of the common ccg dependency types compared to C&C.",
        "One advantage of the shift-reduce parser is that it easily handles sentences for which it is difficult to find a spanning analysis, which can happen with ccg because the lexical categories at the leaves of a derivation place strong contraints on the set of possible derivations, and the supertagger which provides the lexical categories sometimes makes mistakes.",
        "Unlike the C&C parser, the shift-reduce parser naturally produces fragmentary analyses when appropriate (Nivre et al., 2006), and can produce sensible local structures even when a full spanning analysis cannot be found.",
        "Finally, considering this work in the wider parsing context, it provides an interesting comparison between heuristic beam search using a rich set of features, and optimal dynamic programming search where the feature range is restricted.",
        "We are able to perform this comparison because the use of the ccg supertagger means that the C&C parser is able to build the complete chart, from which it can find the optimal derivation, with no pruning whatsoever at the parsing stage.",
        "In contrast, the shift-reduce parser uses a simple beam search with a relatively small beam.",
        "Perhaps surprisingly, given the ambiguity levels in an automatically-extracted grammar, and the amount of information in the ccg lexical categories which form the shift actions, the shift-reduce parser using heuristic beam search is able to outperform the chart-based parser."
      ]
    },
    {
      "heading": "2. CCG Parsing",
      "text": [
        "ccg, and the application of ccg to wide-coverage parsing, is described in detail elsewhere (Steedman, 2000; Hockenmaier, 2003; Clark and Curran, 2007).",
        "Here we provide only a short description.",
        "During ccg parsing, adjacent categories are combined using ccg's combinatory rules.",
        "For example, a verb phrase in English (S\\NP) can combine with",
        "'See e.g. Riezler et al.",
        "(2002) and Zhang et al.",
        "(2007) for chart-based parsers which can produce fragmentary analyses.",
        "an NP to its left using function application:",
        "Categories can also combine using function composition, allowing the combination of \"may\" ((S\\NP)/(S\\NP)) and \"like\" ((S\\NP)/NP) in coordination examples such as \"John may like but may detest Mary\":",
        "In addition to binary rules, such as function application and composition, there are also unary rules which operate on a single category in order to change its type.",
        "For example, forward type-raising can change a subject NP into a complex category looking to the right for a verb phrase: NP => S/(S\\NP)",
        "An example ccg derivation is given in Section 3.",
        "The resource used for building wide-coverage ccg parsers of English is CCGbank (Hockenmaier and Steedman, 2007), a version of the Perm Treebank in which each phrase-structure tree has been transformed into a normal-form CCG derivation.",
        "There are two ways to extract a grammar from this resource.",
        "One approach is to extract a lexicon, i.e. a mapping from words to sets of lexical categories, and then manually define the combinatory rule schémas, such as functional application and composition, which combine the categories together.",
        "The derivations in the treebank are then used to provide training data for the statistical disambiguation model.",
        "This is the method used in the C&C parser.",
        "The second approach is to read the complete grammar from the derivations, by extracting combinatory rule instances from the local trees consisting of a parent category and one or two child categories, and applying only those instances during parsing.",
        "(These rule instances also include rules to deal with punctuation and unary type-changing rules, in addition to instances of the combinatory rule schémas.)",
        "This is the method used by Hockenmaier (2003) and is the method we adopt in this paper.",
        "Fowler and Penn (2010) demonstrate that the second extraction method results in a context-free approximation to the grammar resulting from the first method, which has the potential to produce a mildly context sensitive grammar (given the existence of certain combinatory rules) (Weir, 1988).",
        "However, it is important to note that the advantages of ccg, in particular the tight relationship between syntax and semantic interpretation, are still maintained with the second approach, as Fowler and Penn (2010) argue."
      ]
    },
    {
      "heading": "3. The Shift-reduce CCG Parser",
      "text": [
        "Given an input sentence, our parser uses a stack of partial derivations, a queue of incoming words, and a series of actions – derived from the rule instances in CCGbank – to build a derivation tree.",
        "Following Clark and Curran (2007), we assume that each input word has been assigned a pos-tag (from the Penn Treebank tagset) and a set of ccg lexical categories.",
        "We use the same maximum entropy pos-tagger and supertagger as the C&C parser.",
        "The derivation tree can be transformed into ccg dependencies or grammatical relations by a post-processing step, which essentially runs the C&C parser deterministically over the derivation, interpreting the derivation and generating the required output.",
        "The configuration of the parser, at each step of the parsing process, is shown in part (a) of Figure 1, where the stack holds the partial derivation trees that have been built, and the queue contains the incoming words that have not been processed.",
        "In the figure, s ( H ) represents a category S on the stack with head word H, while Qi represents a word in the incoming queue.",
        "The set of action types used by the parser is as follows: {SHIFT, COMBINE, UNARY, FINISH}.",
        "Each action type represents a set of possible actions available to the parser at each step in the process.",
        "The SHIFT-X action pushes the next incoming word onto the stack, and assigns the lexical category X to the word (Figure 1(b)).",
        "The label X can be any lexical category from the set assigned to the word being shifted by the supertagger.",
        "Hence the shift action performs lexical category disambiguation.",
        "This is in contrast to a shift-reduce dependency parser in which a shift action typically just pushes a word onto the stack.",
        "The COMBINE-X action pops the top two nodes off the stack, and combines them into a new node, which is pushed back on the stack.",
        "The category of",
        "(a) the parser configuration (b) after a SHIFT action S2(vig S^wj (c) after a COMBINE action The stack The queue (d) after a UNARY action",
        "Figure 1 : The parser configuration and set of actions.",
        "the new node is X.",
        "A COMBINE action corresponds to a combinatory rule in the ccg grammar (or one of the additional punctuation or type-changing rules), which is applied to the categories of the top two nodes on the stack.",
        "The UNARY-X action pops the top of the stack, transforms it into a new node with category X, and pushes the new node onto the stack.",
        "A UNARY action corresponds to a unary type-changing or type-raising rule in the ccg grammar, which is applied to the category on top of the stack.",
        "The FINISH action terminates the parsing process; it can be applied when all input words have been shifted onto the stack.",
        "Note that the FINISH action can be applied when the stack contains more than one node, in which case the parser produces a set of partial derivation trees, each corresponding to a node on the stack.",
        "This sometimes happens when a full derivation tree cannot be built due to su-pertagging errors, and provides a graceful solution to the problem of producing high-quality fragmentary parses when necessary.",
        "IBM bought Lotus Action: SHIFT-NP NP bought Lotus Action: SHIFT-(S[dcl]\\NP)/NP NP^ttSIdClJNNPJ/NPJ^NP^ Action: COMBINE-S[dcl]\\NP (= forward application) ((SldClJNNPJ/NPJ^NP^ Action: COMBINE-S[dcl] (= backward application) Action: FINISH",
        "Figure 2 shows the shift-reduce parsing process for the example sentence \"IBM bought Lotus\".",
        "First the word \"IBM\" is shifted onto the stack as an NP; then \"bought\" is shifted as a transitive verb looking for its object NP on the right and subject NP on the left ((S[dcl]\\NP)/NP); and then \"Lotus\" is shifted as an NP.",
        "Then \"bought\" is combined with its object \"Lotus\" resulting in a verb phrase looking for its subject on the left (S[dcl]\\NP).",
        "Finally, the resulting verb phrase is combined with its subject, resulting in a declarative sentence (S[dcl]).",
        "A key difference with previous work on shift-reduce dependency (Nivre et al., 2006) and cfg (Sagae and Lavie, 2006b) parsing is that, for ccg, there are many more shift actions - a shift action for each word-lexical category pair.",
        "Given the amount of syntactic information in the lexical categories, the choice of correct category, from those supplied by the supertagger, is often a difficult one, and often a choice best left to the parsing model.",
        "The C&C parser solves this problem by building the complete packed chart consistent with the lexical categories supplied by the supertagger, leaving the selection of the lexical categories to the Viterbi algorithm.",
        "For the shift-reduce parser the choice is also left to the parsing model, but in contrast to C&C the correct lexical category could be lost at any point in the heuristic search process.",
        "Hence it is perhaps surprising that we are able to achieve a high parsing accuracy of 85.5%, given a relatively small beam size."
      ]
    },
    {
      "heading": "4. Decoding",
      "text": [
        "Greedy local search (Yamada and Matsumoto, 2003; Sagae and Lavie, 2005; Nivre and Scholz, 2004) has typically been used for decoding in shift-reduce parsers, while beam-search has recently been applied as an alternative to reduce error-propagation (Johansson and Nugues, 2007; Zhang and Clark, 2008; Zhang and Clark, 2009; Huang et al., 2009).",
        "Both greedy local search and beam-search have linear time complexity.",
        "We use beam-search in our ccg parser.",
        "To formulate the decoding algorithm, we define a candidate item as a tuple (S, Q, F), where S represents the stack with partial derivations that have been built, Q represents the queue of incoming words that have not been processed, and F is a boolean value that represents whether the candidate item has been finished.",
        "A candidate item is finished if and only if the FINISH action has been applied to it, and no more actions can be applied to a candidate item after it reaches the finished status.",
        "Given an input sentence, we define the start item as the unfinished item with an empty stack and the whole input sentence as the incoming words.",
        "A derivation is built from the start item by repeated applications of actions until the item is finished.",
        "To apply beam-search, an agenda is used to hold the A^-best partial (unfinished) candidate items at each parsing step.",
        "A separate candidate output is function DECODE(input, agenda, list, N, grammar, candidate .output):",
        "agenda, clear■() flge«^fl.insert(GETSTARTlTEM(/«/7wO) candidate.output = none while not agenda.empty\"(): /zsf.clear() for item in agenda:",
        "for action in grammar.geiActions(item): item' = item, apply(action) if item'.F == True:",
        "if candidate .output == none or item'.score > candidate.output.score: candidate.output = item'",
        "list.",
        "append(zYe»/ ) agenda.",
        "clear() agenda.insert(list.best(N))",
        "Figure 3 : The decoding algorithm; N is the agenda size used to record the current best finished item that has been found, since candidate items can be finished at different steps.",
        "Initially the agenda contains only the start item, and the candidate output is set to none.",
        "At each step during parsing, each candidate item from the agenda is extended in all possible ways by applying one action according to the grammar, and a number of new candidate items are generated.",
        "If a newly generated candidate is finished, it is compared with the current candidate output.",
        "If the candidate output is none or the score of the newly generated candidate is higher than the score of the candidate output, the candidate output is replaced with the newly generated item; otherwise the newly generated item is discarded.",
        "If the newly generated candidate is unfinished, it is appended to a list of newly generated partial candidates.",
        "After all candidate items from the agenda have been processed, the agenda is cleared and the A^-best items from the list are put on the agenda.",
        "Then the list is cleared and the parser moves on to the next step.",
        "This process repeats until the agenda is empty (which means that no new items have been generated in the previous step), and the candidate output is the final derivation.",
        "Pseudocode for the algorithm is shown in Figure 3.",
        "Table 1 : Feature templates."
      ]
    },
    {
      "heading": "5. Model and Training",
      "text": [
        "We use a global linear model to score candidate items, trained discriminatively with the averaged perceptron (Collins, 2002).",
        "Features for a (finished or partial) candidate are extracted from each action that have been applied to build the candidate.",
        "Following Collins and Roark (2004), we apply the \"early update\" strategy to perceptron training: at any step during decoding, if neither the candidate output nor any item in the agenda is correct, decoding is stopped and the parameters are updated using the current highest scored item in the agenda or the candidate output, whichever has the higher score.",
        "Table 1 shows the feature templates used by the parser.",
        "The symbols So, Si, S2 and S3 in the table represent the top four nodes on the stack (if existent), and Qo, Qi, q2 and q3 represent the front four words in the incoming queue (if existent).",
        "SoH and SiH represent the subnodes of So and Si that have the lexical head of So and Si, respectively.",
        "SoL represents the left subnode of So, when the lexical head is from the right subnode.",
        "SoR and SiR represent the right subnode of So and Si, respectively, when the lexical head is from the left subnode.",
        "If So is built by a UNARY action, SoU represents the only subnode of So.",
        "The symbols w, p and c represent the word, the pos, and the ccg category, respectively.",
        "feature templates",
        "1",
        "Sowp, Soc, Sopc, Sowc, Siwp, Sic, Sipe, Siwc, S2PC, S2WC, S3PC, S3WC,",
        "2",
        "Qowp, Qiwp, Q2WP, Q3wp,",
        "3",
        "SoLpc, SoLwc, SoRpc, SoRwc, SoUpc, SoUwc, SiLpc, SiLwc, SiRpc, SiRwc, SiUpc, SiUwc,",
        "4",
        "SowcSiwc, SocSiw, SowSic, SocSic, SowcQowp, SocQowp, S0wcQ0p, S0cQ0p, SiwcQowp, SicQowp, SiwcQop, SicQop,",
        "5",
        "SowcSicQop, SocSiwcQop, SocSicQowp,",
        "SocSicQop, SopSipQop,",
        "SowcQopQiP, SocQowpQip, S0cQ0pQiwp,",
        "SocQopQiP, SopQopQiP,",
        "S0WCS1CS2C, S0CS1WCS2C, S0CS1CS2WC,",
        "S0cSicS2c, S0pSipS2p,",
        "6",
        "SocSoHcSoLc, SocSoHcSoRc, SicSiHcSiRc, SocSoRcQop, SocSoRcQow, SocSoLcSiC, SocSoLcSiw, SocSicSiRc, SowSicSiRc.",
        "These rich feature templates produce a large number of features: 36 million after the first training iteration, compared to around 0.5 million in the C&C parser."
      ]
    },
    {
      "heading": "6. Experiments",
      "text": [
        "Our experiments were performed using CCGBank (Hockenmaier and Steedman, 2007), which was split into three subsets for training (Sections 02-21), development testing (Section 00) and the final test (Section 23).",
        "Extracted from the training data, the ccg grammar used by our parser consists of 3070 binary rule instances and 191 unary rule instances.",
        "We compute F-scores over labeled ccg dependencies and also lexical category accuracy, ccg dependencies are defined in terms of lexical categories, by numbering each argument slot in a complex category.",
        "For example, the first NP in a transitive verb category is a ccg dependency relation, corresponding to the subject of the verb.",
        "Clark and Curran (2007) gives a more precise definition.",
        "We use the generate script from the C&C tools to transform derivations into ccg dependencies.",
        "There is a mismatch between the grammar that generate uses, which is the same grammar as the C&C parser, and the grammar we extract from CCGbank, which contains more rule instances.",
        "Hence generate is unable to produce dependencies for some of the derivations our shift-reduce parser produces.",
        "In order to allow generate to process all derivations from the shift-reduce parser, we repeatedly removed rules that the generate script cannot handle from our grammar, until all derivations in the development data could be dealt with.",
        "In fact, this procedure potentially reduces the accuracy of the shift-reduce parser, but the effect is comparatively small because only about 4% of the development and test sentences contain rules that are not handled by the generate script.",
        "All experiments were performed using automatically assigned pos-tags, with 10-fold cross validation used to assign pos-tags and lexical categories to the training data.",
        "At the supertagging stage, multiple lexical categories are assigned to each word in the input.",
        "For each word, the supertagger assigns all lexical categories whose forward-backward probability is above ß ■ max, where maxis the highest lexical category probability for the word, and ß is a threshold parameter.",
        "To give the parser a reasonable freedom in lexical category disambiguation, we used a small ß value of 0.0001, which results in 3.6 lexical categories being assigned to each word on average in the training data.",
        "For training, but not testing, we also added the correct lexical category to the list of lexical categories for a word in cases when it was not provided by the supertagger.",
        "Increasing the size of the beam in the parser beam search leads to higher accuracies but slower running time.",
        "In our development experiments, the accuracy improvement became small when the beam size reached 16, and so we set the size of the beam to 16 for the remainder of the experiments.",
        "Table 2 shows the labeled precision (lp), recall (lr), F-score (If), sentence-level accuracy (lsent) and lexical category accuracy (cats) of our parser and the C&C parser on the development data.",
        "We ran the C&C parser using the normal-form model (we reproduced the numbers reported in Clark and Curran (2007)), and copied the results of the hybrid model from Clark and Curran (2007), since the hybrid model is not part of the public release.",
        "The accuracy of our parser is much better when evaluated on all sentences, partly because C&C failed on 0.94% of the data due to the failure to produce a spanning analysis.",
        "Our shift-reduce parser does not suffer from this problem because it produces fragmentary analyses for those cases.",
        "When evaluated on only those sentences that C&C could analyze, our parser gave 0.29% higher F-score.",
        "Our shift-reduce parser also gave higher accuracies on lexical category assignment.",
        "The sentence accuracy of our shift-reduce parser is also higher than C&C, which confirms that our shift-reduce parser produces reasonable sentence-level analyses, despite the possibility for fragmentary analysis.",
        "Our shift-reduce parser and the chart-based C&C parser offer two different solutions to the ccg parsing problem.",
        "The comparison reported in this section is similar to the comparison between the chart-based MSTParser (McDonald et al., 2005) and shift-reduce MaltParser (Nivre et al., 2006) for dependency parsing.",
        "We follow McDonald and Nivre (2007) and characterize the errors of the two parsers by sentence and dependency length and dependency type.",
        "We measured precision, recall and F-score relative to different sentence lengths.",
        "Both parsers performed better on shorter sentences, as expected.",
        "Our shift-reduce parser performed consistently better than C&C on all sentence lengths, and there was no significant difference in the rate of performance degradation between the parsers as the sentence length increased.",
        "Figure 4 shows the comparison of labeled precision and recall relative to the dependency length (i.e. the number of words between the head and dependent), in bins of size 5 (e.g. the point at x=5 shows the precision or recall for dependency lengths 1 - 5).",
        "This experiment was performed using the normalform version of the C&C parser, and the evaluation was on the sentences for which C&C gave an analysis.",
        "The number of dependencies drops when the dependency length increases; there are 141, 180 and 124 dependencies from the gold-standard, C&C output and our shift-reduce parser output, respectively, when the dependency length is between 21 and 25, inclusive.",
        "The numbers drop to 47, 56 and 36 when the dependency length is between 26 and 30.",
        "The recall of our parser drops more quickly as the dependency length grows beyond 15.",
        "A likely reason is that the recovery oflonger-range dependencies requires more processing steps, increasing the chance of the correct structure being thrown off the beam.",
        "In contrast, the precision did not drop more quickly than C&C, and in fact is consistently higher than C&C across all dependency lengths, which reflects the fact that the long range dependencies our parser managed to recover are comparatively reliable.",
        "Table 3 shows the comparison oflabeled precision (lp), recall (lr) and F-score (lf) for the most common ccg dependency types.",
        "The numbers for C&C are for the hybrid model, copied from Clark and Curran (2007).",
        "While our shift-reduce parser gave higher precision for almost all categories, it gave higher recall on only half of them, but higher F-scores for all but one dependency type.",
        "Table 4 shows the accuracies on the test data.",
        "The numbers for the normal-form model are evaluated by running the publicly available parser, while those for the hybrid dependency model are from Clark and Curran (2007).",
        "Evaluated on all sentences, the accuracies of our parser are much higher than the C&C parser, since the C&C parser failed to produce any output for 10 sentences.",
        "When evaluating both",
        "lp.",
        "lr.",
        "If.",
        "lsent.",
        "cats.",
        "evaluated on",
        "shift-reduce",
        "C&C (normal-form)",
        "87.15% 85.22%",
        "82.95% 82.52%",
        "85.00% 83.85%",
        "33.82% 31.63%",
        "92.77% 92.40%",
        "all sentences all sentences",
        "shift-reduce C&C (hybrid) C&C (normal-form)",
        "87.55% 85.22%",
        "83.63% 84.29%",
        "85.54% 85.25% 84.76%",
        "34.14% 31.93%",
        "93.11% 92.83%",
        "99.06% (C&C coverage) 99.06% (C&C coverage) 99.06% (C&C coverage)",
        "Table 3 : Accuracy comparison on the most common ccg dependency types, (o) - our parser; (C) - C&C (hybrid) parsers on the sentences for which C&C produces an analysis, our parser still gave the highest accuracies.",
        "The shift-reduce parser gave higher precision, and lower recall, than C&C; it also gave higher sentence-level and lexical category accuracy.",
        "The last two rows in the table show the accuracies of Fowler and Penn (2010) (F&P), who applied the cfg parser of Petrov and Klein (2007) to ccg, and the corresponding accuracies for the C&C parser on the same test sentences.",
        "F&P can be treated as another chart-based parser; their evaluation is based on the sentences for which both their parser and C&C produced dependencies (or more specifically those sentences for which generate could produce dependencies), and is not directly comparable with ours, especially considering that their test set is smaller and potentially slightly easier.",
        "The final comparison is parser speed.",
        "The shift-reduce parser is linear-time (in both sentence length and beam size), and can analyse over 10 sentences per second on a 2GHz CPU, with a beam of 16, which compares very well with other constituency parsers.",
        "However, this is no faster than the chartbased C&C parser, although speed comparisons are difficult because of implementation differences (C&C uses heavily engineered C++ with a focus on efficiency)."
      ]
    },
    {
      "heading": "7. Related Work",
      "text": [
        "Sagae and Lavie (2006a) describes a shift-reduce parser for the Penn Treebank parsing task which uses best-first search to allow some ambiguity into the parsing process.",
        "Differences with our approach are that we use a beam, rather than best-first, search; we use a global model rather than local models chained together; and finally, our results surpass the best published results on the ccg parsing task, whereas Sagae and Lavie (2006a) matched the best ptb results only by using a parser combination.",
        "Matsuzaki et al.",
        "(2007) describes similar work to ours but using an automatically-extracted hpsg, rather than ccg, grammar.",
        "They also use the generalised perceptron to train a disambiguation model.",
        "One difference is that Matsuzaki et al.",
        "(2007) use an approximating cfg, in addition to the supertagger, to improve the efficiency of the parser.",
        "category",
        "arg",
        "lp.",
        "(o)",
        "lp.",
        "(C)",
        "lr.",
        "(o)",
        "lr.",
        "(C)",
        "If.",
        "(o)",
        "If (C)",
        "fireq.",
        "N/N",
        "1",
        "95.77%",
        "95.28%",
        "95.79%",
        "95.62%",
        "95.78%",
        "95.45%",
        "7288",
        "NP/N",
        "1",
        "96.70%",
        "96.57%",
        "96.59%",
        "96.03%",
        "96.65%",
        "96.30%",
        "4101",
        "(NP\\NP)/NP",
        "2",
        "83.19%",
        "82.17%",
        "89.24%",
        "88.90%",
        "86.11%",
        "85.40%",
        "2379",
        "(NP\\NP)/NP",
        "1",
        "82.53%",
        "81.58%",
        "87.99%",
        "85.74%",
        "85.17%",
        "83.61%",
        "2174",
        "((S\\NP)\\(S\\NP))/NP",
        "3",
        "77.60%",
        "71.94%",
        "71.58%",
        "73.32%",
        "74.47%",
        "72.63%",
        "1147",
        "((S\\NP)\\(S\\NP))/NP",
        "2",
        "76.30%",
        "70.92%",
        "70.60%",
        "71.93%",
        "73.34%",
        "71.42%",
        "1058",
        "((S[dcl]\\NP)/NP",
        "2",
        "85.60%",
        "81.57%",
        "84.30%",
        "86.37%",
        "84.95%",
        "83.90%",
        "917",
        "PP/NP",
        "1",
        "73.76%",
        "75.06%",
        "72.83%",
        "70.09%",
        "73.29%",
        "72.49%",
        "876",
        "((S[dcl]\\NP)/NP",
        "1",
        "85.32%",
        "81.62%",
        "82.00%",
        "85.55%",
        "83.63%",
        "83.54%",
        "872",
        "((S\\NP)\\(S\\NP))",
        "2",
        "84.44%",
        "86.85%",
        "86.60%",
        "86.73%",
        "85.51%",
        "86.79%",
        "746",
        "lp.",
        "lr.",
        "If.",
        "lsent.",
        "cats.",
        "evaluated",
        "shift-reduce",
        "C&C (normal-form)",
        "87.43% 85.58%",
        "83.61% 82.85%",
        "85.48% 84.20%",
        "35.19% 32.90%",
        "93.12% 92.84%",
        "all sentences all sentences",
        "shift-reduce C&C (hybrid) C&C (normal-form)",
        "87.43% 86.17% 85.48%",
        "83.71% 84.74% 84.60%",
        "85.53% 85.45% 85.04%",
        "35.34% 32.92% 33.08%",
        "93.15% 92.98% 92.86%",
        "99.58% (C&C coverage) 99.58% (C&C coverage) 99.58% (C&C coverage)",
        "F&P (Petrov 1-5)* C&C hybrid*",
        "86.29% 86.46%",
        "85.73% 85.11%",
        "86.01% 85.78%",
        " – ",
        " – ",
        " – (F&P n C&C coverage; 96.65% on dev.",
        "test)",
        " – (F&P n C&C coverage; 96.65% on dev.",
        "test)",
        "Ninomiya et al.",
        "(2009) (and Ninomiya et al.",
        "(2010)) describe a greedy shift-reduce parser for hpsg, in which a single action is chosen at each parsing step, allowing the possibility of highly efficient parsing.",
        "Since the hpsg grammar has relatively tight constraints, similar to ccg, the possibility arises that a spanning analysis cannot be found for some sentences.",
        "Our approach to this problem was to allow the parser to return a fragmentary analysis; Ninomiya et al.",
        "(2009) adopt a different approach based on default unification.",
        "Finally, our work is similar to the comparison of the chart-based MSTParser (McDonald et al., 2005) and shift-reduce MaltParser (Nivre et al., 2006) for dependency parsing.",
        "MSTParser can perform exhaustive search, given certain feature restrictions, because the complexity of the parsing task is lower than for constituent parsing.",
        "C&C can perform exhaustive search because the supertagger has already reduced the search space.",
        "We also found that approximate heuristic search for shift-reduce parsing, utilising a rich feature space, can match the performance of the optimal chart-based parser, as well as similar error profiles for the two ccg parsers compared to the two dependency parsers."
      ]
    },
    {
      "heading": "8. Conclusion",
      "text": [
        "This is the first work to present competitive results for ccg using a transition-based parser, filling a gap in the ccg parsing literature.",
        "Considered in terms of the wider parsing problem, we have shown that state-of-the-art parsing results can be obtained using a global discriminative model, one of the few papers to do so without using a generative baseline as a feature.",
        "The comparison with C&C also allowed us to compare a shift-reduce parser based on heuristic beam search utilising a rich feature set with an optimal chart-based parser whose features are restricted by dynamic programming, with favourable results for the shift-reduce parser.",
        "The complementary errors made by the chart-based and shift-reduce parsers opens the possibility of effective parser combination, following similar work for dependency parsing.",
        "The parser code can be downloaded at",
        "http://www.sourceforge.net/projects/zpar, version 0.5."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "We thank the anonymous reviewers for their suggestions.",
        "Yue Zhang and Stephen Clark are supported by the European Union Seventh Framework Programme (FP7-ICT-2009-4) under grant agreement no.",
        "247762."
      ]
    }
  ]
}
