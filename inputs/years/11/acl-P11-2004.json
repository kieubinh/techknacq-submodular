{
  "info": {
    "authors": [
      "Benjamin van Durme",
      "Ashwin Lall"
    ],
    "book": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies",
    "id": "acl-P11-2004",
    "title": "Efficient Online Locality Sensitive Hashing via Reservoir Counting",
    "url": "https://aclweb.org/anthology/P11-2004",
    "year": 2011
  },
  "references": [
    "acl-D09-1098",
    "acl-N10-1021",
    "acl-P05-1077",
    "acl-P08-1077",
    "acl-P10-2043",
    "acl-W10-2808"
  ],
  "sections": [
    {
      "text": [
        "Benjamin Van Durme Ashwin Lall",
        "Johns Hopkins University Denison University",
        "We describe a novel mechanism called Reservoir Counting for application in online Locality Sensitive Hashing.",
        "This technique allows for significant savings in the streaming setting, allowing for maintaining a larger number of signatures, or an increased level of approximation accuracy at a similar memory footprint."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Feature vectors based on lexical co-occurrence are often of a high dimension, d. This leads to O(d) operations to calculate cosine similarity, a fundamental tool in distributional semantics.",
        "This is improved in practice through the use of data structures that exploit feature sparsity, leading to an expected O(f) operations, where f is the number of unique features we expect to have non-zero entries in a given vector.",
        "Ravichandran et al.",
        "(2005) showed that the Locality Sensitive Hash (LSH) procedure of Charikar (2002), following from Indyk and Motwani (1998) and Goemans and Williamson (1995), could be successfully used to compress textually derived feature vectors in order to achieve speed efficiencies in large-scale noun clustering.",
        "Such LSH bit signatures are constructed using the following hash function, where v G Rd is a vector in the original feature space, and r is randomly drawn from N(0,1)d:",
        "1 if v • r > 0, 0 otherwise.",
        "If is the 6-bit signature resulting from b such hash functions, then the cosine similarity between vectors U and v is approximated by:",
        "cos(u, v) = ^ « cosr*(TW' * n), where £)(•, •) is Hamming distance, the number of bits that disagree.",
        "This technique is used when b <C d, which leads to faster pairwise comparisons between vectors, and a lower memory footprint.",
        "Van Durme and Lall (2010) observed that if the feature values are additive over a dataset (e.g., when collecting word co-occurrence frequencies), then these signatures may be constructed online by unrolling the dot-product into a series of local operations: v • ri = £tvt • ri, where vt represents features observed locally at time t in a data-stream.",
        "Since updates may be done locally, feature vectors do not need to be stored explicitly.",
        "This directly leads to significant space savings, as only one counter is needed for each of the b running sums.",
        "In this work we focus on the following observation: the counters used to store the running sums may themselves be an inefficient use of space, in that they may be amenable to compression through approximation.",
        "Since the accuracy of this LSH routine is a function of b, then if we were able to reduce the online requirements of each counter, we might afford a larger number of projections.",
        "Even if a chance of approximation error were introduced for each hash function, this may be justified in greater overall fidelity from the resultant increase in b.",
        "!A related point was made by Li et al.",
        "(2008) when discussing stable random projections.",
        "Thus, we propose to approximate the online hash function, using a novel technique we call Reservoir Counting, in order to create a space trade-off between the number of projections and the amount of memory each projection requires.",
        "We show experimentally that this leads to greater accuracy approximations at the same memory cost, or similar accuracy approximations at a significantly reduced cost.",
        "This result is relevant to work in large-scale distributional semantics (Bhagat and Ravichandran, 2008; et al., 2010; Goyal et al., 2010; Bergsma and Van Durme, 2011), as well as large-scale processing of social media (Petrovic et al., 2010)."
      ]
    },
    {
      "heading": "2. Approach",
      "text": [
        "While not strictly required, we assume here to be dealing exclusively with integer-valued features.",
        "We then employ an integer-valued projection matrix in order to work with an integer-valued stream of online updates, which is reduced (implicitly) to a stream of positive and negative unit updates.",
        "The sign of the sum of these updates is approximated through a novel twist on Reservoir Sampling.",
        "When computed explicitly this leads to an impractical mechanism linear in each feature value update.",
        "To ensure our counter can (approximately) add and subtract in constant time, we then derive expressions for the expected value of each step of the update.",
        "The full algorithms are provided at the close.",
        "Unit Projection Rather than construct a projection matrix from N(0,1), a matrix randomly populated with entries from the set { – 1, 0,1} will suffice, with quality dependent on the relative proportion of these elements.",
        "If we let p be the percent probability mass allocated to zeros, then we create a discrete projection matrix by sampling from the multinomial: (1- : – 1,p : 0,1- : +1).",
        "An experiment displaying the resultant quality is displayed in Fig. 1, for varied p. Henceforth we assume this discrete projection matrix, with p = 0.5.",
        "The use of such sparse projections was first proposed by Achlioptas (2003), then extended by Li et al.",
        "(2006).",
        "(2010), this equates to a pool of the form: (-1,0,0,1).",
        "Figure 1: With b = 256, mean absolute error in cosine approximation when using a projection based on N(0,1), compared to { – 1,0,1}.",
        "Unit Stream Based on a unit projection, we can view an online counter as summing over a stream drawn from { – 1,1}: each projected feature value unrolled into its (positive or negative) unary representation.",
        "For example, the stream: (3,-2,1), can be viewed as the updates: (1,1,1,-1,-1,1).",
        "Reservoir Sampling We can maintain a uniform sample of size k over a stream of unknown length as follows.",
        "Accept the first k elements into an reservoir (array) of size k. Each following element at position n is accepted with probability n, whereupon an element currently in the reservoir is evicted, and replaced with the just accepted item.",
        "This scheme is guaranteed to provide a uniform sample, where early items are more likely to be accepted, but also at greater risk of eviction.",
        "Reservoir sampling is a folklore algorithm that was extended by Vitter (1985) to allow for multiple updates.",
        "Reservoir Counting If we are sampling over a stream drawn from just two values, we can implicitly represent the reservoir by counting only the frequency of one or the other elements.",
        "We can therefore sample the proportion of positive and negative unit values by tracking the current position in the stream, n, and keeping a log2(k + 1)-bit integer counter, s, for tracking the number of 1 values currently in the reservoir.",
        "When a negative value is accepted, we decrement the counter with probability s. When a positive update is accepted, we increment the counter with probability (1 – | ).",
        "This reflects an update evicting either an element of the same sign, which has no effect on the makeup of the reservoir, or decreasing/increasing the number of 1's currently sampled.",
        "An approximate sum of all values seen up to position n is then simply: n( \"jr – 1).",
        "While this value is potentially interesting in future applications, here we are only concerned with its sign.",
        "Metho",
        "nO",
        "screte rmal",
        ")",
        "J",
        "Parallel Reservoir Counting On its own this counting mechanism hardly appears useful: as it is dependent on knowing n, then we might just as well sum the elements of the stream directly, counting in whatever space we would otherwise use in maintaining the value of n. However, if we have a set of tied streams that we process in parallel, then we only need to track n once, across b different streams, each with their own reservoir.",
        "When dealing with parallel streams resulting from different random projections of the same vector, we cannot assume these will be strictly tied.",
        "Some projections will cancel out heavier elements than others, leading to update streams of different lengths once elements are unrolled into their (positive or negative) unary representation.",
        "In practice we have found that tracking the mean value of n across b streams is sufficient.",
        "When using a p = 0.5 zeroed matrix, we can update n by one half the magnitude of each observed value, as on average half the projections will cancel out any given element.",
        "This step can be found in Algorithm 2, lines 8 and 9.",
        "Example To make concrete what we have covered to this point, consider a given feature vector of dimensionality d = 3, say: [3,2,1].",
        "This might be projected into b = 4, vectors: [3,0,0], [0,-2,1], [0,0,1], and [-3,2,0].",
        "When viewed as positive/negative, loosely-tied unit streams, they respectively have length n: 3, 3, 1, and 5, with mean length 3.",
        "The goal of reservoir counting is to efficiently keep track of an approximation of their sums (here: 3, -1, 1, and -1), while the underlying feature vector is being updated online.",
        "A k = 3 reservoir used for the last projected vector, [-3, 2, 0], might reasonably contain two values of -1, and one value of 1.",
        "Represented explicitly as a vector, the reservoir would thus be in the arrangement:",
        "[1,-1,-1], [-1,1,-1], or [-1,-1,1].",
        "These are functionally equivalent: we only need to know that one of the k = 3 elements is positive.",
        "Expected Number of Samples Traversing m consecutive values of either 1 or – 1 in the unit stream should be thought of as seeing positive or negative m as a feature update.",
        "For a reservoir of size k, let A(m, n, k) be the number of samples accepted when traversing the stream from position n + 1 to n + m. A is non-deterministic: it represents the results of flipping m consecutive coins, where each coin is increasingly biased towards rejection.",
        "Rather than computing A explicitly, which is linear in m, we will instead use the expected number of updates, A'(m,n,k) = E[A(m,n, k)], which can be computed in constant time.",
        "Where H(x) is the harmonic number of x: « k loge( n ).",
        "For example, consider m = 30, encountered at position n = 100, with a reservoir of k = 10.",
        "We will then accept 10 loge(^) « 3.79 samples of 1.",
        "As the reservoir is a discrete set ofbins, fractional portions of a sample are resolved by a coin flip: if a = k loge(n+nm), then accept u = \\a] samples with probability (a – |_aj), and u = |_aj samples otherwise.",
        "These steps are found in lines 3 and 4 of Algorithm 1.",
        "See Table 1 for simulation results using a variety of parameters.",
        "k",
        "n",
        "m",
        "mean(A)",
        "mean(A')",
        "10",
        "20",
        "10",
        "3.80",
        "4.02",
        "10",
        "20",
        "1000",
        "37.96",
        "39.31",
        "50",
        "150",
        "1000",
        "101.30",
        "101.83",
        "100",
        "1100",
        "100",
        "8.88",
        "8.72",
        "100",
        "10100",
        "10",
        "0.13",
        "0.10",
        "Expected Reservoir Change We now discuss how to simulate many independent updates of the same type to the reservoir counter, e.g.: five updates of 1, or three updates of -1, using a single estimate.",
        "Consider a situation in which we have a reservoir of size k with some current value of s, 0 < s < k, and we wish to perform u independent updates.",
        "We denote by U'k(s,u) the expected value of the reservoir after these u updates have taken place.",
        "Since a single update leads to no change with probability |, we can write the following recurrence for U'k :",
        "with the boundary condition: for all s, Uk(s, 0) = s.",
        "Solving the above recurrence, we get that the expected value of the reservoir after these updates is:",
        "which can be mechanically checked via induction.",
        "The case for negative updates follows similarly (see lines 7 and 8 of Algorithm 1).",
        "Hence, instead of simulating u independent updates of the same type to the reservoir, we simply update it to this expected value, where fractional updates are handled similarly as when estimating the number of accepts.",
        "These steps are found in lines 5 through 9 of Algorithm 1, and as seen in Fig. 2, this can give a tight estimate.",
        "Comparison Simulation results over Zipfian distributed data can be seen in Fig. 3, which shows the use of reservoir counting in Online Locality Sensitive Hashing (as made explicit in Algorithm 2), as compared to the method described by Van Durme and Lall (2010).",
        "The total amount of space required when using this counting scheme is b log2(k + 1) + 32: b reservoirs, and a 32 bit integer to track n. This is compared to b 32 bit floating point values, as is standard.",
        "Note that our scheme comes away with similar levels of accuracy, often at half the memory cost, while requiring larger b to account for the chance of approximation errors in individual reservoir counters.",
        "Parameters:",
        "n : size of stream so far k : size of reservoir, also maximum value of s m : magnitude of update a : sign of update s : current value of reservoir 2: Return without doing anything 9: Return [s'] with probability s' – |_s'j, |_s'j otherwise",
        "Figure 3: Online LSH using reservoir counting (red) vs. standard counting mechanisms (blue), as measured by the amount of total memory required to the resultant error.",
        "Expected",
        "•",
        "log2.k",
        "I",
        "•",
        "•",
        "• •",
        "8 32",
        "b •",
        "64",
        "\\",
        "V",
        "■",
        "+",
        "92 56",
        "\\",
        "•",
        "•",
        "•",
        "Algorithm 2 ComputeSignature(S,k,b,p) Parameters:",
        "S : bit array of size b k : size of each reservoir b : number of projections p : percentage of zeros in projection, p G [0,1]",
        "1: Initialize b reservoirs ..., b], each represented by a log2 (k + 1) bit unsigned integer",
        "2: Initialize b hash functions fcj(w) that map features w to elements in a vector made up of – 1 and 1 each with proportion , and 0 at proportion p.",
        "4: {Processing the stream} 5: for each feature value pair ( w, m) in stream do"
      ]
    },
    {
      "heading": "3. Discussion",
      "text": [
        "Time and Space While we have provided a constant time, approximate update mechanism, the constants involved will practically remain larger than the cost of performing single hardware addition or subtraction operations on a traditional 32-bit counter.",
        "This leads to a tradeoff in space vs. time, where a high-throughput streaming application that is not concerned with online memory requirements will not have reason to consider the developments in this article.",
        "The approach given here is motivated by cases where data is not flooding in at breakneck speed, and resource considerations are dominated by a large number of unique elements for which we are maintaining signatures.",
        "Empirically investigating this tradeoff is a matter of future work.",
        "Random Walks As we here only care for the sign of the online sum, rather than an approximation of its actual value, then it is reasonable to consider instead modeling the problem directly as a random walk on a linear Markov chain, with unit updates directly corresponding to forward or backward state",
        "Figure 4: A simple 8-state Markov chain, requiring lg(8) = 3 bits.",
        "Dark or light states correspond to a prediction of a running sum being positive or negative.",
        "States are numerically labeled to reflect the similarity to a small bit integer data type, one that never overflows.",
        "transitions.",
        "Assuming a fixed probability of a positive versus negative update, then in expectation the state of the chain should correspond to the sign.",
        "However if we are concerned with the global statistic, as we are here, then the assumption of a fixed probability update precludes the analysis of streaming sources that contain local irregularities.",
        "In distributional semantics, consider a feature stream formed by sequentially reading the n-gram resource of Brants and Franz (2006).",
        "The pair: (the dog : 3,502,485), can be viewed as a feature value pair: (leftWord='the' : 3,502,485), with respect to online signature generation for the word dog.",
        "Rather than viewing this feature repeatedly, spread over a large corpus, the update happens just once, with large magnitude.",
        "A simple chain such as seen in Fig. 4 will be \"pushed\" completely to the right or the left, based on the polarity of the projection, irrespective of previously observed updates.",
        "Reservoir Counting, representing an online uniform sample, is agnostic to the ordering of elements in the stream."
      ]
    },
    {
      "heading": "4. Conclusion",
      "text": [
        "We have presented a novel approximation scheme we call Reservoir Counting, motivated here by a desire for greater space efficiency in Online Locality Sensitive Hashing.",
        "Going beyond our results provided for synthetic data, future work will explore applications of this technique, such as in experiments with streaming social media like Twitter."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "This work benefited from conversations with Daniel Stefonkovic and Damianos Karakos.",
        "locally negative at the end."
      ]
    }
  ]
}
