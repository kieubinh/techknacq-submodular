{
  "info": {
    "authors": [
      "Michael John Collins",
      "Alexander M. Rush"
    ],
    "book": "Tutorial Abstracts of ACL 2011",
    "id": "acl-P11-5006",
    "title": "Dual Decomposition for Natural Language Processing",
    "url": "https://aclweb.org/anthology/P11-5006",
    "year": 2011
  },
  "references": [],
  "sections": [
    {
      "heading": "Dual Decomposition",
      "text": [
        "for Natural Language Processing Alexander M. Rush and Michael Collins Decoding complexity focus: decoding problem for natural language tasks",
        "motivation: ?",
        "richer model structure often leads to improved accuracy ?",
        "exact decoding for complex models tends to be intractable Decoding tasks many common problems are intractable to decode exactly high complexity",
        "?",
        "combined parsing and part-of-speech tagging (Rush et al., 2010) ?",
        "?loopy?",
        "HMM part-of-speech tagging ?",
        "syntactic machine translation (Rush and Collins, 2011) NP-Hard ?",
        "symmetric HMM alignment (DeNero and Macherey, 2011) ?",
        "phrase-based translation",
        "?",
        "higher-order non-projective dependency parsing (Koo et al., 2010) in practice: ?",
        "approximate decoding methods (coarse-to-fine, beam search, cube pruning, gibbs sampling, belief propagation) ?",
        "approximate models (mean field, variational models) Motivation cannot hope to find exact algorithms (particularly when NP-Hard) aim: develop decoding algorithms with formal guarantees method: ?",
        "derive fast algorithms that provide certificates of optimality ?",
        "show that for practical instances, these algorithms often yield exact solutions ?",
        "provide strategies for improving solutions or finding approximate solutions when no certificate is found dual decomposition helps us develop algorithms of this form Dual Decomposition (Komodakis et al., 2010; Lemare?chal, 2001) goal: solve complicated optimization problem",
        "method: decompose into subproblems, solve iteratively benefit: can choose decomposition to provide ?easy?",
        "subproblems aim for simple and efficient combinatorial algorithms",
        "?",
        "dynamic programming ?",
        "minimum spanning tree ?",
        "shortest path ?",
        "min-cut ?",
        "bipartite match ?",
        "etc.",
        "Related work there are related methods used NLP with similar motivation related methods: ?",
        "belief propagation (particularly max-product) (Smith and Eisner, 2008) ?",
        "factored A* search (Klein and Manning, 2003) ?",
        "exact coarse-to-fine (Raphael, 2001) aim to find exact solutions without exploring the full search space Tutorial outline focus: ?",
        "developing dual decomposition algorithms for new NLP tasks ?",
        "understanding formal guarantees of the algorithms ?",
        "extensions to improve exactness and select solutions outline: 1. worked algorithm for combined parsing and tagging 2. important theorems and formal derivation 3. more examples from parsing, sequence labeling, MT 4. practical considerations for implementing dual decomposition 5. relationship to linear programming relaxations 6. further variations and advanced examples 1.",
        "Worked example aim: walk through a dual decomposition algorithm for combined parsing and part-of-speech tagging ?",
        "introduce formal notation for parsing and tagging ?",
        "give assumptions necessary for decoding ?",
        "step through a run of the dual decomposition algorithm",
        "example: an HMM for part-of speech tagging United1 flies2 some3 large4 jet5 N V D A N Identifying tags notation: identify the tag labels selected by each model",
        "?",
        "y(i , t) = 1 when parse y selects tag t at position i ?",
        "z(i , t) = 1 when tag sequence z selects tag t at position i example: a parse and tagging with y(4,A) = 1 and z(4,A) = 1",
        "such that for all i = 1 .",
        ".",
        ".",
        "n, t ?",
        "T , y(i , t) = z(i , t) i.e. find the best parse and tagging pair that agree on tag labels equivalent formulation: arg max",
        "where l : Y ?",
        "Z extracts the tag sequence from a parse tree Dynamic programming intersection can solve by solving the product of the two models example: ?",
        "parsing model is a context-free grammar ?",
        "tagging model is a first-order HMM ?",
        "can solve as CFG and finite-state automata intersection",
        "u(i , t)y(i , t) generally benign since u can be incorporated into the structure of f example: CFG with rule scoring function h"
      ]
    },
    {
      "heading": "Tagging assumption",
      "text": [
        "we make a similar assumption for the set Z assumption: optimization with u can be solved efficiently arg max",
        "u(i , t)z(i , t) example: HMM with scores for transitions T and observations O",
        "(k), z(k)) is the global optimum proof: focus of the next section"
      ]
    },
    {
      "heading": "2. Formal properties",
      "text": [
        "aim: formal derivation of the algorithm given in the previous section ?",
        "derive Lagrangian dual ?",
        "prove three properties",
        "theorem: for any value of u L(u) ?",
        "f (y?)",
        "+ g(z?)",
        "L(u) provides an upper bound on the score of the optimal solution note: upper bound may be useful as input to branch and bound or A* search Theorem 1.",
        "Upper bound (proof) theorem: for any value of u, L(u) ?",
        "f (y?)",
        "+ g(z?)",
        "proof:",
        "notation: ?",
        "u (k+1) (i , t)?",
        "u(k)(i , t) + ?k(y (k) (i , t)?",
        "z(k)(i , t)) is update ?",
        "u (k) is the penalty vector at iteration k ?",
        "?k is the update rate at iteration k theorem: for any sequence ?1, ?2, ?3, .",
        ".",
        ".",
        "such that",
        "i.e. the algorithm converges to the tightest possible upper bound proof: by subgradient convergence (next section) Dual solutions define: ?",
        "for any value of u",
        "for all i , t then",
        "proof: by the definitions of yu and zu",
        "goal: dual problem is to find the tightest upper bound",
        "subgradient descent: move along the subgradient",
        "guaranteed to find a minimum with conditions given earlier for ?",
        "3.",
        "More examples aim: demonstrate similar algorithms that can be applied to other decoding applications ?",
        "context-free parsing combined with dependency parsing ?",
        "corpus-level part-of-speech tagging ?",
        "combined translation alignment Combined constituency and dependency parsing setup: assume separate models trained for constituency and dependency parsing problem: find constituency parse that maximizes the sum of the two models example: ?",
        "combine lexicalized CFG with second-order dependency parser",
        "notation: identify the dependencies selected by each model ?",
        "y(i , j) = 1 when constituency parse y selects word i as a modifier of word j ?",
        "z(i , j) = 1 when dependency parse z selects word i as a modifier of word j example: a constituency and dependency parse with y(3, 5) = 1",
        "such that for all i = 1 .",
        ".",
        ".",
        "n, j = 0 .",
        ".",
        ".",
        "n,",
        "Corpus-level tagging setup: given a corpus of sentences and a trained sentence-level tagging model problem: find best tagging for each sentence, while at the same time enforcing inter-sentence soft constraints example: ?",
        "test-time decoding with a trigram tagger ?",
        "constraint that each word type prefer a single POS tag Corpus-level tagging full model for corpus-level tagging He saw an American man The smart man stood outside Man is the best measure",
        "(e.g. a hard constraint - all word types only have one tag) example: an MRF model that encourages words of the same type to choose the same tag",
        "Identifying word tags notation: identify the tag labels selected by each model ?",
        "Ys(i , t) = 1 when the tagger for sentence s at position i selects tag t ?",
        "z(s, i , t) = 1 when the constraint assigns at sentence s position i the tag t example: a parse and tagging with Y1(5,N) = 1 and z(1, 5,N) = 1 He saw an American man The smart man stood outside",
        "upon agreement the solution is exact, but this may not occur otherwise, there is an easy way to find an approximate solution choose: the structure y (k",
        "there are other methods to estimate solutions, for instance by averaging solutions (see Nedic?",
        "and Ozdaglar (2009)) Lazy decoding idea: don't recompute y (k) or z(k) from scratch each iteration lazy decoding: if subgradient u(k) is sparse, then y (k) may be very easy to compute from y",
        "(k?1) use: ?",
        "very helpful if y or z factors naturally into several parts ?",
        "decompositions with this property are very fast in practice example: ?",
        "in corpus-level tagging, only need to recompute sentences with a word type that received an update 5.",
        "Linear programming aim: explore the connections between dual decomposition and linear programming ?",
        "basic optimization over the simplex ?",
        "formal properties of linear programming ?",
        "full example with fractional optimal solutions ?",
        "tightening linear program relaxations"
      ]
    },
    {
      "heading": "Simplex",
      "text": [
        "define: ?",
        "?y is the simplex over Y where ?",
        "?",
        "?y implies ?y ?",
        "0 and",
        "however this would make decoding expensive single bigram constraint: cheaper to implement",
        "the solution ?",
        "(1), ?",
        "(1) trivially passes this constraint, while ?",
        "(2), ?",
        "(2) violates it Dual decomposition with tightening tightened decomposition includes an additional Lagrange multiplier",
        "u(i , t)z(i , t)?",
        "v(1, a, b)z(1, a, b) in general, this term can make the decoding problem more difficult example: ?",
        "for small examples, these penalties are easy to compute ?",
        "for CFG parsing, need to include extra states that maintain tag bigrams (still faster than full intersection)",
        "aim: demonstrate some different relaxation techniques ?",
        "higher-order non-projective dependency parsing ?",
        "syntactic machine translation Higher-order non-projective dependency parsing setup: given a model for higher-order non-projective dependency parsing (sibling features) problem: find non-projective dependency parse that maximizes the score of this model difficulty: ?",
        "model is NP-hard to decode ?",
        "complexity of the model comes from enforcing combinatorial constraints strategy: design a decomposition that separates combinatorial constraints from direct implementation of the scoring function Non-projective dependency parsing structure: ?",
        "starts at the root symbol * ?",
        "each word has a exactly one parent word ?",
        "produces a tree structure (no cycles) ?",
        "dependencies can cross",
        "idea: do individual decoding for each head word using dynamic programming if we?re lucky, we?ll end up with a valid final tree but we might violate some constraints",
        "setup: assume a trained model for syntactic machine translation problem: find best derivation that maximizes the score of this model difficulty: ?",
        "need to incorporate language model in decoding ?",
        "empirically, relaxation is often not tight, so dual decomposition does not always converge strategy: ?",
        "use a different relaxation to handle language model ?",
        "incrementally add constraints to find exact solution Syntactic translation example [Animation] Summary presented dual decomposition as a method for decoding in NLP formal guarantees ?",
        "gives certificate or approximate solution ?",
        "can improve approximate solutions by tightening relaxation efficient algorithms ?",
        "uses fast combinatorial algorithms ?",
        "can improve speed with lazy decoding widely applicable ?",
        "demonstrated algorithms for a wide range of NLP tasks (parsing, tagging, alignment, mt decoding)"
      ]
    },
    {
      "heading": "References I",
      "text": []
    },
    {
      "heading": "References II",
      "text": []
    },
    {
      "heading": "References III",
      "text": []
    }
  ]
}
