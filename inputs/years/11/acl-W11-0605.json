{
  "info": {
    "authors": [
      "Edward P. Stabler"
    ],
    "book": "Proceedings of the 2nd Workshop on Cognitive Modeling and Computational Linguistics",
    "id": "acl-W11-0605",
    "title": "Top-Down Recognizers for {MCFGs} and {MGs}",
    "url": "https://aclweb.org/anthology/W11-0605",
    "year": 2011
  },
  "references": [
    "acl-H05-1102",
    "acl-J01-2004",
    "acl-P10-1121",
    "acl-P99-1054",
    "acl-W05-1502"
  ],
  "sections": [
    {
      "text": [
        "Top-down recognizers for MCFGs and MGs",
        "stablerguela.edu",
        "This paper defines a normal form for MCFGs that includes strongly equivalent representations of many MG variants, and presents an incremental priority-queue-based TD recognizer for these MCFGs.",
        "After introducing MGs with overt phrasal movement, head movement and simple adjunction are added without change in the recognizer.",
        "The MG representation can be used directly, so that even rather sophisticated analyses of properly non-CF languages can be defined very succinctly.",
        "As with the similar stack-based CF-methods, finite memory suffices for the recognition of infinite languages, and a fully connected left context for probabilistic analysis is available at every point."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "In the years after Joshi (1985) proposed that human languages are weakly and strongly \"mildly context sensitive\" (MCS), it was discovered that many independently proposed grammar formalisms define exactly the same MCS languages.",
        "The languages defined by Joshi's tree adjoining grammars (TAGs) are exactly the same as those defined by a version of Steedman's combinatory categorial grammars, and the same as those defined by head wrapping grammars (Vijay-Shanker and Weir, 1994).",
        "A slightly larger class of languages is defined by another variant of TAGs (set-local multicomponent), by a version of Pollard's generalized phrase structure grammars called multiple context free grammars (MCFGs), and by a wide range of minimalist grammar (MG) formalizations of Chomskian syntax (Seki et al., 1991; Michaelis, 1998; Michaelis, 2001b; Harkema, 2001a; Stabler, 2011).",
        "These remarkable convergences provide evidence from across grammatical traditions that something like these MCS proposals may be approximately right, and so it is natural to consider psychological models that fit with these proposals.",
        "With a range of performance models for a range of MCS grammars, it becomes possible to explore how grammatical dependencies interact with other factors in the conditioning of human linguistic performance.",
        "For context free grammars (CFGs), perhaps the simplest parsing model is top-down: beginning with the prediction of a sentence, rules are applied to the leftmost predicted category until a terminal element is reached, which is then checked against the input.",
        "This parsing method is of interest in psychological modeling not only because it uses the grammar in a very transparent way, but also it is because it is predictive in a way that may be similar to human parsing.",
        "At every point in analyzing a sentence from left to right, the structure that has been constructed is fully connected: grammatical relationships among the elements that have been heard have been guessed, and there are no pieces of structure which have not been integrated.",
        "Consequently, this structure can be interpreted by a standard compositional semantics and may be appropriate for \"incremental\" models of sentence interpretation (cf. Haddock, 1989; Chambers et al., 2004; Shen and Joshi, 2005; Altmann and Mirkovic, 2009; Demberg and Keller, 2009, Kato and Matsubara, 2009; Schuler, 2010).",
        "And like human parsing, when used with backtracking or a beam search, TD memory demands need not continually increase with sentence length: a fixed bound on stack depth and on backtrack or beam depth suffices for infinitely many sentences.",
        "Furthermore, TD parsing provides explicit, relevant \"left contexts\" for probabilistic conditioning (Roark and Johnson, 1999; Roark, 2001; Roark, 2004).",
        "But it has not been clear until recently how to apply this method to Chomskian syntax or any of the other MCS grammar formalisms.",
        "There have been some proposals along these lines, but they have either been unnecessarily complex or applicable to only a restricted to range of grammatical proposals (Chesi, 2007; Mainguy, 2010).",
        "This paper extends TD parsing to minimalist context free grammars (MCFGs) in a certain normal form and presents minimalist grammars (MGs) as a succinct representation for some of those MCFGs.",
        "With this extension, the TD parsing method handles an infinite range of MCFGs that encompasses, strongly and weakly, an infinite range of (many variants of) MGs in a very transparent and direct way.",
        "The parsing method can be defined in complete detail very easily, and, abstracting away from limitations of time and memory, it is provably sound and complete for all those grammars.",
        "The TD recognizer for MCFGs is presented in §4, generalizing and adapting ideas from earlier work (Mainguy, 2010; Villemonte de la Clergerie, 2002).",
        "Instead of using a stack memory, this recognizer uses a \"priority queue,\" which just means that we can access all the elements in memory, sorting them into left-to-right order.",
        "Then it is easy to observe: (§3.2) while the reference to MCFG is useful for understanding the recognizer, an MG representation can be used directly without explicitly computing out its MCFG equivalent; (§5.1) the extensions for head movement and simple adjunction allow the recognizer of §4 to apply without change; (§5.2) like its stack-based CF counterpart, the MG recognizer requires only finite memory to recognize certain infinite subsets of languages - that is, memory demands do not always strictly increase with sentence length; and (§5.3) the TD recognizer provides, at every point in processing the input, a fully connected left context for interpretation and probabilistic conditioning, unlike LC and other familiar methods.",
        "Since a very wide range of grammatical proposals can be expressed in this formalism and parsed transparently by this method, it is straightforward to compute fully explicit and syntactically sophisticated parses of the sorts of sentences used in psycholinguistic studies."
      ]
    },
    {
      "heading": "2. MCFGs",
      "text": [
        "MCFGs are first defined by Seki et al.",
        "(1991), but here it will be convenient to represent MCFGs in a Prolog-like Horn clause notation, as in Kanazawa (2009).",
        "In this notation, the familiar context free rule for sentences would be written S(x0lxi1 ) :- NP(x0l), VP (xii ).",
        "Reading :- as \"if\", this formula says that a string formed by concatenating any string xo1 with string xi1 is an S, if x0l is an NP, and xi1 is a VP.",
        "We number the variables on the right side in such a way as to indicate that each variable that appears on the right side of any rule appears exactly once on the right and once on the left.",
        "Lexical rules like have empty \"right sides\" and no variables in this notation.",
        "MCFGs allow categories to have multiple string arguments, so that, for example, a VP with a wh-phrase that is moving to another position could be represented with two string arguments, one of which holds the moving element.",
        "In general, each MCFG rule for building an instance of category A from categories B0 ... Bn (n > 0) has the form, where each ti is an term (i.e. a sequence) over the (finite nonempty) vocabulary S and the variables that appear on the right; no variable on the right occurs more than once on the left (no copying); and the designated 'start' category S has 'arity' or 'dimension' d(S) = 1.",
        "For any such grammar, the language L(G) is the set of strings s G S* such that we can derive S(s).",
        "Here, we restrict attention to a normal form in which (i) each MCFG rule is nondeleting in the sense that every variable xij on the right occurs exactly once on the left, and (ii) each rule is either lexical or nonlexical, where a lexical rule is one in which n = 0 and d(A) = 1 and t1 G S U{e|, and a nonlexical rule is one in which n > 0 and each ti G Var*.",
        "Clearly these additional restrictions do not affect the expressive power of the grammars.",
        "Consider this MCFG for {aibjcidj | i, j > 0}, with 5 non-lexical rules, 4 lexical rules, and start category S. We letter the rules for later reference:",
        "With this grammar we can show that abbcdd has category S with a derivation tree like this:",
        "S(abbcdd)",
        "See, for example, Kanazawa (2009) for a more detailed discussion of MCFGs in this format."
      ]
    },
    {
      "heading": "3. MGs as MCFGs",
      "text": [
        "Michaelis (1998; 2001a) shows that every MG has a 'strongly equivalent' MCFG, in the sense that the MG derivation trees are a relabeling of the MCFG derivation trees.",
        "Here we present MGs as finite sets of lexical rules that define MCFGs.",
        "MG categories contain finite tuples of feature sequences, where the features include categories like N,V,A,P,..., selectors for those categories =N,=V,=A,=P,..., licensors",
        "MCFG representation, a category is a tuple where (i) j > 0, (ii) x = 1 if the element is lexical and 0 otherwise, (iii) each öi is a nonempty feature sequence, and (iv) the category has dimension j + 1.",
        "An MG is then given by a specified start category and a finite set of lexical rules",
        "< M0 )(a).",
        "for some a G S. The MG defines the language generated by its lexicon together with MCFG rules determined by the lexicon, as follows.",
        "Let n2(Lex) be the set of feature sequences ö0 contained in the lexical rules, and let k be the number of different types of licensees f that occur in the lexical rules.",
        "For all 0 < i,j < k, all x,y G {0,1}, all a, ß, Si,y% G suffix(n2(Lex)), and ß = e, we have these 'merge' rules, broken as usual into the cases where (i) we are merging into complement position on the right, (ii) merging into specifier position on the left, or (iii) merging with something that is moving:",
        "And we have these 'move' rules, broken as usual into the cases where the moving element is landing, when Si = -f, and cases where the moving element must move again, when Si = f ß, where none of S1,..., Si-1, Si+1,..., Sj begin with -f. The language of the MG is the MCFL defined by the lexicon and all instances of these 5 rule schemes (always a finite set).",
        "the set-local multicomponent tree adjoining languages (MCTALs) (Weir, 1988; Seki et al., 1991).",
        "TALs are a proper subset, defined by 'well-nested 2-MCFGs' (Seki et al., 1991; Kanazawa, 2009).",
        "Consider the following lexicon containing 7 items, with the 'complementizer' start category C,",
        "Using the definition given just above, this determines an MG.",
        "This is a derivation tree for one of the infinitely many expressions of category C:",
        "If we relabel this tree so that each instance of merge is labeled Merge or •, and each instance of move is labeled Move or o, the result is the corresponding MG derivation tree, usually depicted like this:",
        "In fact, the latter tree fully specifies the MCFG derivation above, because, in every MG derivation, for every internal node, the categories of the children determine which rule applies.",
        "This is easily verified by checking the 5 schemes for non-lexical rules on the previous page; the left side of each rule is a function of the right.",
        "Consequently the MCFG categories at the internal nodes can be regarded as specifying the states of a deterministic finite state bottom-up tree recognizer for the MG derivation trees (Kobele et al., 2007; Graf, 2011; Kobele, 2011).",
        "We did not explicitly present the nonlexical MCFG rules used in the previous section §3.1, since they are determined by the lexical rules.",
        "The first rule used at the root of the derivation tree is, for example, an instance of the first rule scheme in §3, namely:",
        "( 0,C )(soto) :- ( 1, =VC )(so), ( 0, V )(to).",
        "Generating these non-lexical MCFG rules from the MG lexicon is straightforward, and has been implemented in (freely available) software by Guillau-min (2004).",
        "But the definition given in §3 requires that all feature sequences in all rules be suffixes of lexical feature sequences, and notice that in any derivation tree, like the one shown in §3.1, for example, feature sequences increase along the left branch from any node to the leaf which is its 'head.'",
        "Along any such path, the feature sequences increase one feature at a time until they reach the lexical leaf.",
        "So in effect, if we are building the derivation top-down, each step adds or 'unchecks' features in lexical sequences one at a time, and obviously the options for doing this can be seen without compiling out all the MCFG nonlexical rules."
      ]
    },
    {
      "heading": "4. The top-down recognizer",
      "text": [
        "For any sequence s of elements of S, let | s| =the length of s and nth(i,s) = a iff a G S, and for some u, v G S*, s = uav and |u| = i.",
        "Adapting basic ideas from earlier work (Mainguy, 2010; Villemonte de la Clergerie, 2002) for TD recognition, we will instantiate variables not with strings but with indices i G N* to represent linear order of constituents, to obtain indexed atoms A(i1;..., id(A)).",
        "Y=B0(x0i ; ^ ^ ^ ; x0d(B0) )' ^ ^ ^ ' Bn(xni, ^ ^ ^ , xnd(Bn) ).",
        "For each variable xi7 in y, define ifc if tfc = xij ifcp if |tfc | > 1,xij = nth(p,tfc).",
        "Consider any nonlexical rule a :- Y and any indexed atom ß where",
        "Let indexa ß (y) be the result of replacing each variable xij in y by index«/(xij ).",
        "Finally, let trim(Y) map Y to itself except in the case when when every index in Y begins with the same integer n, in which case that initial n is deleted from every index.",
        "Define a total order on the indices N* as follows.",
        "For any a, ß G N*,",
        "{ a = e = ß, or a = ia', ß = jß', i < j, or a = ia',ß = iß', a' < ß'.",
        "For any atom a, let //(a) be the least index in a.",
        "So, for example, /x(AB(31, 240)) = 240.",
        "And for any indexed atoms a, ß, let a < ß iff / (a) < / (ß).",
        "We use this order it to sort categories into left-to-right order in the 'expand' rule below.",
        "We now define TD recognition in a deductive format.",
        "The state of the recognition sequence is given by a (remaining input,priority queue) pair, where the queue represents the memory of predicted elements, sorted according to < so that they can be processed from left to right.",
        "We have 1 initial axiom, which predicts that input s will have start category S, where S initially has index e:",
        "The main work is done by the expand rule, which pops atom a off the queue, leaving sequence 6 underneath.",
        "Then, for any rule ß :- Y with ß of the same category as a, we compute index«/(y), append the result and 6, then sort and trim:",
        "(We could use ordered insertion instead of sorting, and we could trim the indices much more aggressively, but we stick to simple formulations here.)",
        "Finally, we have a scan rule, which scans input a if we have predicted an A and our grammar tells us that A(a).",
        "For all a G (S U e),s G S*,n G N*:",
        "A string s is accepted if we can use these rules to get from the start axiom to (e,e).",
        "This represents the fact that we have consumed the whole input and there are no outstanding predictions in memory.",
        "4.1 Example 1, continued.",
        "Here is the sequence of recognizer states that accepts abbcdd, using the grammar presented in §2.1:",
        "initial axiom:",
        "expand with rule a:",
        "expand with rule c (note sort):",
        "scan with rule f:",
        "expand with rule d:",
        "scan with rule g:",
        "expand with rule e:",
        "scan with rule h (note trim removes 3):",
        "scan with rule i:",
        "The number of recognizer steps is always exactly the number of nodes in the corresponding derivation tree; compare this accepting sequence to the derivation tree shown in §2.1, for example."
      ]
    },
    {
      "heading": "5. Properties and extensions",
      "text": [
        "Frey and Gartner (2002) propose that adjunction be added to MGs by (i) allowing another kind of selecting feature ftf, which selects but does not 'check and delete' the feature f of a phrase that it modifies, where (ii) the head of the result is the selected, 'modified' phrase that it combines with, and (iii) the selecting 'modifier' cannot have any constituents moving out of it.",
        "We can implement these ideas by adding a rule scheme like the following (compare the first rule scheme in §3):",
        "(x ~f )(so).",
        "Note this rule 'attaches' the modifier on the right.",
        "We could also allow left modifiers, but in the examples below will only use this one.",
        "Some analyses of simple tensed sentences say that tense affixes 'hop' onto the verb after the verb has combined with its object.",
        "Affix hopping and head movement are more challenging that adjunction, but previous approaches can be adapted to the present perspective by making two changes: (i) we keep the head separate from other material in its phrase until that phrase is merged with another phrase, so now every non-lexical category A has d(A) > 3 and (ii) we add diacritics to the selection features to indicate whether hopping or head movement should apply in the merge step.",
        "To indicate that a head A selects category f we give A the feature =f, but to indicate the the head of A should hop onto the head of the selected constituent, we give A the feature f=>.",
        "Essentially this representation of MGs with head movement and affix hopping as MCFGs is immediate from the formalization in Stabler (2001) and the automated translation by Guillaumin (2004).",
        "The examples in this paper below will use only affix hopping which is defined by the following modified version of the first rule in §3:",
        "The first atom on the right side of this rule, the 'selector', is a lexical head with string sh.",
        "The second atom on the right of the rule has string components ts,th,tc (these are the specifier, head, and complement strings) together with j > 0 moving elements t1 , .",
        ".",
        ".",
        ", tj.",
        "In the result on the left, we see that the lexical selector sh is 'hopped' to the right of the selected head th, where it is sandwiched between the other concatenated parts of the selected phrase, leaving e in the head position.",
        "Since the usual start category C now has 3 components, like every other head, we begin with a special category S that serves only to concatenate the 3 components of the matrix complementizer phrase, by providing the recognizer with this additional initializing rule:",
        "S(ssshsc) :- (x,C)(ss,sfc,sc).",
        "The nature of adjunction is not quite clear, and there is even less consensus about whether head movement or affix hopping or both are needed in grammars of human languages, but these illustrate how easily the MCFG approach to MGs can be extended.",
        "Like many of the other MG variants, these extensions do not change the class of languages that can be defined (Stabler, 2011), and the recognizer defined in §4 can handle them without change.",
        "With head movement and adjunction we can, for example, provide a roughly traditional analysis of the famous example sentence from King and Just (1991) shown in Figure 1.",
        "Note again that the derivation tree in that figure has lexical items at the leaves, and these completely determine the non-lexical rules and the structure of the derivation.",
        "Various representations of the 'derived trees', like the X-bar tree shown in this figure, are easily computed from the derivation tree (Kobele et al., 2007).",
        "And Figure 2 shows the recognizer steps accepting that sentence.",
        "Plotting queue size versus recognizer step, and simply overlaying the King and Just self-paced reading times to see if they are roughly similar, we see that, at least in sentences like these, readers go more slowly when the queue gets large:",
        "Recent work has challenged the claim that reading times are a function of the number of predictions in memory, (e.g., Nakatani and Gibson, 2008, p.81) but preliminary studies suggest that other performance measures may correlate (Bachrach, 2008; Brennan et al., 2010; VanWagenen et al., 2011).",
        "Exploring these possibilities is beyond the scope this paper.",
        "The present point is that any analysis expressible in the MG formalism can be parsed transparently with this approach, assessing its memory demands; partially parallel beam search models for ambiguity, used in natural language engineering, can also be straightforwardly assessed.",
        "reporter",
        "VP error senator attack -ed",
        "Figure 1: 28 node derivation tree and corresponding X-bartree forKing and Just (1991) example",
        "Although memory use is not the main concern of this paper, it is worth noting that, as in stack-based CF models, memory demands do not necessarily increase without bound as sentence length increases.",
        "So for example, we can extend the naive grammar of Figure 2 to accept this is the man that kiss -ed the maid that milk -ed the cow that toss -ed the dog that worry -ed the cat that chase -ed the rat, a sentence with 6 clauses, and use no more memory at any time than is needed for the 2 clause King and Just example.",
        "Dynamic, chart-based parsing methods usually require more memory without bound as sentence length grows, even when there is little or no indeterminacy.",
        "More directly relevant to incremental models is the fact that the portions of the derivation traversed at any point in TD recognition are all connected to each other, their syntactic relations are established.",
        "As we see in all our examples, the TD recognizer is always traversing the derivation tree on paths connected to the root; while the indexing and sorting ensures that the leaves are scanned in the order of their appearance in the derived X-bar tree.",
        "Left corner traversals do not have this property.",
        "Consider a sentence like the reporter poured the egg in the bowl over the flour.",
        "In a syntax in the spirit of the one we see in Figure 1, for example, in the bowl could be right adjoined to the direct object, and over the flour right adjoined to VP.",
        "Let VP1 be the parent of over the flour, and VP2 its sister.",
        "With LC, VP1 will be predicted right after the subject is completed.",
        "But the verb is the left corner of VP2, and VP2 will not be attached to VP1 - and so the subject and verb will not be connected - until VP1 is completed.",
        "This delay in the LC attachment of the subject to the verb can be extended by adding additional right modifiers to the direct object or the verb phrase, but the evidence suggests that listeners make such connections immediately upon hearing the words, as the TD recognizer does."
      ]
    },
    {
      "heading": "6. Future work",
      "text": [
        "Standard methods for handling indeterminacy in top-down CF parsers, when there are multiple ways to expand a derivation top down, are easily adapted to the MCFG and MG parsers proposed here.",
        "With backtracking search, left recursion can cause nontermination, but a probabilistic beam search can do better.",
        "For a = ( i, 6) any recognizer state, let step(a) be the (possibly empty) sequence of all the next states that are licensed by the rules in §3 (always finitely many).",
        "A probabilistic beam search uses the rules, popping a recognizer state a off the top of the queue a6, appending step(a) and 6, then sorting and pruning the result.",
        "The sort in the search steps is done according to the probability of each parser",
        "Figure 2: 28 step TD recognition of derivation in Figure 1, abbreviating input words by their initial characters.",
        "The left column indicates queue size, plotted in §5.1.",
        "state in context C, where the context may include a history of previous recognizer steps - i.e. of each derivation up to this point - but also possibly ex-trasentential information of any sort.",
        "The pruning rule acts to remove highly improbable analyses, and success is achieved if a step puts (e, e) on top of the queue.",
        "Roark shows that this ability to condition on material not in parser memory - indeed on anything in the left context - can allow better estimates of parse probability.",
        "On small experimental grammars, we are finding that TD beam search performance can be better than our chart parsers using the same grammar.",
        "Further feasibility studies are in progress.",
        "1",
        "init.",
        "(trttsa-a-te,",
        "S(e))",
        "1",
        "init.",
        "(trttsa-a-te,",
        "(0,C}(0,1,2))",
        "2",
        "1.",
        "(trttsa-a-te,",
        "(1,=TC)(1),(0,T}(20,21,22))",
        "1",
        "2.",
        "(trttsa-a-te,",
        "(0,T}(0,1,2))",
        "1",
        "3.",
        "(trttsa-a-te,",
        "(0,+epT,-ep}(01,1,2,00))",
        "2",
        "4.",
        "(trttsa-a-te,",
        "(0,V,-ep)(20,21,23,00),(1,V=>+epT}(22))",
        "3",
        "5.",
        "(trttsa-a-te,",
        "(0,D-ep) (000,001,002), (0,=DV} (20,21,23), ( 1 ,V=>+epT} (22))",
        "4",
        "6.",
        "(trttsa-a-te,",
        "( 1,=ND-ep} (001), (0,N} (0020,0021,0022), (0,=DV} (20,21,23), ( 1,V=>+epT} (22))",
        "3",
        "7.",
        "(rttsa-a-te,",
        "(0,N}(0020,0021,0022),(0,=DV}(20,21,23),(1,V=>+epT}(22))",
        "4",
        "8.",
        "(rttsa-a-te,",
        "(1,N}(0021),(0,ftN }(00220,00221,00222),(0,=DV}(20,21,23),(1,V=>+epT}(22))",
        "3",
        "9.",
        "(ttsa-a-te,",
        "(0,»N} (00220,00221,00222), (0,=DV} (20,21,23), ( 1 ,V=>+epT} (22))",
        "3",
        "10.",
        "(ttsa-a-te,",
        "(0,+wfrsN ,-wh} (002201,00221,00222,002200), (0,=DV} (20,21,23), ( 1 ,V=>+epT} (22))",
        "4",
        "11.",
        "(ttsa-a-te,",
        "(0,T,-wh}(002220,002221,002222,002200),(1,=T+whftN }(00221),(0,=DV}(20,21,23),(1,V=>+epT}(22))",
        "4",
        "12.",
        "(ttsa-a-te,",
        "(0,+epT,-ep,-wh} (0022201,002221,002222,0022200,002200), ( 1 ,=T+wh;sN} (00221), (0,=DV} (20,21,23),",
        "(1,V=>+epT}(22))",
        "5",
        "13.",
        "(ttsa-a-te,",
        "(0,V,-ep,-wh} (0022220,0022221,0022223,0022200,002200), ( 1 ,=T+wh;sN} (00221 ), ( 1,V=>+epT} (0022222),",
        "(0,=DV}(20,21,23),(1,V=>+epT}(22))",
        "6",
        "14.",
        "(ttsa-a-te,",
        "(0,=DV,-wh} (0022220,0022221,0022223,002200), ( 1 ,=T+wh;sN} (00221),",
        "(0,D-ep} (00222000,00222001,00222002), ( 1,V=>+epT} (0022222), (0,=DV} (20,21,23), ( 1 ,V=>+epT} (22))",
        "7",
        "15.",
        "(ttsa-a-te,",
        "( 1 ,D-wh} (002200), ( 1,=T+wh»N} (00221 ), (0,D-ep} (00222000,00222001,00222002), ( 1,=D=DV} (0022221),",
        "( 1,V=>+epT} (0022222), (0,=DV} (20,21,23), ( 1 ,V=>+epT} (22))",
        "6",
        "16.",
        "(ttsa-a-te,",
        "( 1 ,=T+whftN}(00221), (0,D-ep} (00222000,00222001,00222002), ( 1 ,=D=DV} (0022221),",
        "( 1,V=>+epT} (0022222), (0,=DV} (20,21,23), ( 1 ,V=>+epT} (22))",
        "5",
        "17.",
        "(tsa-a-te,",
        "(0,D-ep} (00222000,00222001,00222002), ( 1 ,=D=DV} (0022221), ( 1,V=>+epT} (0022222),",
        "(0,=DV}(20,21,23),(1,V=>+epT}(22))",
        "6",
        "18.",
        "(tsa-a-te,",
        "( 1 ,=ND-ep} (00222001), ( 1,N} (00222002), ( 1,=D=DV} (0022221), ( 1,V=>+epT} (0022222), (0,=DV} (20,21,23),",
        "(1,V=>+epT}(22))",
        "5",
        "19.",
        "(sa-a-te,",
        "( 1 ,N} (00222002), ( 1,=D=DV} (0022221), ( 1 ,V=>+epT} (0022222), (0,=DV} (20,21,23), ( 1 ,V=>+epT} (22))",
        "4",
        "20.",
        "(a-a-te,",
        "( 1 ,=D=DV} (0022221 ), ( 1,V=>+epT} (0022222), (0,=DV} (20,21,23), ( 1 ,V=>+epT} (22))",
        "3",
        "21.",
        "(-a-te,",
        "( 1 ,V=>+epT} (0022222), (0,=DV} (20,21,23), ( 1,V=>+epT} (22))",
        "2",
        "22.",
        "(a-te,",
        "(0,=DV}(20,21,23),(1,V=>+epT}(22))",
        "3",
        "23.",
        "(a-te,",
        "( 1 ,=D=DV} (1), ( 1,V=>+epT} (2), (0,d} (30,31,32))",
        "2",
        "24.",
        "(-te,",
        "(1,V=>+epT}(2),(0,D}(30,31,32))",
        "1",
        "25.",
        "(te,",
        "(0,D}(30,31,32))",
        "2",
        "26.",
        "(te,",
        "(1,=ND}(1),(1,N}(2))",
        "1",
        "27.",
        "(e,",
        "(1,N}(2))",
        "0",
        "28.",
        "(e,",
        "The recognizer presented here simplifies Main-guy's (2010) top-down MG recognizer by generalizing it handle an MCFG normal form, so that a wide range of MG extensions are immediately accommodated.",
        "This is made easy when we adopt Kanazawa's Horn clause formulation of MCFGs where the order of variables on the left side of the rules so visibly indicates the surface order of string components.",
        "With the Horn clause notation, the indexing can be string-based and general rather than tree-based and tied to particular assumptions about how the MGs work.",
        "Transparently generalizing the operations of CF TD recognizers, the indexing and operations here are also slightly simpler than 'thread automata' (Ville-monte de la Clergerie, 2002).",
        "Compare also the indexing, sometimes more or less similar, in chart-based recognizers of MCF and closely related systems (Burden and Ljunglof, 2005; Harkema, 2001c; Boullier, 1998; Kallmeyer, 2010).",
        "Mainguy shows that when the probability of a derivation is the product of the rule probabilities, as usual, and when those rule probabilities are given by a consistent probability assignment, a beam search without pruning will always find a derivation if there is one.",
        "When there is no derivation, though, an unpruned search can fail to terminate; a pruning rule can guarantee termination in such cases.",
        "Those results extend to the MCFG recognizers proposed here.",
        "Various applications have found it better to use abeam search with top-down recognition of left-or right-corner transforms of CF grammars (Roark, 2001; Roark, 2004; Schuler, 2010; Wu et al., 2010); those transforms can (but need not always) disrupt grammatical connectedness as noted in §5.3.",
        "Work in progress explores the possibilities for such strategies in incremental MCFG parsing.",
        "It would also be interesting to generalize Hale's (2011) \"rational parser\" to these grammars."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "Thanks to Thomas Mainguy, Sarah VanWagenen and Eric Villemonte de la Clergerie for helpful discussions of this material."
      ]
    }
  ]
}
