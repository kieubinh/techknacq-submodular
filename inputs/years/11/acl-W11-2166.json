{
  "info": {
    "authors": [
      "Mark Hopkins",
      "Greg Langmead",
      "Tai Vo"
    ],
    "book": "Proceedings of the Sixth Workshop on Statistical Machine Translation",
    "id": "acl-W11-2166",
    "title": "Extraction Programs: A Unified Approach to Translation Rule Extraction",
    "url": "https://aclweb.org/anthology/W11-2166",
    "year": 2011
  },
  "references": [
    "acl-D07-1104",
    "acl-D08-1022",
    "acl-J07-2003",
    "acl-J10-3008",
    "acl-N07-1063",
    "acl-P03-2041",
    "acl-P05-1033",
    "acl-P06-1077",
    "acl-P06-1121",
    "acl-P07-1089",
    "acl-P08-1064",
    "acl-P08-1114",
    "acl-P09-1063",
    "acl-P10-1146",
    "acl-W06-1606",
    "acl-W06-3119",
    "acl-W06-3601",
    "acl-W09-0424",
    "acl-W99-0604"
  ],
  "sections": [
    {
      "text": [
        "Mark Hopkins and Greg Langmead and Tai Vo",
        "SDL Language Technologies Division 6060 Center Drive, Suite 150 Los Angeles, CA 90045",
        "We provide a general algorithmic schema for translation rule extraction and show that several popular extraction methods (including phrase pair extraction, hierarchical phrase pair extraction, and GHKM extraction) can be viewed as specific instances of this schema.",
        "This work is primarily intended as a survey of the dominant extraction paradigms, in which we make explicit the close relationship between these approaches, and establish a language for future hybridizations.",
        "This facilitates a generic and extensible implementation of alignment-based extraction methods."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The tradition of extracting translation rules from aligned sentence pairs dates back more than a decade.",
        "A prominent early example is phrase-based extraction (Och et al., 1999).",
        "Around the middle of the last decade, two extraction paradigms were proposed for syntax-based machine translation: the Hiero paradigm of (Chiang, 2005) and the GHKM paradigm of (Galley et al., 2004).",
        "From these papers followed two largely independent lines of research, respectively dubbed formally syntax-based machine translation (Chiang, 2007; Zollmann and Venugopal, 2006; Venugopal et al., 2007; Lopez, 2007; Marton and Resnik, 2008; Li et al., 2009; de Gispert et al., 2010) and linguistically syntax-based machine translation (Galley et al., 2006; Marcu et al., 2006; Liu et al., 2006; Huang",
        "Zhang et al., 2008; Liu et al., 2009).",
        "In this paper, we unify these strands of research by showing how to express Hiero extraction, GHKM extraction, and phrase-based extraction as instances of a single master extraction method.",
        "Specifically, we express each technique as a simple \"program\" given to a generic \"evaluator\".",
        "Table 1 summarizes how to express several popular extraction methods as \"extraction programs.\"",
        "Besides providing a unifying survey of popular alignment-based extraction methods, this work has the practical benefit of facilitating the implementation of these methods.",
        "By specifying the appropriate input program, the generic evaluator (coded, say, as a Python module) can be used to execute any of the extraction techniques in Table 1.",
        "New extraction techniques and hybridizations of existing techniques can be supported with minimal additional programming."
      ]
    },
    {
      "heading": "2. Building Blocks",
      "text": [
        "The family of extraction algorithms under consideration share a common setup: they extract translation rules from a sentence pair and an alignment.",
        "In this section, we define these concepts.",
        "Assume we have a global vocabulary of atomic symbols, containing the reserved substitution symbol V. Define a pattern as a sequence of symbols.",
        "Define the rank of a pattern as the count of its V symbols.",
        "Let Vk = (VTvXV).",
        "We will typically use space-delimited quotations to represent example patterns, e.g. \"ne V pas\" rather than (ne, V,pas).",
        "We will use the dot operator to represent the concatenation of patterns, e.g. \"il ne\" • \"va pas\" = \"il ne va pas\".",
        "Table 1: Various rule extraction methods, expressed as extraction programs.",
        "Boldfaced methods are proven in this paper; the rest are left as conjecture.",
        "Parameters: t, t are spanmaps (see Section 3); t, t are fuzzy spanmaps (see Section 7); T, T are sets of spanmaps (typically encoded as forests); A is an alignment (see Section 2).",
        "We refer to a contiguous portion of a pattern with a span, defined as either the null span <fi , or a pair [b, c] of positive integers such that b < c. We will treat span [b, c] as the implicit encoding of the set {b, b + 1,c}, and employ set-theoretic operations on spans, e.g. [3,8] n [6,11] = [6, 8].",
        "Note that the null span encodes the empty set.",
        "If a set I of positive integers is non-empty, then it has a unique minimal enclosing span, defined by the operator span(I) = [min(I), max(I)].",
        "For instance, span({1, 3, 4}) = [1, 4].",
        "Define span({}) = <<.",
        "Finally, define a sentence as a pattern of rank 0.",
        "An alignment is a triple (m, n, A), where m and n are positive integers, and A is a set of ordered integer pairs (i, j) such that 1 < i < m and 1 < j < n.",
        "Define a ~ a to mean that (a, a) G A (in words, we say that A aligns primary index a to secondary",
        "Figure 1: A demonstration of alignment terminology.",
        "(a) An alignment is a relation between positive integer sets.",
        "(b) The primary domain of the example alignment is {1,2,3,4} and the secondary domain is {1,3,5}.",
        "(c) The image of primary span [2,4] is {3,5}.",
        "(d) The minimal projection of primary span [2,4] is [3,5].",
        "Secondary spans [2,5], [3,6], and [2,6] are also projections of primary span [2,4].",
        "index a), and define a $ a to mean that (a, a) G A.",
        "Define an aligned sentence pair as a triple (s, a, A) where A is an alignment and s, a are sentences of length |A|p and |A|s, respectively.",
        "Primary and Secondary Domain: The primary domain of alignment A is the set of primary indices that are aligned to some secondary index, i.e.",
        "define sdom(A) = {a|3a s.t.",
        "a $ a}.",
        "For the example alignment of Figure 1(b), pdom(A) = {1, 2, 3, 4} and sdom(A) = {1,3, 5}.",
        "Extraction Program",
        "Method",
        "Primary Protocol",
        "Secondary Protocol",
        "Labeling Protocol",
        "PBMT (Och et al., 1999)",
        "RANKPPo",
        "TrivSPa",
        "TRIVLP",
        "Hiero (Chiang, 2005)",
        "RANKPPoo",
        "TrivSPa",
        "TRIVLP",
        "GHKM (Galley et al., 2004)",
        "MAPPPt",
        "TrivSPa",
        "PMAPLPt",
        "SAMT (Zollmann and Venugopal, 2006)",
        "RANKPPo",
        "TrivSPa",
        "PMAPLPt~",
        "Forest GHKM (Mi and Huang, 2008)",
        "MAPPPT",
        "TrivSPa",
        "PMAPLPT",
        "Tree-to-Tree GHKM (Liu et al., 2009)",
        "MAPPPt",
        "MAPSPt;a",
        "IMAPLP{t|){r}",
        "Forest-to-Forest GHKM (Liu et al., 2009)",
        "MAPPPT",
        "MapSPt ,a",
        "IMAPLPTT",
        "Fuzzy Dual Syntax (Chiang, 2010)",
        "MAPPPt~",
        "MAPSPf;A",
        "IMAPLPm,{f}",
        "11",
        "!",
        "2 I",
        "3 \\4\\ 5",
        "!",
        "6 I",
        "[3,5]",
        "Image: The image of a set I of primary indices (denoted pimageA(I)) is the set of secondary indices to which the primary indices of I align.",
        "In Figure 1(c), for instance, the image of primary span [2, 4] is the set {3, 5}.",
        "Formally, for a set I of primary indices of alignment A, define:",
        "Projection: The minimal projection of a set I of primary indices (denoted pmprojA(I)) is the minimal enclosing span of the image of I.",
        "In other words, pmprojA(I) = span(pimageA(I)).",
        "In Figure 1(d), for instance, the minimal projection of primary span [2, 4] is the secondary span [3, 5].",
        "Consider Figure 1(d).",
        "We will also allow a more relaxed type of projection, in which we allow the broadening of the minimal projection to include unaligned secondary indices.",
        "In the example, secondary spans [2, 5], [3, 6], and [2, 6] (in addition to the minimal projection [3, 5]) are all considered projections of primary span [2, 4].",
        "Formally, define pprojA([b, c]) as the set of superspans [ß, 7] of pmprojA([b, c]) such that [ß, 7] n sdom(A) ç",
        "We define an unlabeled rule as a tuple (k,s*, a*, n) where k is a nonnegative integer, s* and a* are patterns of rank k, and n is a permutation of the sequence (1,2,...,k).",
        "Such rules can be rewritten using a more standard Synchronous Context-Free Grammar (SCFG) format, e.g. (3, \"le V V de V\", \"V 's V V\", (3,2,1)) can be written: V – (le Vi V2 de V3, V3 's V2 Vi).",
        "A labeled rule is a pair (r, l), where r is an unlabeled rule, and l is a \"label\".",
        "The unlabeled rule defines the essential structure of a rule.",
        "The label gives us auxiliary information we can use as decoding constraints or rule features.",
        "This deliberate modularization lets us unify sequence-based and tree-based extraction methods.",
        "Labels can take many forms.",
        "Two examples (depicted in Figure 2) are:",
        "1.",
        "An SCFG label is a (k + 1)-length sequence of symbols.",
        "Figure 2: An example SCFG label (top) and STSG label (bottom) for unlabeled rule V – (le Vi V2 de V3, V3 's V2 Vi).",
        "2.",
        "An STSG label (from Synchronous Tree Substitution Grammar (Eisner, 2003)) is a pair of trees.",
        "STSG labels subsume SCFG labels.",
        "Thus STSG extraction techniques can be used as SCFG extraction techniques by ignoring the extra hierarchical structure of the STSG label.",
        "Due to space constraints, we will restrict our focus to SCFG labels.",
        "When considering techniques originally formulated to extract STSG rules (GHKM, for instance), we will consider their SCFG equivalents."
      ]
    },
    {
      "heading": "3. A General Rule Extraction Schema",
      "text": [
        "In this section, we develop a general algorithmic schema for extracting rules from aligned sentence pairs.",
        "We will do so by generalizing the GHKM algorithm (Galley et al., 2004).",
        "The process goes as follows:",
        "• Repeatedly:",
        "- Choose a \"construction request,\" which consists of a \"primary subrequest\" (see Figure 3a) and a \"secondary subrequest\" (see Figure 3b).",
        "- Construct the unlabeled rule corresponding to this request (see Figure 3, bottom).",
        "- Label the rule (see Figure 2).",
        "label",
        "labeled rule",
        "< NP, NN, JJ, NNP >",
        "NP <le JJ2 de NNP3 ,",
        "NNP3's JJ2NN., >",
        "NP NP",
        "NP",
        "NPB PP NNP POS JJ NN",
        "NPB PP",
        "DT NN JJ IN NNP *",
        "DT NN JJ IN NNP",
        "V L – 7 – ^",
        "le 7\"7 – de",
        "NNP POS JJ NN",
        "NP",
        "primary pattern",
        "secondary pattern permutation",
        "Figure 3: Extraction of the unlabeled rule V – (Vi does not V2, Vine V2 pas).",
        "(a) Choose primary subre-quest [1,4] w [1,1][4,4].",
        "(b) Choose secondary subrequest [1,4] w [1,1][3,3].",
        "(bottom) Construct the rule V – (V1 does not V2, V1 ne V2 pas).",
        "The first step in the extraction process is to choose a \"construction request,\" which directs the algorithm about which unlabeled rule(s) we wish to construct.",
        "A \"construction request\" consists of two \"subrequests.\"",
        "Subrequests: A subrequest is a nonempty sequence of non-null spans ([bo,co], [bi,ci],..., [bk,ck]) such that, for all 1 < i < j < k, [bi,Ci] and [bj,Cj] are disjoint proper subsets of [b0,c0].",
        "If it also true that ci < bj, for all 1 < i < j < k, then the subrequest is called monotonie.",
        "We refer to k as the rank of the subrequest.",
        "We typically write subrequest ([bo,co], [bi,ci],[bk,Ck]) using the notation:",
        "or as [bo, co] w e if k = 0.",
        "covered (x) = Uk=i[bi,ci] uncovered(x) = [bo, co]\\covered(x)",
        "Primary Subrequests: Given an alignment A, define the set frontier( A) as the set of primary spans [b, c] of alignment A such that pmproj^([b, c])) is nonempty and disjoint from pimage^([1, b – 1]) U pimageA([c + 1, |A|P]).",
        "Algorithm ConstructRules;(j)a(x, £):",
        "[1,1]",
        "[1,4]",
        "[4,4]",
        "he",
        "does",
        "j not",
        "go ■ – » – ■",
        "/ X",
        "Il il I",
        "ne",
        "i va i",
        "pas I",
        "[1,1]",
        "[3,3]",
        "[1,4]",
        "SORT",
        "▼",
        "does",
        "not",
        "INDEX",
        "1",
        "3",
        "2",
        "4",
        "SORT",
        "▼",
        "▼",
        "ne",
        "pas",
        "INDEX",
        "1",
        "3",
        "SORT",
        "1",
        "2",
        "if construction request (x, £) matches alignment A then {ui, = uncovered ([bo, co] w [bi, ci]...[bk ,ck ])",
        "return {} end if",
        "Figure 4: Pseudocode for rule construction.",
        "Arguments: s = \"s1 s2 ... sm\" and ct = \"ct1 ct2 ... ct„\" are sentences, A = (m,n, 21) is an alignment, x = [bo,co] w [b1, c1]...[bfc,cfc] and £ = [ßo,Yo] w [ß1,71]...[ßk, Yk] are subrequests.",
        "Define preqs(A) as the set of monotonic subre-quests whose spans are all in frontier(A).",
        "We refer to members of preqs(A) as primary subrequests of alignment A.",
        "Figure 3a shows a primary subrequest of an example alignment.",
        "Secondary Subrequests: Given a primary sub-request x = [bo,co] w [bi, ci]...[bk,ck] of alignment A, define sreqs(x, A) as the set of subrequests [ßo,Yo] w [ßi,Yi]...[ßk,Yk] suchthat [ßi,Yi] G pprojA([bi, ci]), for all 0 < i < k. We refer to members of sreqs(x, A) as secondary subrequests of primary subrequest x and alignment A.",
        "Figure 3b shows a secondary subrequest of the primary subre-quest selected in Figure 3a.",
        "Construction Requests: A construction request is a pair of subrequests of equivalent rank.",
        "Construction request (x, £) matches alignment A if x G preqs(A) and £ G sreqs(x, A).",
        "The basis of rule construction is the IndexSort operator, which takes as input a sequence of integers I = (ii,i2,...,ik), and an equivalent-length sequence of arbitrary values v2,vk), and returns a sequence (vj1 ,vj2,...,vjk), where ( ji , j2 , ... , jk) is a permutation of sequence I in ascending order.",
        "For instance, Index-Sort((4, 1, 50, 2), (\"a\", \"b\", \"c\", \"d\")) =",
        "property is a property of the alignment alone.",
        "It is independent of the auxiliary information that GHKM uses, in particular the tree.",
        "Primary Protocol RankPPk :",
        "Primary Protocol MapPPt:",
        "Primary Protocol MapPPt: (J MapPPt",
        "Figure 5: Various primary protocols.",
        "Parameters: k is a nonnegative integer; t is a spanmap; T is a set of span-maps (typically encoded as a forest).",
        "(\"b\", \"d\", \"a\", \"c\").",
        "Note that the output of IndexSort(I, V) is nondeterministic if sequence I has repetitions.",
        "In Figure 4, we show the pseudocode for rule construction.",
        "We show an example construction in Figure 3 (bottom).",
        "Rule construction produces unlabeled rules.",
        "To label these rules, we use a labeling protocol, defined as a function that takes a construction request as input, and returns a set of labels.",
        "Figure 7 defines a number of general-purpose la-",
        "Secondary Protocol TrivSPa(x): return sreqs(x, A)",
        "Labeling Protocol TrivLP(x, £): return Vk+i Labeling Protocol IMapLPtt(x, £):",
        "Secondary Protocol MapSPr A(x):",
        "Figure 6: Various secondary protocols.",
        "Parameters: t is a spanmap; A is an alignment; x = [b0,c0] w [b1, c1]...[bk, ck] is a subrequest.",
        "beling protocols.",
        "Some of these are driven by trees.",
        "We will represent a tree as a spanmap, defined as a function that maps spans to symbol sequences.",
        "For instance, if a parse tree has constituent NP over span [4, 7], then the corresponding spanmap t has t([4, 7]) = (NP).",
        "We map spans to sequences in order to accommodate unary chains in the parse tree.",
        "Nonconstituent spans are mapped to the empty sequence.",
        "For spanmap t, let spans(t) be the set of spans [b, c] for which t([b, c]) is a nonempty sequence."
      ]
    },
    {
      "heading": "4. Extraction Programs",
      "text": [
        "In the previous section, we developed a general technique for extracting labeled rules from aligned sentence pairs.",
        "Note that this was not an algorithm, but rather an algorithmic schema, as it left two questions unanswered:"
      ]
    },
    {
      "heading": "1.. What construction requests do we make?",
      "text": []
    },
    {
      "heading": "2.. What labeling protocol do we use?",
      "text": [
        "We answer these questions with an extraction program, defined as a triple (X, S, L), where:",
        "• X is a set of subrequests, referred to as the primary protocol.",
        "It specifies the set of primary subrequests that interest us.",
        "Figure 5 defines some general-purpose primary protocols.",
        "• S maps every subrequest to a set of subrequests.",
        "We refer to S as the secondary protocol.",
        "It specifies the set of secondary subrequests that interest us, given a particular primary subre-quest.",
        "Figure 6 defines some general-purpose secondary protocols.",
        "Figure 7: Various labeling protocols.",
        "Parameters: t, t are spanmaps; T, T are sets of spanmaps; x = [b0,c0] w [b1,c1]...[bk,ck] and £ = [ß0,Y0] w [ß1,Y1 ]...[ßk,Yk] are subrequests.",
        "• L is a labeling protocol.",
        "Figure 7 defines some general-purpose labeling protocols.",
        "Figure 8 shows the pseudocode for an \"evaluator\" that takes an extraction program (and an aligned sentence pair) as input and returns a set of labeled rules.",
        "As previously stated, we developed our extraction schema by generalizing the GHKM algorithm (Galley et al., 2004).",
        "To recover GHKM as an instance of this schema, use the following program:",
        "ExtractS)(J;A(MapPPt, TrivSPA, PMapLPt) where t is a spanmap encoding a parse tree over the primary sentence.",
        "for all subrequests x G X do for all subrequests £ G S(x) do U = ConstructRules;(j)a(x, £) L = L(x,£) R = R U (U x L) end for end for return R_",
        "Figure 8: Evaluator for extraction programs.",
        "Parameters: (s, CT, A) is an aligned sentence pair; X is a primary protocol; S is a secondary protocol; L is a labeling protocol."
      ]
    },
    {
      "heading": "5. The Phrase Pair Extraction Program",
      "text": [
        "In this section, we express phrase pair extraction (Och et al., 1999) as an extraction program.",
        "For primary span [b, c] and secondary span [ß, y] of alignment A, let [b, c] A [ß, y] if the following three conditions hold:",
        "Define the ruleset Pbmt(s, ct, A) to be the set of labeled rules (r, V) such that:",
        "We want to express Pbmt(s, ct, A) as an extraction program.",
        "First we establish a useful lemma and corollary.",
        "[ß, Y] G pprojA([b, c]).",
        "Equivalence 1 holds by definition of frontier(A).",
        "Equivalence 2 holds because [ß, y] differs from pmprojA ([b, c]) only in unaligned indices.",
        "Equivalence 3 holds because given the disjointness from pimageA ([b, c]c), [ß, y] differs from pimageA ([b, c]) only in unaligned indices.",
        "Equivalences 4 and 5 are a restatement of conditions 2 and 3 plus the observation that empty spans can satisfy conditions 2 and 3.",
        "□ Corollary 2.",
        "Consider monotonic subrequest x = [bo,co] w [bi, ci]...[bk,ck] and arbitary subrequest £ = [ßo,Yo] w [ßi,Yi]...[ßk,Yk].",
        "Construction request ( x, £) matches alignment A iff [bi, ci] A[ßi, Yi] for all 0 < i < k.",
        "We are now ready to express the rule set Pbmt(s, ct, A) as an extraction program.",
        "Extracts)(j;a(RankPPo, TrivSPa, TrivLP)",
        "Proof.",
        "Equivalence 1 holds by the definition of EXTRACT and RankPPo.",
        "Equivalence 2 holds by the pseudocode of ConstructRule.",
        "Equivalence 3 holds from Corollary 2.",
        "Equivalence 4 holds from the definition of PBMT(s, ct, A).",
        "□"
      ]
    },
    {
      "heading": "6. The Hiero Extraction Program",
      "text": [
        "In this section, we express the hierarchical phrase-based extraction technique of (Chiang, 2007) as an extraction program.",
        "Define Hieroo(s, ct, A) = Pbmt(s,ct, A).",
        "For positive integer k, define HlEROk (s, ct, A) as the smallest superset of Hi-EROk-l(s, ct, A) satisfying the following condition:",
        "5. ct* has rank j.",
        "it holds that labeled rule (r, Vk+l) is a member of HlEROk(s, ct, A), where r is:",
        "Theorem 4.",
        "HlEROk (s, ct, A) =",
        "EXTRACTS)(J;A(RANKPPk, TRIVSPA, TRIVLP)",
        "Proof.",
        "By induction.",
        "Define ext(k) to mean EXTRACTS)(J;A(RANKPPk, TRIVSPA, TRIVLP).",
        "From Theorem 3, Hieroo(s,ct, A) = ext(0).",
        "Assume that HlEROk-l(s, ct, A) = ext(k – 1) and prove that HlEROk(s, ct, A)\\HlEROk-l(s, ct, A) = ext(k)\\ext(k – 1).",
        "s2 has rank 0 and ct* has rank j",
        "Equivalence 1 holds by the definition of ext(k)\\ext(k – 1).",
        "Equivalence 2 holds by the pseudocode of ConstructRule.",
        "Equivalence 3 holds by the inductive hypothesis and Corollary 2.",
        "Equivalence 4 holds by the definition of HlEROk(s, CT, A)\\HlEROk-l(s,CT, A).",
        "□"
      ]
    },
    {
      "heading": "7. Discussion",
      "text": [
        "In this paper, we have created a framework that allows us to express a desired rule extraction method as a set of construction requests and a labeling protocol.",
        "This enables a modular, \"mix-and-match\" approach to rule extraction.",
        "In Table 1, we summarize the results of this paper, as well as our conjectured extraction programs for several other methods.",
        "For instance, Syntax-Augmented Machine Translation (SAMT) (Zollmann and Venugopal, 2006) is a hybridization of Hiero and GHKM that uses the primary protocol of Hiero and the labeling protocol of GHKM.",
        "To bridge the approaches, SAMT employs a fuzzy version of the spanmap t that assigns a trivial label to non-constituent primary spans:",
        "Other approaches can be similarly expressed as straightforward variants of the extraction programs we have developed in this paper.",
        "Although we have focused on idealized methods, this framework also allows a compact and precise characterization of practical restrictions of these techniques.",
        "For instance, (Chiang, 2007) lists six criteria that he uses in practice to restrict the generation of Hiero rules.",
        "His condition 4 (\"Rules can have at most two nonterminals.\")",
        "and condition 5 (\"It is prohibited for nonterminals to be adjacent on the French side.\")",
        "can be jointly captured by replacing Hiero's primary protocol with the following:",
        "His other conditions can be similarly captured with appropriate changes to Hiero's primary and secondary protocols.",
        "This work is primarily intended as a survey of the dominant translation rule extraction paradigms, in which we make explicit the close relationship between these approaches, and establish a language for future hybridizations.",
        "From a practical perspective, we facilitate a generic and extensible implementation which supports a wide variety of existing methods, and which permits the precise expression of practical extraction heuristics."
      ]
    }
  ]
}
