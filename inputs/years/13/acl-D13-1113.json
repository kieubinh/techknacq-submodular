{
  "info": {
    "authors": [
      "Tieyun Qian",
      "Bing Liu"
    ],
    "book": "EMNLP",
    "id": "acl-D13-1113",
    "title": "Identifying Multiple Userids of the Same Author",
    "url": "https://aclweb.org/anthology/D13-1113",
    "year": 2013
  },
  "references": [
    "acl-C04-1088",
    "acl-C08-1065",
    "acl-I05-1084",
    "acl-J00-4001",
    "acl-P03-1054",
    "acl-P11-1030",
    "acl-P11-1032",
    "acl-P11-2012",
    "acl-P12-2052",
    "acl-W06-1657"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper studies the problem of identifying users who use multiple userids to post in social media.",
        "Since multiple userids may belong to the same author, it is hard to directly apply supervised learning to solve the problem.",
        "This paper proposes a new method, which still uses supervised learning but does not require training documents from the involved userids.",
        "Instead, it uses documents from other userids for classifier building.",
        "The classifier can be applied to documents of the involved userids.",
        "This is possible because we transform the document space to a similarity space and learning is performed in this new space.",
        "Our evaluation is done in the online review domain.",
        "The experimental results using a large number of userids and their reviews show that the proposed method is highly effective."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "It is common knowledge that some users in social media register multiple accounts/userids to post articles, blogs, reviews, etc.",
        "There are many reasons for doing this.",
        "For example, due to past postings, a user may become despised by others.",
        "He/she then registers another userid in order to regain his/her status.",
        "A user may also use multiple userids to instigate controversy or debates to popularize a topic to make it ?hot?",
        "or even just to promote activities at a website.",
        "Yet, a user may also use multiple userids to post fake or deceptive opinions to promote or demote some products (Liu, 2012).",
        "It is thus important to develop technologies to identify such multi-id users.",
        "This paper deals with this problem based on writing style and other linguistic clues.",
        "Problem definition: Given a set of userids ID = {id1, ?, idn} and each idi has a set of documents Di, we want to identify userids that belong to the same physical author.",
        "The main related works to ours are in the area of authorship attribution (AA), which aims to identify authors of documents.",
        "AA is often solved using supervised learning.",
        "Let A = {a1, ?, ak} be a set of authors (or classes) and each author ai ?",
        "A has a set of training documents Di.",
        "A classifier is then built to decide the author a of each test document d, where a ?",
        "A.",
        "We will discuss this and other related works in Section 2.",
        "This supervised AA formulation, however, is not suitable for our task because we only have userids but not real authors.",
        "Since some of the userids may belong to the same author, we cannot treat each userid as a class because in that case, we will be classifying based on userids, which won't help us find authors with multiple userids (see Section 7 also).",
        "This paper proposes a novel algorithm.",
        "To simplify the presentation, we assume that at most two userids can belong to a single author, but the algorithm can be extended to handle more than two userids from the same author.",
        "Using this assumption, the algorithm works in two steps: 1.",
        "Candidate identification: For each userid idi, we first find the most likely userid idj (i ?",
        "j) that may have the same author as idi.",
        "We call idj the candidate of idi.",
        "We also call this function can-did-iden, i.e., idj = candid-iden(idi).",
        "For easy presentation, here we only use one argument for * The work was mainly done when the first author was visiting the University of Illinois at Chicago.",
        "candid-iden.",
        "In the computation, it needs more arguments (see Section 4).",
        "2.",
        "Candidate confirmation: In the reverse order, we apply the function candid-iden on idj, which produces idk, i.e., idk = candid-iden(idj).",
        "Decision making: If k = i, we conclude that idi and idj are from the same author.",
        "Otherwise, idi and idj are not from the same author.",
        "The key of the algorithm is candid-iden.",
        "An obvious approach for candid-iden is to use an information retrieval method.",
        "We can first split the documents Di of each idi into two subsets, a query set Qi and a sample set Si.",
        "We then compare each query document in Qi with each sample document in Sj from other userids idj (?",
        "ID ?",
        "{idi}).",
        "Cosine can be used here for similarity comparison.",
        "All the similarity scores are then aggregated and used to rank the userids in ID ?",
        "{idi}.",
        "The top ranked userid is the candidate for idi.",
        "Note that partitioning the documents of a userid idi into the query set Qi and the sample set Si is crucial here.",
        "We cannot use all documents in Di to compare with all documents in Dj.",
        "If so and we get candid-iden(idi) = idj, we will definitely get candid-iden(idj) = idi since the similarity function is symmetric.",
        "This cosine similarity based method, however, does not work well (see Section 7).",
        "We propose a supervised learning method to compute the scores.",
        "For this, we need to reformulate the problem.",
        "The idea of this reformulation is to learn in a similarity space rather than in the original document space as in traditional AA.",
        "In the new formulation, each document d is still represented as a feature vector, but the vector no longer represents the document d itself.",
        "Instead, it represents a set of similarities between the document d and a query q.",
        "We call this method learning in the similarity space (LSS).",
        "Specifically, in LSS, each document d is first represented with a document space vector (called a d-vector) based on the document itself as in the traditional classification learning of AA.",
        "Each feature in the d-vector is called a d-feature (document-feature).",
        "A query document q is represented in the same way.",
        "We then produce a similarity vector sv (called s-vector) for d. sv consists of a set of similarity values between document d (in a d-vector) and query q (in a d-vector): sv =Sim(d, q), where Sim is a similarity function consists of a set of similarity measures.",
        "Thus, the d-vector for document d in the document space is transformed to an s-vector sv for d in the similarity space.",
        "Each feature in sv is called an s-feature.",
        "For example, we have the following d-vector for query q: q: 1:1 2:1 6:2 where x:z represents a d-feature x (a word) and its frequency z in q.",
        "We also have two non-query documents, one is d1 which is written by the author of query q and the other is d2 which is not written by query author q.",
        "Their d-vectors are: d1: 1:2 2:1 3:1 d2: 2:2 3:1 5:2 If we use cosine as the first similarity measure in Sim, we can generate an s-feature 1:0.50 for d1 (cosine(q, d1) = 0.50) and an s-feature 1:0.27 for d2 (cosine(q, d2) = 0.27).",
        "If we have more similarity measures more s-features can be produced.",
        "The resulting two s-vectors for d1 and d2 with their class labels, 1 and -1, are as follows: d1: 1 1:0.50 ?",
        "d2: 1 1:0.27 ?",
        "Class 1 means ?written by author of query q?, also called q-positive, and class 1 means ?not written by author of query q?, also called q-negative.",
        "LSS gives us a two-class classification problem.",
        "In this formulation, a test userid and his/her documents do not have to be seen in training as long as a set of known documents from this userid is available.",
        "Any supervised learning method can be used to build a classifier.",
        "We use SVM.",
        "The resulting classifier is employed to compute a score for each review to be used in the two-step algorithm above to find the candidate for each userid and then the userids with the same authors.",
        "Due to the use of query documents, the LSS formulation has some resemblance to document ranking based on learning to rank (Li, 2011; Liu, 2011).",
        "However, LSS is very different because we turn the problem into a supervised classification problem.",
        "The key difference between learning to rank and classification is that ranking will always put some documents at the top even if the desired documents do not exist.",
        "However, classification will not return any document if the desired documents do not exist in the test data (unless there are classification errors).",
        "Our Type II experiments in Section 7 were specifically designed for testing such non-existence situations.",
        "Using online review as the application domain, we conduct experiments on a large number of reviews and their author/reviewer userids from Am-azon.com.",
        "The results show that the proposed algorithm is highly accurate and outperforms three strong baselines markedly."
      ]
    },
    {
      "heading": "2 Related Work",
      "text": [
        "A similar problem was attempted in (Chen et al., 2004) in the context of open forums where users interact with each other in their discussions.",
        "Their method is based on post relationships and intervals between posts.",
        "It does not use any linguistic clues.",
        "It is thus not applicable to domains like online reviews.",
        "Reviews do not involve user interactions since each review is independent of other reviews.",
        "Novak et al. also solved the same problem under the name of ?Anti-aliasing?",
        "(Novak et al., 2004).",
        "They used a clustering based method which assumed the number of actual authors is known.",
        "This is unrealistic in practice as there is no way to know which author has and does not have multiple ids.",
        "Our work is also related to authorship attribution (AA).",
        "However, to our knowledge, our problem has not been attempted in AA.",
        "Existing works focused on two main themes: finding good writing style features, and developing effective classification methods.",
        "On finding good features (d-features in our case), it was found that the most promising features are function words (Mosteller, 1964; Ar-gamon and Levitan, 2004; Argamon et al., 2007) and rewrite rules (Halteren et al., 1996).",
        "Length (Gamon 2004; Graham et al., 2005), richness (Halteren et al., 1996; Koppel and Schler, 2004), punctuations (Graham et al., 2005), character n-grams (Grieve, 2007; Hedegaard and Simonsen, 2011), word n-grams (Burrows, 1992; Sanderson and Guenter 2006), POS n-grams (Gamon, 2004; Hirst and Feiguina, 2007), syntactic category pairs (Na-rayanan et al., 2012) are also useful.",
        "On classification, numerous methods have been tried, e.g., Bayesian analysis (Mosteller, 1964), discriminant analysis (Stamatatos et al., 2000), PCA (Hoover, 2001), neural networks (Graham et al., 2005; Zheng et al., 2006; Graham et al., 2005), clustering (Sanderson and Guenter, 2006), decision trees (Uzuner and Katz, 2005; Zhao and Zobel, 2005), regularized least squares classification (Narayanan et al., 2012), and SVM (Diederich et al., 2000; Gamon 2004; Koppel and Schler, 2004; Hedegaard and Simonsen, 2011).",
        "Among them, SVM was found to be most accurate (Li et al., 2006; Kim et al., 2011).",
        "Although we also use supervised learning, we do not learn in the original document space as these existing methods do.",
        "The transformation is important because it enables us to use documents from other authors in training.",
        "The traditional supervised learning (TSL) cannot do that.",
        "In our case, the only documents that TSL can use for training are the queries in the testing set.",
        "However, as we will see in our experiments, such a method performs poorly.",
        "Since we use online reviews as our experiment domain, our work is related to fake review detection (Jindal and Liu, 2008) as imposters can use multiple userids to post fake reviews.",
        "Existing research has proposed many methods to detect fake reviewers (Lim et al., 2010; Wang et al., 2011; Mukherjee et al., 2012) and fake reviews (Jindal and Liu, 2008; Ott et al., 2011, 2012; Li et al., 2011; Feng et al., 2012).",
        "However, none of them identifies userids belonging to the same person.",
        "3 Learning in the Similarity Space We now formulate the proposed supervised learning in the similarity space (LSS), which will be used in the candid-iden function in our algorithm to be discussed in Section 4.",
        "The key difference between LSS and the classic document space learning is in the document representation.",
        "Another difference is in the testing phase.",
        "We discuss testing first.",
        "Test data: We are given: ?",
        "A query q from query author (userid) aq ?",
        "A set of test documents DT = {dt1, ?, dtm}.",
        "Goal: classify the test documents into those authored by aq and those not authored by aq.",
        "We note the following points: i) This is like a retrieval scenario, but we use supervised learning to perform the task.",
        "ii) Unlike traditional supervised classification, here the test query author aq does not have to be used in training.",
        "But we are given a query document q from aq.",
        "Clearly, in practice, we can have multiple query documents from aq, which we will discuss in Section 4.",
        "Training document representation: As noted earlier, each document is represented with a similarity vector (s-vector) computed using a similarity",
        "function Sim.",
        "Sim takes a query document and a non-query document and produces a vector of similarity values or s-features to represent the non-query document.",
        "We present the detail below: Let the set of training authors be AR = {ar1, .., arn}.",
        "Each author ari has a set of documents DRi.",
        "Each document in DRi is first represented with a document vector (or d-vector).",
        "The algorithm for producing the training set, called straining set, is given in Figure 1.",
        "We randomly select a small set of queries Qi from documents DRi of each author ari (lines 1, and 2).",
        "For each query qij ?",
        "Qi (line 3), it selects a set of documents DRij also from DRi (excluding qij) of the same author (line 4) to be the positive documents for qij, called q-positive and labeled 1.",
        "Then, for each document drijk in DRij, a q-positive straining example with the label 1 is generated for drijk by computing the similarities of qij and drijk using the similarity function Sim (lines 5, 6).",
        "In line 7, it selects a set of documents DRij,rest from other authors to be the negative documents for qij, called q-negative and labeled -1.",
        "For each document drijk,rest in DRij,rest (line 8), a q-negative straining example with label 1 is generated for drijk by computing the similarities of qij and drijk,rest using Sim (line 9).",
        "How to select Qi, DRij and DRij,rest (lines 2, 4 and 7) is left open intentionally to give flexibility in implementation.",
        "This formulation gives us a two-class classification problem.",
        "The classes are 1 (q-positive meaning ?written by author of query qij?)",
        "and 1 (q-negative meaning ?not written by author of query qij.?",
        "Figure 2 shows what the straining data looks like.",
        "For easy presentation, we assume that there are k queries in every Qi, and p documents in every DRij and u documents in every DRij,rest.",
        "The number of authors is n. Each author ari generates k?",
        "(p+u) straining examples.",
        "As we will see in Section 7, k can be very small, even 1.",
        "Complexity: In the worst case, every document",
        "1.",
        "For each document set Di of idi ?",
        "ID do 2. partition Di into two subsets: (1) query set Qi and (2) sample set Si; 3.",
        "For each document set Di of idi ?",
        "ID do // step 1: candidate identification 4. idj = candid-iden(idi, ID), i < j; // step 2: candidate confirmation 5. idk = candid-iden(idj, ID), k ?",
        "j; 6.",
        "If k = i then idi and idj are from the same author 8. else idi and idj are not from the same author Figure 3: Identifying userids from the same authors Function candidate-iden(idi, ID) 1.",
        "For each sample document set Sj of idj ?",
        "ID-{idi} do 2. pcount[idj], psum[idj], psqsum[idj], max[idj] = 0; 3.",
        "For each query qi ?",
        "Qi do 4.",
        "For each sample sjf ?",
        "Sj do 5. ssjf = <(idi, qi), (Sim(sjf, qi), ?",
        ")>; 6.",
        "Classify ssjf using the classifier built earlier; 7.",
        "If ssjf is classified positive, i.e., 1 then 8. pcount[idj] = pcount[idj] + 1; 9. psum[idj] = psum[idj] + ssjf.score 10 psqsum[idj] = psqsum[idj] + (ssjf.score)2 11.",
        "If ssif.score > max[idj] then 12. max[idj] = srjf.score // Four methods to decide which idj is the candidate for idi 13.",
        "If for all idj ?",
        "ID-{idi}, pcount[idi] = 0 then",
        "1.",
        "For each author ari ?",
        "AR 2. select a set of query documents Qi ?",
        "DRi 3.",
        "For each query qij ?",
        "Qi // produce positive straining examples 4. select a set of documents from author ari DRij ?",
        "DRi ?",
        "{qij} 5.",
        "For each document drijk ?",
        "DRij 6. produce an straining example for drijk, (Sim(drijk, qij), 1) // produce negative straining examples 7. select a set of documents from the rest of authors DRij,rest ?",
        "(DR1 ?",
        "?",
        "?",
        "DRn) ?",
        "DRi 8.",
        "For each document drijk,rest ?",
        "DRij,rest 9. produce an straining example for drijk,rest,",
        "can serve as a query or a non-query document.",
        "Then we need to compute all pairwise document similarities.",
        "If the number of training documents is m, the complexity is O(m2), which is both space and computation expensive.",
        "However, in practice, we don't need all pairwise comparisons.",
        "Only a small subset is sufficient (see Section 7).",
        "Test document representation: Like training documents, test documents are represented as s-vectors as well in the similarity space.",
        "Given a query q from author aq and a set of test documents DT, each test document dti is converted to a s-vector svi = Sim(dti, q).",
        "To reflect svi is computed based on query q from author aq, a s-test case is thus represented as <(aq, q), (svi, ?)>.",
        "Training: A binary classifier is learned using the straining data.",
        "Each straining example is represented with (sv, y), where sv is an s-vector and y (?",
        "{1, -1}) is its class.",
        "Any supervised learning algorithm, e.g., SVM, can be applied.",
        "Testing: The classifier is applied to each s-test case <(aq, q), (svi, ?",
        ")> (where svi = S(dti, q)) to give it a class q-positive or q-negative.",
        "Note that the classifier is only applied on svi.",
        "In most cases, classification based on a single query is inaccurate.",
        "Using multiple queries of an author can classify much more accurately."
      ]
    },
    {
      "heading": "4 Identify Userids of the Same Author",
      "text": [
        "We now expand the sketch of the two-step algorithm in Section 1 based on the problem statement in Section 1.",
        "The algorithm is given in Figure 3.",
        "Lines 1-2 partitions the documents set Di of each idi in ID = {id1, id2, ?, idn}, the set of userids that we are working on.",
        "How to do the partition is flexible (see Section 7).",
        "Line 4 is the step 1 of candidate identification, and line 5 is the step2 of candidate confirmation.",
        "Lines 6-8 is the decision making of step 2 (see Section 1).",
        "Line 6 produced a classification score using the classifier described in Section 3.",
        "The key function here is candid-iden.",
        "Its algorithm is in Figure 4.",
        "The candid-iden function takes two arguments: the query userid idi and the whole set of userids ID.",
        "It classifies each sample ssjf in sample set Sj of idj ?",
        "ID-{idi} to positive (qi-positive) or negative (qi-negative) (lines 4, 5, 6).",
        "We then aggregate the classification results to determine which userid is likely to have the same author as idi.",
        "One simple aggregation method is voting.",
        "We count the total number of positive classifications of the sample documents of each userid in ID-{idi}.",
        "The userid idj with the highest count is the candidate cid which may share the same author as query idi.",
        "cid is returned as the candidate.",
        "There are also other methods, which can depend on what output value the classifier produces.",
        "Here we propose four methods including the voting method above.",
        "The other three methods requires the classifier to produces a prediction score, which reflects the positive and negative certainty.",
        "Many classification algorithms produce such a score.",
        "Here we use SVM.",
        "For each classification, SVM outputs a positive or negative score indicating the certainty that the test case is positive or negative.",
        "To save space, all four alternative methods are given in Figure 4.",
        "Line 2 initializes some variables for recording the aggregated values for the final decision making.",
        "The four methods are as follows: 1).",
        "Voting: For each sample from userid idj, if it is classified as positive, one vote/count is added to pcount[idj].",
        "The userid with the highest pcount is regarded as the candidate userid, cid (line 15).",
        "Note that the normalization is applied because the sizes of the sample sets Sj can be different for different userids.",
        "Lines 13 and 14 mean that if all documents of all userids are classified as negative (pcount[idj] = 0, which also implies psum[idj] = psqsum[idj] = 0), we use method 4).",
        "2).",
        "ScoreSum: This method works similarly to the voting method above except that instead of counting positive classifications, this method sums up all scores of positive classifications in psum[idj] for each userid (line 9).",
        "The decision is also made similarly (line 16).",
        "3).",
        "ScoreSqSum: This method works similarly to ScoreSum above except that it sums up the squared scores of positive classifications in psqsum[idj] for each userid (line 10).",
        "The decision is also made similarly (line 17).",
        "4).",
        "ScoreMax: This method works similarly to the voting method as well except that it finds the maximum classification score for the documents of each userid (lines 11 and 12).",
        "The decision is made in line 18."
      ]
    },
    {
      "heading": "5 D-features",
      "text": [
        "We now compute s-features (similarity features)",
        "for each non-query document based on a query document.",
        "Since s-features are calculated using d-features of a non-query document and a query document, we thus discuss d-features first, which are extracted from each document itself.",
        "We employ 26 d-features in four categories: length d-features, frequency based d-features, tf.idf based d-features, and richness d-features.",
        "Although many features below have been used in various tasks before, our key contribution is solving a new problem based on a new learning formulation (LSS).",
        "Length d-feature: We derive three length d-features from each raw document: (1) average sentence length (in terms of word count); (2) average word length (in terms of character count in one word); (3) average document length (in terms of word count in one document).",
        "Frequency based d-features: We extract lexical, syntactic, and stylistic tokens from the raw documents and the parsed syntactic trees to produce the following features:",
        "?",
        "Lexical tokens: word unigrams ?",
        "Syntactic tokens: content-independent struc",
        "tures: POS n-grams (1 ?",
        "n ?",
        "3) and rewrite rules (Halteren et al., 1996; Hirst and Feiguina, 2007).",
        "A rewrite rule is a combination of a node and its immediate constituents in a syntactic tree.",
        "For example, the rewrite rule for \"the best book\" is NP->DT+JJS+NN.",
        "?",
        "Common stylistic token: K-length word (1 ?",
        "K ?",
        "15), punctuations, and 157 function words (www.flesl.net/Vocabulary/SinglewordLists/fun ctionwordlist.php).",
        "?",
        "Review specific stylistic tokens: These tokens reflect styles of reviews: all cap words, pairs of quotation marks, pairs of brackets, exclamatory marks, contractions, two or more consecutive non-alphanumeric characters, model auxiliaries (e.g., should, must), word ?recommend?",
        "or ?recommended?, sentences with the first letter capitalized, sentences starting with This is (this is) or This was (this was).",
        "We then treat these tokens as pseudo-words and count their frequency to form frequency d-features.",
        "TF-IDF based d-feature: For the tokens listed in the frequency based features above, we also compute their tf.idf values.",
        "We list these two kinds of d-features separately because they will be used for different s-features later.",
        "Richness d-features: This is a set of vocabulary richness functions used to quantify the diversity of vocabulary in text (Holmes and Forsyth, 1995).",
        "In this paper, we apply them to the counts of word unigrams, POS n-grams (1 ?",
        "n ?",
        "3), and rewrite rules.",
        "Here POS n-grams and rewrite rules are treated as pseudo-words.",
        "Let T be the total number of tokens (words or pseudo-words), and V(T) be the number of different tokens in a document, v be the highest frequency of occurrence of a token, and V(m, T) be the number of tokens which occur m times in the document.",
        "We use the following six richness measures (Yule, 1944; Burrows, 1992; Halteren et al., 1996) given in Table 1: Yule's characteristic (K), Hapax dislegomena (S), Simpson's index (D), Honor's measure (R), Brunet's measure (W), and Hapax legomena (H).",
        "They give us a set of richness d-features about word unigrams, POS n-grams, and rewrite rules.",
        "The extracted d-features are transformed into s-features, which are a set of similarity functions on two documents.",
        "We adopt five types of s-features.",
        "Sim4 Length s-features: This is a set of four similarity functions defined by us.",
        "They are used for d-feature vectors of length.",
        "The four formulae are given in Table 2, where lwq.",
        "(lwd), lsq.",
        "(lsd), and lrq.",
        "(lrd) denote the average word, sentence, and document length respectively, either in query q or non-query document d. They produce four s-features.",
        "Sim3 Sentence s-features: This is a set of three sentence similarity functions (Metzler et al., 2005).",
        "We apply them (called Sim3) to documents.",
        "Sim3 s-features are used for frequency based d-features.",
        "The three formulae are given in Table 3, where f(t, s) is the frequency count of token t in a document s, and lq and ld are the average document length of the query and non-query document, respectively.",
        "Sim7 Retrieval s-features: This is a set of seven similarity functions (Table 4) applicable to all frequency based d-features.",
        "These functions were used in information retrieval (Cao et al., 2006).",
        "d f t d?",
        "?",
        "??",
        "In Table 4, f(t, d) denotes the frequency count of token t in a non-query document d, q denotes the query, D is the entire collection, |.",
        "|is the size of a set, and idf is the inverse document frequency.",
        "These 7 formulae can produce 7 s-features.",
        "SimC tf-idf s-feature: This is the cosine similarity used for d-vectors represented by the tf.idf based d-features.",
        "SimC tf-idf produces one s-feature.",
        "SimC Richness s-feature: This is also cosine similarity.",
        "However, it is applied to the richness d-feature vectors, and produces one s-feature."
      ]
    },
    {
      "heading": "7 Experimental Evaluation",
      "text": [
        "We now evaluate the proposed approach and compare it with baselines.",
        "All our experiments use the SVMperf classifier (Joachims, 2006)."
      ]
    },
    {
      "heading": "7.1 Experiment Setup Experiment Data: We use a set of reviews and",
      "text": [
        "their authors/reviewers from Amazon.com as our experiment data.",
        "We select the authors who have posted more than 30 reviews in the book category.",
        "After cleaning, we have 831 authors, 731 authors for training and 100 authors for testing.",
        "The numbers of reviews in the training and test author set are 59256 and 14308, respectively.",
        "We use the Stanford parser (Klein and Manning, 2003) to generate the grammar structure of review sentences for extracting syntactic d-features.",
        "Note that the authors here are in fact userids.",
        "However, since they are randomly selected from a large number of userids, the probability that two sampled userids belong to the same person is very small.",
        "Thus, it should be safe to assume that each userid here represents a unique author.",
        "Training data: We randomly choose 1 (one) review for each author as the query and all of his/her other reviews as q-positive reviews.",
        "The q-negative reviews consist of reviews randomly selected from the other 730 authors, two reviews per author.",
        "We also tried to use more queries from each author, but they make little difference.",
        "Test data: The test authors are all unseen, i.e., their reviews have not been used in training.",
        "We prepare the test case for each author as follows.",
        "We first divide the reviews of each author into two equal subsets.",
        "The purpose is to simulate the situation where there are two userids idia and idib from the same author ai.",
        "Our objective is that given one userid idia and its query set, we want to find the other userid idib from the same author.",
        "For the review subset of idia (or idib), we randomly select 9 reviews as the query set and another 10 reviews as the sample set for the userid.",
        "The two sets are disjoint.",
        "We don't use more queries or sample reviews from each author since in the review domain most authors do not have many reviews (Jindal and Liu, 2008).",
        "In the experiments, we will vary the number of test userids, the number of queries, and the number of samples.",
        "We use the following format to describe each test data: T<n>_Q<n>S<n>, where T denotes the total number of test userids, Q the query set and S the sample set, and <n> a number.",
        "For example, T50_Q9S10 stands for a test data with 50 userids, and for each userid, 9 reviews are selected as queries and 10 reviews are selected as samples.",
        "* rep",
        "resents a wildcard whose value we can vary.",
        "Note that we use this ?artificial?",
        "data rather than manually labeled data for our experiments because it is very hard to reliably label any gold-standard data manually in this case.",
        "The problem is similar to labeling fake reviews.",
        "In the fake review detection research, researchers have manually label fake reviews and reviewers (Yoo and Gretzel 2009; Lim et al., 2010; Li et al., 2011; Wang et al., 2011).",
        "However, based on the actual fake reviews written using Amazon Mechanical Turk, Ott et al. (2011) have showed that the accuracy of human labeling of fake reviews is very poor.",
        "We also believe that our test data is realistic for evaluation as we can image that the two sets of reviews are from two accounts (userids) of the same author (reviewer).",
        "Two types of experiments: For each author with two userids, we conduct two types of tests.",
        "?",
        "Type I: Identify two userids belong to the same author.",
        "The experiment runs iteratively to test every userid.",
        "In each iteration, we plant one userid of an author in the test set and use the other userid of the same author as the query userid.",
        "That is, in the ith run, the test data consist of the following two components:",
        "1.",
        "Query userid idia and its query set Qia 2.",
        "Test userids {id1a, ?, id(i-1)a, idib, ?, idma}",
        "and their corresponding sample review sets {S1a, ?, S(i-1)a, Sib, ?, Sma}.",
        "Note that the query userid idia and the test userid idib are from the same author.",
        "Our objective is to use Qia to find idib through Sib.",
        "Evaluation measure: We use precision, recall, and F1 score to evaluate Type I experiments as we want to identify all matching pairs.",
        "The errors are ?no pair?",
        "and ?wrong pair?",
        "found.",
        "?",
        "Type II: Type II experiments test the cases when no pair exists.",
        "That is, we do not plant any matching userid for the query userid.",
        "Then, the algorithm should not find anything.",
        "For the ith run, the test data has these components: 1.",
        "Query userid idia and its query set Qia 2.Test userids {id1a, ?, id(i-1)a, id(i+1)a, ?, idma} and their sample review sets {S1a, ?, S(i-1)a, S(i+1)a, ?, Sma}.",
        "idib is not planted.",
        "Evaluation measure: Here we cannot use precision and recall because we are not trying to find any pairs.",
        "We thus use accuracy as our measure.",
        "For each idi, if no pair is found, it is correct.",
        "If a pair is found, it is wrong.",
        "Baseline methods: As mentioned eariler, there are only two works that tried to identify multi-id users.",
        "The first is that in (Chen et al., 2004).",
        "However, as we discussed in related work, their approach is not applicable to reviews.",
        "The other is that in (Novak et al., 2004), which used clustering but assumed that the number of actual authors (or clusters) is known.",
        "This is unrealistic in practice.",
        "Thus we designed three new baselines: TSL: This baseline is based on the traditional supervised learning (TSL).",
        "We use it to evaluate how the traditional approach performs in the original feature space.",
        "In this case, each document in TSL has to be represented as a vector of d-features or traditional n-gram features.",
        "For each test userid id, we build a SVM classifier based on the one vs. all strategy.",
        "That is, for training we use id's queries in T*_Q*S10 as the positive documents, and all queries of the other test userids (e.g., 99 userids if the test data has 100 userids) as the negative documents.",
        "Note that TSL cannot use the 731 userids for training as in LSS because they do not appear in the test data.",
        "In testing, userid id's sample (non-query) documents in T*_Q*S10 are used as positive documents, and the sample documents of all other test userids are used as negative documents.",
        "SimUG: It uses the word unigrams to compare the cosine similarity of queries and samples.",
        "Cosine similarity with unigrams is the most widely used document similarity measure.",
        "SimAD: It uses all d-features to compare the cosine similarity of queries and samples.",
        "For both SimUG and SimAD, their cosine similarity values are used in place of SVM scores of LSS or TSL.",
        "We then apply the same 4 strategies to decide the final author attribution except voting as cosine similarity cannot classify."
      ]
    },
    {
      "heading": "7.2 Results and analysis",
      "text": [
        "1) Effects of positive/total ratio in training set: Since our data is highly skewed and too many negative cases may not be good for classification, we thus performed this experiment to find a good ratio.",
        "Table 5 shows the results for Type I experiments.",
        "From Table 5, we can see that the results are highly accurate.",
        "Even for 100 userids, our method can correctly identify 85% cases.",
        "Here we use the data sets T*_Q9S10 and the decision method is ScoreSqSum, which produces the best result.",
        "The",
        "results for Type II experiments (Table 6) are also accurate.",
        "In most cases, the values of accuracy are higher than 90%.",
        "For all our experiments below, we use the model/classifier trained with 0.4 ratio.",
        "(2) Effects of different decision methods: We show the results of the four proposed decision methods: Voting, ScoreSum, ScoreSqSum, and ScoreMax, using our basic data of T*_Q9S10 with varied number of test userids.",
        "Figure 5(a) shows that ScoreSqSum is the best for Type I experiments.",
        "Figure 5(b) shows ScoreMax is the best for Type II, but ScoreSqSum also does very well.",
        "Below, ScoreSqSum is used as our default method because Type I is more important than Type II.",
        "queries.",
        "We see that more queries give better results, which is easy to understand because more queries give more information.",
        "We use 9 queries per userid in all other experiments.",
        "tried 2, 4, 6, 8, 10 samples per userid.",
        "Although there are some fluctuations for Type II (Fig.7(b)), we can see an upward trend for Type I in Fig. 7(a).",
        "This indicates that more sample documents give better results in general.",
        "The main reason again is that more samples from a userid give more identifying information about the userid.",
        "We use 10 test documents (samples) per userid in all experiments.",
        "(5) Impact of individual s-feature sets: Here we",
        "show the effectiveness of individual s-feature sets.",
        "From Table 7, we see that Sim7Retrieval s-features are extremely important for Type I test."
      ]
    },
    {
      "heading": "Removing Sim7Retrieval causes about 10% to",
      "text": [
        "20% F1 score drop on different datasets.",
        "SimCT-fidf s-features are also useful.",
        "The impacts of other s-features are small.",
        "The same applies to Type II test (Table 8).",
        "On average, using all features is the best.",
        "Hence we use all features in all other experiments above.",
        "(6) Comparing with the three baselines: Similar",
        "to our method, the training data for TSL is highly skewed as it uses a one-vs.-all strategy.",
        "Hence we also investigate the effect of p/t ratio in training for TSL.",
        "Results show that 0.4 ratio is the best setting.",
        "Thus this setting is adopted for TSL in the following experiments.",
        "Note that we cannot conduct p/t ratio experiments for SimAD and SimUG as they are unsupervised methods.",
        "We use ScoreMax for TSL, ScoreSqSum for SimUG and SimAD, respectively, since they perform the best for their corresponding approaches.",
        "Tables 9 and 10 show the results of our LSS method and the baseline methods for Type I and II tests respectively.",
        "For TSL, we use all d-features.",
        "Unigram features gave TSL much worse results and are thus not included here.",
        "From Tables 9 and 10, we can make the following observations.",
        "?",
        "For Type I, F1 scores of LSS are markedly better than those of the three baselines.",
        "The results of SimUG also drop more quickly than LSS with the increased number of userids.",
        "SimAD's results are extremely poor.",
        "These show that LSS is much more superior to the unsupervised methods.",
        "TSL performed the worst, indicating that traditional supervised learning is inappropriate for this task.",
        "There are two main reasons: First, for one vs. all learning, the negative training data actually contain positive documents which are written by the same author using another userid as the positive data, which confuses the classifier.",
        "Second, TSL is unable to build an accurate classifier using the small number of queries (which are training data).",
        "In contrast, our LSS method can exploit a large number of other authors who do not have to appear in testing and thus achieves the huge improvements.",
        "?",
        "For Type II, LSS also performs very well.",
        "The baselines perform well too and even better, which is not surprising because they have difficulty in finding matching pairs for Type I.",
        "Since Type II datasets have no author with multiple userids, naturally the baselines will do well for Type II.",
        "But that is useless because when there are authors with multiple usersids (Type I), they are unable to find them well.",
        "In summary, we can conclude that for Type I tests (there are authors with multiple userids), LSS is dramatically better than all baseline methods.",
        "For Type II tests (there is no author with multiple userids), it also performs very well."
      ]
    },
    {
      "heading": "8 Conclusion",
      "text": [
        "This paper proposed a novel method to identify userids that may be from the same author.",
        "The core of the method is a supervised learning method which learns in a similarity space rather than the document space.",
        "This learning method is able to better determine whether a document may be written by a known author, although no document from the author has been used in training (as long as we have some documents from the author to serve as queries).",
        "To the best of our knowledge, there is no existing method based on linguistic analysis for solving the problem.",
        "Our experimental results based on a large number of reviewers and their reviews show that the proposed algorithm is highly accurate.",
        "It outperforms three baselines markedly."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "We are grateful to the anonymous reviewers for their thoughtful comments.",
        "Tieyun Qian was supported in part by the NSFC Projects (61272275, 61272110, 61202036), and the 111 Project (B07037).",
        "Bing Liu was supported in part by a grant from National Science Foundation (NSF) under no.",
        "IIS-1111092."
      ]
    }
  ]
}
