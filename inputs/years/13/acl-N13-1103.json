{
  "info": {
    "authors": [
      "Nate Kushman",
      "Regina Barzilay"
    ],
    "book": "NAACL",
    "id": "acl-N13-1103",
    "title": "Using Semantic Unification to Generate Regular Expressions from Natural Language",
    "url": "https://aclweb.org/anthology/N13-1103",
    "year": 2013
  },
  "references": [
    "acl-D07-1071",
    "acl-D09-1001",
    "acl-D10-1119",
    "acl-D11-1039",
    "acl-D11-1140",
    "acl-N06-1056",
    "acl-P06-1115",
    "acl-P06-2034",
    "acl-P07-1121",
    "acl-P09-1010",
    "acl-P09-1011",
    "acl-P09-1110",
    "acl-P11-1060",
    "acl-Q13-1005",
    "acl-W05-1506",
    "acl-W10-2903",
    "acl-W98-1308"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We consider the problem of translating natural language text queries into regular expressions which represent their meaning.",
        "The mismatch in the level of abstraction between the natural language representation and the regular expression representation make this a novel and challenging problem.",
        "However, a given regular expression can be written in many semantically equivalent forms, and we exploit this flexibility to facilitate translation by finding a form which more directly corresponds to the natural language.",
        "We evaluate our technique on a set of natural language queries and their associated regular expressions which we gathered from Amazon Mechanical Turk.",
        "Our model substantially outperforms a state-of-the-art semantic parsing baseline, yielding a 29% absolute improvement in accuracy.1"
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Regular expressions (regexps) have proven themselves to be an extremely powerful and versatile formalism that has made its way into everything from spreadsheets to databases.",
        "However, despite their usefulness and wide availability, they are still considered a dark art that even many programmers do not fully understand (Friedl, 2006).",
        "Thus, the ability to automatically generate regular expressions from natural language would be useful in many contexts.",
        "Our goal is to learn to generate regexps from natural language, using a training set of natural language and regular expression pairs such as the one in Figure 1.",
        "We do not assume that the data includes an alignment between fragments of the natural lan",
        "regular expression.3 ducing such an alignment during learning is particularly challenging because oftentimes even humans are unable to perform a fragment-by-fragment alignment.",
        "We can think of this task as an instance of grounded semantic parsing, similar to the work done in the domain of database queries (Kate and Mooney, 2006; Zettlemoyer and Collins, 2005; Kwiatkowski et al., 2010).",
        "However, the current success in semantic parsing relies on two important properties of the data.",
        "First, while the past work did not assume the alignment was given, they did assume that finding a fine grained fragment-by-fragment alignment was possible.",
        "Secondly, the semantic domains considered in the past were strongly typed.",
        "This typing provides constraints which significantly reduce the space of possible parses, thereby greatly reducing the ambiguity.",
        "However, in many interesting domains these two properties may not hold.",
        "In our domain, the alignment between the natural language and the regular expressions often happens at the level of the whole phrase, making fragment-by-fragment alignment impossible.",
        "For example, in Figure 1 no fragment of the regexp maps clearly to the phrase ?three letter?.",
        "Instead, the regexp explicitly represents the fact that there is only two characters after X, which is not stated explicitly by the text description and must be inferred.",
        "Furthermore, regular expressions have 3Our regular expression syntax supports Perl regular expression shorthand which utilizes \\b to represent a break (i.e. a space or the start or end of the line).",
        "Our regular expression syntax also supports intersection (&) and complement(?",
        ").",
        "equivalent to that in Figure 1, yet admits a fragment-by-fragment mapping to the natural language.",
        "(b) shows this mapping.",
        "relatively few type constraints.",
        "The key idea of our work is to utilize semantic unification in the logical domain to disambiguate the meaning of the natural language.",
        "Semantic unification utilizes an inference engine to determine the semantic equality of two syntactically divergent expressions.",
        "This is a departure from past work on semantic parsing which has largely focused on the syntactic interface between the natural language and the logical form, and on example-based semantic equality, neither of which utilize the inference power inherent in many symbolic domains.",
        "To see how we can take advantage of semantic unification, consider the regular expression in Figure 2(a).",
        "This regular expression is semantically equivalent to the regular expression in Figure 1.",
        "Furthermore, it admits a fragment-by-fragment mapping as can be seen in Figure 2(b).",
        "In contrast, as we noted earlier, the regexp in Figure 1 does not admit such a mapping.",
        "In fact, learning can be quite difficult if our training data contains only the regexp in Figure 1.",
        "We can, nonetheless, use the regexp in Figure 2 as a steppingstone for learning if we can use semantic inference to determine the equivalence between the two regular expressions.",
        "More generally, whenever the regexp in the training data does not factorize in a way that facilitates a direct mapping to the natural language description, we must find a regexp which does factorize and be able to compute its equivalence to the regexp we see in the training data.",
        "We compute this equivalence by converting each regexp to a minimal deterministic finite automaton (DFA) and leveraging the fact that minimal DFAs are guaranteed to be the same for semantically equivalent regexps (Hopcroft et al., 1979).",
        "We handle the additional ambiguity stemming from the weak typing in our domain through the use of a more effective parsing algorithm.",
        "The state of the art semantic parsers (Kwiatkowski et al., 2011; Liang et al., 2011) utilize a pruned chart parsing algorithm which fails to represent many of the top parses and is prohibitively slow in the face of weak typing.",
        "In contrast, we use an n-best parser which always represents the most likely parses, and can be made very efficient through the use of the parsing algorithm from Jimenez and Marzal (2000).",
        "Our approach works by inducing a combinatory categorial grammar (CCG) (Steedman, 2001).",
        "This grammar consists of a lexicon which pairs words or phrases with regular expression functions.",
        "The learning process initializes the lexicon by pairing each sentence in the training data with the full regular expression associated with it.",
        "These lexical entries are iteratively refined by considering all possible ways to split the regular expression and all possible ways to split the phrase.",
        "At each iteration we find the n-best parses with the current lexicon, and find the subset of these parses which are correct using DFA equivalence.",
        "We update the weights of a log-linear model based on these parses and the calculated DFA equivalence.",
        "We evaluate our technique using a dataset of sentence/regular expression pairs which we generated using Amazon Mechanical Turk (Turk, 2013).",
        "We find that our model generates the correct regexp for 66% of sentences, while the state-of-the-art semantic parsing technique from Kwiatkowski et al. (2010) generates correct regexps for only 37% of sentences.",
        "The results confirm our hypothesis that leveraging the inference capabilities of the semantic domain can help disambiguate natural language meaning."
      ]
    },
    {
      "heading": "2 Related Work Generating Regular Expressions Past work has",
      "text": [
        "looked at generating regular expressions from natural language using rule based techniques (Ranta, 1998), and also at automatically generating regular expressions from examples (Angluin, 1987).",
        "To the best of our knowledge, however, our work is the first to use training data to learn to automatically generate regular expressions from natural language.",
        "Language Grounding There is a large body of research mapping natural language to some form of meaning representation (Kate and Mooney, 2006; Kate et al., 2005; Raymond and Mooney, 2006; Thompson and Mooney, 2003; Wong and Mooney,",
        "2006; Wong and Mooney, 2007; Zelle and Mooney, 1996; Branavan et al., 2009; Mihalcea et al., 2006; Poon and Domingos, 2009).",
        "In some of the considered domains the issue of semantic equivalence does not arise because of the way the data is generated.",
        "The most directly related work in these domains, is that by Kwiatkowski et al. (2010 and 2011) which is an extension of earlier work on CCG-based semantic parsing by Zettlemoyer and Collins (2005).",
        "Similar to our work, Kwiatkowski et al. utilize unification to find possible ways to decompose the logical form.",
        "However, they perform only syntactic unification.",
        "Syntactic unification determines equality using only variable substitutions and does not take advantage of the inference capabilities available in many semantic domains.",
        "Thus, syntactic unification is unable to determine the equivalence of two logical expressions which use different lexical items, such as ?.*?",
        "and ?.*.*?.",
        "In contrast, our DFA based technique can determine the equivalence of such expressions.",
        "It does this by leveraging the equational inference capabilities of the regular expression domain, making it a form of semantic unification.",
        "Thus, the contribution of our work is to show that using semantic unification to find a deeper level of equivalence helps to disambiguate language meanings.",
        "In many other domains of interest, determining semantic equivalence is important to the learning process.",
        "Previous work on such domains has focused on either heuristic or example-driven measures of semantic equivalence.",
        "For example, Artzi and Zettlemoyer (2011) estimate semantic equivalence using a heuristic loss function.",
        "Other past work has executed the logical form on an example world or in a situated context and then compared the outputs.",
        "This provides a very weak form of semantic equivalence valid only in that world/context (Clarke et al., 2010; Liang et al., 2009; Liang et al., 2011; Chen and Mooney, 2011; Artzi and Zettlemoyer, 2013).",
        "In contrast, our work uses an exact, theoretically sound measure of semantic equivalence that determines whether two logical representations are equivalent in any context, i.e. on any input string."
      ]
    },
    {
      "heading": "3 Background",
      "text": []
    },
    {
      "heading": "3.1 Finding Regexp Equivalence Using DFAs",
      "text": [
        "Regular expressions can be equivalently represented as minimal DFAs, which are guaranteed to be equal function sig.",
        "regexp function signature regexp",
        "lambda calculus along with their regexp syntax.",
        "for the same regular language (Hopcroft et al., 1979).",
        "The DFA representation of a regular expression may be exponentially larger than the the original regular expression.",
        "However, past work has shown that most regular expressions do not exhibit this exponential behavior (Tabakov and Vardi, 2005; Moreira and Reis, 2012), and the conversion process is renowned for its good performance in practice (Moreira and Reis, 2012).",
        "Hence, we compare the equivalence of two regular expressions by converting them to minimal DFAs and comparing the DFAs.",
        "We do this using a modified version of M?ller"
      ]
    },
    {
      "heading": "3.2 Lambda Calculus Representation",
      "text": [
        "To take advantage of the inherent structure of regular expressions, we deterministically convert them from a flat string representation into simply typed lambda calculus expressions.",
        "The full set of functions available in our lambda calculus can be seen in Figure 3.",
        "As can be seen from the figures, our lambda calculus is very weakly typed.",
        "It has only two primitive types, integer (I) and regexp (R), with most arguments being of type R."
      ]
    },
    {
      "heading": "3.3 Parsing",
      "text": [
        "Our parsing model is based on a Combinatory Cate-gorial Grammar.",
        "In CCG parsing most of the grammar complexity is contained in the lexicon, ?, while the parser itself contains only a few simple rewrite rules called combinators.",
        "Lexicon The lexicon, ?, consists of a set of lexical entries that couple natural language with a lambda calculus expression.",
        "Our lexical entries contain words or phrases, each of which is associated with a function from the lambda calculus we described in ?3.2.",
        "For example: 4We set a timeout on this process to catch any cases where the resulting DFA might be prohibitively large.",
        "We use a one second timeout in our experiments, which results in timeouts on less than 0.25% of the regular expressions.",
        "with ?bob?",
        "after ?joe???????",
        "??",
        "???????",
        "?",
        "?",
        "Note that the lambda expressions contain type information indicating the number of arguments and the type of those arguments as described in ?3.2.",
        "However, this information is augmented with a (/) or a (\\) for each argument indicating whether that argument comes from the left or the right, in sentence order.",
        "Thus R\\R/R can be read as a function which first takes an argument of type R on the right then takes another argument of type R on the left, and returns an expression of type R. Combinators Parses are built by combining lexical entries through the use of a set of combinators.",
        "Our parser uses only the two most basic combinators, forward function application and backward function application.",
        "These combinators work as follows:",
        "The forward combinator applies a function to an argument on its right when the type of the argument matches the type of the function's first argument.",
        "The backward combinator works analogously.",
        "Figure 4 shows an example parse."
      ]
    },
    {
      "heading": "4 Parsing Model",
      "text": [
        "For a given lexicon, ?, and sentence, ~w, there will in general be many valid parse trees, t ?",
        "T (~w; ?).",
        "We assign probabilities to these parses using a standard log-linear parsing model with parameters ?",
        ":",
        "Our training data, however, includes only the correct regular expression, r, and not the correct parse, 5Technically, this choice of combinators makes our model just a Categorial Grammar instead of a CCG.",
        "t. The training objective used by the past work in such circumstances, is to maximize the probability of the correct regular expression by marginalizing over all parses which generate that exact regular expression.",
        "Such an objective is limited, however, because it does not allow parses that generate semantically correct regexps which are not syntactically equivalent to r, such as those in Figure 2.",
        "The main departure of our work is to use an objective which allows such parses through the use of the DFA-EQUAL procedure.",
        "DFA-EQUAL uses the process described in ?3.1 to determine whether parse t evaluates to a regexp which is semantically equivalent to r, leading to the following objective:",
        "At testing time, for efficiency reasons, we calculate only the top parse.",
        "Specifically, if r = eval(t) is the regexp which results from evaluating parse t, then we generate t?",
        "= arg maxt?T (~w) p(t|~w; ?,?",
        "), and return r?",
        "= eval(t?",
        ")."
      ]
    },
    {
      "heading": "5 Learning",
      "text": [
        "Our learning algorithm starts by generating a single lexical entry for each training sample which pairs the full sentence, ~wi, with the associated regular expression, ri.",
        "Formally, we initialize the lexicon as ?",
        "= {?~wi, R : ri?",
        "|i = 1 .",
        ".",
        ".",
        "n}.",
        "We then run an iterative process where in each iteration we update both ?",
        "and ?",
        "for each training sample.",
        "Our initial ?",
        "will perfectly parse the training data.",
        "However it won't generalize at all to the test data since the lexical entries contain only full sentences.",
        "Hence, in each iteration we refine the lexicon by splitting existing lexical entries to generate more granular lexical entries which will generalize better.",
        "The candidates for splitting are all lexical entries used by parses which generate the correct regular expression, ri, for the current training sample.",
        "We consider all possible ways to factorize each lexical entry, and we add to ?",
        "a new lexical entry for each possible factorization, as discussed in ?5.2.",
        "Finally, we update ?",
        "by performing a single stochastic gradient ascent update step for each training sample, as discussed in ?5.1.",
        "See Algorithm 1 for details.",
        "This learning approach follows the structure of the previous work on CCG based semantic parsers (Zettlemoyer and Collins, 2005;",
        "Inputs: Training set of sentence regular expression pairs.",
        "{?~wi, ri?",
        "|i = 1 .",
        ".",
        ".",
        "n}",
        "Kwiatkowski et al., 2010).",
        "However, our domain has distinct properties that led to three important departures from this past work.",
        "First, we use the DFA based semantic unification process described in ?3.1 to determine the set of correct parses when performing parameter updates.",
        "This is in contrast to the syntactic unification technique, used by Kwiatkowski et al. (2010), and the example based unification used by other semantic parsers, e.g. Artzi and Zettlemoyer (2011).",
        "Using semantic unification allows us to handle training data which does not admit a fragment-by-fragment mapping between the natural language and the regular expression, such as the example in Figure 2.",
        "Second, our parser is based on the efficient n-best parsing algorithm of Jimenez and Marzal (2000) instead of the pruned chart parsing algorithm used by the past work (Zettlemoyer and Collins, 2005; Kwiatkowski et al., 2010).",
        "As we show in ?8.2, this results in a parser which more effectively represents the most likely parses.",
        "This allows our parser to better handle the large number of potential parses that exist in our domain due to the weak typing.",
        "Third, we consider splitting lexical entries used in any correct parse, while the past work (Zettlemoyer and Collins, 2005; Kwiatkowski et al., 2010) considers splitting only those used in the best parse.",
        "We must utilize a less constrictive splitting policy since our domain does not admit the feature weight initialization technique used in the domains of the past work.",
        "We discuss this in ?5.2.1.",
        "In the remainder of this section we discuss the process for learning ?",
        "and for generating the lexicon, ?."
      ]
    },
    {
      "heading": "5.1 Estimating Theta",
      "text": [
        "To estimate ?",
        "we will use stochastic gradient ascent, updating the parameters based on one training example at a time.",
        "Hence, we can differentiate the objective from equation 1 to get the gradient of parameter ?j for training example i, as follows:",
        "(2) This gives us the standard log-linear gradient, which requires calculating expected feature counts.",
        "We define the features in our model over individual parse productions, admitting the use of dynamic programming to efficiently calculate the unconditioned expected counts.",
        "However, when we condition on generating the correct regular expression, as in the first term in (2), the calculation no longer factorizes, rendering exact algorithms computationally infeasible.",
        "To handle this, we use an approximate gradient calculation based on the n-best parses.",
        "Our n-best parser uses an efficient algorithm developed originally by (Jimenez and Marzal, 2000), and subsequently improved by (Huang and Chiang, 2005).",
        "This algorithm utilizes the fact that the first best parse, t1, makes the optimal choice at each decision point, and the 2nd best parse, t2 must make the same optimal choice at every decision point, except for one.",
        "To execute on this intuition, the algorithm first calculates t1 by generating an unpruned CKY-style parse forest which includes a priority queue of possible subparses for each constituent.",
        "The set of possible 2nd best parses T are those that choose the 2nd best subparse for exactly one constituent of t1 but are otherwise identical to t1.",
        "The algorithm chooses t2 = arg maxt?T p(t).",
        "More generally, T is maintained as a priority queue of possible nth best parses.",
        "At each iteration, i, the algorithm sets ti = arg maxt?T p(t) and augments T by all parses which both differ from ti at exactly one constituent ci and choose the next best possible subparse for ci.",
        "We use the n-best parses to calculate an approximate version of the gradient.",
        "Specifically, Ti is the",
        "set of n-best parses for training sample i, and Ci includes all parses t in Ti such that DFA-EQUAL(t, ri).",
        "We calculate the approximate gradient as:",
        "In contrast to our n-best technique, the past work has calculated equation (2) using a beam search approximation of the full inside-outside algorithm (Zettlemoyer and Collins, 2005; Kwiatkowski et al., 2010; Liang et al., 2011).",
        "Specifically, since the conditional probability of t given r does not factorize, a standard chart parser would need to maintain the full logical form (i.e. regular expression) for each subparse, and there may be an exponential number of such subparses at each chart cell.",
        "Thus, they approximate this full computation using beam search, maintaining only the m-best logical forms at each chart cell.",
        "Qualitatively, our n-best approximation always represents the most likely parses in the approximation, but the number of represented parses scales only linearly with n. In contrast, the number of parses represented by the beam search algorithm of the past work can potentially scale exponentially with the beam size,m, due to its use of dynamic programming.",
        "However, since the beam search prunes myopically at each chart cell, it often prunes out the highest probability parses.",
        "In fact, we find that the single most likely parse is pruned out almost 20% of the time.",
        "Furthermore, our results in ?8 show that the beam search's inability to represent the likely parses significantly impacts the overall performance.",
        "It is also important to note that the runtime of the n-best algorithm scales much better.",
        "Specifically, as n increases, the n-best runtime increases as O(n|~w |log(|~w||P |+ n), where P is the set of possible parse productions.",
        "In contrast, as m is increased, the beam search runtime scales as O(|~w|5m2), where the |~w|5 factor comes from our use of headwords, as discussed in ?6.",
        "In practice, we find that even with n set to 10, 000 and m set to 200, our algorithm still runs almost 20 times faster."
      ]
    },
    {
      "heading": "5.2 Lexical Entry Splitting",
      "text": [
        "Each lexical entry consists of a sequence of n words aligned to a typed regular expression function, ?w0:l, T : r?.",
        "Our splitting algorithm considers all possible ways to split a lexical entry into two new",
        "from the lexical entry ?with bob, R:.*bob.*?.",
        "One possible split of this lexical entry generates the parent lexical entry ?with, R/R:?x.(.*x.*)?",
        "and the child lexical entry, ?bob, R:bob?, whose lambda expressions are represented by (b) and (c), respectively.",
        "lexical entries such that they can be recombined via function application to obtain the original lexical entry.",
        "This process is analogous to the syntactic unification process done by Kwiatkowski et al. (2010).",
        "We first consider all possible ways to split the lambda expression r. The splitting process is most easily explained using a tree representation for r, as shown in Figure 5(a).",
        "This tree format is simply a convenient visual representation of a lambda calculus function, with each node representing one of the function type constants from Figure 3.",
        "Each split, s ?",
        "S(r), generates a child expression sc and a parent expression sp such that r = sp(sc).",
        "For each node, n, in r besides the root node, we generate a split where sc is the subtree rooted at node n. For such splits, sp is the lambda expression r with the sub-expression sc replaced with a bound variable, say x.",
        "In addition to these simple splits, we also consider a set of more complicated splits at each node whose associated function type constant can take any number of arguments, i.e. or, and, or cons.",
        "If C(n) are the children of node n, then we generate a split for each possible subset, {V |V ?",
        "C(n)}.",
        "Note that for cons nodes V must be contiguous.",
        "In ?6 we discuss additional restrictions placed on the splitting process to avoid generating an exponential number of splits.",
        "For the split with subset V , the child tree, sc, is a version of the tree rooted at node n pruned to contain only the children in V .",
        "Additionally, the parent tree, sp, is generated from r by replacing all the children in V with a single bound variable, say x.",
        "Figure 5 shows an example of such a split.",
        "We only consider splits in which sc does not have any bound variables, so its type, Tc, is always either R or I .",
        "The type of sp is then type of the original expression, T augmented by an additional argument of the child type, i.e. either T/Tc or T\\Tc.",
        "Each split s generates two pairs of lexical entries,",
        "one for forward application, and one for backward application.",
        "The set of such pairs of pairs is:",
        "Our model splits all lexical entries used in parses which generate correct regular expressions, i.e. those in Ci, and adds all of the generated lexical entries to ?.",
        "In contrast, the previous work (Zettlemoyer and Collins, 2005; Kwiatkowski et al., 2010) has a very conservative process for adding new lexical entries.",
        "This process relies on a good initialization of the feature weights associated with a new lexical entry.",
        "They perform this initialization using a Giza++ alignment of the words in the training sentences with the names of functions in the associated lambda calculus expression.",
        "Such an initialization is ineffective in our domain since it has very few primitive functions and most of the training examples use more than half of these functions.",
        "Instead, we add new lexical entries more aggressively, and rely on the n-best parser to effectively ignore any lexicon entries which do not generate high probability parses."
      ]
    },
    {
      "heading": "6 Applying the Model",
      "text": [
        "Features To allow inclusion of head words in our features, our chart cells are indexed by start word, end word, and head word.",
        "Thus for each parse production we have a set of features that combine the head word and CCG type, of the two children and the newly generated parent.",
        "Additionally, for each lexical entry ?~wi, R : ri?",
        "?",
        "?, we have four types of features: (1) a feature for ?~wi, R : ri?, (2) a feature for ~wi, (3) a feature for R : ri, and (4) a set of features indicating whether ~wi contains a string literal and whether the leaves of ri contain any exact character matches (rather than character range matches).",
        "Initialization In addition to the sentence level initialization discussed in ?5 we also initialize the lexicon, ?, with two other sets of lexical entries.",
        "The first set is all of the quoted string literals in the natural language phrases from the training set.",
        "Thus for the phrase, ?lines with ?bob?",
        "twice?",
        "we would add the lexical entry ?",
        "?bob?, R:bob ?.",
        "We also add lexical entries for both numeric and word representations of numbers, such as ?",
        "1, R:1?",
        "and ?",
        "one, R:1?.",
        "We add these last two types of lexical entries because learning them from the data is almost impossible due to data sparsity.",
        "Lastly, for every individual word in our training set vocabulary, we add an identity lexical entry whose lambda expression is just a function which takes one argument and returns that argument.",
        "This allows our parser to learn to skip semantically unimportant words in the natural language description, and ensures that it generates at least one parse for every example in the dataset.",
        "At test time we also add both identity lexical entries for every word in the test set vocabulary as well as lexical entries for every quoted string literal seen in the test queries.",
        "Note that the addition of these lexical entries requires only access to the test queries and does not make use of the regular expressions (i.e. labels) in the test data in any way.",
        "Parameters We initialize the weight of all lexical entry features except the identity features to a default value of 1 and initialize all other features to a default weight of 0.",
        "We regularize our log-linear model using the L2-norm and a ?",
        "value of 0.001.",
        "We use a learning rate of ?",
        "= 1.0, set n = 10, 000 in our n-best parser, and run each experiment with 5 random restarts and K = 50 iterations.",
        "We report results using the pocket alorithm technique originated by Gallant (1990).",
        "Constraints on Lexical Entry Splitting To prevent the generation of an exponential number of splits, we constrain the lexical entry splitting process as follows:?",
        "We only consider splits at nodes which are at most a depth of 2 from the root of the original tree.",
        "?",
        "We limit lambda expressions to 2 arguments.",
        "?",
        "In unordered node splits (and and or) the resulting child can contain at most 4 of the arguments.",
        "These restrictions ensure the number of splits is at most an M-degree polynomial of the regexp size.",
        "The unification process used by Kwiatowski et al. (2010) bounded the number of splits similarly."
      ]
    },
    {
      "heading": "7 Experimental Setup",
      "text": [
        "generate their own original natural language queries to capture a subset of the lines in a file (similar to UNIX grep).",
        "In order to compare to example based techniques we also ask the Mechanical Turk workers to generate 5 positive and 5 negative examples for each query.",
        "On oDesk we hired a set of programmers to generate regular expressions for each of these natural language queries.",
        "We split our data into 3 sets of 275 queries each and tested using 3 fold cross validation.",
        "We tuned our parameters separately on each development set but ended up with the same values in each case.",
        "Evaluation Metrics We evaluate by comparing the generated regular expression for each sentence with the correct regular expression using our DFA equivalence technique.",
        "As discussed in ?3.1 this metric is exact, indicating whether the generated regular expression is semantically equivalent to the correct regular expression.",
        "Additionally, as discussed in ?6, our identity lexical entries ensure we generate a valid parse for every sentence, so we report only accuracy instead of precision and recall.",
        "Baselines We compared against six different baselines.",
        "The UBL baseline uses the published code from Kwiatkowski et al. (2010) after configuring it to handle the lambda calculus format of our regular expressions.",
        "The other baselines are ablated and/or modified versions of our model.",
        "The Beam-Parse baselines replace the N-BEST procedure from Algorithm 1 with the beam search algorithm used for parsing by past CCG parsers (Zettlemoyer and Collins, 2005; Kwiatkowski et al., 2010).8 The StringUnify baseline replaces the DFA-EQUAL procedure from Algorithm 1 with exact regular expression string equality.",
        "The HeuristicUnify baselines strengthen this by replacing DFA-EQUAL with a smart heuristic form of semantic unification.",
        "Our heuristic unification procedure first flattens the regexp trees by merging all children into the parent node if they are both of the same type and of type or, and, or cons.",
        "It then sorts all children of the and and or operators.",
        "Finally, it converts both regexps back to a flat string and compares these strings for equivalence.",
        "This process should more effective than any",
        "form of syntactic unification and any simpler heuristics.",
        "The ExampleUnify baseline represents the performance of the example based semantic unification techniques.",
        "It replaces DFA-EQUAL with a procedure that evaluates the regexp on all the positive and negative examples associated with the given query and returns true if all 10 are correctly classified.",
        "Finally, BeamParse-HeuristicUnify-TopParse uses the same algorithm as that for BeamParse-HeuristicUnify except that it only generates lexical entries from the top parse instead of all parses.",
        "This more closely resembles the conservative lexical entry splitting algorithm used by Kwiatkowski et al"
      ]
    },
    {
      "heading": "8 Results",
      "text": [
        "Our model outperforms all of the baselines, as shown in Table 1.",
        "The first three baselines ?",
        "UBL, BeamParse-HeuristicUnify, and BeamParse-HeuristicUnify-TopParse?",
        "represent the algorithm used by Kwiatkowski et al. Our model outperforms the best of these by over 30% in absolute terms and 180% in relative terms.",
        "The improvement in performance of our model over the NBestParse-StringUnify, NBestParse-ExampleUnify and NBestParse-HeuristicUnify baselines highlights the importance of our DFA based semantic unification technique.",
        "Specifically, our model outperforms exact string based unification by over 30%, example based semantic unification by over 13% and our smart heuristic unification procedure by 9%.",
        "These improvements confirm that leveraging exact semantic unification during the learning process helps to disambiguate language meanings."
      ]
    },
    {
      "heading": "8.1 Effect of Additional Training Data",
      "text": [
        "Table 2 shows the change in performance as we increase the amount of training data.",
        "We see that our model provides particularly large gains when there",
        "sented by the n-best algorithm used in our model to the set of parses represented by the beam search algorithm used by the past work.",
        "Note that our n-best algorithm represents 100% of the top 10000 parses.",
        "is a small amount of training data.",
        "These gains decrease as the amount of training data increases because the additional data allows the baseline to learn new lexical entries for every special case.",
        "This reduces the need for the fine grained lexicon decomposition which is enabled by our DFA based unification.",
        "For example, our DFA based model will learn separate lexical entries for ?line?, ?word?, ?starting with?, and ?ending with?.",
        "The baseline instead will just learn separate lexical entries for every possible combination such as ?line starting with?, ?word ending with?, etc.",
        "Our model's ability to decompose, however, allows it to provide equivalent accuracy to even the best baseline with less than half the amount of training data.",
        "Furthermore, we would expect this gain to be even larger for domains with more complex mappings and a larger number of different combinations."
      ]
    },
    {
      "heading": "8.2 Beam Search vs. N-Best",
      "text": [
        "A critical step in the training process is calculating the expected feature counts over all parses that generate the correct regular expression.",
        "In ?4 we discussed the trade-off between approximating this calculation using the n-best parses, as our model does, verses the beam search model used by the past work.",
        "The effect of this trade-off can be seen clearly in Figure 6.",
        "The n-best parser always represents the n-best parses, which is set to 10,000 in our experiments.",
        "In contrast, on the first iteration, the beam search algorithm fails to represent the top parse almost 20% of the time and represents less than 15% of the 10,000 most likely parses.",
        "Even after 10 iterations it still only represents 70% of the top parses and fails to represent the top parse almost 10% of the time.",
        "This difference in representation ability is what provides the more than 30% difference in accuracy between the BeamParse-HeuristicUnify version of our model and the NBestParse-HeuristicUnify version of our model."
      ]
    },
    {
      "heading": "9 Conclusions and Future Work",
      "text": [
        "In this paper, we present a technique for learning a probabilistic CCG which can parse a natural language text search into the regular expression that performs that search.",
        "The key idea behind our approach is to use a DFA based form of semantic unification to disambiguate the meaning of the natural language descriptions.",
        "Experiments on a dataset of natural language regular expression pairs show that our model significantly outperforms baselines based on a state-of-the-art model.",
        "We performed our work on the domain of regular expressions, for which semantic unification is tractable.",
        "In more general domains, semantic unification is undecidable.",
        "Nevertheless, we believe our work motivates the use of semantic inference techniques for language grounding in more general domains, potentially through the use of some form of approximation or by restricting those domains in some way.",
        "For example, SAT and SMT solvers have seen significant success in performing semantic inference for program induction and hardware verification despite the computational intractability of these problems in the general case."
      ]
    },
    {
      "heading": "10 Acknowledgments",
      "text": [
        "The authors acknowledge the support of Battelle Memorial Institute (PO#300662) and NSF (grant IIS-0835652).",
        "We thank Luke Zettlemoyer, Tom Kwiatkowski, Yoav Artzi, Mirella Lapata, the MIT NLP group, and the ACL reviewers for their suggestions and comments.",
        "Any opinions, findings, conclusions, or recommendations expressed in this paper are those of the authors, and do not necessarily reflect the views of the funding organizations."
      ]
    }
  ]
}
