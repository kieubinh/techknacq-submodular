{
  "info": {
    "authors": [
      "Francesco Sartorio",
      "Giorgio Satta",
      "Joakim Nivre"
    ],
    "book": "ACL",
    "id": "acl-P13-1014",
    "title": "A Transition-Based Dependency Parser Using a Dynamic Parsing Strategy",
    "url": "https://aclweb.org/anthology/P13-1014",
    "year": 2013
  },
  "references": [
    "acl-D07-1013",
    "acl-D08-1059",
    "acl-D12-1133",
    "acl-J08-4003",
    "acl-J93-2004",
    "acl-N09-1064",
    "acl-N10-1115",
    "acl-P02-1034",
    "acl-P10-2035",
    "acl-P11-2033",
    "acl-P11-2121",
    "acl-P90-1035",
    "acl-W04-0308",
    "acl-W06-2922"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We present a novel transition-based, greedy dependency parser which implements a flexible mix of bottom-up and top-down strategies.",
        "The new strategy allows the parser to postpone difficult decisions until the relevant information becomes available.",
        "The novel parser has a ?12% error reduction in unlabeled attachment score over an arc-eager parser, with a slowdown factor of 2.8."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Dependency-based methods for syntactic parsing have become increasingly popular during the last decade or so.",
        "This development is probably due to many factors, such as the increased availability of dependency treebanks and the perceived usefulness of dependency structures as an interface to downstream applications, but a very important reason is also the high efficiency offered by dependency parsers, enabling web-scale parsing with high throughput.",
        "The most efficient parsers are greedy transition-based parsers, which only explore a single derivation for each input and relies on a locally trained classifier for predicting the next parser action given a compact representation of the derivation history, as pioneered by Yamada and Matsumoto (2003), Nivre (2003), Attardi (2006), and others.",
        "However, while these parsers are capable of processing tens of thousands of tokens per second with the right choice of classifiers, they are also known to perform slightly below the state-of-the-art because of search errors and subsequent error propagation (McDonald and Nivre, 2007), and recent research on transition-based dependency parsing has therefore explored different ways of improving their accuracy.",
        "The most common approach is to use beam search instead of greedy decoding, in combination with a globally trained model that tries to minimize the loss over the entire sentence instead of a locally trained classifier that tries to maximize the accuracy of single decisions (given no previous errors), as first proposed by Zhang and Clark (2008).",
        "With these methods, transition-based parsers have reached state-of-the-art accuracy for a number of languages (Zhang and Nivre, 2011; Bohnet and Nivre, 2012).",
        "However, the drawback with this approach is that parsing speed is proportional to the size of the beam, which means that the most accurate transition-based parsers are not nearly as fast as the original greedy transition-based parsers.",
        "Another line of research tries to retain the efficiency of greedy classifier-based parsing by instead improving the way in which classifiers are learned from data.",
        "While the classical approach limits training data to parser states that result from oracle predictions (derived from a treebank), these novel approaches allow the classifier to explore states that result from its own (sometimes erroneous) predictions (Choi and Palmer, 2011; Goldberg and Nivre, 2012).",
        "In this paper, we explore an orthogonal approach to improving the accuracy of transition-based parsers, without sacrificing their advantage in efficiency, by introducing a new type of transition system.",
        "While all previous transition systems assume a static parsing strategy with respect to top-down and bottom-up processing, our new system allows a dynamic strategy for ordering parsing decisions.",
        "This has the advantage that the parser can postpone difficult decisions until the relevant information becomes available, in a way that is not possible in existing transition systems.",
        "A second advantage of dynamic parsing is that we can extend the feature inventory of previous systems.",
        "Our experiments show that these advantages lead to significant improvements in parsing accuracy, compared to a baseline parser that uses the arc-eager transition system of Nivre (2003), which is one of the most",
        "widely used static transition systems.",
        "2 Static vs.",
        "Dynamic Parsing",
        "The notions of bottom-up and top-down parsing strategies do not have a general mathematical definition; they are instead specified, often only informally, for individual families of grammar formalisms.",
        "In the context of dependency parsing, a parsing strategy is called purely bottom-up if every dependency h ?",
        "d is constructed only after all dependencies of the form d ?",
        "i have been constructed.",
        "Here h?",
        "d denotes a dependency with h the head node and d the dependent node.",
        "In contrast, a parsing strategy is called purely top-down if h?",
        "d is constructed before any dependency of the form d?",
        "i.",
        "If we consider transition-based dependency parsing (Nivre, 2008), the purely bottom-up strategy is implemented by the arc-standard model of Nivre (2004).",
        "After building a dependency h ?",
        "d, this model immediately removes from its stack node d, preventing further attachment of dependents to this node.",
        "A second popular parser, the arc-eager model of Nivre (2003), instead adopts a mixed strategy.",
        "In this model, a dependency h?",
        "d is constructed using a purely bottom-up strategy if it represents a left-arc, that is, if the dependent d is placed to the left of the head h in the input string.",
        "In contrast, if h ?",
        "d represents a right-arc (defined symmetrically), then this dependency is constructed before any right-arc d ?",
        "i (top-down) but after any left-arc d?",
        "i (bottom-up).",
        "What is important to notice about the above transition-based parsers is that the adopted parsing strategies are static.",
        "By this we mean that each dependency is constructed according to some fixed criterion, depending on structural conditions such as the fact that the dependency represents a left or a right arc.",
        "This should be contrasted with dynamic parsing strategies in which several parsing options are simultaneously available for the dependencies being constructed.",
        "In the context of left-to-right, transition-based parsers, dynamic strategies are attractive for several reasons.",
        "One argument is related to the well-known PP-attachment problem, illustrated in Figure 1.",
        "Here we have to choose whether to attach node P as a dependent of V (arc ?2) or else as a dependent of N1 (arc ?3).",
        "The purely bottom-up arc-standard model has to take a decision as soon as N1 is placed into the stack.",
        "This is so",
        "identifying two alternative choices.",
        "because the construction of ?1 excludes ?3 from the search space, while the alternative decision of shifting P into the stack excludes ?2.",
        "This is bad, because the information about the correct attachment could come from the lexical content of node P. The arc-eager model performs slightly better, since it can delay the decision up to the point in which ?1 has been constructed and P is read from the buffer.",
        "However, at this point it must make a commitment and either construct ?3 or pop N1 from the stack (implicitly committing to ?2) before N2 is read from the buffer.",
        "In contrast with this scenario, in the next sections we implement a dynamic parsing strategy that allows a transition system to decide between the attachments ?2 and ?3 after it has seen all of the four nodes V, N1, P and N2.",
        "Other additional advantages of dynamic parsing strategies with respect to static strategies are related to the increase in the feature inventory that we apply to parser states, and to the increase of spurious ambiguity.",
        "However, these arguments are more technical than the PP-attachment argument above, and will be discussed later."
      ]
    },
    {
      "heading": "3 Dependency Parser",
      "text": [
        "In this section we present a novel transition-based parser for projective dependency trees, implementing a dynamic parsing strategy."
      ]
    },
    {
      "heading": "3.1 Preliminaries",
      "text": [
        "For non-negative integers i and j with i ?",
        "j, we write [i, j] to denote the set {i, i+1, .",
        ".",
        ".",
        ", j}.",
        "When i > j, [i, j] is the empty set.",
        "We represent an input sentence as a string w = w0 ?",
        "?",
        "?wn, n ?",
        "1, where token w0 is a special root symbol and, for each i ?",
        "[1, n], token wi = (i, ai, ti) encodes a lexical element ai and a part-of-speech tag ti associated with the i-th word in the sentence.",
        "A dependency tree for w is a directed, ordered tree Tw = (Vw, Aw), where Vw = {wi |i ?",
        "[0, n]} is the set of nodes, and Aw ?",
        "Vw ?",
        "Vw is the set of arcs.",
        "Arc (wi, wj) encodes a dependency wi ?",
        "wj .",
        "A sample dependency tree (excluding w0) is displayed in Figure 2.",
        "If (wi, wj) ?",
        "Aw for j < i, we say that wj is a left child of wi; a right child is defined in a symmetrical way.",
        "The left spine of Tw is an ordered sequence ?u1, .",
        ".",
        ".",
        ", up?",
        "with p ?",
        "1 and ui ?",
        "Vw for i ?",
        "[1, p], consisting of all nodes in a descending path from the root of Tw taking the leftmost child node at each step.",
        "More formally, u1 is the root node of Tw and ui is the leftmost child of ui?1, for i ?",
        "[2, p].",
        "The right spine of Tw is defined symmetrically; see again Figure 2.",
        "Note that the left and the right spines share the root node and no other node."
      ]
    },
    {
      "heading": "3.2 Basic Idea",
      "text": [
        "Transition-based dependency parsers use a stack data structure, where each stack element is associated with a tree spanning some (contiguous) sub-string of the input w. The parser can combine two trees T and T ?",
        "through attachment operations, called left-arc or right-arc, under the condition that T and T ?",
        "appear at the two topmost positions in the stack.",
        "Crucially, only the roots of T and T ?",
        "are available for attachment; see Figure 3(a).",
        "In contrast, a stack element in our parser records the entire left spine and right spine of the associated tree.",
        "This allows us to extend the inventory of the attachment operations of the parser by including the attachment of tree T as a dependent of any node in the left or in the right spine of a second tree T ?, provided that this does not violate projectivity.1 See Figure 3(b) for an example.",
        "The new parser implements a mix of bottom-up and top-down strategies, since after any of the attachments in Figure 3(b) is performed, additional dependencies can still be created for the root of T .",
        "Furthermore, the new parsing strategy is clearly dy-1A dependency tree for w is projective if every subtree has a contiguous yield in w.",
        "namic, due to the free choice in the timing for these attachments.",
        "The new strategy is more powerful than the strategy of the arc-eager model, since we can use top-down parsing at left arcs, which is not allowed in arc-eager parsing, and we do not have the restrictions of parsing right arcs (h?",
        "d) before the attachment of right dependents at node d. To conclude this section, let us resume our discussion of the PP-attachment example in Figure 1.",
        "We observe that the new parsing strategy allows the construction of a tree T ?",
        "consisting of the only dependency V?",
        "N1 and a tree T , placed at the right of T ?, consisting of the only dependency P?",
        "N2.",
        "Since the right spine of T ?",
        "consists of nodes V and N1, we can freely choose between attachment V?",
        "P and attachment N1?",
        "P. Note that this is done after we have seen node N2, as desired."
      ]
    },
    {
      "heading": "3.3 Transition-based Parser",
      "text": [
        "We assume the reader is familiar with the formal framework of transition-based dependency parsing originally introduced by Nivre (2003); see Nivre (2008) for an introduction.",
        "To keep the notation at a simple level, we only discuss here the unlabeled version of our parser; however, a labeled extension is used in ?5 for our experiments.",
        "Our transition-based parser uses a stack data structure to store partial parses for the input string w. We represent the stack as an ordered sequence ?",
        "= [?d, .",
        ".",
        ".",
        ", ?1], d ?",
        "0, of stack elements, with the topmost element placed at the right.",
        "When d = 0, we have the empty stack ?",
        "= [].",
        "Sometimes we use the vertical bar to denote the append operator for ?, and write ?",
        "= ?",
        "?|?1 to indicate that ?1 is the topmost element of ?.",
        "A stack element is a pair",
        "where the ordered sequences ?uk,1, .",
        ".",
        ".",
        ", uk,p?",
        "and",
        "?vk,1, .",
        ".",
        ".",
        ", vk,q?",
        "are the left and the right spines, respectively, of the tree associated with ?k.",
        "Recall that uk,1 = vk,1, since the root node of the associated tree is shared by the two spines.",
        "The parser also uses a buffer to store the portion of the input string still to be processed.",
        "We represent the buffer as an ordered sequence ?",
        "= [wi, .",
        ".",
        ".",
        ", wn], i ?",
        "0, of tokens from w, with the first element placed at the left.",
        "Note that ?",
        "always represents a (non-necessarily proper) suffix of w. When i > n, we have the empty buffer ?",
        "= [].",
        "Sometimes we use the vertical bar to denote the append operator for ?, and write ?",
        "= wi|??",
        "to indicate that wi is the first token of ?",
        "; consequently, we have ??",
        "= [wi+1, .",
        ".",
        ".",
        ", wn].",
        "When processing w, the parser reaches several states, technically called configurations.",
        "A configuration of the parser relative to w is a triple c = (?, ?,A), where ?",
        "and ?",
        "are a stack and a buffer, respectively, and A ?",
        "Vw ?",
        "Vw is a set of arcs.",
        "The initial configuration for w is ([], [w0, .",
        ".",
        ".",
        ", wn], ?).",
        "The set of terminal configurations consists of all configurations of the form ([?1], [], A), where ?1 is associated with a tree having root w0, that is, u1,1 = v1,1 = w0, and A is any set of arcs.",
        "The core of a transition-based parser is the set of its transitions.",
        "Each transition is a binary relation defined over the set of configurations of the parser.",
        "Since the set of configurations is infinite, a transition is infinite as well, when viewed as a set.",
        "However, transitions can always be specified by some finite means.",
        "Our parser uses three types of transitions, defined in what follows.",
        "?",
        "SHIFT, or sh for short.",
        "This transition removes the first node from the buffer and pushes into the stack a new element, consisting of the left and right spines of the associated tree.",
        "More formally (?,wi|?,A) `sh (?|(?wi?, ?wi?",
        "), ?, A) ?",
        "LEFT-ARCk, k ?",
        "1, or lak for short.",
        "Let h be the k-th node in the left spine of the topmost tree in the stack, and let d be the root node of the second topmost tree in the stack.",
        "This transition creates a new arc h?",
        "d. Furthermore, the two topmost stack elements are replaced by a new element associated with the tree resulting from the h?",
        "d attachment.",
        "The transition does not advance with the reading of the buffer.",
        "More formally",
        "and where we have set h = u1,k and d = u2,1.",
        "?",
        "RIGHT-ARCk, k ?",
        "1, or rak for short.",
        "This transition is defined symmetrically with respect to lak.",
        "We have (?",
        "?|?2|?1, ?, A) `rak (?",
        "?|?ra, ?, A ?",
        "{h?",
        "d}) where ?1 and ?2 are as in the lak case,",
        "and we have set h = v2,k and d = v1,1.",
        "Transitions lak and rak are parametric in k, where k is bounded by the length of the input string and not by a fixed constant (but see also the experimental findings in ?5).",
        "Thus our system uses an unbounded number of transition relations, which has an apparent disadvantage for learning algorithms.",
        "We will get back to this problem in ?4.3.",
        "A complete computation relative to w is a sequence of configurations c1, c2, .",
        ".",
        ".",
        ", ct, t ?",
        "1, such that c1 and ct are initial and final configurations, respectively, and for each i ?",
        "[2, t], ci is produced by the application of some transition to ci?1.",
        "It is not difficult to see that the transition-based parser specified above is sound, meaning that the set of arcs constructed in any complete computation on w is always a dependency tree for w. The parser is also complete, meaning that every (projective) dependency tree for w is constructed by some complete computation on w. A mathematical proof of this statement is beyond the scope of this paper, and will not be provided here."
      ]
    },
    {
      "heading": "3.4 Deterministic Parsing Algorithm",
      "text": [
        "The transition-based parser of the previous section is a nondeterministic device, since several transitions can be applied to a given configuration.",
        "This might result in several complete computations",
        "for w. We present here an algorithm that runs the parser in pseudo-deterministic mode, greedily choosing at each configuration the transition that maximizes some score function.",
        "Algorithm 1 takes as input a string w and a scoring function score() defined over parser transitions and parser configurations.",
        "The scoring function will be the subject of ?4 and is not discussed here.",
        "The output of the parser is a dependency tree for w. At each iteration the algorithm checks whether there are at least two elements in the stack and, if this is not the case, it shifts elements from the buffer to the stack.",
        "Then the algorithm uses the function score() to evaluate all transitions that can be applied under the current configuration c = (?, ?,A), and it applies the transition with the highest score, updating the current configuration.",
        "To parse a sentence of length n (excluding the root token w0) the algorithm applies exactly 2n+1 transitions.",
        "In the worst case, each transition application involves 1 + p+ s transition evaluations.",
        "We therefore conclude that the algorithm always reaches a configuration with an empty buffer and a stack which contains only one element.",
        "Then the algorithm stops, returning the dependency tree whose arc set is defined as in the current configuration."
      ]
    },
    {
      "heading": "4 Model and Training",
      "text": [
        "In this section we introduce the adopted learning algorithm and discuss the model parameters."
      ]
    },
    {
      "heading": "4.1 Learning Algorithm",
      "text": [
        "We use a linear model for the score function in",
        "p?",
        "length of left spine of ?1 s?",
        "length of right spine of ?2",
        "update c with bestCorrectT a feature vector representation for a transition t applying to a configuration c. The function ?",
        "will be discussed at length in ?4.3.",
        "The vector ~?",
        "is trained using the perceptron algorithm in combination with the averaging method to avoid overfitting; see Fre-und and Schapire (1999) and Collins and Duffy (2002) for details.",
        "The training data set consists of pairs (w,Ag), where w is a sentence and Ag is the set of arcs of the gold (desired) dependency tree for w. At training time, each pair (w,Ag) is processed using the learning algorithm described as Algorithm 2.",
        "The algorithm is based on the notions of correct and incorrect transitions, discussed at length in ?4.2.",
        "Algorithm 2 parsesw following Algorithm 1 and using the current ~?, until the highest score selected transition bestT is incorrect according to Ag .",
        "When this happens, ~?",
        "is updated by decreasing the weights of the features associated with the incorrect bestT and by increasing the weights of the features associated with the transition bestCorrectT having the highest score among all possible correct transitions.",
        "After each update, the learning algorithm resumes parsing from the current configuration by applying bestCorrectT , and moves on using the updated weights."
      ]
    },
    {
      "heading": "4.2 Correct and Incorrect Transitions",
      "text": [
        "Standard transition-based dependency parsers are trained by associating each gold tree with a canonical complete computation.",
        "This means that, for each configuration of interest, only one transition",
        "tions; drawn arcs are in Ag but have not yet been added to the configuration.",
        "Transition sh is incorrect for configuration (a) and (b); sh and ra1 are correct for (c); sh and la1 are correct for (d).",
        "leading to the gold tree is considered as correct.",
        "In this paper we depart from such a methodology, and follow Goldberg and Nivre (2012) in allowing more than one correct transition for each configuration, as explained in detail below.",
        "Let (w,Ag) be a pair in the training set.",
        "In ?3.3 we have mentioned that there is always a complete computation on w that results in the construction of the set Ag .",
        "In general, there might be more than one computation forAg .",
        "This means that the parser shows spurious ambiguity.",
        "Observe that all complete computations for Ag share the same initial configuration cI,w and final configuration cF,Ag .",
        "Consider now the set C(w) of all configurations c that are reachable from cI,w, meaning that there exists a sequence of transitions that takes the parser from cI,w to c. A configuration c ?",
        "C(w) is correct for Ag if cF,Ag is reachable from c; otherwise, c is incorrect for Ag .",
        "Let c ?",
        "C(w) be a correct configuration for Ag .",
        "A transition t is correct for c and Ag if c `t c?",
        "and c?",
        "is correct for Ag ; otherwise, t is incorrect for c and Ag .",
        "The next lemma provides a characterization of correct and incorrect transitions; see Figure 4 for examples.",
        "We use this characterization in the implementation of predicate isCorrect() in Algorithm 2.",
        "Lemma 1 Let (w,Ag) be a pair in the training set and let c ?",
        "C(w) with c = (?, ?,A) be a correct configuration for Ag .",
        "Let alo v1,k, k ?",
        "[1, q], be the nodes in the right spine of ?1.",
        "(i) lak and rak are incorrect for c and Ag if and only if they create a new arc (h?",
        "d) 6?",
        "Ag ; (ii) sh is incorrect for c and Ag if and only if the following conditions are both satisfied: (a) there exists an arc (h ?",
        "d) in Ag such that h is in ?",
        "and d = v1,1; (b) there is no arc (h?",
        "?",
        "d?)",
        "in Ag with h?",
        "= v1,k, k ?",
        "[1, q], and d?",
        "in ?.",
        "2 PROOF (SKETCH) To prove part (i) we focus on",
        "transition rak; a similar argument applies to lak.",
        "The ?if?",
        "statement in part (i) is self-evident.",
        "?Only if?.",
        "Assuming that transition rak creates a new arc (h?",
        "d) ?",
        "Ag , we argue that from configuration c?",
        "with c `rak c?",
        "we can still reach the final configuration associated with Ag .",
        "We have h = v2,k and d = u1,1.",
        "The tree fragments in ?",
        "with roots v2,k+1 and u1,1 must be adjacent siblings in the tree associated with Ag , since c is a correct configuration for Ag and (v2,k ?",
        "u1,1) ?",
        "Ag .",
        "This means that each of the nodes v2,k+1, .",
        ".",
        ".",
        ", v2,s in the right spine in ?2 in c must have already acquired all of its right dependents, since the tree is projective.",
        "Therefore it is safe for transition rak to eliminate the nodes v2,k+1, .",
        ".",
        ".",
        ", v2,s from the right spine in ?2.",
        "We now deal with part (ii).",
        "Let c `sh c?, c?",
        "= (?",
        "?, ?",
        "?, A).",
        "?If?.",
        "Assuming (ii)a and (ii)b, we argue that c?",
        "is incorrect.",
        "Node d is the head of ??2.",
        "Arc (h?",
        "d) is not inA, and the only way we could create (h?",
        "d) from c?",
        "is by reaching a new configuration with d in the topmost stack symbol, which amounts to say that ?",
        "?1 can be reduced by a correct transition.",
        "Node h is in some ?",
        "?i, i > 2, by (ii)a.",
        "Then reduction of ?",
        "?1 implies that the root of ?",
        "?1 is reachable from the root of ?",
        "?2, which contradicts (ii)b.",
        "?Only if?.",
        "Assuming (ii)a is not satisfied, we argue that sh is correct for c and Ag .",
        "There must be an arc (h?",
        "d) not in A with d = v1,1 and h is some token wi in ?.",
        "From stack ??",
        "= ???|??2|?",
        "?1 it is always possible to construct (h?",
        "d) consuming the substring of ?",
        "up to wi and ending up with stack ??",
        "?|?red , where ?red is a stack element with root wi.",
        "From there, the parser can move on to the final configuration cF,Ag .",
        "A similar argument applies if we assume that (ii)b is not satisfied.",
        "From condition (i) in Lemma 1 and from the fact that there are no cycles in Ag , it follows that there is at most one correct transition among the transitions of type lak or rak.",
        "From condition (ii) in the lemma we can also see that the existence of a correct transition of type lak or rak for some configuration does not imply that the sh transition is incorrect",
        "for the same configuration; see Figures 4(c,d) for examples.",
        "It follows that for a correct configuration there might be at most 2 correct transitions.",
        "In our training experiments for English in ?5 we observe 2 correct transitions for 42% of the reached configurations.",
        "This nondeterminism is a byproduct of the adopted dynamic parsing strategy, and eventually leads to the spurious ambiguity of the parser.",
        "As already mentioned, we do not impose any canonical form on complete computations that would hardwire a preference for some correct transition and get rid of spurious ambiguity.",
        "Following Goldberg and Nivre (2012), we instead regard spurious ambiguity as an additional resource of our parsing strategy.",
        "Our main goal is that the training algorithm learns to prefer ash transition in a configuration that does not provide enough information for the choice of the correct arc.",
        "In the context of dependency parsing, the strategy of delaying arc construction when the current configuration is not informative is called the easy-first strategy, and has been first explored by Goldberg and Elhadad (2010)."
      ]
    },
    {
      "heading": "4.3 Feature Extraction",
      "text": [
        "In existing transition-based parsers a set of atomic features is statically defined and extracted from each configuration.",
        "These features are then combined together into complex features, according to some feature template, and joined with the available transition types.",
        "This is not possible in our system, since the number of transitions lak and rak is not bounded by a constant.",
        "Furthermore, it is not meaningful to associate transitions lak and rak, for any k ?",
        "1, always with the same features, since the constructed arcs impinge on nodes at different depths in the involved spines.",
        "It seems indeed more significant to extract information that is local to the arc h?",
        "d being constructed by each transition, such as for instance the grandparent and the great grandparent nodes of d. This is possible if we introduce a higher level of abstraction than in existing transition-based parsers.",
        "We remark here that this abstraction also makes the feature representation more similar to the ones typically found in graph-based parsers, which are centered on arcs or subgraphs of the dependency tree.",
        "We index the nodes in the stack ?",
        "relative to the head node of the arc being constructed, in case of the transitions lak or rak, or else relative to the root node of ?1, in case of the transition sh.",
        "More precisely, let c = (?, ?,A) be a configuration and let t be a transition.",
        "We define the context of c and t as the tuple C(c, t) = (s3, s2, s1, q1, q2, gp, gg), whose components are placeholders for word tokens in ?",
        "or in ?.",
        "All these placeholders are specified in Table 1, for each c and t .",
        "Figure 5 shows an example of feature extraction for the displayed configuration c = (?, ?,A) and the transition la2.",
        "In this case we have s3 = u3,1,",
        "gg = none because the head of gp is not available in c. Note that in Table 1 placeholders are dynamically assigned in such a way that s1 and s2 refer to the nodes in the constructed arc h?",
        "d, and gp, gg refer to the grandparent and the great grandparent nodes, respectively, of d. Furthermore, the node assigned to s3 is the parent node of s2, if such a node is defined; otherwise, the node assigned to s3 is the root of the tree fragment in the stack underneath ?2.",
        "Symmetrically, placeholders q1 and q2 refer to the parent and grandparent nodes of s1, respectively, when these nodes are defined; otherwise, these placeholders get assigned tokens from the buffer.",
        "See again Figure 5.",
        "Finally, from the placeholders in C(c, t) we extract a standard set of atomic features and their complex combinations, to define the function ?.",
        "Our feature template is an extended version of the feature template of Zhang and Nivre (2011), originally developed for the arc-eager model.",
        "The extension is obtained by adding top-down features for left-arcs (based on placeholders gp and gg), and by adding right child features for the first stack element.",
        "The latter group of features is usually exploited for the arc-standard model, but is undefined for the arc-eager model."
      ]
    },
    {
      "heading": "5 Experimental Assessment",
      "text": [
        "Performance evaluation is carried out on the Penn Treebank (Marcus et al., 1993) converted to Stanford basic dependencies (De Marneffe et al., 2006).",
        "We use sections 2-21 for training, 22 as development set, and 23 as test set.",
        "The part-of-speech tags are assigned by an automatic tagger with accuracy 97.1%.",
        "The tagger used on the training set is trained on the same data set by using four-way jackknifing, while the tagger used on the development and test sets is trained on all the training set.",
        "We train an arc-labeled version of our parser.",
        "In the first three lines of Table 2 we compare",
        "context sh lak rak placeholder k = 1 k = 2 k > 2 k = 1 k = 2 k > 2",
        "sh or lak, rak, k ?",
        "1.",
        "Symbols uj,k and vj,k are the k-th nodes in the left and right spines, respectively, of stack element ?j , with uj,1 = vj,1 being the shared root of ?j ; none is an artificial element used when some context's placeholder is not available.",
        "tuation, for unlabeled attachment score (UAS), labeled attachment score (LAS), unlabeled exact match (UEM).",
        "the accuracy of our parser against our implementation of the arc-eager and arc-standard parsers.",
        "For the arc-eager parser, we use the feature template of Zhang and Nivre (2011).",
        "The same template is adapted to the arc-standard parser, by removing the top-down parent features and by adding the right child features for the first stack element.",
        "It turns out that our feature template, described in ?4.3, is the exact merge of the templates used for the arc-eager and the arc-standard parsers.",
        "We train all parsers up to 30 iterations, and for each parser we select the weight vector ~?",
        "from the iteration with the best accuracy on the development set.",
        "All our parsers attach the root node at the end of the parsing process, following the ?None?",
        "approach discussed by Ballesteros and Nivre (2013).",
        "Punctuation is excluded in all evaluation metrics.",
        "Considering UAS, our parser provides an improvement of 1.15 over the arc-eager parser and an improvement of 1.31 over the arc-standard parser, that is an error reduction of ?12% and ?13%, respectively.",
        "Considering LAS, we achieve improvements of 1.33 and 1.47, with an error reduction of ?11% and ?12%, over the arc-eager and the arc-standard parsers, respectively.",
        "We speculate that the observed improvement of our parser can be ascribed to two distinct components.",
        "The first component is the left-/right-spine representation for stack elements, introduced in ?3.3.",
        "The second component is the easy-first strategy, implemented on the basis of the spurious ambiguity of our parser and the definition of correct/incorrect transitions in ?4.2.",
        "In this perspective, we observe that our parser can indeed be viewed as an arc-standard model augmented with (i) the spine representation, and (ii) the easy-first strategy.",
        "More specifically, (i) generalizes the la/ra transitions to the lak/rak transitions, introducing a top-down component into the purely bottom-up arc-standard.",
        "On the other hand, (ii) drops the limitation of canonical computations for the arc-standard, and leverages",
        "on the spurious ambiguity of the parser to enlarge the search space.",
        "The two components above are mutually independent, meaning that we can individually implement each component on top of an arc-standard model.",
        "More precisely, the arc-standard + spine model uses the transitions lak/rak but retains the definition of canonical computation, defined by applying each lak/rak transition as soon as possible.",
        "On the other hand, the arc-standard + easy-first model retains the original la/ra transitions but is trained allowing any correct transition at each configuration.",
        "In this case the characterization of correct and incorrect configurations in Lemma 1 has been adapted to transitions la/ra, taking into account the bottom-up constraint.",
        "With the purpose of incremental comparison, we report accuracy results for the two ?incremental?",
        "models in the last two lines of Table 2.",
        "Analyzing these results, and comparing with the plain arc-standard, we see that the spine representation and the easy-first strategy individually improve accuracy.",
        "Moreover, their combination into our model (third line of Table 2) works very well, with an overall improvement larger than the sum of the individual contributions.",
        "We now turn to a computational analysis.",
        "At each iteration our parser evaluates a number of transitions bounded by ?+1, with ?",
        "the maximum value of the sum of the lengths of the left spine in ?1 and of the right spine in ?2.",
        "Quantity ?",
        "is bounded by the length n of the input sentence.",
        "Since the parser applies exactly 2n + 1 transitions, worst case running time is O(n2).",
        "We have computed the average value of ?",
        "on our English data set, resulting in 2.98 (variance 2.15) for training set, and 2.95 (variance 1.96) for development set.",
        "We conclude that, in the expected case, running time is O(n), with a slow down constant which is rather small, in comparison to standard transition-based parsers.",
        "Accordingly, when running our parser against our implementation of the arc-eager and arc-standard models, we measured a slowdown of 2.8 and 2.2, respectively.",
        "Besides the change in representation, this slowdown is also due to the increase in the number of features in our system.",
        "We have also checked the worst case value of ?",
        "in our data set.",
        "Interestingly, we have seen that for strings of length smaller than 40 this value linearly grows with n, and for longer strings the growth stops, with a maximum worst case observed value of 22."
      ]
    },
    {
      "heading": "6 Concluding Remarks",
      "text": [
        "We have presented a novel transition-based parser using a dynamic parsing strategy, which achieves a ?12% error reduction in unlabeled attachment score over the static arc-eager strategy and even more over the (equally static) arc-standard strategy, when evaluated on English.",
        "The idea of representing the right spine of a tree within the stack elements of a shift-reduce device is quite old in parsing, predating empirical approaches.",
        "It has been mainly exploited to solve the PP-attachment problem, motivated by psycholinguistic models.",
        "The same representation is also adopted in applications of discourse parsing, where right spines are usually called right frontiers; see for instance Subba and Di Eugenio (2009).",
        "In the context of transition-based dependency parsers, right spines have also been exploited by Kitagawa and Tanaka-Ishii (2010) to decide where to attach the next word from the buffer.",
        "In this paper we have generalized their approach by introducing the symmetrical notion of left spine, and by allowing attachment of full trees rather than attachment of a single word.2 Since one can regard a spine as a stack in itself, whose elements are tree nodes, our model is reminiscent of the embedded pushdown automata of Schabes and Vijay-Shanker (1990), used to parse tree adjoining grammars (Joshi and Schabes, 1997) and exploiting a stack of stacks.",
        "However, by imposing projectivity, we do not use the extra-power of the latter class.",
        "An interesting line of future research is to combine our dynamic parsing strategy with a training method that allows the parser to explore transitions that apply to incorrect configurations, as in Goldberg and Nivre (2012)."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We wish to thank Liang Huang and Marco Kuhl-mann for discussion related to the ideas reported in this paper, and the anonymous reviewers for their useful suggestions.",
        "The second author has been partially supported by MIUR under project PRIN No.",
        "2010LYA9RH 006.",
        "2Accuracy comparison of our work with Kitagawa and Tanaka-Ishii (2010) is not meaningful, since these authors have evaluated their system on the same data set but based on gold part-of-speech tags (personal communication)."
      ]
    }
  ]
}
