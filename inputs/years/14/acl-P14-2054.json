{
  "info": {
    "authors": [
      "Xian Qian",
      "Yang Liu"
    ],
    "book": "ACL",
    "id": "acl-P14-2054",
    "title": "Polynomial Time Joint Structural Inference for Sentence Compression",
    "url": "https://aclweb.org/anthology/P14-2054",
    "year": 2014
  },
  "references": [
    "acl-C96-1058",
    "acl-D10-1001",
    "acl-D13-1047",
    "acl-D13-1156",
    "acl-E06-1038",
    "acl-P05-1012",
    "acl-P09-2066",
    "acl-P11-1049",
    "acl-P12-2069",
    "acl-P13-1101",
    "acl-W09-1801",
    "acl-W13-3508"
  ],
  "sections": [
    {
      "text": [
        "Abstract",
        "We propose two polynomial time inference algorithms to compress sentences under bigram and dependency-factored objectives.",
        "The first algorithm is exact and requires O(n 6 ) running time.",
        "It extends Eisner's cubic time parsing algorithm by using virtual dependency arcs to link deleted words.",
        "Two signatures are added to each span, indicating the number of deleted words and the rightmost kept word within the span.",
        "The second algorithm is a fast approximation of the first one.",
        "It relaxes the compression ratio constraint using Lagrangian relaxation, and thereby requires O(n 4 ) running time.",
        "Experimental results on the popular sentence compression corpus demonstrate the effectiveness and efficiency of our proposed approach."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Sentence compression aims to shorten a sentence by removing uninformative words to reduce reading time.",
        "It has been widely used in compressive summarization (Liu and Liu, 2009; Li et al., 2013; Martins and Smith, 2009; Chali and Hasan, 2012; Qian and Liu, 2013).",
        "To make the compressed sentence readable, some techniques consider the n-gram language models of the compressed sentence (Clarke and Lapata, 2008; Mc-Donald, 2006).",
        "Recent studies used a subtree deletion model for compression (Berg-Kirkpatrick et al., 2011; Morita et al., 2013; Qian and Liu, 2013), which deletes a word only if its modifier in the parse tree is deleted.",
        "Despite its empirical suc-cess, such a model fails to generate compressions that are not subject to the subtree constraint (see Figure 1).",
        "In fact, we parsed the Edinburgh sentence compression corpus using the MSTparser 1 , 1 http://sourceforge.net/projects/mstparser/ Warrensays the economy continues the steady improvementROOT Warren says steadythe economy continues the improvementROOT Figure 1: The compressed sentence is not a subtree of the original sentence.",
        "Words in gray are removed.",
        "and found that 2561 of 5379 sentences (47.6%) do not satisfy the subtree deletion model.",
        "Methods beyond the subtree model are also explored.",
        "Trevor et al. proposed synchronous tree substitution grammar (Cohn and Lapata, 2009), which allows local distortion of the tree topology and can thus naturally capture structural mismatches.",
        "(Genest and Lapalme, 2012; Thadani and McKeown, 2013) proposed the joint compression model, which simultaneously considers the n-grammodel and dependency parse tree of the compressed sentence.",
        "However, the time complexity greatly increases since the parse tree dynamically depends on the compression.",
        "They used Integer Linear Programming (ILP) for inference which requires exponential running time in the worst case.",
        "In this paper, we propose a new exact decoding algorithm for the joint model using dynamic programming.",
        "Our method extends Eisner's cubic time parsing algorithm by adding signatures to each span, which indicate the number of deleted words and the rightmost kept word within the span, resulting in O(n 6 ) time complexity andO(n 4 ) space complexity.",
        "We further propose a faster approximate algorithm based on Lagrangian relaxation, which has TO(n 4 ) running time and O(n 3 ) space complexity (T is the iteration number in the subgradient decent algorithm).",
        "Experiments on the popular Edinburgh dataset show that 327 x x ... x x ... x ...0 (root) 2 i i+1 jx x1 n w0idep w i2dep w ijdep w i i+1dep w2ibgr w i i+1bgr w i+1 jbgr Figure 2: Graph illustration for the objective function.",
        "In this example, words x 2 , x i , x i+1 , x j are kept, others are deleted.",
        "The value of the objective function is w tok 2 + w tok i + w tok i+1 + w tok j + w dep 0i +w dep i2 +w dep ii+1 +w dep ij +w bgr 2i +w bgr ii+1 +w bgr i+1j .",
        "the proposed approach is 10 times faster than a high-performance commercial ILP solver.",
        "2 Task Definition We define the sentence compression task as: given a sentence composed of n words, x = x 1 , .",
        ".",
        ".",
        ", x n , and a length L ?",
        "n, we need to remove (n ?",
        "L) words from x, so that the sum of the weights of the dependency tree and word bigrams of the remaining part is maximized.",
        "Formally, we solve the following optimization problem: max z,y ?",
        "i w tok i z i + ?",
        "i,j w dep ij z i z j y ij (1) + ?",
        "i<j w bgr ij z i z j ?",
        "i<k<j (1?",
        "z k ) s.t.",
        "z is binary , ?",
        "i z i = L y is a projective parse tree over the subgraph: {x i |z i = 1} where z is a binary vector, z i indicates x i is kept or not.",
        "y is a square matrix denoting the projective dependency parse tree over the remaining words, y ij indicates if x i is the head of x j (note that each word has exactly one head).",
        "w tok i is the informativeness of x i , w bgr ij is the score of bigram x i x j in an n-gram model, w dep is the score of dependency arc x i ?",
        "x j in an arc-factored dependency parsing model.",
        "Hence, the first part of the objective function is the total score of the kept words, the second and third parts are the scores of the parse tree and bigrams of the compressed sentence, z i z j ?",
        "i<k<j (1?",
        "z k ) = 1 indicates both x i and x j are kept, and are adjacent after compression.",
        "A graph illustration of the objective function is shown in Figure 2.",
        "Warren says steadythe economy continues the improvementROOT Figure 3: Connect deleted words using virtual arcs. 3 Proposed Method 3.1 Eisner's Cubic Time Parsing Algorithm Throughout the paper, we assume that all the parse trees are projective.",
        "Our method is a generalization of Eisner's dynamic programming algorithm (Eisner, 1996), where two types of structures are used in each iteration, incomplete spans and complete spans.",
        "A span is a subtree over a number of consecutive words, with the leftmost or the rightmost word as its root.",
        "An incomplete span denoted as I i j is a subtree inside a single arc x i ?",
        "x j , with root x i .",
        "A complete span is denoted as C i j , where x i is the root of the subtree, and x j is the furthest descendant of x i .",
        "Eisner's algorithm searches the optimal tree in a bottom up order.",
        "In each step, it merges two adjacent spans into a larger one.",
        "There are two rules for merging spans: one merges two complete spans into an incomplete span, the other merges an incomplete span and a complete span into a large complete span.",
        "3.2 Exact O(n 6 ) Time Algorithm First we consider an easy case, where the bigram scores w bgr ij in the objective function are ignored.",
        "The scores of unigrams w tok i can be transfered to the dependency arcs, so that we can remove all linear terms w tok i z i from the objective function.",
        "That is: ?",
        "i w tok i z i + ?",
        "i,j w dep ij z i z j y ij = ?",
        "i,j (w dep ij + w tok j )z i z j y ij This can be easily verifed.",
        "If z j = 0, then in both equations, all terms having z j are zero; If z j = 1, i.e., x j is kept, since it has exactly one head word x k in the compressed sentence, the sum of the terms having z j is w tok j + w dep kj for both equations.",
        "Therefore, we only need to consider the scores of arcs.",
        "For any compressed sentence, we could augment its dependency tree by adding a virtual 328 i i+1i i+1 + = i jr+1 j + = i r i ji+1 j + = i i+1 ... ... i jr j + = i r Case 1 Case 2 Case 3 Case 4 Figure 4: Merging rules for dependency-factored sentence compression.",
        "Incomplete spans and complete spans are represented by trapezoids and triangles respectively.",
        "arc i?",
        "1 ?",
        "i for each deleted word x i .",
        "If the first word x 1 is deleted, we connect it to the root of the parse tree x 0 , as shown in Figure 3.",
        "In this way, we derive a full parse tree of the original sentence.",
        "This is a one-to-one mapping.",
        "We can reversely get the the compressed parse tree by removing all virtual arcs from the full parse tree.",
        "We restrict the score of all the virtual arcs to be zero, so that scores of the two parse trees are equivalent.",
        "Now the problem is to search the optimal full parse tree with n?",
        "L virtual arcs.",
        "We modify Eisner's algorithm by adding a signature to each span indicating the number of virtual arcs within the span.",
        "Let I i j (k) and C i j (k) denote the incomplete and complete spans with k virtual arcs respectively.",
        "When merging two span-s, there are 4 cases, as shown in Figure 4. ?",
        "Case 1 Link two complete spans by a virtual arc : I i i+1 (1) = C i i (0) + C i+1 i+1 (0).",
        "The two complete spans must be single word-s, as the length of the virtual arc is 1. ?",
        "Case 2 Link two complete spans by a non-virtual arc: I i j (k) = C i r (k ?",
        ")+C j r+1 (k ??",
        "), k ?",
        "+ k ??",
        "= k. ?",
        "Case 3 Merge an incomplete span and a complete span.",
        "The incomplete span is covered by a virtual arc: I i j (j ?",
        "i) = I i i+1 (1) + C i+1 j (j ?",
        "i ?",
        "1).",
        "The number of the virtual arcs within C i+1 j must be j ?",
        "i ?",
        "1, since the descendants of the modifier of a virtual arc x j must be removed.",
        "?",
        "Case 4 Merge an incomplete span and a complete span.",
        "The incomplete span is covered by a non-virtual arc: C i j (k) = I i r (k ? )",
        "+ C r j (k ??",
        "), k ?",
        "+ k ??",
        "= k. The score of the new span is the sum of the two spans.",
        "For case 2, the weight of the dependency arc i ?",
        "j, w dep ij is also added to the final score.",
        "The root node is allowed to have two modifiers: one is the modifier in the compressed sentence, the other is the first word if it is removed.",
        "For each combination, the algorithm enumerates the number of virtual arcs in the left and right spans, and the split position (e.g., k ?",
        ", k ??",
        ", r in case 2), thus it takes O(n 3 ) running time.",
        "The overall time complexity is O(n 5 ) and the space complexity is O(n 3 ).",
        "Next, we consider the bigram scores.",
        "The following proposition is obvious.",
        "Proposition 1.",
        "For any right-headed span I i j or C i j , i > j, words x i , x j must be kept.",
        "Proof.",
        "Suppose x j is removed, there must be a virtual arc j?",
        "1 ?",
        "j which is a conflict with the fact that x j is the leftmost word.",
        "As x j is a descendant of x i , x i must be kept.",
        "When merging two spans, a new bigram is cre-ated, which connects the rightmost kept words in the left span and the leftmost kept word in the right span.",
        "According to the proposition above, if the right span is right-headed, its leftmost word is kept. If the right span is left-headed, there are two cases: its leftmost word is kept, or no word in the span is kept.",
        "In any case, we only need to consider the leftmost word in the right span.",
        "Let I i j (k, p) and C i j (k, p) denote the single and complete span with k virtual arcs and the rightmost kept word x p .",
        "According to the proposition above, we have, for any right-headed span p = i.",
        "We slightly modify the two merging rules above, and obtain: ?",
        "Case 2?",
        "Link two complete spans by a non-virtual arc: I i j (k, j) = C i r (k ?",
        ", p) + C j r+1 (k ??",
        ", j), k ?",
        "+ k ??",
        "= k. The score of the new span is the sum of the two spans plus w dep ij + w bgr p,r+1 .",
        "329 ?",
        "Case 4?",
        "Merge an incomplete span and a complete span.",
        "The incomplete span is covered by a non-virtual arc.",
        "For left-headed spans, the rule is C i j (k, q) = I i r (k ?",
        ", p) + C r j (k ??",
        ", q), k ?",
        "+ k ??",
        "= k, and the score of the new span is the sum of the two spans plus w bgr pr ; for right-headed spans, the rule is C i j (k, i) = I i r (k ?",
        ", i) + C r j (k ??",
        ", r), and the score of the new span is the sum of the two spans.",
        "The modified algorithm requires O(n 6 ) running time and O(n 4 ) space complexity.",
        "3.3 Approximate O(n 4 ) Time Algorithm In this section, we propose an approximate algorithm where the length constraint ?",
        "i z i = L is relaxed by Lagrangian Relaxation.",
        "The relaxed version of Problem (1) is min ?",
        "max z,y ?",
        "i w tok i z i + ?",
        "i,j w dep ij z i z j y ij (2) + ?",
        "i<j w bgr ij z i z j ?",
        "i<k<j (1?",
        "z k ) +?",
        "( ?",
        "i z i ?",
        "L) s.t.",
        "z is binary y is a projective parse tree over the subgraph: {x i |z i = 1} Fixing ?, the optimal z,y can be found using a simpler version of the algorithm above.",
        "We drop the signature of the virtual arc number from each span, and thus obtain an O(n 4 ) time algorithm.",
        "Space complexity is O(n 3 ).",
        "Fixing z,y, the dual variable is updated by ?",
        "= ?",
        "+ ?(L?",
        "?",
        "i z i ) where ?",
        "> 0 is the learning rate.",
        "In this paper, our choice of ?",
        "is the same as (Rush et al., 2010).",
        "4 Experiments 4.1 Data and Settings We evaluate our method on the data set from (Clarke and Lapata, 2008).",
        "It includes 82 newswire articles with manually produced compression for each sentence.",
        "We use the same partitions as (Martins and Smith, 2009), i.e., 1,188 sentences for training and 441 for testing.",
        "Our model is discriminative ?",
        "the scores of the unigrams, bigrams and dependency arcs are the linear functions of features, that is, w tok i = v T f(x i ), where f is the feature vector of x i , and v is the weight vector of features.",
        "The learning task is to estimate the feature weight vector based on the manually compressed sentences.",
        "We run a second order dependency parser trained on the English Penn Treebank corpus to generate the parse trees of the compressed sentences.",
        "Then we augment these parse trees by adding virtual arcs and get the full parse trees of their corresponding original sentences.",
        "In this way, the annoation is transformed into a set of sentences with their augmented parse trees.",
        "The learning task is similar to training a parser.",
        "We run a CRF based POS tagger to generate POS related features.",
        "We adopt the compression evaluation metric as used in (Martins and Smith, 2009) that measures the macro F-measure for the retained unigrams (F ugr ), and the one used in (Clarke and Lapata, 2008) that calculates the F1 score of the grammatical relations labeled by RASP (Briscoe and Car-roll, 2002).",
        "We compare our method with other 4 state-of-the-art systems.",
        "The first is linear chain CRFs, where the compression task is casted as a binary sequence labeling problem.",
        "It usually achieves high unigram F1 score but low grammatical relation F1 score since it only considers the local interdependence between adjacent words.",
        "The second is the subtree deletion model (Berg-Kirkpatrick et al., 2011) which is solved by integer linear programming (ILP) 2 .",
        "The third one is the bigram model proposed by McDonald (McDonald, 2006) which adopts dynamic programming for efficient inference.",
        "The last one jointly infers tree structures alongside bigrams using ILP (Thadani and McKeown, 2013).",
        "For fair comparison, systems were restricted to produce compressions that matched their average gold compression rate if possible.",
        "4.2 Features Three types of features are used to learn our mod-el: unigram features, bigram features and dependency features, as shown in Table 1.",
        "We also use the in-between features proposed by (McDonald et 2 We use Gurobi as the ILP solver in the paper.",
        "http://www.gurobi.com/ 330 Features for unigram x i w i?2 , w i?1 , w i , w i+1 , w i+2 t i?2 , t i?1 , t i , t i+1 , t i+2 w i t i w i?1 w i , w i w i+1 t i?2 t i?1 , t i?1 t i , t i t i+1 , t i+1 t i+2 t i?2 t i?1 t i , t i?1 t i t i+1 , t i t i+1 t i+2 whether w i is a stopword Features for selected bigram x i x j distance between the two words: j ?",
        "i w i w j , w i?1 w j , w i+1 w j , w i w j?1 , w i w j+1 t i t j , t i?1 t j , t i+1 t j , t i t j?1 , t i t j+1 Concatenation of the templates above {t i t k t j |i < k < j} Dependency Features for arc x h ?",
        "x m distance between the head and modifier h?m dependency type direction of the dependency arc (left/right) w h w m , w h?1 w m , w h+1 w m , w h w m?1 , w h w m+1 t h t m , t h?1 t m , t h+1 t m , t h t m?1 , t h t m+1 t h?1 t h t m?1 t m , t h t h+1 t m?1 t m t h?1 t h t m t m+1 , t h t h+1 t m t m+1 Concatenation of the templates above {t h t k t m |x k lies between x h and x m } Table 1: Feature templates.",
        "w i denotes the word form of token x i and t i denotes the POS tag of x i .",
        "al., 2005), which were shown to be very effective for dependency parsing.",
        "4.3 Results We show the comparison results in Table 2.",
        "As expected, the joint models (ours and TM13) consistently outperform the subtree deletion model, since the joint models do not suffer from the subtree restriction.",
        "They also outperform McDon-ald?s, demonstrating the effectiveness of considering the grammar structure for compression.",
        "It is not surprising that CRFs achieve high unigram F scores but low syntactic F scores as they do not System C Rate F uni RASP Sec.",
        "Ours(Approx) 0.68 0.802 0.598 0.056 Ours(Exact) 0.68 0.805 0.599 0.610 Subtree 0.68 0.761 0.575 0.022 TM13 0.68 0.804 0.599 0.592 McDonald06 0.71 0.776 0.561 0.010 CRFs 0.73 0.790 0.501 0.002 Table 2: Comparison results under various quality metrics, including unigram F1 score (F uni ), syntactic F1 score (RASP), and compression speed (seconds per sentence).",
        "C Rate is the compression ratio of the system generated output.",
        "For fair com-parison, systems were restricted to produce compressions that matched their average gold compression rate if possible.",
        "consider the fluency of the compressed sentence.",
        "Compared with TM13's system, our model with exact decoding is not significantly faster due to the high order of the time complexity.",
        "On the other hand, our approximate approach is much more efficient, about 10 times faster than TM13?",
        "sys-tem, and achieves competitive accuracy with the exact approach.",
        "Note that it is worth pointing out that the exact approach can output compressed sentences of all lengths, whereas the approximate method can only output one sentence at a specific compression rate.",
        "5 Conclusion In this paper, we proposed two polynomial time decoding algorithms using joint inference for sentence compression.",
        "The first one is an exact dynamic programming algorithm, and requires O(n 6 ) running time.",
        "This one does not show significant advantage in speed over ILP.",
        "The second one is an approximation of the first algorithm. It adopts Lagrangian relaxation to eliminate the compression ratio constraint, yielding lower time complexity TO(n 4 ).",
        "In practice it achieves nearly the same accuracy as the exact one, but is much faster.",
        "3 The main assumption of our method is that the dependency parse tree is projective, which is not true for some other languages.",
        "In that case, our method is invalid, but (Thadani and McKeown, 2013) still works.",
        "In the future, we will study the non-projective cases based on the recent parsing techniques for 1-endpoint-crossing trees (Pitler et al., 2013).",
        "Acknowledgments We thank three anonymous reviewers for their valuable comments.",
        "This work is partly supported by NSF award IIS-0845484 and DARPA under Contract No.",
        "FA8750-13-2-0041.",
        "Any opinions expressed in this material are those of the authors and do not necessarily reflect the views of the funding agencies.",
        "References"
      ]
    }
  ]
}
