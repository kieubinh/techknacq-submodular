{
  "info": {
    "authors": [
      "Naoki Yonezaki",
      "Hajime Enomoto"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C80-1032",
    "title": "Database System Based on Intensional Logic",
    "url": "https://aclweb.org/anthology/C80-1032",
    "year": 1980
  },
  "references": [],
  "sections": [
    {
      "heading": "DEPARTMENT OF COMPUTER SCIENCE TOKYO INSTITUTE OF TECHNOLOGY",
      "text": [
        "2-12-1, 50KAYAMA, MEGURO-KU TOKYO 152, JAPAN Model theoretic semantics of database systems is studied.",
        "As Rechard Montague has done in his work,5 we translate statements of DDL and DML into intensional logic and the latter is interpreted with reference to a suitable model.",
        "Major advantages of its approach include (i) it leads itself to the design of database systems which can handle historical data, (ii) it provides with a formal description of database semantics."
      ]
    },
    {
      "heading": "1. INTRODUCTION",
      "text": [
        "There have been developed several knowledge-base systems which utilize mathematical logic, however they capjreat facts or rules at the current world only.\"' In the medical fields or the area of artificial intelligence there are many applications in which the database systems with historical data handling capability are required.",
        "For example, in a query to a medical database 'Has a sterum treatment been applied to John?'",
        "historical data is essential.",
        "One of the reasons why existing database systems provide poor support for such historical information is probably because very few theoretical study has been done yet.",
        "Intensional logic (IL) which Rechard Montague developed to describe semantics of natural language formally seems to be useful to the theory of such database.",
        "The first application of modal logic to the logic of database was done by Lipski, though he treated incompleteness of database only: In the Montague's approach, concepts of intension and extension are used.5'6 The same concepts can be applied in the theory of database.",
        "Correspondence between IL and semantics of database is shown in Fig.1.",
        "[Intensional Logic] : [Database] possible worlds states of database extension data at some state intension historical data meaning postulates : integrity constraints"
      ]
    },
    {
      "heading": "Fig.1 Correspondence between Intensionals Logic and Database system",
      "text": [
        "The extension of a constant predicate P in IL which corresponds to a relation in database corresponds to the contents in the current database state.",
        "The main purpose of this paper is to describe in a implementation-independent way aspects of those database semantics, which are characterized by interpretation of update operations and queries .",
        "And we show the feasibility of using intensional logic for description of the semantics.",
        "The treatment of update of database is closely related to that of assignment in programming language with data type specification facility.",
        "Firstly we use Montague's intensional logic and later we will introduce two-sorted type theory to treat queries which refer state indirectly.",
        "In section 2, we define a data model treated in this article.",
        "This data model is considered as hierachical relational model.",
        "In section 3, syntax of intensional logic is defined and its semantics is stated in section 4.",
        "In section 5,6, syntax of query statements and their Montague semantics are given.",
        "In section 7, 8, data manipulation statements are introduced and their semantics is also defined.",
        "In section 9, semantics of two kinds of null value is stated as meaning postulates.",
        "In section 10, we introduce two-sorted type theory and give semantics of statements referring states.",
        "Section 11 is a concluding section."
      ]
    },
    {
      "heading": "2. DATA MODEL",
      "text": [
        "In this section we define a data model which corresponds to relational model exploiting hierarchical structure of relations, that is, each component of relation may be also a relation or set of relations recursively.",
        "In the Relational Model which Codd7 introduced, 3rd-normal form or 4th-normal form is exploited to avoid the update anomalies, though we regard it as an implementational matter.",
        "Hierachical structure of relation is quite natural for representing information in the real world.",
        "As a part of a data definition language (DDL), schema declaration is formally defined as follows.",
        "This DDL describes hierachical schema of database, name of each relation and attribute names or selector names of a relation.",
        "When we consider schema of relation, we do not concern the name of relation.",
        "Let SQ be the set of all elementary data types e.g. integer, real or string of characters and so on, and F be the set of selector names.",
        "Schemas of database are constructed from So recursively as strings on Ct = So u {[,].",
        "',:} u F. Def.",
        "The set S of schemes is the smallest set S2 satisfying (1),(2).",
        "(1) SIDSouS2, (2) tp.\",tneSi, si sncF",
        "j for ij) => [si:ti,...,sn:tn]ES2 (15n).",
        "Schema declaration in our DDL is of the form Relation name = t where t e S. Now we can define the hierarchical relational database (HRDB) as follows.",
        "Def.",
        "The set HD of HRDB is defined as HD= u Dt teS For t E S. Dt is the set of database whose schema is t defined recursively with the following rules (1), (2).",
        "(1) teS => Dt=Et' where Et is the set of data having elementary type t, (2) teS and t=[si:ti....,sn:tn] =>",
        ", where DJ=Dtu(NULL1,NULL2).",
        "An example of a database is shown as follows.",
        "Example 1 Now, we consider an employee relation comprising of tuples which have hierarchical structure.",
        "Each such tuple consists of employee number, name, education relation, age, a set of skills and children relation.",
        "Corresponding schema declaration is as follows.",
        "EMP1=[$E:int, NAME:string, EDUCATION:[SCHOOL:string, DEG:string, YR:int], SKILL:[SNAME:string], KIDS:[KNAME:string, AGE:int, SEX:string], SAL:int] Fig.2 is an instance of database with this schema at some state or world.",
        "EMP1"
      ]
    },
    {
      "heading": "3 SMITH C A 50 SB MARY 17 F SD 20K SE 4 JACK --- – ------------",
      "text": []
    },
    {
      "heading": "Fig.2 Instance of the Employee Relation",
      "text": [
        "The value 'NULL1' means nothing, however in some state there may be some values.",
        "The value 'NULL2' means absolutely no value exists in any state.",
        "The order of selector in each tuple is insignificant and order of raw is also insignificant.",
        "This hierarchical schema can be visualized by tree graph.",
        "Fig.2 is a two-dimensional representation of hierarchical data which reflects the images of data instances.",
        "Note that the data declaration in our DDL and this graph show the data structure only while the graph provides a convenient means to visualize the instances."
      ]
    },
    {
      "heading": "3. SYNTAX OF INTENSIONAL LOGIC",
      "text": [
        "Intensional logic used in the Montague's approach is based on the theory of types.",
        "In this section we describe the extended version of IL according to Gallin.",
        "The set of all possible types is recursively defined as follows.",
        "Def.",
        "Let e, t, s be any three objects.",
        "The set of types of IL is the smallest set T satisfying (1)–(3).",
        "(1) e, t e T, (2) a. b c T => <a, b> e T, (3) a e T => <s. a> e T.",
        "Objects of type e correspond to entities.",
        "Type of IL corresponds schema of our DDL or DML.",
        "Our schema supports nary relations, and it is considered as nary function whose range is truth values.",
        "For any function of two (or more) arguments there exists an equivalent one which takes one argument at a time,9 i.e. (D1xD2x \".",
        "the types in IL correspond to schemas of our DDL.",
        "Dtype which is a subset of type T in IL is now introduced as follows.",
        "Def.",
        "Dtype is the satisfying (1)–(4).",
        "(1) e e TB, (2) a e TA => <s, a> e TB' (3) a e TB => <a, t> e TA, (4) be TB, a c TA => <b, a> e TA.",
        "Constants of type <s.a> (a e Dtype) correspond to relations with schema corresponding to type a.",
        "Such translation will be defined formally in section 6.",
        "Intuitively speaking, constants of type <s,<e,t>> smallest set of TA",
        "corresponds to relations with schema [s: int], Cs: real] or Cs: string], i.e. single flat domain relation.",
        "Constants of type <s,«s,a>,t>> correspond to relations with schema [s: [...]] i.e. hierarchical relations of single domain whose value is not flat but a relation with schema corresponding to type a.",
        "By rule (4), we can define the type of IL corresponding to nary relation schemas.",
        "Example 2 The type of constant in IL which corresponds to relation in Example 1 is <s,<e,<e,<<s,<e,<e,<e,t>>>>,<<s,<e,t>> ,<<s,<e.<e,<e,t>>>>.<e.t>>>>>>>.",
        "We take CONa (VARa) to be the set of constants (variables) of type a.",
        "Now, we define the set Tma of terms of IL of type a as follows.",
        "Def.",
        "(1) CONa c Tma, (2) VARa c Tma, (3) A, B e Tme => A+B, A-B, A*B, e Tule, (4) A e Tm<a.b>, B e Tma => ACB] E Tmb, (5) A e Tmb, x e VARa => Xx(A) E Tm<a,b>, (6) A, B c Tma => (A■B) e Tmt.",
        "(7) A E Tma => AA e Tm<s,a>, (8) A c Tm<s,a> => vA ETmag (9) A, B e Tma, P e Tmt => (P -* A, B) E Tma, (10) A E Tma, c e CON<s,b>, B E Tmb => {B/vc}A E Tma, (11) A e Tmt => PA E Tmt, FA e Tmt.",
        "by Janssen.\" Following Henkin,11 we define The additional construct (10) is introduced sentential connectives, quantifiers and modal operators as follows.",
        "Def.",
        "(1) T = [kxtxt■Axtxt], (2) F = E4xtxt■AxtV• (3) = Xxt[Faxt].",
        "(4) A = xxtxypf,t,t>[fx■y]mAf<t,t›EfT]b (5) = AX0qt[EXAY]■X], (6) V = NxtXyt[ – x+y].",
        "(7) YxaA = [AxalomXxaT], (8) gxaA = (9) CAaABa] = CAAawABa].",
        "(10) OA = [ALT], (11) OA = – 0 – A.",
        "We write [AAB] instead of [[AA]B] where A and B are formulas, similarly for the other binary connectives."
      ]
    },
    {
      "heading": "4. SEMANTICS OF IL",
      "text": [
        "The terms of intensional logic are interpreted in an intensional model.",
        "Such a model is a system M = (Ma, <, m)acT, where M is a a a frame based on non-empty sets D and I, and < is a linear ordering on S. To simplify following arguments, we make no distinction among 'int', 'real' and 'string', and they are represented by D. Def.",
        "Frame is defined as the indexed family (Ma)acT of sets, where",
        "(1) Me=D u (NULL1, NULL2}, (2) Mt=2={0,1}, (3) M<a,b>=Mbma=(FIF:Ma ->Mb )",
        "Function m must be such that if ca is a constant of type a, then m(ca)eM‹so>' The assignment g is a function from variable to value such that if x e VARa then g(xa) E Ma.",
        "If xa is a variable of type a, and x e Ma then g(x/X) denotes the value assignment exactly like g except that it assigns the value X to the variable x.",
        "Now we define the interpretation of a term Aa in a model M with respect to the state s and the assignment g. It is denoted by Vm,a,g(Aa) and defined inductively as follows.",
        "(We dropped the subscript 'M'.)",
        "Vs,g(xa)=g(xa), xaeVARa, Vs,g(ca)=m(ca)(s), caECONa,",
        "(3) Vs,g(Ae+Be)=Vs,g(Ae)+Vs,g(Be) and similar for the other arithmetical operations, (4) Vs,g(A<a,b,CBa])=Vs.g(A<a.b>)EV,,g(Ba)].",
        "(5) Vs,g(XxaAb)=the function f with domain Ma, such that whenever XEMa then f(x)=Vs.e(Ab), where g'=g(x/X).",
        "By using meta-operator r, we express the above as F XCV,,e(Ab)], (6) Vs,g(Aa*Ba)=1 if Vs.g(Aa)=Vs,g(Ba), and 0 otherwise, (7) Vs,g(AAa)=1 jEVi.g(Aa)], (8) Vs,g(vA<s,a0= Vs,g(A‹,,a0(s), (9) Vs,g((Pt÷Aa, Ba))=Vs,g(Aa) if Vs,g(Pt)=1, and Vs,g(Ba) otherwise, (10) Vs.g({Bb/vc<s,b0Aa)=Vt.g(Aa), where t=<c±Vs,g(Bb)>s, (11) Vs,g(PAt)=1 if there is some s' in S such that s'<s and Vs,g(A)=1, 0 otherwise, (12) Vs,g(FAt)=1 if there is some s' in S such that s<s' and Vs,,g(A)=1, 0 otherwise.",
        "- 222 In the rule (10) t denotes the state in which all constants have values exactly like in s except that the value of vc is the value of the expression Bb in the state s. We must clarify the notion of state in our model to define the meaning of database.",
        "State is understood to present the internal situation of a database.",
        "A state is altered by update operations.",
        "A new state sl preceeds an old state s2, i.e. (s2<s1).",
        "Clearly a state scI determines the value of all relations.",
        "The effect of update operation is that it modifies the value of single relation, and in order to model this update operation, it should be assumed that the resulting state always exists and is unique.",
        "So we restrict our model for IL which satisfies the following postulates.",
        "1) Update postulate For every t1 E I. every c e CON<a 'a> (a E Dtype) and every i E Ma, there exists a unique t2 E S such that",
        "for all constants c' x c. 2) Uniqueness postulate For every tl, t2 E I (t1 x t2), there exists c e CON<s,a> (a E Dtype) such that",
        "that is, the result of update operation should be distinct from all of the other states.",
        "Therefore, we can identify a state with contents of database.",
        "The database is translated into constant in IL.",
        "So the set I of states is defined by"
      ]
    },
    {
      "heading": "IT",
      "text": [
        "/ = aeDtype ceCON,a a>ma"
      ]
    },
    {
      "heading": "5. QUERY STATEMENTS",
      "text": [
        "Now we introduce a syntax of queries in our data manipulation language (DML).",
        "The set Q of queries is defined as Q142 recursively.",
        "Def.",
        "(1) 0.",
        "1 E Q1, (2) d e descriptor => d e Q1, (3) cll.'",
        "q2 C Q1 => (c114.",
        "(12)1 (q1\"12\" (q1-4-q2)• always ql.",
        "past ql, future q2 E Q1, (4) f E Q2, q E Q1 => q when f, q whenever f E Q1, (5) T, F E Q2, (6) q1, q2 e Q1 => q1=q2 e Q2, (7) f2 E Q2 =>-ifl, (fivf2), (f1Af2).",
        "(f1=>f2), always f, past f, future f, f2 when fl, f2 whenever fl e Q2.",
        "Ql is the set of queries for which an answer is a set of objects.",
        "For a query in Q2 an answer is yes or no.",
        "Every descriptor is of the form <R, sl, s2, A>, where R is a relation name, si, s2 are sequences of selectors, and A is the subset of Dt which is accessed by s2.",
        "<R, sl, 82,A> is used to denote the set of si element of tuples in the relation R whose s9 element is in A.",
        "In the above rule (3) all descriptors in (ql+q2), (q1°q2) or (q1-►2) must have the same selector sequence 81 as their second component.",
        "We assume certain auxiliary language for describing A which is a subset of the domain Dt.",
        "Example 3 Let us consider a query, 'Was every employee who has a child named Jack educated at school B or C?'",
        "on the database given in the previous example.",
        "We have a expression <EMP, NAME, KIDS.KNAME, {Jack}› -<EMP, NAME, EDUCATION.SCHOOL, {B, C}>=0.",
        "Let us consider another example as follows.",
        "'Get all names of employees who always earn more than 10000 or less than 500.'",
        "The corresponding expression is always(<EMP, NAME, SAL, {xlx>10000}> + <EMP, NAME, SAL, {xIx<500}>)."
      ]
    },
    {
      "heading": "6. SEMANTICS OF QUERIES",
      "text": [
        "We have already defined a model theoretic meaning of IL.",
        "Thus the remaining part of Montague semantics is defining a translation which gives for each syntactic structure of the language some meaningful expression of IL.",
        "For a part of statement E, its translation into IL is denoted E'.",
        "Relation name R is translated into a constant R' of IL whose type is determined by its schema declared at DDL.",
        "More precisely this type is determined with next rules.",
        "If there is a statement 'Rname: t' in a data definition part, then type of the constant Rname' is G(t), where G is a function satisfying,",
        "Def.",
        "G: S Dtype (1) t = Esi:ti, s2:t2, , sn:tn] G(t)=F(t)=<s,<F(t1),<F(t2),...,<F(tn),t>>...>, (2) to So => F(t) = e.",
        "Each descriptor <R, 81, 62, A> is translated according to the schema of R and sequences of selectors sl and 82.",
        "Let so denote and Iso11'=n, 1811=n+k, 1821=n+q, i.e. 81, 82 are represented as s1=s01's02'“sOn's1Ps12..'slk' 2=s01 \"02 \"'sOn's2Ps22\"'s2q*",
        "1.",
        "For string s. Isl denotes length of s.",
        ", where the sequence 3i1...3im does not contain 3i or 3i .",
        "The number m and sil s21 positions of ri ], Ei, ] in the sequence of sll '21 [il]...Eim] are determined self evidently by the DDL statement about R. If n=0 then the first component ER(sol...son)P[Rt][i] of the above conjunctive form is replaced by If k=0 or q=0 then an appropriate but obvious modification is also needed.",
        "It is possible to construct this IL expression systematically according to a micro syntax of a descriptor, however it is somewhat tedious so we do not concern it.",
        "When a is a type of sub-schema corresponding to the selector s71, A' is a predicate of type <a, t> in which Ar(i) has the value 1 when an object corresponding to i is an element of A.",
        "Each is is a bounded variable whose type is the one determined by G and sub-schema corresponding to a selector s used in a relation R. , where, each bounded variable i1 im has the same type determined by G and sub.-schema corresponding each selector which appears in the same level of relation R as the selector sn appears.",
        "Moreover the sequence 3i1 does not contain gis.",
        "According to Ole syntax of Q, translation into IL expression is defined as follows.",
        "Def.",
        "(1) EOP=\"Ax[F]Ex].",
        "(2) ElP=AAxEVExl.",
        "(3) E-0'=\"Ax( – (vEq]qx])).",
        "(4) Eql+q21'=\"Ax(vEq1PEx]vvEq2PEx]).",
        "(5) Eci1oq2P=AAx(vEqll'Ex]AvEq23 'Ex7).",
        "(6) Eql÷q2]17-AAx( – v[cil7'Ex]vv[q27'Ex]).",
        "(7) [always q]'.AXx(DvEql'[x]), (8) [past q]'=AAx(PvCO'Exp, (9) [future q]'=\"Ax(FvE01[N]).",
        "(10) Eq when f]', Eq whenever f]': these will be defined in section 10, (11) ETP.AT, [1]1=AF.",
        "(12) Eq1=q2P=A(v[ql]'■vEq2P), (13) [If]'=\"( – vEfli).",
        "(14) Efivf27'=\"(vEf1J'vvEf27'), (15) Ef1Af2P.A(vEfIPAvEf27'), t.A(,,,vEfl],vvEf2],), (16) Efi=>f2] (17) [always f]'=Ov[f]'.",
        "(18) [past f]'=PvEfP.",
        "(19) [future f]'=FvEfP, (20) Cf2 when fl]', [f2 whenever fl]':",
        "these will also be defined in section 10.",
        "In case of [0]'.",
        "[1]1. type of x is determined by the context of its usage in a query."
      ]
    },
    {
      "heading": "7. DATA MANIPULATION STATEMENTS",
      "text": [
        "Insertion, deletion and update of tuples in database are now considered.",
        "We concern the case where we can manipulate either one tuple at a time or a set of tuples with a single command.",
        "Syntax of update statements is defined as follows.",
        "Update statements are built up from certain descriptor and operation.",
        "More exactly, the set M of data manipulation statements is defined with the following four cases:",
        "(1) (set oriented update) d: descriptor, <f,d> e M • where f means arbitrary operation on the object in the answer of d, (2) (individual insertion) (2-1) t> E M • where, R is a relation name and t is a tuple which is intended to be inserted into R, (2-2) d: descriptor, <d, t> E M, (3) (individual deletion) (3-1) – <R, t> E M, (3-2) d:descriptor, – <d, t> E M, (4) (set oriented deletion) – <R, S, A> E M , where, R is a relation name, s2 is a sequence of selectors and A is the subset of Dt which is accessed by s2.",
        "A set oriented update statement (1) changes all elements in a relation R that are elements of answer for query q by values which is a result of operation f on them.",
        "An individual insertion (2-1) means insertion of a tuple t into a relation R as usual, and an individual insertion (2-2) means insertion of a tuple t into the all relations which are elements of answer for query d. We can define the meaning of individual deletions (3-1), (3-2) in the same manner as in the case of insertion by changing the word 'insert' by 'delete'.",
        "Set oriented deletion statement (4) deletes all tuples whose values accessed by s2 are in A from relation R."
      ]
    },
    {
      "heading": "8. SEMANTICS OF DATA MANIPULATION",
      "text": [
        "In the Montague semantics, a data manipulation statement is translated into forward predicate transformer, which is a function from a state predicate to a state predicate whose type is <s, t>, and which has the format of an intension of an assertion.",
        "So the predicate transformer has a type <<s, t>, <s, t>> and has the format UN), where PEVAR<s,t> and 0 is a term of type <s, t>.",
        "For set oriented update statement, we define the translation into IL as follows.",
        "In this definition symbol '+' is used to designate the inverse of the translation, i.e. [CE]+]'=E for a term E of IL.",
        "E<Rst>P=ER:=EAll.”Aim(ii=t1 A \".",
        "A im=tm T, Ri[iii.\"[1,])7+:19 E-<R,t>],=ER:=Ddl.\"Aim(ii=t, A \".",
        "A im=tm F, I where we assumed t=<tl, t2, m , , t >.",
        "If n=0, k=0 or q=0 then appropriate modifications are needed as in the case of query statements.",
        "For insertion operation <d,t> and deletion operations -<d,t›; -<R,S,A>, we can define their corresponding IL expressions in the same manner as shown in the case of set oriented update.",
        "By using an intensional version of Floyd's semantics of assignment12 EA:.,B],=xpA3zE{z/vA,}vpAvA,■[z/vA,]B,], and semantics of composition CA;BP= AP[B'(A'(P))], we complete the definition of the semantics of the update statements.",
        "Now, we consider the following simple example for comprehension of the above definition.",
        "Example 4 Suppose relation EMP2 is declared at data definition part as EMP2=[ KIDS:[NAME:string, AGE:int], SAL:int], and that before the update, <*2,<EMP2, SAL, KIDS.NAME, (Jack)» holds that Aq<EMP2, SAL, KIDS.NAME, (Jack}>]' °AXx(x•201)).",
        "We denote this precondition by PC.",
        "The translation of the update statement is",
        "From this we derive that, AAis(3iK(vEMP2'(iK)(is)A3iN3iA(viK(iN)(iA) Aili■Jackl)))■AXx(xm401).",
        "Example 5 As another example, we consider the relation as follows.",
        "EMP3=[NAME: string, MGR: string].",
        "For this relation we perform an update such as the manager of manager of John is Smith, i.e. <=smith,<EMP3,MGR,NAME,<EMP3,MGR,NAME,{John}>>>.",
        "The translation of this update statement is [<=Smith, <EMP3, MGR, NAME, <EMP3, MGR, NAME, (John)>»]/"
      ]
    },
    {
      "heading": "9. SEMANTICS OF NULL VALUES",
      "text": [
        "We can define various kinds of null values, indeed ANSI/SPARC interim report13 cites 14 possible manifestations of null.",
        "However, the two important kinds of null value have the meanings 'value at present unknown' and 'property inapplicable'.",
        "Formal treatment of the first kind of null value has been resolved by the ideas of null substitution principle and non-truth functionality principle.4,14 In this article we study the second kind of null value more precisely.",
        "We introduced two null values NULL1, NULL2 of the second kind of null values.",
        "NULL1 is intended to mean that nothing exists at current state but there may be some states in which the value exists.",
        "NULL2 is intended to mean that there exists absolutely no value in any state.",
        "Those semantics are formally defined by auxiliary update postulates.",
        "(1) Update postulate for NULL1 For every tlEI and every A e Tm<s,a> (a=<al,<...<an,t>>...> E Dtype), if Vs,g(A)(t1)(fa1)...(fak)...(fan)=1 and fa=NULL1 k ,then Vs,g(A)(t1)(fa1)...(h )...(fan)=0 for all h e M -fNULL;A' ak ak and there exists t2CI such that Vs,g(A)(t2 )(fa )...(r )...(f )=1 (2) Update postulate for NULL2 For every tier and every A C Tm<s,a> C Dtype), if Vs,g(A)(ti)(fa)...(fak). – 1 (fa )= l and fa =NULL2 then for every t2 E I and every h E M -{NULL2} k ak Vs,g(A)(t2)(fa)...(hak)...(fan)=0.",
        "l a"
      ]
    },
    {
      "heading": "10. SEMANTICS OF STATE REFERENCE",
      "text": [
        "To define the semantics of queries with 'when' or 'whenever', it is necessary to consider the case that s is a type.",
        "We define such a logic called Two-Sorted Type Theory, and denote it by Ty2.",
        "Def.",
        "The set T' of types of Ty2 is the smallest set such that",
        "(1) e, t, s e T', (2) a, b e T' => <a,b> e T'.",
        "Note that T c T' (T: the set of types of IL).",
        "Def.",
        "The sets TmLof terms of Ty2 of type a are defined with the following rules recursively.",
        "(1) CONa c Tm'a, (2) VARa c Tml, (3) A, B C Tme => A+B, A-B, A*B, C (4) A C Tm4b>, B C Tm'a => A[B] C TmL, , (5) A C TmL r-->AxaA C Tm4gb>, (6) A, B C Tma=> (A■B) e Trqa (7) A, B C Tmla, P C Tmt => (P A,B) C Tmla, (8) A C Tm'a, c C CON<s,b>, x C VARs, B e Tint => {B/c[x]}A C Tm'a, (9) A C Trat.",
        "=> PA e TInt FA Tm'",
        "t' t' To define the semantics of Ty2 the model M'=(Ma , < , m)aeT is introduced, where Ma is a frame based on non-empty sets D, I, and < is a linear ordering on I.",
        "We define the frame as the indexed family (Ms)ser, of sets, where Def.",
        "(1) Me = D u {NULL1, NULL2}, (2) Mt = 2 = 10, 11, (3) Ms = I.",
        "= MbMa ={FIF: Ma -> Mb} (for ags), (4) M<a,b> (5) M<s,a> = Mal = {FIE: I -> Ma}ufNULL1,NULL21.",
        "For each constant ca, m(ca) C Ma, and for each variable xa, g(xa) EMa.",
        "Interpretation of term Aa which is denoted VM,g(Aa) is defined in such a way that the following conditions hold.",
        "(We dropped the subscript",
        "(1) Vg(xa) = g(xa), xa e VARa, (2) Vg(ca) = m(ca), ca E CONa, (3) – (7) similar to the case of IL, (8) Vg({Bb/c<s.b>Exs3}Aa)=Vgt(Aa),",
        ", where g'=g(xs/X), xs e VARs, X e I, such that for all constant c<s,b> except c, Vg(ci[xs]) = Vo(ci[xs]) and Ve(c[xs]) = Vg(B),",
        "(9) Vg(PAt) = 1 if there is some g' = g(xs/X) such that Oxs) < g(xs) and Vg,(A) = 1, 0 otherwise, (10) Vg(FAt) = 1 if there is some g' = g(78/X) such that g(xs) < gqxs) and Vgt(A) = 1, 0 otherwise.",
        "For each term Aa of IL we can define the translation of Aa in Ty2.",
        "Such translation is defined with next rules, and denoted A. Def.",
        "(1) Exai* = xa, (2) [cal* = c<sia,Exs].",
        "(3) CA<ao,>[Bb7]* = A*EB*], (4) ENxaA0* = XxA*, (5) [Aa■Ba]* = CA*ne], (6) [AAa]* =XxsA*.",
        "(7) [VA<s,a>]* = A*Exs7.",
        "Now we can define the semantics of query 'q when f' as a term of Ty2.",
        "[q when fP=XxlsXx(34([[f]']*[4]A [[q]1]*[x21[x])) which means intuitively the set of objects which satisfy q in each states where f has a value 1.",
        "Similarly we define the following."
      ]
    },
    {
      "heading": "11. CONCLUDING REMARKS",
      "text": [
        "We believe we have demonstrated feasibility of the Montague's approach to the semantics of hierarchical database systems with historical data.",
        "As for future reasearch directions, we would like to point out the importance of (i) finding normal forms which allows efficient evaluation of terms, and (ii) finding a set of axioms for equivalence transformations which derive normal forms from given terms.",
        "ACKNOWLEDGEMENTS Our thanks are due to Mr. Kenichi Murata for fruitful discussions and encouragement and to Prof. Takuya Katayama and many other people whose ideas we have unwittingly absorbed over the years."
      ]
    },
    {
      "heading": "REFERENCES",
      "text": []
    }
  ]
}
