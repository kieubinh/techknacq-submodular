{
  "info": {
    "authors": [
      "Koiti Hasida"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C86-1018",
    "title": "Conditioned Unification for Natural Language Processing",
    "url": "https://aclweb.org/anthology/C86-1018",
    "year": 1986
  },
  "references": [
    "acl-P84-1075",
    "acl-P85-1017",
    "acl-P85-1018",
    "acl-P85-1021"
  ],
  "sections": [
    {
      "heading": "ABS TR/IC7'",
      "text": [
        "This paper presents what, we call a conditioned unification, a new method of unification for processing natural languages.",
        "The key idea is to annotate the patterns with a certain sort of conditions, so that they carry abundant information.",
        "This method transmits information from one pattern to another more efficiently than procedure attachments, in which information contained in the procedure is embedded in the program rather than directly attached to patterns.",
        "Coupled with techniques in formal linguistics, moreover, conditioned unification serves most types of operations for natural language processing."
      ]
    },
    {
      "heading": "1. introduction",
      "text": [
        "A current, major trend of natural language processing is characterized by the overall use of unification (Shieber (1984), Kay (1985), l'roudin and Pollard (1985), Pereira (1985), Shieber (1985 ), etc.)",
        "reflecting the recent develop-merits in nontransforinational linguistic formalisms, such as Lexical Functional Grammar (llresnan (1982)), Generalized Phrase Structure Grammar (GPSG) (Gazdar, Klein, Pullum and Sag (1985)), Ilead Grammar (Pollard (19131)), and Head-Driven Phrase Structure Grammar (111'SG) (Pollard (1985a,b)).",
        "'these formalisms dispense with global opera-Lions such as transformation, and instead exploit.",
        "local operations each confined within a local tree.",
        "Such local operations are formulated in terms of unification.",
        "llowever, the ordinary unification as in Prolog is insufficient, seen from both scientific (here, alias linguistic) and engineering point.",
        ":; of view.",
        "The problem is that path terns to be unified with each other lack the capacity for carrying inform att on.",
        "In this paper we present a new method of unification which we call conditioned unification.",
        "The essence of the method is to deal with patterns annotated by some sort, of conditions.",
        "These conditions are so constrained as to be efficiently operated on, and yet to be able to carry rich enough information to capture linguistic generalizations."
      ]
    },
    {
      "heading": "2. The Problem",
      "text": [
        "Ordinary patterns as in Prolog lack expressive power, because variables therein are simply indeterminate and thus carry almost no information.",
        "Therefore, such patterns and unification among them arc insufficient for capturing the gramfT1 tical generalization and the processing efficiency.",
        "1.0, us look at sonic examples below.",
        "A grammatical category is assumed to be a list of features.",
        "A feature consists of a feature name and a value, and represented as a terns like name (value ).",
        "Thc lexical entry of English verb put, for instance, cannot, be described OS a Prolog pattern, but needs sonic annotation (i.e., put_tns_psn_nmb ('I', N)) as in (1).",
        "Here, features other than tense, person, and number are omitted, and predicate put_tns_psn_nmb is defined as in (2).",
        "(2) put.",
        "Ins psn nmb(present, P, N)",
        "Tor a bit more compLeated instance, consider the relm-Gunship between a syntactic gap and its filler.",
        "In GPSG, IIHSG, etc., this relationship is captured in terms of the 51,ASI I feature, which represents gaps.",
        "In the category of I ma crazy, for example, the SI,ASH feature is specified as I NI)].",
        "Ilere SIAS] I is assumed to take as its value a list of categories.",
        "Stated below is a simplified principle about the distribution of this feature in typical cases.",
        "(I) In a local tree, the mother category's SLASII feature is obtained by concatenating from left to right the SI,ASII features of her daughters.",
        "In order to describe this principle, something snore than a mere pattern is required again: (4) local_trieca slash(X)1, I slash( Y)1, I slash(/,)]) • append(Y, K).",
        "Teatimes other than SI,ASII are omitted here.",
        "The so-called procedure attachments is the most common way of complementing the poor descriptive capacity of ordinary patterns F'or instance, you may regard the bodies of Horn clauses (1) and (4) OS attached procedures The drawback of procedure attachment is ni the fact.",
        "that the only way of using the procedures is to execute them.",
        "Tor this reason, procedures arc merely embedded in programs, rather than attached to those patterns which these programs operate on.",
        "The information which procedures contain cannot generally be carried around across several partial structures each of which a procedure directly operates on, because, once a procedure is executed, the information which it contained is partially lest.. Tor instance, when lexical entry (1) is exploited, pul_tas_psn.iomb (7', „N) is executed and 'I' and I' are instantiated to be present and 1st, respectively, Thus left behind is the information about the other ways to instantiate those variables.",
        "Actual procedure attachments must, be arranged so that information should not be lost when procedures are executed.",
        "Freeze of Prolog (Colmeraucr (1982)), for instance, is a means of this arrangement.",
        "13y executing freeze (X, 0, atomic formula i' is frozen; i.e., the execution of 't is suspended until variable Xis instantiated.",
        "If ic.3, contains X, therefore, hopefully not, so much information is lost when is executed.",
        "Nevertheless, freeze is problematic in two respects.",
        "First, information can still be lost, when the frozen procedures are executed.",
        "Second, too much information can be accumulated while several procedures are frozen Suppose, for instance, that, freeze (A', member(K, lag ti 1)) and f re ez e ( Y, me7nber , c I)) have been executed.",
        "Then, X and Y COO be unified with each other without awakening either procedure.",
        "In that case, the information that X may be b is redundant between the two procedures, and the other part.",
        "of information those procedures contain is income sit-Pent.",
        "What.",
        "one might hope here is to instantiate X (and Y) to be b.",
        "If we had executed freeze (C, member ( c , di) instead of freeze member (Y I b , c I), computational",
        "resources would be wasted as the price for a wrong processing.",
        "After all, it is up to a programmer to take a deliberate care so that information should be efficiently transmitted across patterns.",
        "This causes several problems interwoven with one another.",
        "First, since those programs reflect the intended order of execution, they fail to straightforwardly capture Lhe uniformities captured by rules or principles such as (3).",
        "Accordingly, programming takes much labor.",
        "Moreover, the resulting programs work efficiently only along the initially intended order."
      ]
    },
    {
      "heading": "3. Conditioned Unification",
      "text": []
    },
    {
      "heading": "3.1. Conditioned Patterns",
      "text": [
        "These problems will be settled if we can attach information to patterns, instead of attaching procedures to pro-grains.",
        "Here we consider that such information is carried by some conditions on variables.",
        "Variables are then regarded as carrying some information rather than remain:-Mg simply indeterminate.",
        "By a conditioned pattern let us refer to a pair of a pattern and a condition on the variables contained in that pattern.",
        "For simplicity, assume that the condition of a conditioned pattern consists of atomic formulas of Prolog whose argument positions are filled with variables appearing in the pattern, and that the predicates heading those atomic formulas are defined in terms of Horn clauses, For instance, we would like to regard the whole thing in (1) or (4) as a conditioned pattern."
      ]
    },
    {
      "heading": "3.2. Modular Conditions",
      "text": [
        "The conditions in conditioned patterns must riot be executed, or the contained information would be partially lost.",
        "The conditions have to be somehow joined when conditioned patterns are unified, so that, the information they contain should be transmitted properly in the sense that the resulting condition is equivalent to the logical conjunction of the input conditions and contains neither redundant nor inconsistent information.",
        "We call such a unification a conditioned unification.",
        "A simple way to reduce redundancy and inconsistency in a condition is to let each part of each possible value of each variable be subject to at, most one constraint.",
        "Let us formulate this below.",
        "We say that a condition is superficially modular, when no variable appears twice in that condition.",
        "For instance, (ha) is a superficially modular condition, whereas (5b,e) are not.",
        "(Conditions are sometimes written as lists of atomic formulas.)",
        "(5) a.",
        "[a(X, Y), b(Z), a(U, V)] b. l a(X, Y), b(Y)1 c. [a(X, Y, X)]",
        "Further we say that a condition 4) is modular, when all the relevant conditions are superficially modular.",
        "Here, the relevant, conditions are 4] and the bodies of Horn clauses reached by descending along the definitions of the predicates appearing in 4].",
        "A predicate is said to be modular when its definition contains only those Horn clauses whose bodies are modular conditions.",
        "A predicate is potentially modular when it is equivalent to some modular predicate.",
        "A modular condition does not impose two constraints on any one part of any variable, and therefore contains neither redundancy nor inconsistency.",
        "Hereafter we consider that the condition in every conditioned pattern should be modular."
      ]
    },
    {
      "heading": "3.3. Expressive Power",
      "text": [
        "Conditioned patterns can carry rich enough information for capturing the linguistic generality.",
        "Obviously, at first, they can describe any finite set of finite patterns.",
        "For instance, (1) is regarded as a conditioned pattern with modular condition [put_tns_psiii_nmb (7', P, N)].",
        "Moreover, also some recursive predicates are modular, as is demonstrated below.",
        "(6) a. append([], Y, Y),",
        "Ilowever, some recursive predicates are not potentially modular.",
        "They include reverse (the binary predicate which is satisfied iff its two arguments are the reversals of each other, as in reverse ([[ a , c, [d, c, [a, b]])), perm (the binary predicate satisfied iff its arguments are permutations of each other, as in perm ([1, 2, 3], [2, 1, 3])), subset (the binary predicate which obtains iff the first argument is a subset of the second, as in subset ad, b], [a, b, a, d])), etc.",
        "Nevertheless, this causes no problem regarding natural language processing, because potentially infinite patterns come up only out of features such as SLASH, which do not require those non-modular predicates."
      ]
    },
    {
      "heading": "3.4. The Unifier",
      "text": [
        "Shown below is a' trace of the conditioned unification, between conditioned patterns (7) and (8) (here we use the same notation for conditioned patterns as for Horn clauses), where the predicates therein have been defied as in (9).",
        "(The definitions of c () and c 3 are not exploited.)",
        "First, we unify [X, Y, X, W] and [A, I3, C, C] with one another and get X = A, Y B, Z = C, and 11' = In the environment under this unification, the two conditions are concatenated, resulting in [c 0(X), c 11, Z), e 2(Z, IV)].",
        "The major task of this conditioned unification is to obtain a modular condition, equivalent to this non-modular condition.",
        "This is the job of function modularize.",
        "Modulaisize calls function integrate, which returns an atomic formula equivalent to the given condition.",
        "The termination of a modularize or an integrate is indicated by preceding the return-value, with the same amount of indentation as the outset of this function-call was indicated with.",
        "When an integrate calls a modularize, the alphabetic identifier of the exploited llorn clause is indicated to the left-hand side, and the temporal unification Lo the right-hand side.",
        "Atomic formulas made in 'integrate is written following Each horn clause entered into the definition is shown following 1', and given an alphabetic identifier indicated to the right-hand side.",
        "(7) [X, Y, Z, cO(X), cl (Y, 7).",
        "(8) [A, 13, C, : – c2(C, D).",
        "(9) cl(0, 1).",
        "(a)",
        "We can refine the program of integrate so that it should avoid any predicate whose definition contains only one !torn clause.",
        "For instance, the definition of cb consists only of (i).",
        "Instead of (j), therefore, we may have c 0(0, 1, P) c 3(P).",
        "Also (1) can he replaced by c (Q, 2, 0), based on (k).",
        "We arc able to work out recursive conditions from given recursive conditions.",
        "For example, consider how A' and ,1/, arc unified under the condition (10), where member is defined as in (11).",
        "(10) member(X, Y), cO(Z)1 (11) member(A, [A113]).",
        "(a)",
        "member(A, IC 131) :-- incruber(A, 13).",
        "(h) The trace of this unification is shown belgro, where predicate c 1 is recursively defined based on the recursive definition of member modularize(' inernber(X, Y), c0(X)1) integrated member(X, c0(X)1) c l (2, Y) (a) modularizeacO(A)D X = A, Y =1A lin integrate(' c 0(A)1) => co(A) t3=-1c0(A)11 e1(A, [A 113]) :3-- cO(A).",
        "(b) modularize(' member(A, 13), c0(A)1) X - A, Y 1C1111 integrate(linember(A, 13), cO(A)I) ==> el (A, 13) -3:; 1 e 1(A, 13)1 cl(A, 1C1131) 11).",
        "=3> c I (X, Al [cl(X, Y)1 It is a job of integrate to handle recursive definition.",
        "The last integrate above recognizes that the first integrate , which is trying to define o 1, was called with the same drg meats except the variable names.",
        "Hence the last integrate simply returns c 1(A, ft), because the content of c 1 is now being worked out under the first integrate and thus it is redundant, for the last integrate to further examine c 1.",
        "It is not always possible for the above unifier to unify patterns under recursive conditions.",
        "For instance, it cannot unify X with Y under rappend(X, 7,)1, because the resulting condition is not potentially modular.",
        "however, such a situation does not seem to occur in actual language processing."
      ]
    },
    {
      "heading": "1. Conclusion",
      "text": [
        "We have presented a new method of unification, which we call a conditioned C a L101-1, where patterns La be unified are annotated by a certain sort.",
        "of conditions on the variables which occur in those patterns.",
        "These conditions are so restricted that they contain as little redundancy as possible, and thus arc always assured to be satisfiable.",
        "This method has the following welcome characteristics.",
        "First, the patterns to be unified can carry abundant, infer-matron represented by thc conditions hanging on them.",
        "The expressive capacity of these conditions is sufficient fort capturing linguistic generalities.",
        "Second, Stich information is effectively transmitted, by integrating the conditions when patterns are unified.",
        "Unlike procedure attachments, in this connection, the information-conveying efficiency of our conditioned unification is not.",
        "affected by the direction of the data--flow.",
        "Therefore, our conditioned unification is completely reversible, and thus is promising as a tool far describing grammars for both sentence comprehension and production.",
        "Owing to these characteristics, our conditioned unification provides a new programming paradigm for natural language processing, replacing procedure attachments which have traditionally enjoyed Lire ubiquity that, they do not deserve."
      ]
    }
  ]
}
