{
  "info": {
    "authors": [
      "William C. Rounds",
      "Alexis Manaster Ramer"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P87-1013",
    "title": "A Logical Version of Functional Grammar",
    "url": "https://aclweb.org/anthology/P87-1013",
    "year": 1987
  },
  "references": [
    "acl-P86-1010",
    "acl-P86-1038"
  ],
  "sections": [
    {
      "heading": "1 Abstract",
      "text": [
        "Kay's functional-unification grammar notation [5] is a way of expressing grammars which relies on very few primitive notions.",
        "The primary syntactic structure is the feature structure, which can be visualised as a directed graph with arcs labeled by attributes of a constituent, and the primary structure-building operation is unification.",
        "In this paper we propose a mathematical formulation of FUG, using logic to give a precise account of the strings and the structures defined by any grammar written in this notation."
      ]
    },
    {
      "heading": "2 Introduction",
      "text": [
        "Our basic approach to the problem of syntactic description is to use logical formulas to put conditions or constraints on ordering of constituents, ancestor and descendant relations, and feature attribute information in syntactic structures.",
        "The present version of our logic has predicates specifically designed for these purposes.",
        "A grammar can be considered as just a logical formula, and the structures satisfying the formula are the syntactic structures for the sentences of the language.",
        "This notion goes back to DCG's [6], but our formulation is quite different.",
        "In particular, it builds on the logic of Kasper and Rounds [3], a logic intended specifically to describe feature structures.",
        "The formulation has several new aspects.",
        "First, it introduces the oriented feature structure as the primary syntactic structure.",
        "One can think of these structures as parse trees superimposed on directed graphs, although the general definition allows much more flexibility.",
        "In fact, our notation does away with the parse tree altogether.",
        "A second aspect of the notation is its treatment of word order.",
        "Our logic allows small grammars to define free-word order languages over large vocabularies in a way not possible with standard ID/LP rules.",
        "It is not clear whether or not this treatment of word order was intended by Kay, but the issue naturally arose during the process of making this model precise.",
        "(Joshi [I] has adopted much the same conventions in tree adjunct grammar.)",
        "A third aspect of our treatment is the use of fixed-point formulas to introduce recursion into grammars.",
        "This idea is implicit in DCG's, and has been made explicit in the logics CLFP and ILFP [9].",
        "We give a simple way of expressing the semantics of these formulas which corresponds closely to the usual notion of grammatical derivations.",
        "There is an interesting use of type variables to describe syntactic categories and/or constructions.",
        "We illustrate the power of the notation by sketching how the constructions of relational grammar [7] can be formulated in the logic.",
        "To our knowledge, this is the first attempt to interpret the relational ideas in a fully mathematical framework.",
        "Although relational networks themselves have been precisely specified, there does not seem to be a precise statement of how relational derivations take place.",
        "We do not claim that our formalization is the one intended by Postal and Perlmutter, but we do claim that our notation shows clearly the relationship of relational to transformational grammars on one hand, and to lexical-functional grammars on the other.",
        "Finally, we prove that the satisfiability problem for our logic is undecidable.",
        "This should perhaps be an expected result, because the proof relies on simulating Turing machine computations in a grammar, and follows the standard undecidability arguments.",
        "The satisfiability problem is not quite the same problem as the universal recognition problem, however, and with mild conditions on derivations similar to those proposed for LFG [2], the latter problem should become decidable.",
        "We must leave efficiency questions unexamined in this paper.",
        "The notation has not been implemented.",
        "We view this notation as a temporary one, and anticipate that many revisions and extensions will be necessary if it is to be implemented at all.",
        "Of course, FUG itself could be considered as an implementation, but we have added the word order relations to our logic, which are not explicit in FUG.",
        "In this paper, which is not full because of space limitations, we will give definitions and examples in Section 3; then will sketch the relational application in Section 4, and will conclude with the undecidability result and some final remarks."
      ]
    },
    {
      "heading": "3 Definitions and examples",
      "text": []
    },
    {
      "heading": "3.1 Oriented f-structures",
      "text": [
        "In this section we will describe the syntactic structures to which our logical formulas refer.",
        "The next subsection",
        "will give the logic itself.",
        "Our intent is to represent not only feature information, but also information about ordering of constituents in a single structure.",
        "We begin with the unordered version, which is the simple DG (directed graph) structure commonly used for non-disjunctive information.",
        "This is formalized as an acyclic finite automaton, in the manner of Kasper-Rounds [3].",
        "Then we add two relations on nodes of the DG: ancestor and linear precedence.",
        "The key insight about these relations is that they are partial; nodes of the graph need not participate in either of the two relations.",
        "Pure feature information about a constituent need not participate in any ordering.",
        "This allows us to model the \"cset\" and \"pattern\" information of FUG, while allowing structure sharing in the usual DG representation of features.",
        "We are basically interested in describing structures like that shown in Figure 1.",
        "A formalism appropriate for specifying such DG structures is that of finite automata theory.",
        "A labeled DG can be regarded as a transition graph for a partially specified deterministic finite automaton.",
        "We will thus use the ordinary b notation for the transition function of the automaton.",
        "Nodes of the graph correspond to states of the automaton, and the notation b(q, x) implies that starting at state(node) q a transition path actually exists in the graph labeled by the sequence x, to the state b(q, x).",
        "Let L be a set of arc labels, and A be a set of atomic feature values.",
        "An (A, L)- automaton is a tuple",
        "where Q is a finite set of states, qo is the initial state, L is the set of labels above, b is a partial function from Q x L to Q, and r is a partial function from terminating states of A to A.",
        "(q is terminating if b(q,1) is undefined for all 1 E L.) We require that A be connected and acyclic.",
        "The map r specifies the atomic feature values at the final nodes of the DG.",
        "(Some of these nodes can have unspecified values, to be unified in later.",
        "This is why r is only partial.)",
        "Let F be the set of terminating states of A, and let P(A) be the set of full paths of A, namely the set {x E L : b(q0,x) E F}.",
        "Now we add the constituent ordering information to",
        "the nodes of the transition graph.",
        "Let E be the terminal vocabulary (the set of all possible words, morphemes, etc.)",
        "Now r can be a partial map from Q to E U A, with the requirement that if r(q) E A, then q E F. Next, let a and < be binary relations on Q, the ancestor and precedence relations.",
        "We require a to be reflexive, antisymmetric and transitive; and the relation < must be irreflexive and transitive.",
        "There is no requirement that any two nodes must be related by one or the other of these relations.",
        "There is, however, a compatibility constraint between the two relations:",
        "Note: We have required that the precedence and dominance relations be transitive.",
        "This is not a necessary requirement, and is only for elegance in stating conditions like the compatibility constraint.",
        "A better formulation of precedence for computational purposes would be the \"immediate precedence\" relation, which says that one constituent precedes another, with no constituents intervening.",
        "There is no obstacle to having such a relation in the logic directly.",
        "Example.",
        "Consider the structure in Figure 2.",
        "This graph represents an oriented f-structure arising from a LFG-style grammar for the language {an b\" c\" I n> 1}.",
        "In this example, there is an underlying CFG given by the following productions:",
        "The arcs labeled with numbers (1,2,3) are analogous to arcs in the derivation tree of this grammar.",
        "The root node is of \"category\" S, although we have not represented this information in the structure.",
        "The nodes at the ends of the arcs 1,2, and 3 are ordered left to right; in our logic this will be expressed by the formula 1 < 2 < 3.",
        "The other arcs, labeled by COUNT and #, are feature",
        "arcs used to enforce the counting information required by the language.",
        "It is a little difficult in the graph representation to indicate the node ordering information and the ancestor information, so this will wait until the next section.",
        "Incidentally, no claim is made for the linguistic naturalness of this example!"
      ]
    },
    {
      "heading": "3.2 A presentation of the logic",
      "text": [
        "We will introduce the logic by continuing the example of the previous section.",
        "Consider Figure 2.",
        "Particular nodes of this structure will be referenced by the sequences of arc labels necessary to reach them from the root node.",
        "These sequences will be called paths.",
        "Thus the path 1 2 2 2 3 leads to an occurrence of the terminal symbol b.",
        "Then a formula of the form, say, 1 2 COUNT = 2 2 COUNT would indicate that these paths lead to the same node.",
        "This is also how we specify linear precedence: the last b precedes the first c, and this could be indicated by the formula 1 2 2 2 3 < 2 2 2 2 1.",
        "It should already be clear that our formulas will describe oriented f-structures.",
        "We have just illustrated two kinds of atomic formula in the logic.",
        "Compound formulas will be formed using A (and), and V (or).",
        "Additionally, let I be an arc label.",
        "Then an f-structure will satisfy a formula of the form 1: (1), if there is an 1-transition from the root node to the root of a substructure satisfying 0.",
        "What we have not explained yet is how the recursive information implicit in the CFG is expressed in our logic.",
        "To do this, we introduce type variables as elementary formulas of the logic.",
        "In the example, these are the \"category\" variables S, T, and C. The grammar is given as a system of equations (more properly, equivalences), relating these variables.",
        "We can now present a logical formula which describes the language of the previous section.",
        "where 4612 is the formula (c a 1) A (e a 2), in which e is the path of length 0 referring to the initial node of the f-structure, and where the other 0 formulas are similarly defined.",
        "(The 0 formulas give the required dominance information.)",
        "In this example, the set L = {1, 2, 3, #, count}, the set E = {a, 6,c}, and the set A = {end}.",
        "Thus the atomic symbol \"end\" does not appear as part of any derived string.",
        "It is easy to see how the structure in Figure 2 satisfies this formula.",
        "The whole structure must satisfy the formula S, which is given recursively.",
        "Thus the substructure at the end of the 1 arc from the root must satisfy the clause for T, and so forth.",
        "It should now be clearer why we consider our logic a logic for functional grammar.",
        "Consider the FUG description in Figure 3.",
        "According to [5, page 149], this descrilition specifies sentences, verbs, or noun phrases.",
        "Let us call such structures \"entities\", and give a partial translation of this description into our logic.",
        "Create the type variables ENT, S, VERB, and NP.",
        "Consider the recursive formula ENT where",
        "Notice that the category names can be represented as type variables, and that the categories NP and VERB are free type variables.",
        "Given an assignment of a set of f-structures to these type variables, the type ENT will become well-specified.",
        "A few other points need to be made concerning this example.",
        "First, our formula does not have any ancestor information in it, so the dominance relations implicit in Kay's patterns are not represented.",
        "Second, our word order conventions are not the same as Kay's.",
        "For example, in the pattern (subj pred • • .",
        "), it is required that the subject be the very first constituent in the sentence, and that nothing intervene between the subject and predicate.",
        "To model this we would need to add the \"immediately left or predicate, because our < predicate is transitive, and does not require this property.",
        "Next, Kay uses \"CAT\" arcs to represent category information, and considers \"NP\" to be an atomic value.",
        "It would be possible to do this in our logic as well, and this would perhaps not allow NPs to be unified with VERBs.",
        "However, the type variables would still be needed, because they are essential for specifying recursion.",
        "Finally, FUG has other devices for special purposes.",
        "One is the use of nonlocal paths, which are used at inner levels of description to refer to features of the \"root node\" of a DG.",
        "Our logic will not treat these, because in combination with recursion, the description of the semantics is quite complicated.",
        "The full version of the paper will have the complete semantics."
      ]
    },
    {
      "heading": "3.3 The formalism 3.3.1 Syntax",
      "text": [
        "We summarize the formal syntax of our logic.",
        "We postulate a set A of atomic feature names, a set L of attribute labels, and a set E of terminal symbols (word entries in a lexicon.)",
        "The type variables come from a set TVAR = {X0, Xi, ...}.",
        "The following list gives the syntactical constructions.",
        "All but the last four items are atomic formulas.",
        "1.",
        "NIL 2.",
        "TOP 3.",
        "X, in which X E TVAR 4. a, in which a E A 5. o, in which a E E 6. x < y, in which x and y E L° 7. x a y, in which x and y E L' 8.",
        "[xi, , xn], in which each xi E L° 9.",
        "1:",
        "10.",
        "0 A' 11.",
        "0 v 12.",
        "0 where [X1 ::= 951; Xn ::= On] Items (1) and (2) are the identically true and false formulas, respectively.",
        "Item (8) is the way we officially represent path equations.",
        "We could as well have used equations like x = y, where x and y E L, but our definition lets us assert the simultaneous equality of a finite number of paths without writing out all the pairwise path equations.",
        "Finally, the last item (12) is the way to express recursion.",
        "It will be explained in the next subsection.",
        "Notice, however, that the keyword where is part of the syntax."
      ]
    },
    {
      "heading": "3.3.2 Semantics",
      "text": [
        "The semantics is given with a standard Tarski definition based on the inductive structure of wffs.",
        "Formulae are satisfied by pairs (A, p), where A is an oriented f-structure and p is a mapping from type variables to sets off-structures, called an environment.",
        "This is needed because free type variables can occur in formulas.",
        "Here are the official clauses in the semantics:",
        "1.",
        "(A, p) NIL always; 2.",
        "(A, p) TOP never; 3.",
        "(A, p) X iff A E p(X); 4.",
        "(A, p) a iff r(qo) = a, where qo is the initial state of A; 5.",
        "(A, p) a, where a E E, if r(q0) = a; 6.",
        "(A, p) v < w if 6(q0,v) < 6(q0,w); 7.",
        "(A, p) v a w if b(q0,v) a b(q0,w); 8.",
        "(A, p) [xl, .. .,znj if Vi, j : 6(q0, xi) = 9.",
        "(A,p) 1: iff (All,p) 0, where All is the",
        "for some k, (A, p(k)) 0, where p(k) is defined inductively as follows:",
        "• p(o)(xi) = 0; • P(k+1)(X1) = 1B I (B, p) Oil",
        "and where p(k)(X) = p(X) if X Xi for any i.",
        "We need to explain the semantics of recursion.",
        "Our semantics has two presentations.",
        "The above definition is shorter to state, but it is not as intuitive as a syntactic, operational definition.",
        "In fact, our notation where [..Y1 ::= 01, • • • , Xn ::= On]",
        "is meant to suggest that the Xs can be replaced by the Os in 0.",
        "Of course, the Os may contain free occurrences of certain X variables, so we need to do this same replacement process in the system of Os beforehand.",
        "It turns out that the replacement process is the same as the process of carrying out grammatical derivations, but making replacements of nonterminal symbols all at once.",
        "With this idea in mind, we can turn to the definition of replacement.",
        "Here is another advantage of our logic – replacement is nothing more than substitution of formulas for type variables.",
        "Thus, if a formula 8 has distinct free type variables in the set D = {Xi, , X„}, and On • • • On are formulas, then the notation",
        "denotes the simultaneous replacement of any free occurrences of the Xi in 0 with the formula 0j, taking care to avoid variable clashes in the usual way (ordinarily this will not be a problem.)",
        "Now consider the formula where [Xi ::= 01; .",
        "• • Xn The semantics of this can be explained as follows.",
        "Let",
        "These formulas, which can be calculated iteratively, correspond to the derivation process.",
        "Next, we consider the formula ;b.",
        "In most grammars, 0 will just be a \"distinguished\" type variable, say S. If (A, p) is a pair consisting of an automaton and an environment, then we define (A, p) where [X1 ::= 01; • • • Xn ::= On] if for some k,",
        "Then, using the above substitutions, and simplifying according to the laws of Kasper-Rounds, we have",
        "The f-structures defined by the successive formulas for S correspond in a natural way to the derivation trees of the grammar underlying the example.",
        "Next, we need to relate the official semantics to the derivational semantics just explained.",
        "This is done with the help of the following lemmas.",
        "The proofs are omitted.",
        "Finally, we must explain the notion of the language defined by 0, where 0 is a logical formula.",
        "Suppose for simplicity that 0 has no free type variables.",
        "Then the notion A 0 makes sense, and we say that a string w E L(0) if for some subsumption-minimal f-structure A, A 0, and w is compatible with A.",
        "The notion of subsumption is explained in [8].",
        "Briefly, we have the following definition.",
        "Let A and 5 be two automata.",
        "We say A C B (A subsumes B; B extends A) if there is a homomorphism from A to B; that is, a map h :QA QB such that (for all existing transitions)",
        "1. h(64q,1)) = 458(h(q),l); 2. r(h(q)) = r(q) for all q such that r(q) E A; 3. h(q0,) =",
        "It can be shown that subsumption is a partial order on isomorphism classes of automata (without orderings), and that for any formula 0 without recursion or ordering, that there are a finite number of subsumption-minimal automata satisfying it.",
        "We consider as candidate structures for the language defined by a formula, only automata which are minimal in this sense.",
        "The reason we do this is to exclude f-structures which contain terminal symbols not mentioned in a formula.",
        "For example, the formula NIL is satisfied by any &structure, but only the minimal one, the one-node automaton, should be the principal structure defined by this formula.",
        "By compatibility we mean the following.",
        "In an structure A, A, restrict the ordering < to the terminal symbols of A.",
        "This ordering need not be total; it may in fact be empty.",
        "If there is an extension of this partial order on the terminal nodes to a total order such that the labeling",
        "symbols agree with the symbols labeling the positions of w, then w is compatible with A.",
        "This is our new way of dealing with free word order.",
        "Suppose that no precedence relations are specified in a formula.",
        "Then, minimal satisfying f-structures will have an empty <- relation.",
        "This implies that any permutation of the terminal symbols in such a structure will be allowed.",
        "Many other ways of defining word order can also be expressed in this logic, which enjoys an advantage over ID/LP rules in this respect."
      ]
    },
    {
      "heading": "4 Modeling Relational Grammar",
      "text": [
        "Consider the relational analyses in Figures 4 and 5.",
        "These analyses, taken from [7], have much in common with functional analyses and also with transsformational ones.",
        "The present pair of networks illustrates a kind of raising construction common in the relational literature.",
        "In Figure 4, there are arc labels P, 1, and 2, representing \"predicate\", \"subject\", and \"object\" relations.",
        "The \"cl\" indicates that this analysis is at the first linguistic stratum, roughly like a transformational cycle.",
        "In Figure 5, we learn that at the second stratum, the predicate (\"believed\") is the same as at stratum 1, as is the subject.",
        "However, the object at level 2 is now \"John\", and the phrase \"John killed the farmer\" has become a \"chOmeur\" for level 2.",
        "The relational network is almost itself a feature structure.",
        "To make it one, we employ the trick of introducing an arc labeled with 1, standing for \"previous level\".",
        "The conditions relating the two levels can easily be stated as path equations, as in Figure 6.",
        "The dotted lines in Figure 6 indicate that the nodes they connect are actually identical.",
        "We can now indicate precisely other information which might be specified in a relational grammar, such as the ordering information 1 < P < 2.",
        "This would apply to the \"top level\", which for Perlmutter and Postal would be the \"final level\", or surface level.",
        "A recursive specification would also become possible: thus",
        "This is obviously an incomplete grammar, but we think it possible to use this notation to give a complete specification of an RG and, perhaps at some stage, a computational test."
      ]
    },
    {
      "heading": "5 Undecidability",
      "text": [
        "In this section we show that the problem of satisfiability – given a formula, decide if there is an f-structure satisfying it – is undecidable.",
        "We do this by building a formula which describes the computations of a given Turing machine.",
        "In fact, we show how to speak about the computations of an automaton with one stack (a pushdown automaton.)",
        "This is done for convenience; although the halting problem for one-stack automata is decidable, it will be clear from the construction that the computation of a two-stack machine could be simulated as well.",
        "This model is equivalent to a Turing machine – one stack represents the tape contents to the left of the TM head, and the other, the tape contents to the right.",
        "We need not simulate moves which read input, because we imagine the TM started with blank tape.",
        "The halting problem for such machines is still undecidable.",
        "We make the following conventions about our FDA.",
        "Moves are of two kinds:",
        "• qi : push b; go to qi ; • qi : pop stack; if a go to qi else go to cut.",
        "The machine has a two-character stack alphabet {a, b}.",
        "(In the push instruction, of course pushing \"a\" is allowed.)",
        "If the machine attempts to pop an empty stack, it cannot continue.",
        "There is one final state qt.",
        "The machine halts sucessfully in this and only this state.",
        "We reduce the halting problem for this machine to the satisfiability problem for our logic.",
        "Atoms: \"none\" --- bookkeeping marker for telling what is in the stack q0, ql qn --- one for each state Labels: a, b for describing stack contents s -- pointer to top of stack next --- value of next state --- pointer to previous stack configuration"
      ]
    },
    {
      "heading": "Type variables:",
      "text": [
        "COIF -- structure represents a machine configuration SNIT, FINAL configurations at start and finish 00,...,QN: property of being in one of these states The simulation proceeds as in the relational grammar example.",
        "Each configuration of the stack corresponds to a level in an RG derivation.",
        "Initially, the stack is empty.",
        "Thus we put",
        "INIT ::= s : (b : none A a : none) A next : q0.",
        "results which were more positive than a general undecid-Then we describe standard configurations: ability theorem.",
        "Similar remarks hold for theories like relational grammar, in which many such constraints have been studied.",
        "We hope that logical tools will provide a way to classify these empirically motivated conditions."
      ]
    },
    {
      "heading": "CONF ::= INIT V (p : CONF A (Q0 V ... V QN)).",
      "text": [
        "Next, we show how configurations are updated, depending on the move rules.",
        "If qi is push b; go to qj , then we write"
      ]
    },
    {
      "heading": "QI ::= next:qjAp:next:qiAs:a:noneAsb=ps.",
      "text": [
        "The last clause tells us that the current stack contents, after finding a \"b\" on top, is the same as the previous contents.",
        "The \"a: none\" clause guarantees that only a \"b\" is found on the DG representing the stack.",
        "The second clause enforces a consistent state transition from the previous configuration, and the first clause says what the next state should be.",
        "If qi is pop stack; it a go to qj else go to qk, then we write the following.",
        "For the last configuration, we put"
      ]
    },
    {
      "heading": "QF ::= CONF A p : next : qt.",
      "text": [
        "We take QF as the \"distinguished predicate\" of our scheme.",
        "It should be clear that this formula, which is a big where-formula, is satisfiable if the machine reaches state"
      ]
    },
    {
      "heading": "6 Conclusion",
      "text": [
        "It would be desirable to use the notation provided by our logic to state substantive principles of particular linguistic theories.",
        "Consider, for example, Kashket's parser for Warlpiri [4], which is based on GB theory.",
        "For languages like Warlpiri, we might be able to say that linear order is only explicitly represented at the morphemic level, and not at the phrase level.",
        "This would translate into a constraint on the kinds of logical formulas we could use to describe such languages: the < relation could only be used as a relation between nodes of the MORPHEME type.",
        "Given such a condition on formulas, it might then be possible to prove complexity"
      ]
    }
  ]
}
