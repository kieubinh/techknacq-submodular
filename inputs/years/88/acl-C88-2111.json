{
  "info": {
    "authors": [
      "Manny Rayner",
      "Asa Hugosson",
      "Goran Hagert"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C88-2111",
    "title": "Using a Logic Grammar to Learn a Lexicon",
    "url": "https://aclweb.org/anthology/C88-2111",
    "year": 1988
  },
  "references": [
    "acl-P85-1009"
  ],
  "sections": [
    {
      "heading": "Summary",
      "text": [
        "It is suggested that the concept of \"logic grammar\" as relation between a string and a parse-tree can be extended by admitting the lexicon as part of the relation.",
        "This makes it possible to give a simple and elegant formulation of the process of infering a lexicon from example sentences in conjunction with a grammar.",
        "Various problems arising from implementation and complexity factors are considered, and examples are shown to support the claim that the method shows potential as a practical tool for automatic lexicon acquisition."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "The basic idea is as follows: a logic grammar [1] can be viewed as the definition of a relation between a string and a parse-tree.",
        "You can run it two ways: finding the parse-trees that correspond to a given string (parsing), or finding the strings that correspond to a given parse-tree (generating).",
        "However, if we view the lexicon as part of this relation, we get new possibilities.",
        "More specifically, we can compute the lexicons th a t correspond to a given string; this can in a natural way be viewed as a formalization of \"lexicon learning from example sentences\".",
        "In terms of the \"explanation-based learning\" paradigm, this makes the associated parse-tree the \"explanation\" (See diagram 1).",
        "generating Diagram 1 In what comes below, we are going to consider the following questions:",
        "1) We are learning from positive-only examples.",
        "What can't be learned like this?",
        "2) The basic structural constraint, the thing that makes it all work, is the assumption that a word can usually only be interpreted as one part of speech.",
        "If we assume that this is always going to be true, then things really go pretty well (Section 2).",
        "However, this rule is broken sufficiently often that a realistic system has to able to deal with it.",
        "How?",
        "3) How important is the order in which examples are presented?",
        "Can the system select a good order itself, if it is important?",
        "4) What kind of complexity features are there?",
        "How scalable is it in terms of number of sentences, number of grammar rules, number of words to learn?",
        "2.",
        "Learning with the \"one entry per word\" assumption.",
        "This is the simplest variant of the idea: assume that there is one entry per word, and represent the lexicon as an association-list (alist) with one entry for each word.",
        "Each sentence now constrains the possible values of these entries to be ones, which allow it to be parsed; the hope is that a conjunction of a suitably large number of such constraints will be enough to determine the lexicon uniquely.",
        "In concrete Prolog programming terms, what this means is the following.",
        "In the initial lexicon, the entries are all uninstantiated.",
        "We use this to parse the first sentence, which fills in some entries; the resulting partially instantiated lexicon is sent to the second sentence, which either refutes it or instantiates it some more, and the process is repreated until we get to the end.",
        "If at any stage we are unable to parse a sentence, we just backtrack.",
        "If we want to, we can continue even after we've got to the end, to generate all possible lexicons that are consistent with the input sentences and the grammar (and in fact we ought to do this, so as to know which words are still ambiguous).",
        "This procedure can be embodied as a one-page Prolog program (see diagram 2), but despite this it is still surprisingly fast on small examples (a grammar with 15-30 rules, 10-15 sentences with a total of 30-40 words to learn).",
        "We performed some experiments with this kind of setup, and drew these, conclusions:",
        "1) Certain things can't be learned from positive-only examples.",
        "For example (at least with the grammars we have tried), it is impossible to determine whether belongs is a verb which takes a PP complement with preposition to, or is an intransitive verb which just happens to have a PP modifier in all the sentences where it turns up.",
        "However, things of this kind seem fairly rare.",
        "2) Order is fairly critical.",
        "When examples are presented at random, a run time of about 100 seconds for a 10-12 sentence group is typical; ordering them so that not too many new words are introduced at once drops this to about 5 seconds, a factor of 20.",
        "This gets worse with more sentences, since a lot of work can be done before the system realizes it's got a wrong hypothesis and",
        "3) A more important complexity point: structural ambiguities needn't be lexical ambiguities; in other words, it is quite possible to parse a sentence in two distinct ways which still both demand the same lexical entries (in practice, the most common case by far is NP/VP a:tachrnent ambiguity).",
        "Every such ambiguity introducer; a spurious duplication of the lexicon, and since these multiply we get an exponential dependency on the number of sentences.",
        "We could conceivably have tried to construct a grammar which doesn't produce this kind of ambiguity (cf. (21, pp.",
        "64-71), but instead we reorganized the algorithm so as to collect after each step the set of all possible lexicons compatible with the input so far.",
        "Duplicates are then eliminated from this, and the result is passed to the next step.",
        "Although the resulting program is actually considerably more expensive for small examples, it wins in the long run.",
        "Moreover, it seems the right method to build on when we relax the \"one entry per word\" assumption."
      ]
    },
    {
      "heading": "3. Removing the \"one entry per word\" assumption.",
      "text": [
        "\"We don't actually remove the assumption totally, but just weaken it; for each new sentence, we now assume that, of the words already possessed of one or more entries, at most one may have an unknown alternate.",
        ".Multiple entries are sufficiently rare to make this reasonable.",
        "So we extend the methods from the end of section 2; first we try and parse the current sentence by 'looking up known entries and filling in entries for words we so far know nothing about.",
        "If we don't get any result this way, we try again, this time with the added possibility of once assuming that a word which already has known entries in fact has one more.",
        "This is usually OK, but sometimes produces strange results, as witness the following example.",
        "Suppose the first three sentences are John drives a car, John drives well, and John drives.",
        "After the first sentence, the system guesses that drives is a transitive verb, and it is able to maintain this belief after the second sentence if it also assumes that well is a pronoun.",
        "However, the third sentence forces it to realize that drives can also be an intransitive verb.",
        "Later on, it will presumably meet a sentence which forces well to be an adverb; we now have an anomalous lexicon where well has an extra entry (as pronoun), which is not actually used to explain anything any longer.",
        "To correct situations like this one, a two-pass method is necessary; we parse through all the sentences a second time with the final lexicon, keeping count of which entries are actually used.",
        "If we find some way of going through the whole lot without using some entry, it can be discarded.",
        "4.",
        "Ordering the sentences",
        "As remarked above, order is a critical factor; if words are introduced too quickly, so that the system has no chance to disambiguate them before moving on to new ones, then the number of alternate lexicons grows exponentially.",
        "Some way of ordering the sentences automatically is essential.",
        "Our initial effort in this direction is very simple, but still seems reasonably efficient; sentences are pre-ordered so as to minimize the number of new words introduced at each stage.",
        "So the first sentence is the one that contains the smallest number of distinct words, the second is the one which the smallest number of words not present in the first one, and so on.",
        "We have experimented with this approach, using groups of between 20 and 40 sentences and a grammar containing about 40 rules.",
        "If the sentences are randomly ordered, the number of alternate lexicons typically grows to over 400 within the first 6 to 10 sentences; this slows things down to the point where further progress is in practice impossible.",
        "Using the above strategy, we get a fairly dramatic improvement; the number of alternates remains small, reaching peak values of about 30.",
        "This is sufficient to be able to process the groups within sensible times (less than 15 seconds per sentence average).",
        "In the next two sections, we discuss the limitations of this method and suggest some more sophisticated alternatives.",
        "5.",
        "Increasing efficiency It is rather too early to say how feasible the methods described here can be in the long term.",
        "As far as we can see, scalability is good as far as grammar-size is concerned; we have increased the number of rules from 15 in the first version to about 40 in the current one with little performance degradation.",
        "Scalability with respect to number of sentences is more difficult to estimate.",
        "Using the methods described in sections 3 and 4, we have sucessfully processed groups of up to 50 sentences (about equally many words), with run times typically in the region of 10-15 minutes.",
        "An example is shown in the appendix.",
        "It is reasonable to suppose that the system as it stands would be capable of dealing with groups up to four or five times this size (i.e. 200-250 words to learn), but it has a limit; the problem is that there are always going to be a few words in any given corpus which occur insufficiently often for their lexical class to be determinable.",
        "Although these words are typically fairly rare, the ambiguities they introduce multiply in the usual way, leading to an eventual",
        "breakdown of the system.",
        "The following tentative ideas represent some approaches to this problem which we are currently investigating.",
        "What appears to be necessary is to find some intelligent way of utilising the fact that the various alternate lexicons all agree on the majority of entries; typically, less than 10% are ambiguous after any given step in the processing.",
        "The current system completely ignores this, representing each lexicon as a separate entity.",
        "If we are to improve this state of affairs, we can envisage two possible plans.",
        "Firstly, we could simply remove the \"difficult\" words, hoping that there are sufficiently few for this not to matter.",
        "More ambitiously, we can try to share structure between lexicons, so that the common part is not duplicated.",
        "We now expand on these two ideas in more detail.",
        "5.1.",
        "Removing \"difficult\" entries At regular intervals the group of alternate lexicons is analyzed: the normal state of affairs is that they are identical excepting the entries for a few words, the potential \"troublemakers\".",
        "What one could do would be simply to remove these entries, making them once again uninstantiated; then all sentences containing the offending words would be removed from the subgroup marked as already having been processed, and saved for possible future use.",
        "The overall effect would be to reduce the group of alternate lexicons to a single \"lowest common denominator\", which would represent the \"reliable\" information so far acquired, this at the expense of losing some partial information on the \"dubious\" words.",
        "We have carried out a few simple experiements along these lines, using a variant of the idea which at each \"check-point\" removes all ambigous words for which there are no further sentences awaiting processing.",
        "This seems at first sight very reasonable, but unfortunately it turns out that there are problems.",
        "Although one might easily think that an ambiguous word is going to stay ambiguous if it doesn't occur in any of the remaining sentences, in actual fact this is not so; a word can be disambiguated \"indirectly\", as a result of other words being disambiguated.",
        "To give a simple example: suppose that the first sentence is The zebra laughed.",
        "This can give rise to a number of possibilities: for example, the and laughed could be pronouns, and zebra a transitive verb.",
        "If the word zebra didn't occur again, one would thus wrongly conclude that there was no way of determining whether it was a common noun or a transitive verb.",
        "But this can easily be accomplished if the or laughed are later assigned to their proper classes, which will then remove the incorrect interpretation and indirectly make zebra unambiguous too.",
        "Clearly, a more sophisticated implementation is required if this idea is going to work.",
        "5.2.",
        "\"Lexicon compaction\" using Prolog constraints Here, we discuss the idea of exploiting the similarity between different alternate lexicons to \"merge\" or \"compact\" them.",
        "The technical tool we will be using to perform this operation is the Prolog \"constraint\" mechanism [3], [4].",
        "What we propose is illustrated in diagram 3, which shows two alternate lexicons, differing in a single entry.",
        "These can be combined into the third lexicon without any loss of information.",
        "Simple compaction of two lexicons Two alternate lexicons for the sentence: the dog belongs to the man Uthe:d],[dog:n],[belongs:v(intrans).1, [to:prep],[man:n]] [[the:d],[dog:n],[belongs:v(prep(to))], [to:prep],[man:n]] These can be compacted into the following single lexicon Hthe:d],[dog:n], [belongs:<X:X=v(prep(to);X=v(intrans)>], [to:prep],[man:n]] Diagram 3 The technique is potentially very powerful, and in favourable circumstances can be used to compact together large numbers of alternates, as diagram 4 illustrates.",
        "Compacting four lexicons into one in a two-stage process.",
        "lexl: [ ... [belongs :v (intrans)]r • [plays:v(intrans)], ...1 lex2: .",
        ".",
        ".",
        "[belongs:v(prep(to))], • [plays:v(intrans)], ...] lex3: [ [belongs:v(intrans)].e [plays:v(prep(with))], ...] lex4: [ [belongs:v(prep(to))], [plays:v(prep(with))], ...] In the first stage, we compact lex1 and lex2 to make lex12, and lex3 and lex4 to make lex34.",
        "lex12: [ ... [belongs : <X:X=v(prep(to);X=v(intrans)> ], [plays:v(intrans)], lex34: [ ... [belongs: <x:x=v(prep(to);X=v(intrans)> ], [plays:v(prep(with))], ...] Then we compact lex12 and 1ex34 to get the final result.",
        "What makes the \"compaction\" method so attractive is that it appears to get the best of both worlds: no information is lost, but substantial efficency gains can be attained.",
        "The method draws its power from the fact that it is \"intelligent\" about divergences between lexicons: if the sentence to be parsed contains none of the \"constrained\" words, then the compacted lexicon will behave as though it were a single, unambiguous, lexicon; but if \"constrained\" words are present, then the lexicon will be \"split\" again, to exactly the extent required by the various parsings of the sentence.",
        "It is to be noted that all this of course requires a Prolog constraint mechanism which is both efficient and logically complete, something that has only recently become possible [4].",
        "We are currently in the process of implementing the method within our system.",
        "6.",
        "Conclusions and further directions",
        "We have described a series of experiments which investigate the feasibility of automatically infering a lexicon from a logic grammar and a set of example sentences; this stands in fairly sharp contrast to most work done so far within the field of automatic language acquisition, where the emphasis has been either on grammar induction e.g. [5], [6], [7], or learning of word senses [8].",
        "ta view of the fact that much recent linguistic research has been moving towards unification-based formalisms where the bulk of the information is stored in the lexicon, we think that ideas like the ones we propound here should have a rich field of application.",
        "For example, Pollard and Sag's HPSG framework [9] has at only a couple of dozen grammatical rules, all of which are extremely general; the rest of the information is lexical in nature.",
        "Although we think that progress to date has been extremely encouraging, it is still a little too early to make any firm claim that our methods are going to be usable in a practical system.",
        "As discussed above, there are some non-trivial efficiency problems to be overcome: it also seems likely that we will need a more sophisticated ordering algorithm than that described in section 4, probably incorporating some notion of giving higher priority to sentences containing ambiguous words.",
        "Other important topics which we so far have not had time to devote attention to are the use of morphological information and the development of some way of handling incorrect sentences (maybe just ignoring them is enough; but our feeling is that things will be a little trickier).",
        "These and other related questions will, we hope, provide fruitful ground for continued research in this area."
      ]
    }
  ]
}
