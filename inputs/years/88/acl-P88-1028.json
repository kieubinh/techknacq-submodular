{
  "info": {
    "authors": [
      "Naoki Abe"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P88-1028",
    "title": "Polynomial Learnability and Locality of Formal Grammars",
    "url": "https://aclweb.org/anthology/P88-1028",
    "year": 1988
  },
  "references": [
    "acl-P85-1011",
    "acl-P87-1015"
  ],
  "sections": [
    {
      "heading": "ABSTRACT",
      "text": [
        "We apply a complexity theoretic notion of feasible learnability called \"polynomial learnability\" to the evaluation of grammatical formalisms for linguistic description.",
        "We show that a novel, nontrivial constraint on the degree of \"locality\" of grammars allows not only context free languages but also a rich class of mildy context sensitive languages to be polynomially learnable.",
        "We discuss possible implications of this result to the theory of natural language acquisition."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Much of the formal modeling of natural language acquisition has been within the classic paradigm of \"identification in the limit from positive examples\" proposed by Gold [7].",
        "A relatively restricted class of formal languages has been shown to be unlearnable in this sense, and the problem of learning formal grammars has long been considered intractable.'",
        "The following two controversial aspects of this paradigm, however, leave the implications of these negative results to the computational theory of language acquisition inconclusive.",
        "First, it places a very high demand on the accuracy of the learning that takes place – the hypothesized language must be exactly equal to the target language for it to be considered \"correct\".",
        "Second, it places a very permissive demand on the time and amount of data that may be required for the learning – all that is required of the learner is that it converge to the correct language in the limit.2 Of the many alternative paradigms of learning proposed, the notion of \"polynomial learnability\" recently formulated by Blumer et al.",
        "[6] is of particular interest because it addresses both of these problems in a unified 'Supported by an IBM graduate fellowship.",
        "The author gratefully acknowledges his advisor, Scott Weinstein, for his guidance and encouragement throughout this research.",
        "Some interesting learnable subclasses of regular languages have been discovered and studied by Angluin [3].",
        "2 For a comprehensive survey of various paradigms related to \"identification in the limit\" that have been proposed to address the first issue, see Osherson, Stob and Weinstein [12].",
        "As for the latter issue, Angluin ([5], [4]) investigates the feasible learnability of formal languages with the use of powerful oracles such as \"MEMBERSHIP' and \"EQUIVALENCE\".",
        "way.",
        "This paradigm relaxes the criterion for learning by ruling a class of languages to be learnable, if each language in the class can be approximated, given only positive and negative examples,3 with a desired degree of accuracy and with a desired degree of robustness (probability), but puts a higher demand on the complexity by requiring that the learner converge in time polynomial in these parameters (of accuracy and robustness) as well as the size (complexity) of the language being learned.",
        "In this paper, we apply the criterion of polynomial learnability to subclasses of formal grammars that are of considerable linguistic interest.",
        "Specifically, we present a novel, nontrivial constraint on grammars called \"klocality\", which enables context free grammars and indeed a rich class of mildly context sensitive grammars to be feasibly learnable.",
        "Importantly the constraint of k-locality is a nontrivial one because each k-local subclass is an exponential class 4 containing infinitely many infinite languages.",
        "To the best of the author's knowledge, \"k-locality\" is the first nontrivial constraint on grammars, which has been shown to allow a rich class of grammars of considerable linguistic interest to be polynomially learnable.",
        "We finally mention some recent negative result in this paradigm, and discuss possible implications of its contrast with the learnability of k-local classes."
      ]
    },
    {
      "heading": "2 Polynomial Learnability",
      "text": [
        "\"Polynomial learnability\" is a complexity theoretic notion of feasible learnability recently formulated by Blumer et al.",
        "([6]).",
        "This notion generalizes Valiant's theory of learnable boolean concepts [15], [14] to infinite objects such as formal languages.",
        "In this paradigm, the languages are presented via infinite sequences of pos-3We hold no particular stance on the the validity of the claim that children make no use of negative examples.",
        "We do, however, maintain that the investigation of learnability of grammars from both positive and negative examples is a worthwhile endeavour for at least two reasons: First, it has a potential application for the design of natural language systems that learn.",
        "Second, it is possible that children do make use of indirect negative information.",
        "itive and negative examples' drawn with an arbitrary but time invariant distribution over the entire space, that is in our case, Er'.",
        "Learners are to hypothesize a grammar at each finite initial segment of such a sequence, in other words, they are functions from finite sequences of members of Er' X OM to grammars.'",
        "The criterion for learning is a complexity theoretic, approximate, and probabilistic one.",
        "A learner is said to learn if it can, with an arbitrarily high probability (1 – 6), converge to an arbitrarily accurate (within e) grammar in a feasible number of examples.",
        "\"A feasible number of examples\" means, more precisely, polynomial in the size of the grammar it is learning and the degrees of probability and accuracy that it achieves – 8-1 and e-1.",
        "\"Accurate within e\" means, more precisely, that the output grammar can predict, with error probability e, future events (examples) drawn from the same distribution on which it has been presented examples for learning.",
        "We now formally state this criterion.'"
      ]
    },
    {
      "heading": "3 fET",
      "text": [
        "and f is computable in time polynomial in the length of input]"
      ]
    },
    {
      "heading": "If in addition all off's output grammars on example sequences for languages in G belong to g, then we say that is polynomially learnable by g.",
      "text": [
        "Suppose we take the sequence of the hypotheses (grammars) made by a learner on successive initial finite sequences of examples, and plot the \"errors\" of those grammars with respect to the language being learned.",
        "The two learnability criteria, \"identification"
      ]
    },
    {
      "heading": "Identification in the Limit Tint• Moo",
      "text": [
        "in the limit\" and \"polynomial learnability\", require different kinds of convergence behavior of such a sequence, as is illustrated in Figure 1.",
        "Blumer et al.",
        "([6]) shows an interesting connection between polynomial learnability and data compression.",
        "The connection is one way: If there exists a polynomial time algorithm which reliably \"compresses\" any sample of any language in a given collection to a provably small consistent grammar for it, then such an al-ogorithm polynomially learns that collection.",
        "We state this theorem in a slightly weaker form."
      ]
    },
    {
      "heading": "3 K-Local Context Free Grammars : locality(r) = 4",
      "text": [
        "The notion of \"k-locality\" of a context free grammar is defined with respect to a formulation of derivations defined originally for TAG's by Vijay-Shanker, Weir, and Joshi [16] [17], which is a generalization of the notion of a parse tree.",
        "In their formulation, a derivation is a tree recording the history of rewritings.",
        "Each node of a derivation tree is labeled by a rewriting rule, and in particular, the root must be labeled with a rule with the starting symbol as its left hand side.",
        "Each edge corresponds to the application of a rewriting; the edge from a rule (host rule) to another rule (applied rule) is labeled with the \"position\" of the nonterminal in the right hand side of the host rule at which the rewriting takes place.",
        "The degree of locality of a derivation is the number of distinct kinds of rewritings in it - including the immediate context in which rewritings take place.",
        "In terms of a derivation tree, the degree of locality is the number of different kinds of edges in it, where two edges are equivalent just in case the two end nodes are labeled by the same rules, and the edges themselves are labeled by the same node address.",
        "The degree of locality of a grammar is the maximum of those of all its derivations.",
        "We write k-Local-CFG = {G I G E CFG and G is k-Local} and k-Local-CFL = {L(G) I G E k-Local-CFG }-",
        "A crucical property of k-local grammars, which we will utilize in proving the learnability result, is that for each k-local grammar, there exists another k-local grammar in a specific normal form, whose size is only"
      ]
    },
    {
      "heading": "S Si",
      "text": [
        "S1 -4a S1 b 2 Si -411 Si b",
        "polynomially larger than the original grammar.",
        "The normal form in effect puts the grammar into a disjoint union of small grammars each with at most k rules and k nonterminal occurences.",
        "By \"the disjoint union\" of an arbitrary set of n grammars, gn, we mean the grammar obtained by first reanaming nonterminals in each gi so that the nonterminal set of each one is disjoint from that of any other, and then taking the union of the rules in all those grammars, and finally adding the rule S – P Si for each staring symbol Si of gi, and making a brand new symbol S the starting symbol of the grammar so obtained.",
        "11If R is a set of production rules, then NTO(Ri) denotes the number of nonterminal occurrences in those rules.",
        "then 0(G) is the set of all of its k-local components (G* above.)",
        "If G = (Gi I i E I) is a set of k-simple grammars, then ING) is a single grammar that is a \"disjoint union\" of all of the k-simple grammars in G."
      ]
    },
    {
      "heading": "4 K-Local Context Free Languages Are Polynomially Learnable",
      "text": [
        "In this section, we present a sketch of the proof of our main learnabifity result.",
        "Theorem 4.1 For each k E N; k-local-CFL is polynomially learnable.12 Proof: We prove this by exhibiting an Occam algorithm A for k-local-CFL with some fixed k, with range size polynomial in the size of a minimal grammar and less than linear in the sample size.",
        "We assume that A is given a labeled m-sampleI3 Si, for some L E k-local-CFL with size(H) = n where H is its minimal k-local-CFG.",
        "We let length(SL) = Eees length(s) = I.\"",
        "We let St and St denote the positive and negative portions of Si, respectively, i.e., St = I 3s E Si, such that a = (x,0)) and Sj = {x I 35 E SL such that s = (x,1)}.",
        "We fix a minimal grammar in k-local normal form G that is consistent with SL with size(G) < p(n) for some fixed polynomial p by Lemma 3.1. and the fact that a minimal consistent k-local-CFG is not larger than H. Further, we let G be the set of all of \"k-simple components\" of G and define L(d) = UGredL(Gi).",
        "Then note L(6) = L(G).",
        "Since each k-simple component has at most k floater-minals,,we assume without loss of generality that each Gs in G has the same nonterminal set of size k, say"
      ]
    },
    {
      "heading": "Ek =",
      "text": [
        "The idea for constructing A is straightforward.",
        "Step L We generate all possible rules that may be in the portion of G that is relevant to St. That is, if we fix a set of derivations D, one for each string in St from G, then the set of rules that we generate will contain all the rules that participate in any derivation in D. (We let Rel(G , St) denote the restriction of G to St with respect to some V in this fashion.)",
        "We use 12We use the size of a minimal k-local CFG as the size of a k-local-CFL, i.e., VL E k-local-CFL size(L) = minfsize(G) G E k-local-CFG & L(G)= 135L is a labeled m-sample for L if S C groph(char(L)) and card(S) = m. oraph(char(L)) is the grap-I1 of the characteristic function of L, i.e. is the set 1(x, 0) 1 r e u {(r,1) r L}.",
        "14 In the sequel, we refer to the number of strings in a sample as the sample size, and the total length of the strings in a sample as the sample length.",
        "k-locality of G to show that such a set will be polynomially bounded in the length of S. Step 2.",
        "We then generate the set of all possible grammars having at most k of these rules.",
        "Since each k-simple component of G has at most k rules, the generated set of grammars will include all of the k-simple components of G. Step 3.",
        "We then use the negative portion of the sample, Si.",
        "to filter out the \"inconsistent\" ones.",
        "What we have at this stage is a polynomially bounded set of k-simple grammars with varying sizes, which do not generate any of St, and contain all the k-simple grammars of G. Associated with each k-simple grammar is the portion of St that it \"covers\" and its size.",
        "Step 4.",
        "What an Occam algorithm needs to do, then, is to find some subset of these k-simple grammars that \"covers\" St, and has a total size that is provably only polynomially larger than a minimal total size of a subset that covers St, and is less than linear is the sample size, m. We formalize this as a variant of \"Set Cover\" problem which we call \"Weighted Set Cover\"(WSC), and prove the existence of .",
        "an approximation algorithm with a performance guarantee which suffices to ensure that the output of A will be a grammar that is provably only polynomially larger than the minimal one, and is less than linear in the sample size.",
        "The algorithm runs in time polynomial in the size of the grammar being learned and the sample length.",
        "Step 1.",
        "A crucial consequence of the way k-locality is defined is that the \"terminal yield\" of any rule body that is used to derive any string in the language could be split into at most k 1 intervals.",
        "(We define the \"terminal yield* of a rule body R to be h(R), where h is a homomorphism that preserves terminal symbols and deletes nonterminal symbols.)",
        "Definition 4.1 (Subyields) For an arbitrary i E N, an i-tuple of members of E. w = (v1, v2, ..., vi) is said to be a subyield of a, if there are some u1,...,ui,u:+1 E E. such that a = u3v1u2v2...uivitii+1.",
        "We let SubYields(i,․) = {u E (E;.",
        ")x I z <i dc w is a subyield of a).",
        "We then let SubYieldsk(St) denote the set of all subyields of strings in St that may have come from a rule body in a k-local-CFG, i.e. subyields that are tuples of at most k 1 strings.",
        "Definition 4.2",
        "This is obvious, since given a string s of length a, there",
        "are only 0(a2(1+1)) ways of choosing 2(k + 1) different positions in the string.",
        "This completely specifies all the elements of SubYieldsk+1(s).",
        "Since the number of strings (m) in St and the length of each string in St are each bounded by the sample length (1), we have at most 0(1) x 0(12(k+1)) strings in SubYieldsk(St).",
        "Thus we now have a polynomially generable set of possible yields of rule bodies in G. The next step is to generate the set of all possible rules having these yields.",
        "Now, by k-locality, in any derivation of G we have at most k distinct \"kinds\" of rewritings present.",
        "So, each rule has at most k useful nonterminal occurrences and since G is minimal, it is free of useless nonterminals.",
        "We generate all possible rules with at most k nonterminal occurrences from some fixed set of k nonterminals (Ek), having as terminal subyields, one of SubYieldsk(St).",
        "We will then have generated all possible rules of Rel(G , St).",
        "In other words, such a set will provably contain all the rules of Rel(G , St).",
        "We let TFRules(Ek) denote the set of \"terminal free rules\" {Ai.",
        "In<k&Vj< n A\" E Ek} We note that the cardinality of such a set is a function only of k. We then \"assign\" members of SubYieldsk(St) to TFRules(Ek), wherever it is possible (or the arities agree).",
        "We let CRules(k, Sill denote the set of \"candidate rules\" so obtained.",
        "It is easy to see that the number of rules in such a set is also polynomially bounded."
      ]
    },
    {
      "heading": "Claim 4.2 card(C Rules(k, Si)) = 0(1244)",
      "text": [
        "Step 2.",
        "Recall that we have assumed that they each have a nonterminal set contained in some fixed set of k nonterminals, E. So if we generate all subsets of C Rules(k, St) with at most k rules, then these will include all the k-simple grammars in G. Definition 4.4 CGrams(k,St)=Pk(CRules(k,Bt)).'",
        "Step 3.",
        "Now we finally make use of the negative portion of the sample, Sy – , to ensure that we do not include any inconsistent grammars in our candidates.",
        "This filtering can be computed in time polynomial in the length of SL, because for testing consistency of each grammar in CGrams(k, St), all that is involved is the membership question for strings in Sy – with that grammar.",
        "Step 4.",
        "What we have at this stage is a set of `subcovers' of St, each with a size (or 'weight') associated with it, and we wish to find a subset of these `subcovers' that cover the entire St, but has a provably small 'total weight'.",
        "We abstract this as the following problem.",
        "WEIGHTED-SET-COVER(WSC) INSTANCE: (X, Y, w) where X is a finite set and Y is a subset of P(X) and w is a function from Y to N+.",
        "Intuitively, Y is a set of subcovers of the set X, each associated with its 'weight'.",
        "We now prove the existence of an approximation algorithm for this problem with the desired performance guarantee.",
        "1.",
        "Z C Y 2.",
        "Z is a cover for X, i.e. UZ = X 3.",
        "If Z' is a minimal weight set cover for (X,Y,w), then Evez w(y) < p(Eyez, w(y)) x log n. 4.",
        "B runs in time polynomial in the size of the instance.",
        "Proof: To exhibit an algorithm with this property, we make use of the greedy algorithm C for the standard",
        "set-cover problem due to Johnson ([8]), with a performance guarantee.",
        "SET-COVER can be thought of as a special case of WEIGHTED-SET-COVER with weight function being the constant funtion 1.",
        "Now we present the algorithm for WSC.",
        "The idea of the algorithm is simple.",
        "It applies C on X and successive subclasses of Y with bounded weights, upto the maximum weight there is, but using only powers of 2 as the bounds.",
        "It then outputs one with a minimal total weight among those."
      ]
    },
    {
      "heading": "Algorithm B: ((X, Y, to))",
      "text": [
        "maxweight := max{w(y)ly E Y} m := [log maxweightl /* this loop gets an approximate solution using C for subsets of Y each defined by putting an upperbound on the weights */ For i = 1 to m do:",
        "/* this loop replaces all 'bad' (i.e. does not cover X) solutions with Y – the solution with the maximum total weight */ For i = 1 to m do:"
      ]
    },
    {
      "heading": "Time Analysis",
      "text": [
        "Clearly, Algorithm B runs in time polynomial in the instance size, since Algorithm C runs in time polynomial in the instance size and there are only m = flog maxweightl calls to it, which certainly does not exceed the instance size."
      ]
    },
    {
      "heading": "Performance Guarantee",
      "text": [
        "Let (X, Y, to) be a given instance with card(X) = n. Then let Z' be an optimal solution of that instance, i.e., it is a minimal total weight set cover.",
        "Let totalweight(V) = w'.",
        "Now let m* = [log max{w(z) z E 211.",
        "Then m* < min(n, flog max weightl).",
        "So when C is called with an instance (X,Y[m]) in the m\"-th iteration of the first Tor'-loop in the algorithm, every member of Z is in Y[ml.",
        "Hence, the optimal solution of this instance equals Z.",
        "Thus, by the performance guarantee of C, srms] will be a cover of X with cardinality at most card(Z°) x log n. Thus, we have card(s[m]) < card(Ze) x log n. Now, for every member t of s[m\"], w(t) < 2\"‘.",
        "< 24\".1 < 2e.",
        "Therefore, totalweight(s[m]) = card(Z) x log n x 0(2e) = 0(e) x log n x 0(2e), since to\" certainly is at least as large as card(r).",
        "Hence, we have totalweight(strep = 0(e2 x log n).",
        "Now it is clear that the output of B will be a cover, and its total weight will not exceed the total weight of s[ml.",
        "We conclude therefore that B((X ,Y, w)) will be a set-cover for X, with total weight bounded above by 0(tos2 x log n), where to' is the total weight of a minimal weight cover and n =I X I.",
        "Now, to apply algorithm B to our learning problem, we let Y = fst n L(H) H E FGrams(k, SL)} and define the weight function to: Y N+ by Vy E Y w(y) = min{size(H) I HE FGrams(k, S z,) y = L(H) n St) and call B on (St, Y, w).",
        "We then output the grammar 'corresponding' to B((St, Y, to)).",
        "In other words, we let H = {mingrammar(y) I y E B((St, w))} where mingrammar(y) is a minimal-size grammar H in FGrams(k,SL) such that L(H) n St y.",
        "The final output grammar H will be the \"disjoint union\" of all the grammars in H, i.e. H = b(H).",
        "H is clearly consistent with SL, and since the minimal total weight solution of this instance of WSC is no larger than Rel(d, St), by the performance guarantee on the algorithm B, size(H) < p(size(Rel(G, St))) x 0(log m) for some polynomial p, where m is the sample size.",
        "size(G) > size(Rel(G, St)) is also bounded by a polynomial in the size of a minimal grammar consistent with SL.",
        "We therefore have shown the existence of an Occam algorithm with range size polymomial in the size of a minimal consistent grammar and less than linear in the sample size.",
        "Hence, Theorem 4.1 has been proved.",
        "Q.E.D."
      ]
    },
    {
      "heading": "5 Extension to Mildly Context Sensitive Languages",
      "text": [
        "The learnability of k-local subclasses of CFG may appear to be quite restricted.",
        "It turns out, however, that the learnability of k-local subclasses extends to a rich class of mildly context sensitive grammars which we",
        "call \"Ranked Node Rewriting Grammars\" (RNRG's).",
        "RNRG's are based on the underlying ideas of Tree Adjoining Grammars (TAG's) \", and are also a specical case of context free tree grammars [13] in which unrestricted use of variables for moving, copying and deleting, is not permitted.",
        "In other words each rewriting in this system replaces a \"ranked\" nonterminal node of say rank j with an \"incomplete\" tree containing exactly j edges that have no descendants.",
        "If we define a hierarchy of languages generated by subclasses of RNRG's having nodes and rules with bounded rank j (RNRL,), then RNRL0 = CFL, and RNRLi = TAW?",
        "It turns out that each k-local subclass of each RNRL, is polynomially learnable.",
        "Further, the constraint of k-locality on RNRG's is an interesting one because not only each k-local subclass is an exponential class containing infinitely many infinite languages, but also k-local subclasses of the RNRG hierarchy become progressively more complex as we go higher in the hierarchy.",
        "In particular, for each j, RNRG, can \"count up to\" 2(j + 1) and for each k > 2, k-local-RNRG, can also count up to 2(j I 1).18 We will omit a detailed definition of RNRG's (see [2]), and informally illustrate them by some examples.\"",
        "Example 5.2 1.2 = {anbnCndn n E N] E TAL is generated by the following RN RGi grammar, where is shown in Figure 3.",
        "G2 =",
        "16ee adjoining grammars were introduced as a formalism for linguistic description by Joshi et al.",
        "[10], [9].",
        "Various formal and computational properties of TAG's were studied in [16].",
        "Its linguistic relevance was demonstrated in [11].",
        "17 This hierarchy is different from the hierarchy of \"metaTAL's\" invented and studied extensively by Weir in [18].",
        "18A class of grammars g is said to be able to \"count up to\" j, just in case { n E N} E {L(G) I G E g} but fal'ai'...(27+1 I n E N} g {L(G)I G E g}.",
        "18Simpler trees are represented as term structures, whereas more involved trees are shown in the figure.",
        "Also note that we use uppercase letters for nonterminals and lowercase for terminals.",
        "Note the use of the special symbol 1 to indicate an edge with no descendent.",
        "We state the learnability result of RNRL,'s below as a theorem, and again refer the reader to [2] for details.",
        "Note that this theorem sumsumes Theorem 4.1 as the case j = 0."
      ]
    },
    {
      "heading": "6 Some Negative Results",
      "text": [
        "The reader's reaction to the result described above may be an illusion that the learnability of k-local grammars follows from \"bounding by k\".",
        "On the contrary, we present a case where \"bounding by k\" not only does not help feasible learning, but in some senae makes it harder to learn.",
        "Let us consider Tree Adjoining Grammars without local constraints, TAG(wolc) for the sake of comparison.21 Then an anlogous argument to the one for the learnability of k-local-CFL shows that k-local-TAL(wok) is polynornially learnable for any k. Theorem 8.1 Vk E N+ k-local-TAL(wolc) is polynomially learnable.",
        "Now let us define subclasses of TAG(wolc) with a bounded number of initial trees; k-initial-tree-TAG(wolc) is the class of TAG(wolc) with at most k initial trees.",
        "Then surprisingly, for the case of single letter alphabet, we already have the following striking result.",
        "(For full detail, see [1].)",
        "(ii) Vk > 3 k-initial-tree- TAL(wolc) on 1-letter alphabet is not polynomially learnable by k-initial-tree-TAG(wolc).",
        "As a corollary to the second part of the above theorem, we have that k-initial-tree-TAL(wolc) on an arbitrary alphabet is not polynomially learnable (by k-initial-tree-TAG(wolc)).",
        "This is because we would be able to use a learning algorithm for an arbitrary alphabet to construct one for the single letter alphabet case.",
        "Corollary 6.1 k-initial-tree-TAL(wolc) is not polynomially learnable by k-initial-tree-TAG(wolc).",
        "The learnability of k-local-TAL(wolc) and the non-learnability of k-initial-tree-TAL(wok) is an interesting contrast.",
        "Intuitively, in the former case, the \"k-bound\" is placed so that the grammar is forced to be an arbitrarily \"wide\" union of boundedly small grammars, whereas, in the latter, the grammar is forced to be a boundedly \"narrow\" union of arbitrarily large grammars.",
        "It is suggestive of the possibility that in fact human infants when acquiring her native tongue may start developing small special purpose grammars for different uses and contexts and slowly start to generalize and compress the large set of similar grammars into a smaller set."
      ]
    },
    {
      "heading": "7 Conclusions",
      "text": [
        "We have investigated the use of complexity theory to the evaluation of grammatical systems as linguistic formalisms from the point of view of feasible learnability.",
        "In particular, we have demonstrated that a single, natural and non-trivial constraint of \"locality\" on the grammars allows a rich class of mildly context sensitive languages to be feasibly learnable, in a well-defined complexity theoretic sense.",
        "Our work differs from recent works on efficient learning of formal languages, for example by Angluin ([4]), in that it uses only examples and no other powerful oracles.",
        "We hope to have demonstrated that learning formal grammars need not be doomed to be necessarily computationally intractable, and the investigation of alternative formulations of this problem is a worthwhile endeavour."
      ]
    }
  ]
}
