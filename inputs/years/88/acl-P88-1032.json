{
  "info": {
    "authors": [
      "Yves Schabes",
      "Aravind K. Joshi"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P88-1032",
    "title": "An Earley-Type Parsing Algorithm for Tree Adjoining Grammars",
    "url": "https://aclweb.org/anthology/P88-1032",
    "year": 1988
  },
  "references": [
    "acl-C88-2121",
    "acl-C88-2147",
    "acl-P84-1075",
    "acl-P85-1011"
  ],
  "sections": [
    {
      "heading": "AN EARLEY-TYPE PARSING ALGORITHM FOR TREE ADJOINING GRAMMARS *",
      "text": [
        "Philadelphia PA 19104-6389 USA schabesalinc.cis.upenn.edu joshiOcis.npenn.edu"
      ]
    },
    {
      "heading": "ABSTRACT",
      "text": [
        "We will describe an Earley-type parser for Tree Adjoining Grammars (TAGs).",
        "Although a CKY-type parser for TAGs has been developed earlier (Vijay-Shanker and Joshi, 1985), this is the first practical parser for TAGs because as is well known for CFGs, the average behavior of Earley-type parsers is superior to that of CKY-type parsers.",
        "The core of the algorithm is described.",
        "Then we discuss modifications of the parsing algorithm that can parse extensions of TAGs such as constraints on adjunction, substitution, and feature structures for TAGs.",
        "We show how with the use of substitution in TAGs the system is able to parse directly CFGs and TAGs.",
        "The system parses unification formalisms that have a CFG skeleton and also those with a TAG skeleton.",
        "Thus it also allows us to embed the essential aspects of PATR-II."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Although formal properties of Tree Adjoining Grammars (TAGs) have been investigated (Vijay-Shanker, 1987) – for example, there is an 0(n6)-time CKY-like algorithm for TAGs (Vijay-Shanker and Joshi, 1985) – so far there has been no attempt to develop an Earley-type parser for TAGS.",
        "This paper presents an Earley parser for TAGs and discusses modifications to the parsing algorithm that make it possible to handle extensions of TAGs such as constraints on adjunction, sub-*This work is partially supported by ARO grant DAA29-84-9-007, DARPA grant N0014-85-K0018, NSF grants MCS-82-191169 and DCR-84-10413.",
        "The authors would like to express their gratitude to Vijay-Shanlcer for his helpful comments relating to the core of the algorithm, Richard Billington and Andrew Chalnicic for their graphical TAG editor which we integrated in our system and for their programming advice Thanks are also due to Anne Abeille and Ellen Hays.",
        "stitution, and feature structure representation for TAGs.",
        "TAGs were first introduced by Joshi, Levy and Takahashi (1975) and Joshi (1983).",
        "We describe very briefly the Tree Adjoining Grammar formalism.",
        "For more details we refer the reader to Joshi (1983), Kroch and Joshi (1985) or Vijay-Shanker (1987).",
        "Definition 1 (Tree Adjoining Grammar) A TAG is a 5-tuple G = (VN VT I, A) where VN is a finite set of non-terminal symbols, VT is a finite set of terminals, S is a distinguished nonterminal, I is a finite set of trees called initial trees and A is a finite set of trees called auxiliary trees.",
        "The trees in / U A are called elementary trees.",
        "Initial trees (see left tree in Figure 1) are characterized as follows: internal nodes are labeled by non-terminals; leaf nodes are labeled by either terminal symbols or the empty string."
      ]
    },
    {
      "heading": "Z X",
      "text": []
    },
    {
      "heading": "ts\"..termlnels terminals -.of **• – .torminals",
      "text": [
        "Auxiliary trees (see right tree in Figure 1) are characterized as follows: internal nodes are labeled by non-terminals; leaf nodes are labeled by a terminal or by the empty string except for exactly one node (called the foot node) labeled by a non-terminal; furthermore the label of the foot node is the same as the label of the root node.",
        "We now define a composition operation called adjoining or adjunction which builds a new tree from an auxiliary tree fl and a tree a (a is any tree,",
        "initial, auxiliary or tree derived by adjunction).",
        "The resulting tree is called a derived tree.",
        "Let a be a tree containing a node n labeled by X and let ft be an auxiliary tree whose root node is also labeled by X.",
        "Then the adjunction of # to a at node n will be the tree 7 shown in Figure 2.",
        "The resulting tree, 7, is built as follows:",
        "• The sub-tree of a dominated by n, call it t, is excised, leaving a copy of n behind.",
        "• The auxiliary tree # is attached at n and its root node is identified with n. • The sub-tree t is attached to the foot node of # and the root node n of t is identified with the foot node of #.",
        "Then define the tree set of a TAG G, T(G) to be the set of all derived trees starting from initial trees in I.",
        "Furthermore, the string language generated by a TAG, L(G), is defined to be the set of all terminal strings of the trees in T(G).",
        "TAGs factor recursion and dependencies by extending the domain of locality.",
        "They offer novel ways to encode the syntax of natural language grammars as discussed in Kroch and Joshi (1985) and Abeille (1988).",
        "In 1985, Vijay-Shanker and Joshi introduced a CKY-like algorithm for TAGs.",
        "They therefore established 0(n6) time as an upper bound for parsing TAGs.",
        "The algorithm was implemented, but in our opinion the result was more theoretical than practical for several reasons.",
        "First the algorithm assumes that elementary trees are binary branching and that there are no empty categories on the frontiers of the elementary trees.",
        "Second, since it works on nodes that have been isolated from the tree they belong to, it isolates them from their domain of locality.",
        "However all important linguistic and computational properties of TAGs follow from this extended domain of locality.",
        "And most importantly, although it runs in 0(n6) worst time, it also runs in 0(n6) best time.",
        "As a consequence, the CKY algorithm is in practice very slow.",
        "Since the average time complexity of Earley's parser depends on the grammar and in practice runs much better than its worst time complexity, we decided to try to adapt Earley's parser for CFGs to TAGs.",
        "Earley's algorithm for CFGs (Earley, 1970, Aho and Ullman, 1973) is a bottom-up parser which uses top-down information.",
        "It manipulates states of the form A --• a./3{i] while using three processors: the predictor, the comple-tor and the scanner.",
        "The algorithm for CFGs runs in 0(IGI2n3) time and in 0(IGIn2) space in all cases, and parses unambiguous grammars in 0(n2) time (n being the length of the input, ClI the size of the grammar).",
        "Given a context-free grammar in any form and an input string al • • • an, Earley's parser for CFGs maintains the following invariant: The state A – • a.#[i] is in states set Sk if S 6A7, al • -a; and a ai+i • • ak The correctness of the algorithm is a corollary of this invariant.",
        "Finding a Earley-type parser for TAGs was a difficult task because it was not clear how to parse TAGs bottom up using top-down information while scanning the input string from left to right.",
        "In order to construct an Earley-type parser for TAGs, we will extend the notions of dotted rules and states to trees.",
        "Anticipating the proof of correctness and soundness of our algorithm, we will state an invariant similar to Earley's original invariant.",
        "Then we present the algorithm and its main extensions."
      ]
    },
    {
      "heading": "2 Dotted symbols, dotted trees, tree traversal",
      "text": [
        "The full algorithm is explained in the next section.",
        "This section introduces preliminary concepts that will be used by the algorithm.",
        "We first show how dotted rules can be extended to trees.",
        "Then we introduce a tree traversal that the algorithm will mimic in order to scan the input from left to right.",
        "We define a dotted symbol as a symbol associated with a dot above or below and either to the left or to the right of it.",
        "The four positions of the dot are annotated by la, lb, ra, rb (resp.",
        "left above, left below, right above, right below): PgA;:.",
        "Then we define a dotted tree as a tree with exactly one dotted symbol.",
        "Given a dotted tree with the dot above and to the left of the root, we define a tree traversal of a dotted tree as follows (see Figure 3): /.\\",
        "• if the dot is at position la of an internal node, we move the dot down to position lb, • if the dot is at position lb of an internal node, we move to position /a of its leftmost child, • if the dot is at position la of a leaf, we move the dot to the right to position ra of the leaf, • if the dot is at position rb of a node, we move the dot up to position ra of the same node, • if the dot is at position ra of a node, there are two cases:",
        "- if the node has a right sibling, then move the dot to the right sibling at position Ia.",
        "- if the node does not have a right sibling, then move the dot to its parent at position rb.",
        "This traversal will enable us to scan the frontier of an elementary tree from left to right while trying to recognize possible adjunctions between the above and below positions of the dot."
      ]
    },
    {
      "heading": "3 The algorithm",
      "text": [
        "We define an appropriate data structure for the algorithm.",
        "We explain how to interpret the structures that the parser produces.",
        "Then we describe the algorithm itself."
      ]
    },
    {
      "heading": "3.1 Data structures",
      "text": [
        "The algorithm uses two basic data structures: state and states set.",
        "A states set S is defined as a set of states.",
        "The states sets will be indexed by an integer: Si with i E N. The presence of any state in states set i will mean that the input string ai...ai has been recognized.",
        "Any tree a will be considered as a function from tree addresses to symbols of the grammar (terminal and non-terminal symbols): if x is a valid address in a, then a(x) is the symbol at address x in the tree a.",
        "• a: is the name of the dotted tree.",
        "• dot: is the address of the dot in the tree a.",
        "• side: is the side of the symbol the dot is on; side E {left, right}.",
        "• pos: is the position of the dot; pos E {above,below} • star is an address in a.",
        "The corresponding node in a is called the starred node.",
        "• 1 (left), ft (foot left), fr (foot right), i (top left",
        "of starred node), b; (bottom left of starred node) are indices of positions in the input string ranging over [0, n], a being the length of the input string.",
        "They will be explained further below."
      ]
    },
    {
      "heading": "3.2 Invariant of the algorithm",
      "text": [
        "The states s in a states set Si have a common property.",
        "The following section describes this invariant in order to give an intuitive interpretation of what the algorithm does.",
        "This invariant is similar to Earley's invariant.",
        "Before explaining the main characterization of the algorithm, we need to define the set of nodes on which an adjunction is allowed for a given state.",
        "Definition 3 The set of nodes 'Ns) on which an adjunction is possible for a given state"
      ]
    },
    {
      "heading": "S = [a, dot, side, pos, 1, ft, fy. , star,t; , is de",
      "text": [
        "fined as the union of the following sets of nodes in a:",
        "• the set of nodes that have been traversed on the left and right sides, i.e., the four positions of the dot have been traversed; • the set of nodes on the path from the root node to the starred node, root node and starred node included.",
        "Note that if there is no star this set is empty.",
        "Definition 4 (Left part of a dotted tree) The left part of a dotted tree is the union of the set of nodes in the tree that have been traversed on the left and right sides and the set of nodes that have been traversed on the left side only.",
        "We will first give an intuitive interpretation of the ten components of a state, and then give the necessary and sufficient conditions for membership of a state in a states set.",
        "We interpret informally a state",
        "• 1 is an index in the input string indicating where the tree derived from a begins.",
        "• fi is an index in the input string corresponding to the point just before the foot node (if any) in the tree derived from a.",
        "• fr is an index in the input string corresponding to the point just after the foot node (if any) in the tree derived from a.The pair fi and f,.",
        "will mean that the foot node subsumes the string af,+,...of r. • star is the address in a of the deepest node that subsumes the dot on which an adjunction has been partially recognized.",
        "If there is no adjunction in the tree a along the path from the root to the dotted node, star is unbound.",
        "• t; is an index in the input string corresponding to the point in the tree where the adjunction on the starred node was made.",
        "If star is unbound, then t; is also unbound.",
        "• b;' is an index in the input string corresponding to the point in the tree just before the foot node of the tree adjoined at the starred node.",
        "The pair t; and b7 will mean that the string as far as the foot node of the auxiliary tree adjoined at the starred node matches the substring at;+1...abt of the input string.",
        "If star is unbound, then b7 is also unbound.",
        "• s E S1 means that the recognized part of the dotted tree a, which is the left part of it, is consistent with the input string from al to a/ and from a/ to af, and from afr to Oh or from al to ai and from at to ai when the foot node is not in the recognized part of the tree.",
        "We are now ready to characterize the membership of s in Si:"
      ]
    },
    {
      "heading": "Invariant 1",
      "text": [
        "A state s = [a, dot, side,pos,l, fr,star,t7 ,b7] is in Si if and only if there is a derived tree from an initial tree such that (see Figure 4):",
        "1.",
        "The tree a is part of the derivation.",
        "2.",
        "The tree derived from a in the derivation tree, 7F, has adjunctions only on nodes in P(s).",
        "3.",
        "The part Of the tree to the left of the dot in the tree derived spans the string ai",
        "4.",
        "The tree derived from a, re, has a yield that starts just after at, ends at af, before the foot node (if af, is defined), and starts after the foot node just after cif, (if af, is defined).",
        "5.",
        "If there are adjunctions on the path from the dotted node to the root of a, then star is the address of the deepest adjunction on that path and the auxiliary tree adjoined at that node star has a yield that starts just after at and stops at its foot node at ab7.",
        "The proof of this invariant has as corollaries the soundness, completeness, and therefore the correctness of the algorithm."
      ]
    },
    {
      "heading": "3,3 The recognizer",
      "text": [
        "The Earley-type recognizer for TAGs follows: Let G be a TAG.",
        "Let al...an be the input string.",
        "program recognizer begin",
        "kk is an initial tree } For i := 0 to n do begin Process the states of Si, performing one of the following seven operations on each state = [a, dot, side, pos,l, fr,star,t; ,b7J until no more states can be added:",
        "1.",
        "Scanner 2.",
        "Move dot down 3.",
        "Move dot up 4.",
        "Left Predictor 5.",
        "Left Completor 6.",
        "Right Predictor 7.",
        "Right Completor",
        "such that a is an initial tree then return acceptance.",
        "end.",
        "The algorithm is a general recognizer for TAGs.",
        "Unlike the CKY algorithm, it requires no condition on the grammar: the trees can be binary or not, the elementary (initial or auxiliary) trees can have the empty string as frontier.",
        "It is an off-line algorithm: it needs to know the length n of the input string.",
        "However we will see later that it can very easily be modified to an on-line algorithm by the use of an end-marker in the input string.",
        "We now describe one by one the seven processes.",
        "The current states set is presumed to be Si and the state to be processed is",
        "Only one of the seven processes can be applied to a given state.",
        "The side, the position, and the address of the dot determine the unique process that can be applied to the given state.",
        "Definition 5 (Adjunct(a, address)) Given a TAG G, define Adjund(a, address) as the set of auxiliary trees that can be adjoined in the elementary tree a at the node n which has the given address.",
        "In a TAG without any constraints on adjunction, if n is a non-terminal node, this set consists of all auxiliary trees that are rooted by a node with same label as the label of n."
      ]
    },
    {
      "heading": "3.3.1 Scanner",
      "text": [
        "The scanner scans the input string.",
        "Suppose that the dot is to the left of and above a terminal symbol (see Figure 5).",
        "Then if the terminal symbol matches the next input token, the program should record that a new token has been recognized and try to recognize the rest of the tree.",
        "Therefore the scanner applies to",
        "• Case 1: a(dot) = ai+i"
      ]
    },
    {
      "heading": "The scanner adds",
      "text": [
        "[a, dot, right, above,!, fj, fr,siar,i, bfl to Si+i •",
        "• Case 2: a(dot) = e"
      ]
    },
    {
      "heading": "The scanner adds",
      "text": [
        "[a, dot, right, above, l, fi, star,t7 ,bn to ."
      ]
    },
    {
      "heading": "3.3.2 Move Dot Down",
      "text": [
        "Move dot down (See Figure 6), moves the dot down, from position lb of the dotted node to path",
        "tion la of its leftmost child.",
        "It therefore applies to",
        "such that the node where the dot is has a leftmost child at address u.",
        "It adds [a, u,le ft, above,' fr, star, tl, bn to ."
      ]
    },
    {
      "heading": "3.3.3 Move Dot Up",
      "text": [
        "Move dot up (See Figure 7), moves the dot \"up\", from position ra of the dotted node to position la of its right sibling if it has a right sibling, otherwise to position rb of its parent.",
        "It therefore applies to",
        "such that the node on which the dot is has a parent node.",
        "• Case 1: the node where the dot is has a right sibling at address r. It adds [a, r,le ft, above,l, Ii, fr, star,t7 ,bn to Si.",
        "• Case 2: the node where the dot is is the rightmost child of the parent node p.",
        "It adds [a, p, right, below, I, star,t7 ,bn to Si .",
        "Suppose that there is a dot to the left of and above a non-terminal symbol A (see Figure 8).",
        "Then the algorithm takes two paths in parallel: it makes a prediction of adjunction on the node labeled by A and tries to recognize the adjunction (stepl) and it also considers the case where no adjunction has been done (step2).",
        "These operations are performed by the Left Predictor.",
        "It applies to",
        "such that a(dot) is a non-terminal.",
        "• Step 1.",
        "It adds the states UP, 0,1e ft, above, i„ „ , 1,8 E Adjunct(cx, dot) } to Si.",
        "• Step 2.",
        "- Case 1: the dot is not on the foot node.",
        "It adds the state [a, dot,le ft,below, I, fr,star,t; ,14]",
        "to Si.",
        "- Case 2: the dot is on the foot node.",
        "Necessarily, since the foot node has not been already traversed, fi and f,.",
        "are unspecified.",
        "It adds the state [a, dot, le ft,below,l,i,-,star,t; ,bn to ."
      ]
    },
    {
      "heading": "3.3.5 Left Completor",
      "text": [
        "Suppose that the auxiliary that we left-predicted has been recognized as far as its foot (see Figure 9).",
        "Then the algorithm should try to recognize",
        "what was pushed under the foot node.",
        "(A star in the original tree will signal that an adjunction has been made and half recognized.)",
        "This operation is performed by the Left Completor.",
        "It applies to",
        "such that the dot is on the foot node.",
        "For all",
        "• Case 1: doe is on the foot node of fl.",
        "Then necessary, A' and f, are unbound.",
        "It adds the state [Adott,left,below,11,i,-,doti,l,i] to Si.",
        "• Case 2: doe is not on the toot node of fl.",
        "It adds the state p, doe , le ft,below,l' , fi, dot' , I, i] to Si ."
      ]
    },
    {
      "heading": "3.3.6 Right Predictor",
      "text": [
        "Suppose that there is a dot to the right of and below a node A (see Figure 10).",
        "If there has been an adjunction made on A (case 1), the program should try to recognize the right part of the auxiliary tree adjoined at A.",
        "However if there was no adjunction on A (case 2), then the dot should be moved up.",
        "Note that the star will tell us if an adjunction has been made or not.",
        "These operations are performed by the Right predictor.",
        "The right predictor applies to"
      ]
    },
    {
      "heading": "3.3.7 Right Completor",
      "text": [
        "Suppose that the dot is to the right of and above the root of an auxiliary tree (see Figure 11).",
        "Then the adjunction has been totally recognized and the program should try to recognize the rest of the tree in which the auxiliary tree has been adjoined.",
        "This operation is performed by the Right Completor.",
        "It applies to"
      ]
    },
    {
      "heading": "3.4 Handling constraints on adjunction",
      "text": [
        "In a TAG, one can, for each node of an elementary tree, specify one of the following three constraints on adjunction (Joshi, 1987):",
        "• Null adjunction (NA): disallow any adjunction on the given node.",
        "• Obligatory adjunction (OA): an auxiliary tree must be adjoined on the given node.",
        "• Selective adjunction (SA(T)): a set T of auxiliary trees that can be adjoined on the given node is specified.",
        "The algorithm can be very easily modified to handle those constraints.",
        "First, the function Adjunct(a , address) must be modified as follows:",
        "• Adjunct(a, address) = 0, if there is NA on the node.. • Adjunct(a , address) as previously defined, if there is OA on the node.",
        "• Adjunct(a , address) = T, if there is SA(T) on the node.",
        "Second, step 2 of the left predictor must be done"
      ]
    },
    {
      "heading": "3.5 An example",
      "text": [
        "We give one example that illustrates how the recognizer works.",
        "The grammar used for the example generates the language L = {anbnecn dnIn > 0}.",
        "The input string given to the recognizer is: aabbeccdd.",
        "The grammar is shown in Figure 12.",
        "The states sets are shown in Figure 14.",
        "Next to each state we have printed in parentheses the name of the processor that was applied to the state.",
        "The input is recognized since [a, 0, right, above,0 „ ] is in states set 59."
      ]
    },
    {
      "heading": "3.6 Remarks",
      "text": [
        "Use of move dot up and move dot down Move dot down and move dot up can be eliminated in the algorithm by merging the original dot and the position it is moved to.",
        "However for explanatory purposes we chose to use these two processors in this paper."
      ]
    },
    {
      "heading": "Off-line vs on-line",
      "text": [
        "The algorithm given is an off-line recognizer.",
        "It can be very easily modified to work on line by adding an end marker to all initial trees in the grammar (see Figure 13)."
      ]
    },
    {
      "heading": "Extracting a parse",
      "text": [
        "The algorithm that we describe in section 3.3 is a recognizer.",
        "However, if we include pointers from a state to the other states which caused it to be placed in the states set, the recognizer can be modified to produce all parses of the input string."
      ]
    },
    {
      "heading": "3.7 Correctness",
      "text": [
        "The correctness of the parser has been proven and is fully reported in Schabes and Joshi (1988).",
        "It consists of the proof of the invariant given in section 3.2.",
        "Our proof is similar in its concept to the proof of the correctness of Earley's parser given in Aho and Ullman 1973.",
        "The \"only if\" part of the invariant is proved by induction on the number of states that have been added so far to all states sets.",
        "The \"if\" part is proved by induction on a defined rank of a state.",
        "The soundness (the algorithm recognizes only valid strings) and the completeness (if a string is valid, then the algorithm will recognize it) are corollaries of this invariant."
      ]
    },
    {
      "heading": "3.8 Implementation",
      "text": [
        "The parser has been implemented on Symbolics Lisp machines in Flavors.",
        "More details of the actual implementation can be found in Schabes and Joshi (1988).",
        "The current implementation has an 0(102n9) worst case time complexity and 0(IGIn6) worst case space complexity.",
        "We have not as yet been able to reduce the worst case time complexity to 0(lG12n6).",
        "We are currently attempting to reduce this bound.",
        "However, the main purpose of constructing an Earley-type parser is to improve the average complexity, which is crucial in practice."
      ]
    },
    {
      "heading": "4 Extensions",
      "text": [
        "We describe how substitution is defined in a TAG.",
        "We discuss the consequences of introducing substitution in TAGs.",
        "Then we show how substitution can be parsed.",
        "We extend the parser to deal with feature structures for TAGs.",
        "Finally the relationship with PATR-II is discussed."
      ]
    },
    {
      "heading": "4.1 Introducing substitution in TAGs",
      "text": [
        "TAGs use adjunction as their basic composition operation.",
        "It is well known that Tree Adjoining Languages (TALs) are mildly context-sensitive.",
        "TALs properly contain context-free languages.",
        "It is also possible to encode a context-free grammar with auxiliary trees using adjunction only.",
        "However, although the languages correspond, the possible encoding does not reflect directly the original Step 2 add the and merlon to etch initial tram",
        "context free grammar since this encoding uses adjunction.",
        "Substitution is the basic operation used in CFG.",
        "A CFG can be viewed as a tree rewriting system.",
        "It uses substitution as basic operation and it consists of a set of one-level trees.",
        "Substitution is a less powerful operation than adjunction.",
        "However, recent linguistic work in TAG grammar development (Abeille, 1988) showed the need for substitution in TAGs as an additional operation for obtaining appropriate structural descriptions in certain cases such as verbs taking two sentential arguments (e.g. \"John equates solving this problem with doing the impossible\") or compound categories.",
        "It has also been shown to be useful for lexical insertion (Schabes, Abeille and Joshi, 1988).",
        "It should be emphasized that the introduction of substitution in TAGs does not increase their generative capacity.",
        "Neither is it a step back from the original idea of TAGs."
      ]
    },
    {
      "heading": "Definition 6 (Substitution in TAG) We de",
      "text": [
        "fine substitution in TAGs to take place on specified nodes on the frontiers of elementary trees.",
        "When a node is marked to be substituted, no adjunction can take place on that node.",
        "Furthermore, substitution is always mandatory.",
        "Only trees derived from initial trees rooted by a node of the same label can be substituted on a substitution node.",
        "The resulting tree is obtained by replacing the node by the tree derived from the initial tree.",
        "Substitution is illustrated in Figure 15.",
        "We conventionally mark substitution nodes by a down arrow (1).",
        "As a consequence, we can now encode directly a CFG in a TAG with substitution.",
        "The resulting TAG has only one-level initial trees and uses only substitution.",
        "An example is shown in Figure 16."
      ]
    },
    {
      "heading": "4.2 Parsing substitution",
      "text": [
        "The parser can be extended very easily to handle substitution.",
        "We use Earley's original predictor and completor to handle substitution.",
        "The left predictor is restricted to apply to nodes to which adjunction can be applied.",
        "A flag subst?",
        "is added to the states.",
        "When set, it indicates that the tree (initial) has been predicted for substitution.",
        "We use the index 1 (as in Earley's original parser) to know where it has been predicted for substitution.",
        "When the initial tree that has been predicted for substitution has been totally recognized, we complete the state as Earley's original parser does.",
        "A state $ is now an 11 – tuple [a, dot, side, pos , , , f,., star, t;' , br, sub.stl where subst?",
        "is a boolean that indicates whether the tree has been predicted for substitution.",
        "The other components have not been changed.",
        "We add two more processors to the parser."
      ]
    },
    {
      "heading": "Substitution Predictor",
      "text": [
        "Suppose that there is a dot to the left of and above a non-terminal symbol on the frontier A that is marked for substitution (see Figure 17).",
        "Then the algorithm predicts for substitution all initial trees rooted by A and tries to recognize the initial tree.",
        "This operation is performed by the substitution predictor.",
        "It applies to",
        "such that a(dot) is a non-terminal on the frontier of a which is marked for substitution: It adds the states f[,8,o, le ft, above, i, „ „ , true]"
      ]
    },
    {
      "heading": "1# is an initial tree s.t 43(0) = a(dot)}",
      "text": []
    },
    {
      "heading": "to S. Substitution Completor",
      "text": [
        "Suppose that the initial tree that we predicted for substitution has been recognized (see Figure 18).",
        "Then the algorithm should try to recognize the rest of the tree in which we predicted a substitution.",
        "This operation is performed by the substitution cornpletor.",
        "It applies to",
        "For all states s = [/ 3, dot' , le ft, above, l' , f, f;, star' ,t7' , br , subsel in Si s.t.",
        "/3(doe) is marked for substitution and O(dot) = a(0) .",
        "It adds the following state to Si: [j3, dot', right, above, 1', f; , f,'., star', tr , br, subst?']",
        "."
      ]
    },
    {
      "heading": "Complexity",
      "text": [
        "The introduction of the substitution predictor and the substitution completor does not increase the complexity of the overall TAG parser.",
        "If we encode a CFG with substitution in TAG, the parser behaves in 0(IGI2n3) worst case time and 0(IGIn2) worst case space like Earley's original parser.",
        "This comes from the fact that when there are no auxiliary trees and when only substitution is used, the indices fr,t7, b7 of a state will never be set.",
        "The algorithm will use only the substitution predictor and the substitution corn-pletor.",
        "Thus, it behaves exactly like Earley's original parser on CFGs."
      ]
    },
    {
      "heading": "4.3 Parsing feature structures for TAGs",
      "text": [
        "The definition of feature structures for TAGs and their semantics was proposed by Vijay-Shanker (1987) and Vijay-Shanker and Joshi (1988).",
        "We first explain briefly how they work in TAGs and show.",
        "how we have implemented them.",
        "We introduce in a TAG framework a language similar to PATR-II which was investigated by Shieber (Shieber, 1984 and 1986).",
        "We then show how one can embed the essential aspects of PATR-II in this system."
      ]
    },
    {
      "heading": "Feature structures in TAGs",
      "text": [
        "As defined by Vijay-Shanker (1987) and Vijay-Shanker and Joshi(1988), to each adjunction node in an elementary tree two feature structures are attached: a top and a bottom feature structure.",
        "The top feature corresponds to a top view in the tree from the node.",
        "The bottom feature corresponds to the bottom view.",
        "When the derivation is completed, the top and bottom features of all nodes are unified.",
        "If the top and bottom features of a node do not unify, then a tree must be adjoined at that node.",
        "This definition can be trivially extended to substitution nodes.",
        "To each substitution node we attach two identical feature structures (top and bottom).",
        "The updating of features in case of adjunction is shown in Figure 19."
      ]
    },
    {
      "heading": "Unification equations",
      "text": [
        "As in PATR-II, we express with unification equations dependencies between DAGs in an elementary tree.",
        "The system therefore consists of a TAG and a set of unification equations on the DAGs associated with nodes in elementary trees.",
        "An example of the use of unification equations in TAGs is given in Figure 20.",
        "Note that the top and bottom features of node S in a can not be unified.",
        "This forces an adjunction to be performed on S. Thus, the following sentence is not accepted: *to go to the movies.",
        "The auxiliary tree $1 can be adjoined at S in a: John wants to go to the movies.",
        "But since the bottom feature of S has tensed value – in a and since the bottom feature of S has tensed value + in 02, 01 can not be adjoined at node S in a: *Bob thinks to go to the movies.",
        "But 132 can be adjoined in #1, which itself can be adjoined in a: Bob thinks John wants to go to the",
        "We refer the reader to Abeille (1988) and to Schabes, Abeille and Josh i (1988) for further explanation of the use of unification equations and substitution in TAGs.",
        "Parsing and the relationship with PATR-II By adding to each state the set of DAGs corresponding to the top and bottom features of each node, and by making sure that the unification equations are satisfied, we have extended the parser to parse TAGs with feature structures.",
        "Since we introduced substitution and since we are able to encode a CFG directly, the system has the main functionalities of PATR-II.",
        "The system parses unification formalisms that have a CFG skeleton and a TAG skeleton."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We described an Earley-type parser for TAGs.",
        "We extended it to deal with substitution and feature structures for TAGs.",
        "By doing this, we have built a system that parses unification formalisms that have a CFG skeleton and also those that have a TAG skeleton.",
        "The system is being used for Tree Adjoining Grammar development (Aherne, 1988).",
        "This work has led us to a new general parsing strategy (Schabes, Aherne and Joshi, 1988) which allows us to construct a two-stage parser.",
        "In the first stage a subset of the elementary trees is extracted and in the second stage the sentence is parsed with respect to this subset.",
        "This strategy significantly improves performance, especially as the grammar size increases."
      ]
    }
  ]
}
