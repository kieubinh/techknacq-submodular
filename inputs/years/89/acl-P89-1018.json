{
  "info": {
    "authors": [
      "Sylvie Billott",
      "Bernard Lang"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P89-1018",
    "title": "The Structure of Shared Forests in Ambiguous Parsing",
    "url": "https://aclweb.org/anthology/P89-1018",
    "year": 1989
  },
  "references": [
    "acl-C88-1075",
    "acl-J87-1004",
    "acl-P84-1075",
    "acl-P85-1018",
    "acl-P88-1031"
  ],
  "sections": [
    {
      "heading": "INRIA 'and Universite d'Orleans",
      "text": [
        "billotOinria.inria.fr langOinria.inria.fr"
      ]
    },
    {
      "heading": "Abstract",
      "text": [
        "The Context-Free backbone of some natural language analyzers produces all possible CF parses as some kind of shared forest, from which a single tree is to be chosen by a disambiguation process that may be based on the finer features of the language.",
        "We study the structure of these forests with respect to optimality of sharing, and in relation with the parsing schema used to produce them.",
        "In addition to a theoretical and experimental framework for studying these issues, the main results presented are:",
        "- sophistication in chart parsing schemata (e.g. use of look-ahead) may reduce time and space efficiency instead of improving it,",
        "- there is a shared forest structure with at most cubic size for any CF grammar, - when 0(n3) complexity is required, the shape of a shared forest is dependent on the parsing schema used.",
        "Though analyzed on CF grammars for simplicity, these results extend to more complex formalisms such as unification based grammars."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Several natural language parser start with a pure Context-Free (CF) backbone that makes a first sketch of the structure of the analyzed sentence, before it is handed to a more elaborate analyzer (possibly a coroutine), that takes into account the finer grammatical structure to filter out undesirable parses (see for example [24,28]).",
        "In [28], Shieber surveys existing variants to this approach before giving his own tunable approach based on restrictions that \" split up the infinite nonterminal domain into a finite set of equivalence classes that can be used for parsing\".",
        "The basic motivation for this approach is to benefit from the CF parsing technology whose development over 30 years has lead to powerful and efficient parsers [1,7].",
        "A parser that takes into account only an approximation of the grammatical features will often find ambiguities it cannot resolve in the analyzed sentences'.",
        "A natural solution 'Address: INRIA, B.P.",
        "105, 78153 Le Chesnay, France.",
        "The work reported here was partially supported by the Eureka Software Factory project.",
        "I Ambiguity may also have a semantical origin.",
        "is then to produce all possible parses, according to the CF backbone, and then select among them on the basis of the complete features information.",
        "One hitch is that the number of parses may be exponential in the size of the input sentence, or even infinite for cyclic grammars or incomplete sentences [16].",
        "However chart parsing techniques have been developed that produce an encoding of all possible parses as a data structure with a size polynomial in the length of the input sentence.",
        "These techniques are all based on a dynamic programming paradigm.",
        "The kind of structure they produce to represent all parses of the analyzed sentence is an essential characteristic of these algorithms.",
        "Some of the published algorithms produce only a chart as described by Kay in [14], which only associates nonterminal categories to segments of the analyzed sentence [11,39,13,3,9], and which thus still requires non-trivial processing to extract parse-trees [26].",
        "The worst size complexity of such a chart is only a square function of the size of the input2.",
        "However, practical parsing algorithms will often produce a more complex structure that explicitly relates the instances of nonterminals associated with sentence fragments to their constituents, possibly in several ways in case of ambiguity, with a sharing of some common subtrees between the distinct ambiguous parses [7,4,24,31,25]3 One advantage of this structure is that the chart retains only these constituents that can actually participate in a parse.",
        "Furthermore it makes the extraction of parse-trees a trivial matter.",
        "A drawback is that this structure may be cubic in the length of the parsed sentence, and more generally polynomial4 for some proposed algorithms [31].",
        "However, these algorithms are rather well behaved in practice, and this complexity is not a problem."
      ]
    },
    {
      "heading": "In this paper we shall call shared forests such data struc",
      "text": [
        "2 We do not consider CF recognizers that have asymptotically the lowest complexity, but are only of theoretical interest here [35,5].",
        "3 There are several other published implementation of chart parsers [23,20,33], but they often do not give much detail on the output of the parsing process, or even sidestep the problem altogether [33].",
        "We do not consider here the well formed stastring tables of Shell [26] which falls somewhere in between in our classification.",
        "They do not use pointers and parse-trees are only \"indirectly\" visible, but may be extracted rather simply in linear time.",
        "The table may contain useless constituents.",
        "tures used to represent simultaneously all parse trees for a given sentence.",
        "Several questions may be asked in relation with shared forests:",
        "• How to construct them during the parsing process?",
        "• Can the cubic complexity be attained without modifying the grammar (e.g. into Chomsky Normal Form)?",
        "• What is the appropriate data structure to improve sharing and reduce time and space complexity?",
        "• How good is the sharing of tree fragments between ambiguous parses, and how can it be improved?",
        "• Is there a relation between the coding of parse-trees in the shared forest and the parsing schema used?",
        "• How well formalized is their definition and construction?",
        "These questions are of importance in practical systems because the answers impact both the performance and the implementation techniques.",
        "For example good sharing may allow a better factorization of the computation that filters parse trees with the secondary features of the language.",
        "The representation needed for good sharing or low space complexity may be incompatible with the needs of other components of the system.",
        "These components may also make assumptions about this representation that are incompatible with some parsing schemata.",
        "The issue of formalization is of course related to the formal tractability of correctness proof for algorithms using shared forests.",
        "In section 2 we describe a uniform theoretical framework in which various parsing strategies are expressed and compared with respect to the above questions.",
        "This approach has been implemented into a system intended for the experimental study and comparison of parsing strategies.",
        "This system is described in section 3.",
        "Section 4 contains a detailed example produced with our implementation which illustrates both the working of the system and the underlying theory."
      ]
    },
    {
      "heading": "2 A Uniform Framework",
      "text": [
        "To discuss the above issues in a uniform way, we need a general framework that encompasses all forms of chart parsing and shared forest building in a unique formalism.",
        "We shall take as a baths a formalism developed by the second author in previous papers [15,16].",
        "The idea of this approach is to separate the dynamic programming constructs needed for efficient chart parsing from the chosen parsing schema.",
        "Comparison between the classifications of Kay [14] and Griffith dc Petrick [10] shows that a parsing schema (or parsing strategy) may be expressed in the construction of a Push-Down Transducer (PDT), a well studied formalization of left-to-right CF parsers'.",
        "These PDTs are usually non-deterministic and cannot be used as produced for actual parsing.",
        "Their backtrack simulation does not always terminate, and is often time-exponential when it does, while breadth-first simulation is usually exponential for both time and space.",
        "However, by extending Earley's dynamic programming construction to PDTs, Lang provided in[15] a way of simulating all possible computations of any PDT in cubic time and space complex5 Griffith & Petrick actually use Turing machines for pedagogical reasons.",
        "ity.",
        "This approach may thus be used as a uniform framework for comparing chart parsers'."
      ]
    },
    {
      "heading": "2.1 The algorithm",
      "text": [
        "The following is a formal overview of parsing by dynamic programming interpretation of PDTs.",
        "Our aim is to parse sentences in the language L(G) generated by a CF phrase structure grammar G = (V, E, 11,N) according to its syntax.",
        "The notation used is V for the set of nonterminal, E for the set of terminals, II for the rules, N for the initial nonterminal, and e for the empty string.",
        "We assume that, by some appropriate parser construction technique (e.g. [12,6,1]) we mechanically produce from the grammar G a parser for the language L(G) in the form of a (possibly non-deterministic) push-down transducer (PDT) TG.",
        "The output of each possible computation of the parser is a sequence of rules in Ir to be used in a left-to-right reduction of the input sentence (this is obviously equivalent to producing a parse-tree).",
        "We assume for the PDT TG a very general formal definition that can fit most usual PDT construction techniques.",
        "It",
        "•",
        "is defined as an 8-tuple TG = (Q, E, A, 11,5, q, $, P) where: Q is the set of states, M is the set of input word symbols, is the set of stack symbols, 11 is the set of output symbols8 • (i.e. rules of G), q is the initial state, $ is the initial stack symbol, F is the set of final states, 6 is a finite set of teran ns - sitio of the form: (p A a I – .",
        "q B u) with pciQ,"
      ]
    },
    {
      "heading": "A,B E U{e}, a E Ell{e}, and u",
      "text": [
        "Let the PDT be in a configuration p = (p Aa ax u) where p is the current state, Aa is the stack contents with A on the top, axis the remaining input where the symbol a is the next to be shifted and x E E*, and u is the already produced output.",
        "The application of a transition r = (p A a I – .",
        "qB v) results in a new configuration p' = (q 8a x uv) where the terminal symbol a has been scanned (i.e. shifted), A has been popped and B has been pushed, and v has been concatenated to the existing output u.",
        "If the terminal symbol a is replaced by e in the transition, no input symbol is scanned.",
        "If A (resp.",
        "B) is replaced bye then no stack symbol is popped from (resp.",
        "pushed on) the stack.",
        "Our algorithm consists in an Earley-like8 simulation of the PDT TG.",
        "Using the terminology of [1], the algorithm builds an item set Si successively for each word symbol x, holding position i in the input sentence x.",
        "An item is constituted of two modes of the form (p A i) where p is a PDT state, A is a stack symbol, and Os the index of an input symbol.",
        "The item set Si contains items of the form ((p A i) (q B j)) .",
        "These items are used as nonterminals of an output grammar 6 The original intent of (15] was to show how one can generate efficient general CF chart parsers, by first producing the PDT with the efficient techniques for deterministic parsing developed for the compiler technology (6,12,1].",
        "This idea was later successfully used by Ton:tits [31] who applied it to LR(1) parsers [6,1], and later to other pushdown based parsers [32].",
        "g (S, fl, P, Ui), where $ is the set of all items (i.e. the union of Si), and the rules in P are constructed together with their left-hand-side item by the algorithm.",
        "The initial nonterminal Uf of g derives on the last items produced by a successful computation.",
        "Appendix A gives the details of the construction of items and rules in g by interpretation of the transitions of the PDT.",
        "More details may be found in [15,16]."
      ]
    },
    {
      "heading": "2.2 The shared forest",
      "text": [
        "An apparently major difference between the above algorithm and other parsers is that it represents a parse as the string of the grammar rules used in a leftmost reduction of the parsed sentence, rather than as a parse tree (cf. section 4).",
        "When the sentence has several distinct parses, the set of all possible parse strings is represented in finite shared form by a CF grammar that generates that possibly infinite set.",
        "Other published algorithms produce instead a graph structure representing all parse-trees with sharing of common subparts, which corresponds well to the intuitive notion of a shared forest.",
        "This difference is only appearance.",
        "We show here in section 4 that the CF grammar of all leftmost parses is just a theoretical formalization of the shared-forest graph.",
        "Context-Free grammars can be represented by AND-OR graphs that are closely related to the syntax diagrams often used to describe the syntax of programming languages [37], and to the transition networks of Woods [22].",
        "In the case of our grammar of leftmost parses, this AND-OR graph (which is acyclic when there is only finite ambiguity) is precisely the shared-forest graph.",
        "In this graph, AND-nodes correspond to the usual parse-tree nodes, while OR-nodes correspond to ambiguities, i.e. distinct possible subtrees occurring in the same context.",
        "Sharing of subtrees in represented by nodes accessed by more than one other node.",
        "The grammar viewpoint is the following (d. the example in section 4).",
        "Non-terminal (reap.",
        "terminal) symbols correspond to nodes with (reap.",
        "without) outgoing arcs.",
        "AND-nodes correspond to right-hand sides of grammar rules, and OR-nodes (i.e. ambiguities) correspond to non-terminals defined by several rules.",
        "Subtree sharing is represented by several uses of the same symbol in rule right-hand sides.",
        "To our knowledge, this representation of parse-forests as grammars is the simplest and most tractable theoretical formalization proposed so far, and the parser presented here is the only one for which the correctness of the output grammar – i.e. of the shared-forest – has ever been proved.",
        "Though in the examples we use graph(ical) representations for intuitive understanding (grammars are also sometimes represented as graphs [37]), they are not the proper formal tool for manipulating shared forests, and developing formalized (proved) algorithms that use them.",
        "Graph formalization is considerably more complex and awkward to manipulate than the well understood, specialized and few concepts of CF grammars.",
        "Furthermore, unlike graphs, this grammar formalization of the shared forest may be tractably extended to other grammatical formalisms (cf. section 5).",
        "More importantly, our work on the parsing of incomplete sentences [16] has exhibited the fundamental character of our grammatical view of shared forests: when parsing the completely unknown sentence, the shared forest obtained is precisely the complete grammar of the analyzed language.",
        "This also leads to connections with the work on partial evaluation [8]."
      ]
    },
    {
      "heading": "2.3 The shape of the forest",
      "text": [
        "For our shared-forest, a cubic space complexity (in the worst case – space complexity is often linear in practice) is achieved, without requiring that the language grammar be in Chomsky Normal Form, by producing a grammar of parses that has at most two symbols on the right-hand side of its rules.",
        "This amounts to representing the list of sons of a parse tree node as a Lisp-like list built with binary nodes (see figures 1 Sz 2), and it allows partial sharing of the sons 1°.",
        "The structure of the parse grammar, i.e. the shape of the parse forest, is tightly related to the parsing schema used, hence to the structure of the possible computation of the non-deterministic PDT from which the parser is constructed.",
        "First we need a precise characterization of parsing strategies, whose distinction is often blurred by superimposed optimizations.",
        "We call bottom-up a strategy in which the PDT decides on the nature of a constituent (i.e. on the grammar rule that structures it), after having made this decision first on its subconstituents.",
        "It corresponds to a postfix left-to-right walk of the parse tree.",
        "Top-Down parsing recognizes a constituent before recognition of its subconstituents, and corresponds to a prefix walk.",
        "Intermediate strategies are also possible.",
        "The sequence of operations of a bottom-up parser is basically of the following form (up to possible simplifying optimizations): To parse a constituent A, the parser first parses and pushes on the stack each sub-constituent B,; at some point, it decides that it has all the constituents of A on the stack and it pops them all, and then it pushes A and outputs the (rule number r of the) recognized rule : A – ■ 131 Bn,.",
        "Dynamic programming interpretation of such a sequence results in a shared forest containing parse-trees with the shape described in figure 1, i.e. where each node of the forest points to the beginning of the list of its sons.",
        "A top-down PDT uses a different sequence of operations, detailed in appendix B, resulting in the shape of figure 2 where a forest node points to the end of the list of sons, which is itself chained backward.",
        "These two figures are only simple examples.",
        "Many variations on the shape of parse trees and forests may be obtained by changing the parsing schema.",
        "Sharing in the shared forest may correspond to sharing of a complete subtree, but also to sharing of a tail of a list of sons: this is what allows the cubic complexity.",
        "Thus bottom-up parsing may share only the rightmost subconstituents of a constituent, while top-down parsing may share only the leftmost subconstituents.",
        "This relation between parsing schema and shape of the shared forest (and type of sharing) is a consequence of intrinsic properties of chart parsing, and not of our specific implementation.",
        "It is for example to be expected that the bidirectional nature of island parsing leads to irregular structure in shared forests, when optimal sharing is sought for."
      ]
    },
    {
      "heading": "3 Implementation and Experimental Results",
      "text": [
        "The ideas presented above have been implemented in an experimental system called Tin (after the woodman of OZ).",
        "This was noted by Shell [26] and is implicit in his use of \"2form\" grammars.",
        "The intent is to provide a uniform framework for the construction and experimentation of chart parsers, somewhat as systems like MCHART [29], but with a more systematic theoretical foundation.",
        "The kernel of the system is a virtual parsing machine with a stack and a set of primitive commands corresponding essentially to the operation of a practical Push-Down Transducer.",
        "These commands include for example: push (resp.",
        "pop) to push a symbol on the stack (resp.",
        "pop one), chackwindow to compare the lookahead symbol(s) to some given symbol, chsckatack to branch depending on the top of the stack, scan to read an input word, output to output a rule number (or a terminal symbol), pto for unconditional jumps, and a few others.",
        "However these commands are never used directly to program parsers.",
        "They are used as machine instructions for compilers that compile grammatical definitions into Tin code according to some parsing schema.",
        "A characteristic of these commands is that they may all be marked as non-deterministic.",
        "The intuitive interpretation is that there is a non-deterministic choice between a command thus marked and another command whose address in the virtual machine code is then specified.",
        "However execution of the virtual machine code is done by an all-paths interpreter that follows the dynamic programming strategy described in section 2.1 and appendix A.",
        "The Tin interpreter is used in two different ways: 1. to study the effectiveness for chart parsing of known parsing schemata designed for deterministic parsing.",
        "We have only considered formally defined parsing schemata, corresponding to established PDA construction techniques that we use to mechanically translate CF grammars into Tin code.",
        "(e.g. LALR(1) and LALR(2) [6], weak precedence [12], LL(0) top-down (recursive descent), LR(0), LR(1) [1] ...).",
        "2. to study the computational behavior of the generated code, and the optimization techniques that could be used on the Tin code – and more generally chart parser code – with respect to code size, execution speed and better sharing in the parse forest.",
        "Experimenting with several compilation schemata hae shown that sophistication may have a negative effect on thi efficiency of all-path parsingli .",
        "Sophisticated PDT construction techniques tend to multiply the number of special cases, thereby increasing the code size of the chart parser.",
        "Sometimes it also prevents sharing of locally identical subcomputations because of differences in context analysis.",
        "Thie in turn may result in lesser sharing in the parse forest and sometimes longer computation, as in example SBBL in appendix C, but of course it does not change the set of parse-trees encoded in the forest12.",
        "Experimentally, weak precedence gives slightly better sharing than LALR(1) parsing The latter is often viewed as more efficient, whereas it only has a larger deterministic domain.",
        "One essential guideline to achieve better sharing (and often also reduced computation time) is to try to recognize ever3 grammar rule in only one place of the generated chart parse] code, even at the cost of increasing non-determinism.",
        "Thus simpler schemata such as precedence, LL(0) (and probably LR(0)13) produce the best sharing.",
        "However, since they correspond to a smaller deterministic domain within the CF grammar realm, they may sometimes be computationally less efficient because they produce a larger number of uselesE items (i.e. edges) that correspond to dead-end computationai paths.",
        "Slight sophistication (e.g. LALR(1) used by Tomita [31], or LR(1) ) may slightly improve computational performance by detecting earlier dead-end computations.",
        "Tide may however be at the expense of the forest sharing quality.",
        "More sophistication (say LR(2)) is usually losing on both accounts as explained earlier.",
        "The duplication of computational paths due to distinct context analysis overweights the 11 We mean here the sophistication of the CF parser construc.",
        "tion technique rather than the sophistication of the language fea.",
        "tures chosen to be used by this parser.",
        "11 This negative behavior of some techniques originally intendec to preserve determinism had been remarked and analyzed in a special case by Bouckaert, Pirotte and Snelling [3].",
        "However we believe their result to be weaker than ours, since it seems to rely on the fact that they directly interpret granunars rather than firsi compile them.",
        "Hence each interpretive step include in some sense compilation steps, which are more expensive when lookahead increased.",
        "Their paper presents several examples that run less efficiently when lookahead is increased.",
        "For all these examples, thil behavior disappears in our compiled setting.",
        "However the gram.",
        "Mar SBBL in appendix C shows a loss of efficiency with increasec lookahead that is due exclusively to loss of sharing caused by irrelevant contextual distinctions.",
        "This effect is particularly visible when parsing incomplete sentences (14 Efficiency loss with increased lookahead is mainly due to state splitting [6].",
        "This should favor LALR techniques over LR ones.",
        "13 Our results do not take into account a newly found optimize), Lion of PDT interpretation that applies to all and only to bottom.",
        "up PDTs.",
        "This should make simple bottom-up schemes compet.",
        "itive for sharing quality, and even increase their computationa efficiency.",
        "However it should not change qualitatively the rein tive performances of bottom-up parsers, and may emphasize eve, more the phenomenon that reduces efficiency when lookahead in creases.",
        "benefits of early elimination of dead-end paths.",
        "But there can be no absolute rule: if a grammar is \"close\" to the LR(2) domain, an LR(2) schema is likely to give the best result for most parsed sentences.",
        "Sophisticated schemata correspond also to larger parsers, which may be critical in some natural language applications with very large grammars.",
        "The choice of a parsing schema depends in fine on the grammar used, on the corpus (or kind) of sentences to be analyzed, and on a balance between computational and sharing efficiency.",
        "It is best decided on an experimental basis with a system such as ours.",
        "Furthermore, we do not believe that any firm conclusion limited to CF grammars would be of real practical usefulness.",
        "The real purpose of the work presented is to get a qualitative insight in phenomena which are best exhibited in the simpler framework of CF parsing.",
        "This insight should help us with more complex formalisms (cf. section 5) for which the phenomena might be less easily evidenced.",
        "Note that the evidence gained contradicts the common belief that parsing schemata with a large deterministic domain (see for example the remarks on LR parsing in (31D are more effective than simpler ones.",
        "Most experiments in this area were based on incomparable implementations, while our uniform framework gives us a common theoretical yardstick."
      ]
    },
    {
      "heading": "4 A Simple Bottom-Up Example",
      "text": [
        "The following is a simple example based on a bottom-up PDT generated by our LALR(1) compiler from the following grammar taken from (34",
        "(0) lax ::= $ (4) 'up : det n (1) 's ::= 'up 'vp (5) 'up : 'pp (2) 's ::= 's 'pp 'pp prep 'up (3) 'up ::= n 'vp ::= • 'up",
        "Nonterminals are prefixed with a quote symbol The first rule is used for initialization and handling of the delimiter symbol $.",
        "The $ delimiters are implicit in the actual input sentence.",
        "The sample input is \"(n v det n prep n)\".",
        "It figures (for example) the sentence: \"I see a man at hone\"."
      ]
    },
    {
      "heading": "4.1 Output grammar produced by the parser",
      "text": [
        "The grammar of parses of the input sentence is given in figure 3.",
        "The initial nonterminal is the left-hand side of the first rule.",
        "For readability, the nonterminals have been given computer generated names of the form ntx, where x is an integer.",
        "All other symbols are terminal.",
        "Integer terminals correspond to rule numbers of the input language grammar given above, and the other terminals are symbols of the parsed language, except for the special terminal \"nil\" which indicates the end of the list of subconstituents of a sentence constituent, and may also be read as the empty string e. Note the ambiguity for nonterminal nt4.",
        "It is possible to simplify this grammar to 7 rules without losing the sharing of common subparses.",
        "However it would no longer exhibit the structure that makes it readable as a shared-forest (though this structure could be retrieved).",
        "The two parses of the input sentence defined by this grammar are: $ n3 v det n 471 prep n 3 6 2 $ $ n 3 v det a 4 prep n 3 6 5 7 1$ Here again the two $ symbols must be read as delimiters.",
        "The \"nil\" symbols, no longer useful, have been omitted in these two parses."
      ]
    },
    {
      "heading": "4.2 Parse shared-forest constructed from that grammar",
      "text": [
        "To explain the structure of the shared forest, we first build a graph from the grammar, as shown in figure 4.",
        "Each node corresponds to one terminal or nonterminal of the grammar in figure 3, and is labelled by it.",
        "The labels at the right of small dashes are rule numbers from the parsed language grammar (see beginning of section 4).",
        "The basic structure is that of figure 1.",
        "From this first graph, we can trivially derive the more traditional shared forest given in figure 5.",
        "Note that this simplified representation is not always adequate since it does not allow partial sharing of their sons between two nodes.",
        "Each node includes a label which is a non-terminal of the parsed language grammar, and for each possible derivation (several in case of ambiguity) there is the number of the grammar rule used for that derivation.",
        "Though this simplified version is more readable, the representation of figure 5 is not adequate to represent partial sharing of the subconstituents of a constituent.",
        "Of course, the \"constructions\" given in this section are purely virtual.",
        "In an implementation, the data-structure representing the grammar of figure 3 may be directly interpreted and used as a shared-forest.",
        "A similar construction for top-down parsing is sketched in appendix B."
      ]
    },
    {
      "heading": "5 Extensions",
      "text": [
        "As indicated earlier, our intent is mostly to understand phenomena that would be harder to evidence in more complex grammatical formalisms.",
        "This statement implies that our approach can be extended.",
        "This is indeed the case.",
        "It is known that many simple parsing schemata can be expressed with stack based machines [32].",
        "This is certainly the case for all left-to-right CF chart parsing schemata.",
        "We have formally extended the concept of PDA into that of Logical PDA which is an operational push-down stack device for parsing unification based grammars [17,18] or other non-CF grammars such as Tree Adjoining Grammars [19].",
        "Hence we are reusing and developing our theoretical [18] and experimental [36] approach in this much more general setting which is more likely to be effectively usable for natural language parsing.",
        "Furthermore, these extensions can also express, within the PDA model, non-left-to-right behavior such as is used in island parsing [38] or in Shell's approach [26].",
        "More generally they allow the formal analysis of agenda strategies, which we have not considered here.",
        "In these extensions, the counterpart of parse forests are proof forests of definite clause programs."
      ]
    },
    {
      "heading": "6 Conclusion",
      "text": [
        "Analysis of all-path parsing schemata within a common framework exhibits in comparable terms the properties of these schemata, and gives objective criteria for chosing a given schema when implementing a language analyzer.",
        "The approach taken here supports both theoretical analysis and actual experimentation, both for the computational behavior of parsers and for the structure of the resulting shared forest.",
        "Many experiments and extensions still remain to be made: improved dynamic programming interpretation of bottom-up parsers, more extensive experimental measurements with a variety of languages and parsing schemata, or generalization of this approach to more complex situations, such as word lattice parsing [21,30], or even handling of \"secondary\" language features.",
        "Early research in that latter direction is promising: our framework and the corresponding paradigm for parser construction have been extended to full first-order Horn clauses [17,18], and are hence applicable to unification based grammatical formalisms [27].",
        "Shared forest construction and analysis can be generalized in the same way to these more advanced formalisms.",
        "Acknowledgements: We are grateful to Veronique Donzeau-Gouge for many fruitful discussions.",
        "This work has been partially supported by the Eureka Software Factory (ESF) project."
      ]
    },
    {
      "heading": "References",
      "text": []
    },
    {
      "heading": "A The algorithm",
      "text": [
        "This is the formal description of a minimal dynamic programming PDT interpreter.",
        "The actual Tin interpreter has a larger instruction set.",
        "Comments are prefixed with \" – \".",
        " – Begin parse with input sentence x of length n",
        "while i < n loop for every item U = ((p A i) (q B j)) in Si do for every transition r in 8 do – we consider four kinds of transitions, corresponding – to the instructions of a minimal PDT interpreter.",
        "if r = (p e e r e z) then – OUTPUT V := ((rAi) (qB j));",
        "if r = (p A e 1-+ r e c) then – POP A for every iten Y = ((q B j) (s D k)) in Si do",
        "for every item U = n)(q$ 0)) in Sn such that f E F do",
        "Uf is the initial nonterminal of g. – End of parse"
      ]
    },
    {
      "heading": "B Interpretation of a top-down PDT",
      "text": [
        "To illustrate the creation of the shared forest, we present here informally a simplified sequence of transitions in their order of execution by a top-down parser.",
        "We indicate the transitions as Tin instructions on the left, as defined in appendix A.",
        "On the right we indicate the item and the rule produced by execution of each instruction: the item is the left-hand-side of the rule.",
        "The pseudo-instruction scan is given in italics because it does not exist, and stands for the parsing of a subconstituent: either several transitions for a complex constituent or a single shift instruction for a lexical constituent.",
        "The global behavior of scan is the same as that of shift, and it may be understood as a shift on the whole sub-constituent.",
        "Items are represented by a pair of integer.",
        "Hence we give no details about states or input, but keep just enough information to see how items are interrelated when applying a pop transition: it must use two items of the form (a ,b) and (b,c) as indicated by the algorithm.",
        "The symbol r stands for the rule used to recognize a constituent s, and ri stands for the rule used to recognize its sub-constituent S. The whole sequence, minus the first and the last two instructions, would be equivalent to \"scan s\".",
        "This grammar may be simplified by eliminating useless non-terminals, deriving on the empty string e or on a single other non-terminal.",
        "As in section 4, the simplified grammar may then be represented as a graph which is similar, with more details (the rules used for the subconstituents), to the graph given in figure 2.",
        " – SHIFT a"
      ]
    },
    {
      "heading": "C Experimental Comparisons",
      "text": [
        "This appendix gives some of the experimental data gathered to compare compilation schemata.",
        "For each grammar, the first table gives the size of the PDTs obtained by compiling it according to several compilation schemata.",
        "This size corresponds to the number of instructions generated for the PDT, which is roughly the number of possible PDT states.",
        "The second table gives two figures for each schema and for several input sentences.",
        "The first figure is the number of items computed to parse that sentence with the given schema: it may be read as the number of computation steps and is thus a measure of computational efficiency.",
        "The second figure is the number of items remaining after simplification of the output grammar: it is thus an indicator of sharing quality.",
        "Sharing is better when this second figure is low.",
        "In these tables, columns headed with LR/LALR stands for the LR(0), .LR(1), LALFt(1) and LALFt(2) cases (which often give the same results), unless one of these cases has its own explicit column.",
        "Tests were run on the GFtE, NSE, UBDA and RR grammars of [3]: they did not exhibit the loss of efficiency with increased lookahead that was reported for the bottom-up lookahead of [3].",
        "We believe the results presented here are consistent and give an accurate comparison of performances of the parsers considered, despite some implementation departure from the strict theoretical model required by performance considerations.",
        "A first version of our LL(0) compiler gave results that were inconsistent with the results of the bottom-up parsers.",
        "This was a clue to a weakness in that LL(0) compiler which was then corrected.",
        "We consider this experience to be a confirmation of the usefulness of our uniform framework.",
        "It must be stressed that these are preliminary experiments.",
        "On the basis of their.",
        "analysis, we intend a new set of experiments that will better exhibit the phenomena discussed in the paper.",
        "In particular we wish to study variants of the schemata and dynamic programming interpretation that give the best possible sharing."
      ]
    },
    {
      "heading": "C.1 Grammar UBDA",
      "text": []
    },
    {
      "heading": "C.2 Grammar RR",
      "text": [
        "1::•SAIx This grammar is LALR(1) but not LR(0), which explains the lower performance of the LR(0 parser.",
        "LR(0) LR(1) LALR(1) LALR(2) preced.",
        "- LL(0) 34 37 37 37 48 46 input string LR(0) LR/LALR pieced.",
        "LL(0) x 14-9 14-9 15-9 28-9 xx 23 - 13 20 - 13 25 - 13 43 - 13 LEEK= 99 - 29 44 - 29 56 - 29 123 - 29"
      ]
    },
    {
      "heading": "C.4 Grammar of Ada expressions",
      "text": [
        "This grammar, too long for inclusion here, is the grammar of expressions of the language Ada, as given in the reference manual [34].",
        "This grammar is ambiguous.",
        "In these examples, the use of lookahead give approximately a 25% gain in speed efficiency over LR(0) parsing, with the same forest sharing.",
        "However the use of lookahead may increase the LR(1) parser size quadratically with the grammar size.",
        "Still, a better engineered LR(1) construction should not usually increase that size as dramatically as indicated by our experimental figure.",
        "This grammar is LR(1) but is not LALR.",
        "For each compilation schema, it gives the same result on all possible inputs: eked, aec, bet and bed.",
        "The terminal f may be ambiguously parsed as X or as Y.",
        "This ambiguous left context increases uselessly the complexity of the LR(1) parses during recognition of the A and B constituents.",
        "Hence LR(0) performs better in this case since it ignores the context."
      ]
    }
  ]
}
