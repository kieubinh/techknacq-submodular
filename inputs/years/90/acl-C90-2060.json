{
  "info": {
    "authors": [
      "Tomek Strzalkowski"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C90-2060",
    "title": "How to Invert a Natural Language Parser into an Efficient Generator: An Algorithm for Logic Grammars",
    "url": "https://aclweb.org/anthology/C90-2060",
    "year": 1990
  },
  "references": [
    "acl-C88-2128",
    "acl-P89-1002",
    "acl-P90-1027"
  ],
  "sections": [
    {
      "heading": "HOW TO INVERT A NATURAL LANGUAGE PARSER INTO AN EFFICIENT GENERATOR: AN ALGORITHM FOR LOGIC GRAMMARS",
      "text": []
    },
    {
      "heading": "ABSTRACT",
      "text": [
        "The use of a single grammar in natural language parsing and generation is most desirable for variety of reasons including efficiency, perspicuity, integrity, robustness, and a certain amount of elegance.",
        "In this paper we present an algorithm for automated inversion of a PROLOG-coded unification parser into an efficient unification generator, using the collections of minimal sets of essential arguments (MSEA) for predicates.",
        "The algorithm is also applicable to more abstract systems for writing logic grammars, such as DCG."
      ]
    },
    {
      "heading": "INTRODUCTION",
      "text": [
        "In this paper we describe the results obtained from the experiment with reversing a PROLOG parser for a substantial subset of English into an efficient generator.",
        "The starting point of the experiment was a string parser for English (Grishman, 1986), which is used in an English-Japanese MT project.",
        "The PROLOG version of this parser was inverted, using the method described here, into an efficient PRoLoG generator working from regularized parse forms to English sentences.",
        "To obtain a PROLOG parser (or any PROLOG program) working in the reverse, requires1 some manipulation of the clauses, especially the ordering of the literals on their right-hand side, as noted by Dymetman and Isabelle (1988).",
        "We do not discuss here certain other transformations used to \"normalize\" the parser code in order to attain maximum efficiency of the derived generator program (Strzalkowski, 1989)."
      ]
    },
    {
      "heading": "IN AND OUT ARGUMENTS",
      "text": [
        "Arguments in a PROLOG literal can be marked as either \"in\" or \"out\" depending on whether they are bound at the time the literal is submitted for execution or after the computation is completed.",
        "For example, in tovo ( [to, eat fish] , T4, [np, [n, john] ] P3) the first and the third arguments are \"in\", while the Barring the presence of non-reversible operators.",
        "remaining two are \"out\".",
        "When tovo is used for generation, i.e., tow) (Tl, T4, Pl, [eat, [np, [n, john]], [np, [n, fish] ] ] ) then the last argument is \"in\", while the first and the third are \"out\"; T4 is neither \"in\" nor \"out\".",
        "The information about \"in\" and \"out\" status of arguments is important in determining the \"direction\" in which predicates containing them can be run2.",
        "As a further example consider the literal stibject (Al , A2, WHO, NUM, P) where Al and A2 arc input and output strings of words, WHQ indicates whether the subject phrase is a part of a clause within a wh-question, M124 is the number of the subject phrase, and P is the final translation.",
        "During parsing, the \"in\" arguments are: Al and WHQ, the \"out\" arguments are A2, NUM and P; during generation, the \"in\" arguments are P and WHO, the \"out\" arguments are Al and NUM.",
        "In generating, A2 is neither \"in\" nor \"out\".",
        "Thus, upon reversing the direction of computation, an \"out\" argument does not automatically become an \"in\" argument, nor does an \"in\" argument automatically become an \"out\" argument.",
        "Below is a method for computing \"in\" and \"out\" status of arguments in any given literal in a PROLOG program, as required by the inversion procedure.",
        "This algorithm is already general enough to handle any PROLOG program.",
        "An argument X of literal pred( X ) on the rhs of a clause is \"in\" if",
        "(A) it is a constant; or (B) it is a function and all its arguments are \"in\"; or (C) it is \"in\" or immediately \"out\" in some previous literal pred0 on the rhs of the same clause, i.e., 1(Y) :-- pred 0(X,Y),pred (X); or (D) it is \"out\" in an rhs literal pred 0 delayed until after some predicate pred1 such that pred0 precedes 2 For more discussion on directed predicates in PROLOG sec Shoham and McDermott (1984), and Debray (1989).",
        "pred , and predi precedes pred on the rhs ;3 or (E) it is \"in\" in the head literal L on lhs of the same clause.",
        "An argument X is \"in\" in the head literal L = pred ( X ) of a clause if (A), or (B), or (F) L is the top-level literal and X is \"in\" in it (known a priori); or (G) X occurs more than once in L and at least one of these occurrences is \"in\"; or (H) for every literal L1= pred ( Y .",
        ".)",
        "unifiable with L on the rhs of any clause with the head predicate predi different than pred, and such that Y unifies with X, Y is \"in\" in L1.",
        "We distinguish two categories of \"out\" arguments in literals appearing on the right-hand side of a clause: immediate and delayed.",
        "An argument X occurring in literal pred ( X ) is immediately \"out\" if it is fully bounce immediately after pred ( X ) is executed.",
        "An argument X in pred( X ) is \"out\" delayed until after predo, if it is fully bound only after predo, following pred on rhs, is executed.",
        "For example, consider the following fragment: vp (SN) : - agree (SN, VN) , v (VN) .",
        "agree (N, N) .",
        "If VN is immediately \"out\" in v, then SN in agree is \"out\" delayed until after v. For arguments with their \"out\" status delayed until after predo, the \"out\" status is assigned only after predo is executed.",
        "An argument X of literal pred ( X ) on the rhs of a clause is immediately \"out\" if",
        "(A) it is \"in\" in pred ( X ); or (B) it is a functional expression and all its arguments are either \"in\" or immediately \"out\"; or (C) for every clause with the head literal pred( Y ) unifiable with pred( X ) and such that Y unifies with X, Y is either \"in\", \"out\" or \"unknwn\", and Y is marked \"in\" or \"out\" in at least one case.",
        "An argument X of literal pred ( X ) on the rhs of a clause is \"out\" delayed until after predo( Y ) following pred if (D) Y is immediately \"out\" in predo and X=f (Y); or (E) X is a functional expression and all of its arguments are either \"in\" or immediately \"out\" or \"out\" delayed until after predo; or 3 The precedence is with respect to the order of evaluation, which in PROLOG is left-to-right.",
        "An argument is considered fully bound if it is a constant or it is bound by a constant; an argument is partially bound if it is, or is bound by, a term in which at least one variable is unbound.",
        "(F) there is a predicate predi( X Z.: ) preceding predo on the rhs, where Z* is a subset of arguments of predi such that every argument in Z* is \"out\" delayed until after predo and whenever Z* is \"in\" then X is immediately \"out\" in pred i.",
        "An argument X of literal pred ( X ) on the lhs of a clause is \"out\" if (G) it is \"in\" in pred ( X ); or (H) it is \"out\" (immediately or delayed) in literal predi( X ) on the rhs of this clause, providing that predi pred (again, we must take provisions to avoid infinite descend, cf. (H) in \"in\" algorithm); if predi = pred then X is marked \"unknwn\"."
      ]
    },
    {
      "heading": "ESSENTIAL ARGUMENTS",
      "text": [
        "Some arguments of every literal are essential in the sense that the literal cannot be executed successfully unless all of them are bound, at least partially, at the time of execution.",
        "A literal may have several alternative, possibly overlapping, sets of essential arguments.",
        "If all arguments in any one of such sets of essential arguments are bound, then the literal can be executed.",
        "Any set of essential arguments which have the above property is called essential.",
        "We shall call the set MSEA of essential arguments a minimal set of essential arguments if it is essential, and no proper subset of MSEA is essential.",
        "If we alter the ordering of the rhs literals in the definition of a predicate, we may also change its set of MSEA's.",
        "We call the set of MSEA's existing for a current definition of a predicate the set of active MSEA's for this predicate.",
        "To run a predicate in a certain direction requires that a specific MSEA is among the currently active MSEA's for this predicate, and if this is not already the case, then we have to alter the definition of this predicate so as to make this MSEA become active.",
        "As an example consider the following clause from our PROLOG parser: objectbe (01,02, Pl, P2, PSA, P) : venpass (01,02, P1, P3) concat ( [P2, P3] , PSA, P) .",
        "Assuming that (01) and (P3) are MSEA's of venpass and that P3 is \"out\" in venpass whenever 01 is \"in\", we obtain that (01) is the only candidate for an active MSEA in objectbe.",
        "This is because P3 is not present on the argument list of objectbe, and thus cannot receive a binding before the execution of venpass commences.",
        "Moving to the concat literal, we note that its first argument is partially bound since P3 is \"out\" in venpass.",
        "This is enough for concat to execute, and we conclude that 01 is in fact the only essential argument in objectbe.",
        "If we reverse the order of venpass and concat, then (p) becomes the new active MSEA for objectbe, while (01) is no longer active.",
        "Given the binding to its third argument, concat returns bindings to the 348 2 first two, and thus it also binds P3, which is an essential argument in venpass.5 Below is the general procedure MSEAS for computing the active sets of essential arguments in the head literal of a clause as proposed in (Strz,alkowski and Peng, 1990).",
        "Let's consider the following abstract clause defining a predicate Ri:",
        "Suppose that, as defined by (R), R; has the set MS, = (mi, ' ,in) of active MSEA's, and let MR, DMSi be the set of all MSEA for R; that can be obtained by permuting the order of literals on the right-hand side of (R).",
        "Let us assume further that R; occurs on rhs of some other clause, as shown below:",
        "We want to compute MS, the set of active MSEA's for P, as defined by (P), where s 1, assuming that we know the sets of active MSEA for each R; on the rhs.6 In the following procedure, the expression VAR (T), where T is a set of terms, denotes the the set of all variables occurring in the terms in T.",
        "MSEAS (MS,MSEA,VP,i3OUT) (1) Start with VP = VAR ({X 1, ,X,J), MS'EA = 0, i=1, and OUT = 0.",
        "When the computation is completed, MS is bound to the set of active MSEA's for?.",
        "(2) Let MR I be the set of active MS'EA's of R1, and let MRU I be obtained from MR1 by replacing all variables in each member of MR1 by their corresponding actual arguments of R1 on the rhs of (C1).",
        "(3) If R1 = P then for every Ml,k E AIRU1 if every argument Y, c rn1 k is always unifiable7 with its",
        "We note that since concat could also be executed with P2 bound, the set (01,P2) constitutes another active MSEA for inverted objectbe.",
        "However, this MSEA is of little use since the binding to 01 is unlikely to be known in generation.",
        "6 MSEA's of basic predicates, such as concat, arc assumed to be known a priori; MSEA's for recursive predicates arc first computed from non-recursive clauses.",
        "We assume that symbols X; in definitions (P) and (R) above represent terms, not just variables.",
        "For more details see (Strzalkowski and Peng, 1990).",
        "The case of s is discussed below.",
        "7 A term Y is always unifiable with a term X if they unify regardless of the possible bindings of any variables occurring in Y (variables standardized apart), while the variables occurring in X are unbound.",
        "Any term is always unifiable with a variable, but the inverse is not necessarily true.",
        "corresponding argument X, in P then remove m 1,k from MRU 1.",
        "For every set m 1,ki = {X1,j), where X1,1 is an argument in R1 such that it is not already in m id, and it is not always unifiable with its corresponding argument in?, and m 1,kj is not a superset of any other m1,1 remaining in MRUI, add mi,kj toMRU1.",
        "(4) For each rn1,1 c MRUI (j=1 ri) compute 111,j := VAR (ini,i) n VP.",
        "Let MP = I j=1 r), where r>0, and 0(11,1,i) 411,./ 0 or (kJ = 0 and VAR (mid).",
        "0)].",
        "If MP = 0 then QUIT: (Cl) is ill-formed and cannot be executed.",
        "(5) For each 1.11,1 e MP1 we do the following: (a) assume thatis \"in\" in R1; (b) compute set OUTIJ of \"out\" arguments for R1; (c) call MSEAS (MS j2,0UT Li); (d) assign MS U MS J. j=1..r (6) In some i-th step, where 1<i5..s, and MSEA = 114-1,k, let's suppose that MR; and MRU ; are the sets of active MSEA's and their instantiations with actual arguments of 121, for the literal R; on the rhs of (P).",
        "(7) If R; = P then for every rn1 e MRU; if every argument Y, c mi is always unifiable with its corresponding argument X, in P then remove mi,u from MRUi.",
        "For every set mirn1, u (X1,1) where X11 is an argument in R; such that it is not already in mi,u and it is not always unifiable with its corresponding argument in P and rn1 is not a superset of any other mid remaining in MRU;, add mi,uj to /V/RUi.",
        "(8) Again, we compute the set MP; = I 1=1 r;), where j.tjj = (VAR (in,) OUTi_i,k), where OUT,_1,k is the set of all \"out\" arguments in literals R1 to R1_1.",
        "(9) For each pti,i remaining in MP; where i5s do the following: (a) if = 0 then: (i) compute the set OUT./ of \"out\" arguments of Ri; (ii) compute the union OUTi,i := OUTj U OUT,j_i,k; (iii) call MSEAS (MS1j4t1_1,k,VP,i+1,OUTO; (b) otherwise, if Ki 0 then find all distinct minimal size sets v, c VP such that whenever the arguments in v, are \"in\", then the arguments in are \"out\".",
        "If such vi's exist, then for every v, do: (i) assume v, is \"in\" in P; (ii) compute the set OUT;J, of \"out\" arguments in all literals from R1 to Ri; (iii) call MSEAS (MS001.4_1,kuvVP,i+1,0UT111); (c) otherwise, if no such v, exist, MS1,1 := 0.",
        "(10) Compute MS :=MSi,j;",
        "(11) For i=s +1 set MS := (MSEA).",
        "In order to compute the set of all MSEA's for P, the procedure presented above need to be modified so that it would consider all feasible orderings of literals on the rhs of (P), using information about all MSEA's for Ri's.",
        "This modified procedure would regard the rhs of (P) as an unordered set of literals, and use various heuristics to consider only selected orderings.",
        "We outline the modified procedure briefly below.",
        "Let RR denote this set, that is, RR = (I?, I i=1 s).",
        "We add RR as an extra argument to MSEAS procedure, so that the call to the modified version becomes MSEAS (MS,MSEA,VP,RR,i3OUT).",
        "Next we modify step (2) in the procedure as follows: (2') For every element R1 e RR, do (2) to (5): (2) Let Mitt, I be the set of all MSEA's of Rt,1, and let MRU,.",
        "I be obtained from MR,.i by replacing all variables in each member of MR1,1 by their corresponding actual arguments of R1,1.",
        "Further steps are modified accordingly.",
        "The reader may note that the modified MSEAS procedure will consider all feasible ways of ordering elements of RR.",
        "In the steps shown above, we select all literals as potential leading elements on the right hand side, even though most of them will be rejected by steps (3) and (4).",
        "For those that survive, we will select elements from the rest of RR that can follow them.",
        "In step (5) the recursive call to MSEAS will be MSEAS (MS,.",
        "Li {R1.1},2,OUT1.",
        "Li).",
        "In step (6), that is, in i-th step of the recursion, we consider all elements of RR(R14 I j=1 1-1) , for selection of the i-th literal on the right-hand side.",
        "By this time we will have already generated a number of possible orderings of (RI 11=1 1-1).",
        "We add step (6') which contains the head of an iteration over the remaining elements of RR, and covering steps (6) to (11).",
        "Again, some of the elements of RR will be rejected in steps (7) and CIO).",
        "We continue until RR is completely ordered, possibly in several different ways.",
        "For each such possible ordering a set of MSEA's will be computed.",
        "Step (12) is an end condition with RR=0.",
        "To obtain a meaningful result, MSEA' s in MR,,i's must be grouped into sets of these which are active at the same time, that is, they belong to the set of active MSEA's for a specific definition of P (i.e., ordering of RR).",
        "MSEA's belonging to different groups give rise to alternative sets of MSEA's in the final set MS.",
        "Note that in this modified algorithm, MS becomes a set of sets of sets.",
        "An important part in the process of computing essential arguments for literals is the selection of MSEA's for lexicon access and other primitives whose definitions are not subject to change.",
        "As an example, consider a fragment of a lexicon: verb ( [looks IV] , V, sg, look) .",
        "verb ( [look I V] , V, pl, look) .",
        "verb((arrivesIV),V,sg,arrive).",
        "verb([arrivelV],V,p1,arrive).",
        "The lexicon access primitive verb (V1 , V2, Nra, P) has two sets of essential arguments: (v1) and (Nm, P).",
        "This is because (v1) can be consistently unified with at most one of ([looks IV]), [look IV] }, ( [arrive I V] 1, etc., at a time.",
        "Similarly, (Nm, P ) can be consistently unified at any one time with at most one of (sg, look), (pi, look), (sg, arrive), etc.",
        "Note that neither (P) nor (Nra) alone are sufficient, since they would unify with corresponding arguments in more than one clause.",
        "This indeterminacy, although not necessarily fatal, may lead to severe inefficiency if the generator has to make long backups before a number agreement is established between, say, a verb and its subject.",
        "On the other hand, if the representation from which we generate does not include information about the lexical number for constituents, we may have to accept (P } as the generation-mode MSEA for verb, or else we risk that the grammar will not be reversed at all."
      ]
    },
    {
      "heading": "REORDERING LITERALS IN CLAUSES",
      "text": [
        "When attempting to expand a literal on the rhs of any clause the following basic rule should be observed: never expand a literal before at least one its active MSEA's is \"in\", which means that all arguments in at least one MSEA are bound.",
        "The following algorithm uses this simple principle to reorder rhs of parser clauses for reversed use in generation.",
        "This algorithm uses the information about \"in\" and \"out\" arguments for literals and sets of MSEA's for predicates.",
        "If the \"in\" MSEA of a literal is not active then the rhs's of every definition of this predicate is recursively reordered so that the selected MSEA becomes active.",
        "We proceed top-down altering definitions of predicates of the literals to make their MSEA's active as necessary, starting with the top level predicate parse(S,P), where P is marked \"in\" (parse structure) and S is marked \"out\" (generated sentence).",
        "We continue until we reach the level of atomic or non-reversible primitives such as concat, member, or dictionary lookup routines.",
        "If this process succeeds at reversing predicate definitions at each level, then the reversed-parser generator is obtained.",
        "INVERSE(\"head old-rhs\",ins,outs); (ins and outs are subsets of VAR(head) which are \"in\" and are required to be \"out\", respectively) begin compute M the set of all MSEA's for head; foreveryMSEAmc M do",
        "if m is an active MSEA such that mcins then begin compute \"out\" arguments in head; add them to OUT;",
        "if outscOUT then DONE(\"head:-old-rhs\") end else if m is a non-active MSEA and mcins then begin",
        "for every literal L do ML := 0; (done only once during the inversion) repeat mark \"in\" old-rhs-1 arguments which are either constants, or marked \"in\" in head, or marked \"in\", or \"out\" in new-rhs; select a literal L in old-rhs-1 which has an \"in\" MSEA mL and if mL is not active in L then either M 0 or mL C ML\" set up a backtracking point containing all the remaining alternatives to select L from old-rhs-1; if L exists then begin if rn is non-active in L then begin if M = 0 then ML .= ML u (mL ) ' for every clause \"Li rhsLi\" such that Li has the same predicate as L do begin INVERSE(\"Llrhs \" M 0)- LI ' 1,\" if GIVEUP returned then backup, undoing all changes, to the latest backtracking point and select another alternative end end; compute \"in\" and \"out\" arguments in L; add \"out\" arguments to OUT;",
        "else begin backup, undoing all changes, to the latest backtracking point and select another alternative; if no such backtracking point exists then QUIT := true end [else) until old-rhs-1= 0 or QUIT; if outscOUT and not QUIT then",
        "GIVEUP(\"grammar can't be inverted as specified\") end;"
      ]
    },
    {
      "heading": "MOVING LITERALS BETWEEN CLAUSES",
      "text": [
        "The inversion algorithm, as realized by the procedure INVERSE, requires that for each clause in the parser code we can find a definite order of literals on its right-hand side that would satisfy the requirements of running this clause in the reverse: appropriate minimal sets of essential arguments (MSEA's) are bound at the right time.",
        "However, this requirement is by no means guaranteed and INVERSE may encounter clauses for which no ordering of the literals on the right-hand side would be possible.",
        "It may happen, of course, that the clause itself is ill-formed but this is not the only situation.",
        "It may be that two or more literals on the right-hand side of a clause cannot be scheduled because each is waiting for the other to deliver the missing bindings to some essential arguments.",
        "As an example, consider the grammar fragment below: sent (P): - sub (N1, P1) ,",
        "In the generation mode, that is, with the variable P instantiated by the parse structure of a sentence, the following active MSEA's and \"out\" arguments have been computed:",
        "Now we can reintroduce the non-terminal vp, and break the above rule back into two.",
        "Note that as a result agree migrated to the first clause, and N2 replaced Ni on the argument list of vp.",
        "Note also that N2 is not an essential argument in the new vp.",
        "sent (P): vp (N2, Pl, P) , sub (N1, Pl) ,",
        "The only thing that remains to be done is to automatically determine the arguments of the new vp predicate.",
        "Doubtless, it will be a subset of the arguments occurring in the literals that create the right-hand side of the new clause.",
        "In the example given this set is (N2, P1, P2, P).",
        "From this set, we remove all those arguments which do not occur in other literals of the original clause, that is, before the break up.",
        "The only such argument is P2, and thus the final set of arguments to vp becomes fN2 , P1 , P ), as shown above.",
        "The complete algorithm for interclausal reordering of goals can be described by a largely straightforward extension to INVERSE (Strzalkowski, 1989)8 CONCLUSIONS In this paper we presented an algorithm for automatic inversion of a unification parser for natural language into an efficient unification generator.",
        "The inverted program of the generator is obtained by an off-line compilation process which directly manipulates the PROLOG code of the parser program.",
        "We distinguish two logical stages of this transformation: computing the minimal sets of essential arguments (MSEA's) for predicates, and generating the inverted program code with INVERSE.",
        "We have completed a first implementation of the system and used it to derive both a parser and a generator from a single DCG grammar for English (Strzalkowski and Peng, 1990).",
        "This method is contrasted with the approaches that seek to define a generalized but computationally expensive evaluation strategy for running a grammar in either direction without a need to manipulate its rules (Shieber, 1988), (Shieber et al., 1989), and see also (Colmerauer, 1982) and (Naish, 1986) for some relevant techniques, employing the trick known as goal freezing.",
        "To reduce the cost of the goal freezing, and also to circumvent some of its deficiencies, Shieber et al.",
        "(1989) introduce a mixed top-down/bottom-up goal expansion strategy, in which only selected goals are expanded during the top-down phase of the interpreter.",
        "This technique, still substantially more expensive than a fixed-order top-down interpreter, does not by itself guarantee that the underlying grammar formalism can be used bidirectionally, and it may need to be augmented by static goal reordering, as described in this paper."
      ]
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": [
        "Ralph Grishman, Ping Peng and other members of the Natural Language Discussion Group provided valuable comments to earlier versions of this paper.",
        "8 It should be noted that recursive clauses are never used for literal expansion during interclausal ordering, and that literals are not moved to or from recursive clauses, although argument lists of recursive literals may be affected by literals being moved elsewhere.",
        "This paper is based upon work supported by the Defense Advanced Research Project Agency under Contract N00014-85-K-0163 from the Office of Naval Research."
      ]
    },
    {
      "heading": "REFERENCES",
      "text": []
    }
  ]
}
