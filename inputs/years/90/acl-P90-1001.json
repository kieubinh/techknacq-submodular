{
  "info": {
    "authors": [
      "K. Vijay-Shanker",
      "David Weir"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P90-1001",
    "title": "Polynomial Time Parsing of Combinatory Categorial Grammars",
    "url": "https://aclweb.org/anthology/P90-1001",
    "year": 1990
  },
  "references": [
    "acl-E89-1002",
    "acl-P87-1011",
    "acl-P87-1012",
    "acl-P88-1031",
    "acl-P88-1034",
    "acl-P89-1018"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "In this paper we present a polynomial time parsing algorithm for Combinatory Categorial Grammar.",
        "The recognition phase extends the CKY algorithm for CFG.",
        "The process of generating a representation of the parse trees has two phases.",
        "Initially, a shared forest is build that encodes the set of all derivation trees for the input string.",
        "This shared forest is then pruned to remove all spurious ambiguity."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Combinatory Categorial Grammar (CCG) [7, 5] is an extension of Classical Categorial Grammar in which both function composition and function application are allowed.",
        "In addition, forward and backward slashes are used to place conditions on the relative ordering of acliacent categories that are to be combined.",
        "There has been considerable interest in parsing strategies for CCG' [4, 11, 8, 2].",
        "One of the major problems that must be addressed is that of spurious ambiguity.",
        "This refers to the possibility that a CCG can generate a large number of (exponentially many) derivation trees that assign the same function argument structure to a string.",
        "In [9] we noted that a CCG can also generate exponentially many genuinely ambiguous (non-spurious) derivations.",
        "This constitutes a problem for the approaches cited above since it results in their respective algorithms taking exponential time in the worst case.",
        "The algorithm we present is the first known polynomial time parser for CCG.",
        "The parsing process has three phases.",
        "Once the recognizer decides (in the first phase) that an input can be generated by the given CCG the set of parse •This work was partially supported by NSF grant IRI8909810.",
        "We are very grateful to Aravind Joshi, Michael Niv, Mark Steedrnan and Kent Wittenbttrg for helpful discussions.",
        "trees can be extracted in the second phase.",
        "Rather than enumerating all parses, in Section 3, we describe how they can be encoded by means of a shared forest (represented as a grammar) with which an exponential number of parses are encoded using a poIynoinially bounded structure.",
        "This shared forest encodes all derivations including those that are spuriously ambiguous.",
        "In Section 4.1, we show that it is possible to modify the shared forest so that it contains no spurious ambiguity.",
        "This is done (in the third phase) by traversing the forest, examining two levels of nodes at each stage, detecting spurious ambiguity locally.",
        "The three stage process of recognition, building the shared forest, and eliminating spurious ambiguity takes polynomial time."
      ]
    },
    {
      "heading": "1.1 Definition of CCG",
      "text": [
        "A CCG, G , is denoted by (VT ,VN, S,f, R) where VT is a finite set of terminals (lexical items), VN is a finite set of nonterminals (atomic categories), S is a distinguished member of ITN, f is a function that maps elements of VT to finite sets of categories, R is a finite set of combinatory rules.",
        "Combinatory rules have the following form.",
        "In each of the rules x, y, z1, ... are variables and Ii E",
        "1.",
        "Forward application: x/y y x 2.",
        "Backward application: y z 3.",
        "Forward composition (for n > 1): x/y YliziI2 • • • Inzr, xlizil2 • • • In Zn 4.",
        "Backward composition (for n > 1): Y11z112•••Inzn x\\Y",
        "In the above rules, x I y is the primary category and the other left-hand-side category is the secondary category.",
        "Also, we refer to the leftmost nonterminal",
        "of a category as the target of the category.",
        "We assume that categories are parenthesis-free.",
        "The results presented here, however, generalize to the case of fully parenthesized categories.",
        "The version of CCG used in [7, 51 allows for the possibility that the use of these combinatory rules can be restricted.",
        "Such restrictions limit the possible categories that can instantiate the variables.",
        "We do not consider this possibility here, though the results we present can be extended to handle these restrictions.",
        "Derivations in a CCG involve the use of the combinatory rules in R. Let be defined as follows, where T1 and T2 are strings of categories and terminals and c, el, ca are categories.",
        "• If c1e2 – + c is an instance of a rule in R then T1cT2 T1cic2T2.",
        "• If c E f(a) for some a E VT and category c then T1cT2 TiaTz.",
        "The string language generated is defined as L(G)=--{wIS"
      ]
    },
    {
      "heading": "1.2 Context-Free Paths",
      "text": [
        "In Section 2 we describe a recognition algorithm that involves extending the CICY algorithm for CFG.",
        "The differences between the CKY algorithm and the one presented here result from the fact that the derivation tree sets of CCG have more complicated path sets than the (regular) path sets of CFG tree sets.",
        "Consider the set of CCG derivation trees of the form shown in Figure 1 for the language { ww I w E {a, b}*}.",
        "Due to the nature of the combinatory rules, categories behave rather like stacks since their arguments are manipulated in a last-in-first-out fashion.",
        "This has the effect that the paths can exhibit nested dependencies as shown in Figure 1.",
        "Informally, we say that CCG tree sets have context-free paths.",
        "Note that the tree sets of CFG have regular paths and cannot produce such tree sets."
      ]
    },
    {
      "heading": "2 Recognition of CCG",
      "text": [
        "The recognition algorithm uses a 4 dimensional array L for the input al ...an.",
        "In entries of the array L we cannot store complete categories since exponentially many categories can derive the substring",
        "...aj1 it is necessary to store categories carefully It is possible, however, to share parts of categories between different entries in L. This follows from the fac' that the use of a combinatory rule depends only on (1) the target category of the primary category of tht rule; (2) the first argument (suffix of length 1) of tht primary category of the rule;(3) the entire (bounded secondary category.",
        "Therefore, we need only find (bounded) information in each array entry in crde to determine whether a rule can be used.",
        "Entries o the form ((A, a), T) are stored in L[i, j][p,q].",
        "This en codes all categories whose target is A, suffix a, an that derive the ai ...aj.",
        "The tail T and the indices I and q are used to locate the remaining part of them categories.",
        "Before describing precisely the informatior that is stored in L we give some definitions.",
        "If a E (1\\,/)VN)n then lal = n. Given a CCG, G = (VT, VN, S f, R) let k1 be the largest n such that R contains a rule whose secondary category is Inzn and let k2 be the maximum of k1 and all n where there is some c E f(a) such that c Aa and la' = n. In considering how categories that are derived in the course of a derivation should be stored we have two Cases.",
        "items appearing in the input string or whose length is less that k1 and could therefore be secondary categories of a rule.",
        "Thus all categories whose length is bound by k2 are encoded in their entirety within a single array entry.",
        "2.",
        "All other categories are encoded with a sharing mechanism in which we store up to k1 arguments locally together with an indication of where the remaining arguments can be found.",
        "Next, we give a proposition that characterizes when an entry is included in the array by the algorithm.",
        "An entry (A, a), T) E j][p, q] where A E 17,v and",
        "(1) Acx'a (2) Aa17 ...aq.",
        "(3) Informally, the category Aa'7 in (1) above is \"derived\" from Aa'a such that there is no intervening point in the derivation before reaching Aa7 at which the all of the suffix a of Aa'a has been \"popped\".",
        "Alternatively, if T = – then 0 < led < k + k2, (p, q) ----- (0,0) and Aa ai ...ai .",
        "Note that we have !al < ki k2 rather than [al < k2 (as might have been expected from the discussion above).",
        "This is the case because a category whose length is strictly less than k2, can, as a result of function composition, result in a category of length < k1 + k2.",
        "Given the way that we have designed the algorithm below, the latter category is stored in this (non-sharing) form."
      ]
    },
    {
      "heading": "2.1 Algorithm",
      "text": [
        "If c E f(a) for some category c, such that c Aa, then include the tuple a), – ) in Lfi, in, 0].",
        "For some i and j, I.<i < j < n consider each rule x/Y For some k, i < < j, we look for some ((8,13), – ) E L[k 1, j] [0, 0], where 10u m, (corresponding to the secondary category of the rule) and we look for ((A,a B), T) E L[i, k][p,qj for some a, T, p and q (corresponding to the primary category of the rule).",
        "From these entries in L we know that for some Aa'a/B ai ak and BO ak+i ...aj.",
        "Backward composition and application are treated in the same way as this rule, except that all occurrences below of and k are swapped with occurrences of k+ 1 and respectively.",
        "Thus, by the combinatory rule given above we have A& a3 and we should store and encoding of the category Aa'af3 in Lii, jj.",
        "This encoding depends on a', a, ,3, and T",
        "• T = – If Fafil < k1 + k2 then (case la) add ((A, a,3), – ) to • j] (0, 0).",
        "Otherwise, (case 1b) add ((A, 0), /B) to • T – and in > 1",
        "The new category is longer than the one found in",
        "• klip,q].",
        "If a 0 c then (case 2a) add ((A, 0),/B) to kl, otherwise (case 2b) add ((A, 13), T) to • j] fp, q).",
        "• T – and m 1 (case 3)",
        "The new category has the same length as the one found in Lti, klip, gl.",
        "Add ((A, a(3), T) to",
        "• T \"ir – and ni",
        "The new category has the a length one less than the one found in L(i,k][p,q).",
        "If a 0 c then (case 4a) add ((A, a), T) to Ly, ji[p, q].",
        "Otherwise, (case 4b) since a = c we have to look for part of the category that is not stored locally in L[i, klip, q).",
        "This may be found by looking in each entry L[12, q][r, .91 for each ((A, 0), T').",
        "We know that either TS – or p, c and add ((A, f3'),T1) to L[i, ji[r, sl, Note that for some a\", Aa\"0\"7 aq, A&'.5' /B ai • • • ak and thus by the combinatory rule above Act\"01 ai aj.",
        "As in the case of CKY algorithm we should have loop statements that allow i, j to range from 1 through • such that the length of the spanned substring starts from 1 (1 = j) and increases to n (i 1 and j = n).",
        "When we consider placing entries in L[i, j] (i.e., to detect whether a category derives ai ...ai) we have to consider whether there are two subconstituents (to simplify the discussion let us consider only forward combinations) which span the substrings o. and ak+1 ...aj.",
        "Therefore we need to consider all values for k between i through j – 1 and consider the entries in Lii,klip,q) and L[k + 1, jj[0, Oj where i<p<q<k or p q = 0.",
        "The above algorithm can be shown to run in time Q(n7) where n is the length of the input.",
        "In case Llb.",
        "we have to consider all possible values for r, s between p and q.",
        "The complexity of this case dominates the complexity of the algorithm since the other cases do involve fewer variables (i.e., r and .s are not involved).",
        "Case 4b takes time 0((q p)2) and with the loops for j, k, p,q ranging from I through n the time complex",
        "ity of the algorithm is 0(n7).",
        "However, this algorithm can be improved to obtain a time complexity of 0(n6) by using the same method employed in [91.",
        "This improvement is achieved by moving part of case 4b outside of the k loop, since looking for ((A, 131/791 T') in Lip, s] need not be done within the k loop.",
        "The details of the improved method may be found in [9] where parsing of Linear Indexed Grammar (LIG) was considered.",
        "Note that 0(n6) (which we achieve with the improved method) is the best known result for parsing Tree Adjoining Grammars, which generates the same class of languages generated by CCG and LIG.",
        "244.-cr] rail ...,,[cri – dA,(..filAt+ias+1]... Ant a .1"
      ]
    },
    {
      "heading": "A[a] a",
      "text": [
        "The first form of production is interpreted as: if a nonternainal A is associated with some stack with the sequence a on top (denoted [--ap, it can be rewritten such that the Vh child inherits this stack with ,3 replacing a.",
        "The remaining children inherit the bounded stacks given in the production.",
        "The second form of production indicates that if a nonterminal A has a stack containing a sequence a then it can be rewritten to a terminal symbol a.",
        "The language generated by a LIG is the set of strings derived from the start symbol with an empty stack."
      ]
    },
    {
      "heading": "3 Recovering Al! Parses",
      "text": [
        "At this stage, rather than enumerating all the parses, we will encode these parses by means of a shared forest structure.",
        "The encoding of the set of all parses must be concise enough so that even an exponential number of parses can be represented by a polynomial sized shared forest.",
        "Note that this is not achieved by any previously presented shared forest presentation for CCG [8]."
      ]
    },
    {
      "heading": "3.1 Representing the Shared Forest",
      "text": [
        "Recently, there has been considerable interest in the use of shared forests to represent ambiguous parses in natural language processing [1, 8].",
        "Following 811- lot and Lang [1], we use grammars as a representation scheme for shared forests.",
        "In our case, the grammars we produce may also be viewed as acyclic and-or graphs which is the more standard representation used for shared forests.",
        "The grammatical formalism we use for the representation of shared forest is Linear Indexed Grammar (LIG)3.",
        "Like Indexed Grammars (IG), in a LIG stacks containing indices are associated with nontermina.ls, with the top of the stack being used to determine the set of productions that can be applied.",
        "Briefly, we define LIG as follows.",
        "If a is a sequence of indices and 7 is an index, we use the notation A[a] to represent the case where a stack is associated with a nonterminal A having 7 on top with the remaining stack being the a.",
        "We use the following forms of productions.",
        "3It has been shown in [10, 3] that LIG and CCG generate the same class of languages."
      ]
    },
    {
      "heading": "3.2 Building the Shared Forest",
      "text": [
        "We start building the shared forest after the recognizer has completed the array L and decided that a given input al ... an is well-formed.",
        "In recovering the parses, having established that some a is in an element of L, we search other elements of L to find two categories that combine to give a.",
        "Since categories behave like stacks the use of CFG for the representation of the set of parse trees is not suitable.",
        "For our purposes the LIG formalism is appropriate since it involves stacks and production describing how a stack can be decomposed based on only its top and bottom elements.",
        "We refer to the LIG representing the shared forest as G11.",
        "The set of indices used in Gsf have the form (A, a, i, j).",
        "The terminals used in G,/ are names for the combinatory rule or the lexical assignment used (thus derived terminal strings encode derivations in G).",
        "For example, the terminal Fm indicates the use of the forward composition rule ziy YilZI 12 • - • Inizm and (c, a) indicates the lexical assignment, c to the symbol a.",
        "We use one nonterminal, P. An input al .",
        "an is accepted if it is the case that ((S, e), – ) E L[1, n][0, 0].",
        "We start by marking this entry.",
        "By marking an entry ((A, a), T) E L[i, j][p,q] we are predicting that there is some derivation tree, rooted with the category S and spanning the input al , in which a category represented by this entry will participate.",
        "Therefore at some point we will have to consider this entry and build a shared forest to represent all derivations from this category.",
        "Since we start from ((5,€), – ) E L[1, n][0, 0] and proceed to build a (representation of) derivation trees in a top down fashion we will have loop statements that vary the substring spanned (ai ai) from the",
        "largest possible (i.e., i = 1 and j = n) to the smallest (i.e., i = j).",
        "Within these loop statements the algorithm (with some particular values for i and j) will consider marked entries, say ((A, a), T) E j][p, q] (where i<p<q<j or p = 0), and will build representations of all derivations from the category (specified by the marked entry) such that the input spanned is ai Since ((A, a), T) is a representation of possibly more than one category, several cases arise depending on a and T. All these cases try to uncover the reasons why the recognizer placed this entry in j][p, q].",
        "Hence the cases considered here are inverses of the cases considered in the recognition phase (and noted in the algorithm given below).",
        "Mark ((S, c), – ) in L(1, n1(0, 0].",
        "By varying i from I to n, j from n to i and for all appropriate values of p and q if there is a marked entry, say ((A, a), T) E 111, j][p,q] then do the following.",
        "• Type .1 Production (inverse of la, 3, and 4a)",
        "If for some k such that .1 < k < j, same a8 such that a' = a(3, and B E VN we have ((A, a 1 B), T) E Lii,k][p,q1 and ((B, 13), – ) E L[k + 1, j][0 , 01 then let p be the production P[.",
        "'(A, a' j)] F,,, P(.-(A, al , k)] P[(B, 11, k + 1,j)] where m = 101. lip is not already present in G,1 then add p and mark ((A, al B),T) E kllp, ql as well as ((a, 0), – ) E L[k + I, j1( 0 , 0].",
        "• Type 2 Production (inverse of lb and 2a) If for some k such that i < k < j, and a, B,T' r, s, k we have ((A, al B), E klir, s1 where (p, q) =",
        "(i, k), ((B , – ) L[k + 1, ob T = B, and the lengths of a and a' meet the requirements on the corresponding strings in case lb and 2a of the recognition algorithm then then let p be the production P[..(A, a / B, i, k)(A, a', 1, j)]"
      ]
    },
    {
      "heading": "Fm PHA, al B,i, k)] FRB, a' ,k +1, j)]",
      "text": [
        "where m kr' I.",
        "If p is not already present in Gall then add p and mark ((A, a 1 B),T1) E L[i, kl[r, s] and",
        "• Type 3 Production (inverse of 2b)",
        "If for some k such that i < k < j, and some B it is the case that ((A, / B),T) E L[i,kilp,q) and (0, – ) E L[k + 1, j][0, 0) where )a') > 1 then then let p be the production",
        "• Type 4 Production (inverse of 413)",
        "If for some k such that i < k < j, and some B,71,r,s,k, we find ((A, 1 B ,), E L[i, k]fr, s], ((A, a'71), T) E L[r, sllp, q], and ((B,e), – ) E L[le + 1, AO, 01 then then let p be the production",
        "PRA, a', 11 1)1 (Act, ai) The number of terminals and nonterminais in the grammar is bounded by a constant.",
        "The number of indices and the number of productions in G f are 0(n).",
        "Hence the shared forest representation we build is polynomial with respect to the length of the input, n, despite the fact that the number of derivations trees could be exponential.",
        "We will now informally argue that G1 can be built in time 0(117).",
        "Suppose an entry ((A, al), T) is in j][p,q] indicating that for some the category Afia' dominates the substring a ..cr.'.",
        "The method outlined above will build a shared forest structure to represent all such derivations.",
        "In particular, we will start by considering a production whose left hand side is given by P[..(A, a', i, j)].",
        "It is clear that an introduction of production of type 4 dominates the time complexity since this case involves three other variables (over input positions), i.e., r, s; k; whereas the introduction of other types of production involve only one new variable k. Since we have to consider all possible values for r, 8, k within the range i through j, this step will take OW – ir) time.",
        "With the outer loops for P, and q allowing these indices to range from 1 through n, the time taken by the algorithm is 0(717).",
        "Since the algorithm given here for building the shared forest simply finds the inverses of moves made in the recognition phase we could have modified the recognition algorithm so as to output appropriate G,f productions during the process of recognition without altering the asymptotic complexity of the recognizer.",
        "However this will cause the introduction of useless productions, i.e., those that describe subderivations which do not partake in any derivation from the category S spanning the entire input string ai • • am."
      ]
    },
    {
      "heading": "4 Spurious Amb iguity",
      "text": [
        "We say that a given CCG, G , exhibits spurious ambiguity if there are two distinct derivation trees for a string w that assign the same function argument structure.",
        "Two well-known sources of such ambiguity in CCG result from type raising and the associativity of composition.",
        "Much attention has been given to the latter form of spurious ambiguity and this is the one that we will focus on in this paper.",
        "To illustrate the problem, consider the following string of categories.",
        "Any pair of adjacent categories can be combined using a composition rule.",
        "The number of such derivations is given by the Catalan series and is therefore exponential in n. We return a single representative of the class of equivalent derivation trees (arbitrarily chosen to be the right branching tree in the later discussion)."
      ]
    },
    {
      "heading": "4.1 Dealing with Spurious Ambiguity",
      "text": [
        "We have discussed how the shared forest representation, C51, is built from the contents of array L. The recognition algorithm does not consider whether some of the derivations built are spuriously equivalent and this is reflected in G31.",
        "We show how productions of G31 can be marked to eliminate spuriously ambiguous derivations.",
        "Let us call this new grammar Gas.",
        "As stated earlier, we are only interested in detecting spuriously equivalent derivations arising from the associativity of composition.",
        "Consider the example involving spurious ambiguity shown in Figure 2.",
        "This example illustrates the general form of spurious ambiguity (due to associativity of composition) in the derivation of a string made up of contiguous substrings ai, (11,, and aia ...ai3 resulting in a category A1aia2a3.",
        "For the sake of simplicity we assume that each combination indicated is a forward combination and hence i2 = j1 + 1 and i5 = j2 + 1.",
        "Each of the 4 combinations that occur in the above figure arises due to the use of a combinatory rule, and hence will be specified in G1 by a production.",
        "For example, it is possible for combination 1 to be represented by the following type 1 production.",
        "P[••(A.1, asa2/A3., , j2 )1] F,, P[.•(Ai, a'I A2,11, ii)] P[(A2, ag, i2, f2)] where i2 = j1-1- 1, a' is a suffix of al of length less than",
        "la2I.",
        "Since Ai cti/A3 , and m = and A3a3 are used as secondary categories, their lengths are bounded by k1 + 1.",
        "Hence these categories will appear in their entirety in their representations in the G31 productions.",
        "The four combinations4 will hence be represented in",
        "These productions give us sufficient information to detect spurious ambiguity locally, i.e., the local left and right branching derivations.",
        "Suppose we choose to retain the right branching derivations only.",
        "We are no longer interested in combination 2.",
        "Therefore we mark the production corresponding to this combination.",
        "This production is not discarded at this stage because although it is marked it might still be useful in detecting more spurious ambiguity.",
        "Notice in Figure 3",
        "that the subtree obtained from considering combination 5 and combination 1 is right branching whereas the entire derivation is not.",
        "Since we are looking for the presence of spurious ambiguity locally (i.e., by considering two step derivations) in order to mark this derivation we can only compare it with the derivation where combination 7 combines Aa I Ai with AI cricr2ois (the result of combination 2)5.",
        "Notice we would have already marked the production corresponding to combination 2.",
        "If this production had been discarded then the required comparison could not have been made and the production due to combination 6 can not have been marked.",
        "At the end of the marking process all marked productions can be discarded6 In the procedure to build the grammar Gnz we start with the productions for lexical assignments (type 5).",
        "By varying i1 from n to 1, ,j3 from i + 2 to n, i2 from js to i1 + 1, and is from i2 + 1 to js we look for a group of four productions (as discussed above) that locally indicates the the presence of spurious ambiguity.",
        "Productions involved in derivations that are not right branching are marked.",
        "It can be shown that this local marking of spurious derivations will eliminate all and only the spuriously ambiguous derivations.",
        "That is, enumerating all derivations using unmarked productions, will give all and only genuine derivations.",
        "If there are two derivations that are spuriously ambiguous (due to the associativity of composition) then in these derivations there must be at least one occurrence of sub derivations of the nature depicted in Figure 3.",
        "This will result in the marking of appropriate productions and hence the spurious ambiguity will be detected.",
        "By induction it is also possible to show that only the spuriously ambiguous derivations will be detected by the marking process outlined above."
      ]
    },
    {
      "heading": "5 Conclusions",
      "text": [
        "Several parsing strategies for CCG have been given recently (e.g., [4, 11, 2, 8]).",
        "These approaches have concentrated on coping with ambiguity in CCG derivations.",
        "Unfortunately these parsers can take exponential time.",
        "They do not take into account the fact that categories spanning a substring of the input could be of a length that is linearly proportional to the length of the input spanned and hence exponential in number.",
        "We adopt a new strategy that runs in polynomial time.",
        "We take advantage of the fact that regardless of the length of the category only a bounded amount of information (at the beginning and end of the cate-sAlthough this category is also the result of combination 4, the tree with combinations 5 and 6 can not he compared with the tree having the combinations 7 and 4.",
        "gory) is used in determining when a combinatory rule can apply.",
        "We have also given an algorithm that builds a shared forest encoding the set of all derivations for a given input.",
        "Previous work on the use of shared forest structures [1] has focussed on those appropriate for context-free grammars (whose derivation trees have regular path sets).",
        "Due to the nature of the CCG derivation process and the degree of ambiguity possible this form of shared forest structures is not appropriate for CCG.",
        "We have proposed a shared forest representation that is useful for CCG and other for-malisrn.s (such as Tree Adjoining Grammars) used in computational linguistics that share the property of producing trees with context free paths.",
        "Finally, we show the shared forest can be marked so that during the process of enumerating all parses we do not list two derivations that are spuriously ambiguous.",
        "In order to be able to eliminate spurious ambiguity problem in polynomial time, we examine two step derivations to locally identify when they are equivalent rather than looking at the entire derivation trees.",
        "This method was first considered by [2] where this strategy was applied in the recognition phase.",
        "The present algorithm removes spurious ambiguity in a separate phase after recognition has been completed.",
        "This is a reasonable approach when a CKY-style recognition algorithm is being used (since the degree of ambiguity has no effect on recognition time).",
        "However, if a predictive (e.g., Earley-style) parser were employed then it would be advantageous to detect spurious ambiguity during the recognition phase.",
        "In a predictive parser the performance on an ambiguous input may be inferior to that on an unambiguous one.",
        "Due to the spurious ambiguity problem in CCG, even without genuine ambiguity, the parser's performance be poor if spurious ambiguity was not detected during recognition.",
        "CKY-style parsers are closely related to predictive parsers such as Earley's.",
        "Therefore, we believe that the techniques presented here, i.e., (1) the sharing of stacks used in recognition and in the shared forest representation and (2) the local identification of spurious ambiguity (first proposed by [2]) can be adapted for use in more practical predictive algorithms."
      ]
    }
  ]
}
