{
  "info": {
    "authors": [
      "Tomek Strzalkowski",
      "Ping Peng"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P90-1027",
    "title": "Automated Inversion of Logic Grammars for Generation",
    "url": "https://aclweb.org/anthology/P90-1027",
    "year": 1990
  },
  "references": [
    "acl-C88-2128",
    "acl-C88-2150",
    "acl-P84-1065",
    "acl-P89-1002"
  ],
  "sections": [
    {
      "text": [
        "We describe a system of reversible grammar in which, given a logic-grammar specification of a natural language, two efficient PROLOG programs are derived by an off-line compilation process: a parser and a generator for this language.",
        "The centerpiece of the system is the inversion algorithm designed to compute the generator code from the parser's PROLOG code, using the collection of minimal sets of essential arguments (MSEA) for predicates.",
        "The system has been implemented to work with Definite Clause Grammars (DCG) and is a part of an English-Japanese machine translation project currently under development at NYU's Courant Institute.",
        "INTRODUCTION The results reported in this paper are part of the ongoing research project to explore possibilities of an automated derivation of both an efficient parser and an efficient generator for natural language, such as English or Japanese, from a formal specification for this language.",
        "Thus, given a grammar-like description of a language, specifying both its syntax as well as \"semantics\" (by which we mean a correspondence of well-formed expressions of natural language to expressions of a formal representation language) we want to obtain, by a fully automatic process, two possibly different programs: a parser and a generator.",
        "The parser will translate well-formed expression of the source language into expressions of the language of \"semantic\" representation, such as regularized operator-argument forms, or formulas in logic.",
        "The generator, on the other hand, will accept well-formed expressions of the semantic representation language and produce corresponding expressions in the source natural language.",
        "Among the arguments for adopting the bidirectional design in NLP the following are perhaps the most widely shared:",
        "• A bidirectional NLP system, or a system whose inverse can be derived by a fully automated process, greatly reduces effort required for the system development, since we need to write only one",
        "program or specification instead of two.",
        "The actual amount of savings ultimately depends upon the extend to which the NLP system is made bidirectional, for example, how much of the language analysis process can be inverted for generation.",
        "At present we reverse just a little more than a syntactic parser, but the method can be applied to more advanced analyzers as well.",
        "• Using a single specification (a grammar) underlying both the analysis and the synthesis processes leads to more accurate capturing of the language.",
        "Although no NLP grammar is ever complete, the grammars used in parsing tend to be \"too loose\", or unsound, in that they would frequently accept various ill-formed strings as legitimate sentences, while the grammars used for generation are usually made \"too tight\" as a result of limiting their output to the \"best\" surface forms.",
        "A reversible system for both parsing and generation requires a finely balanced grammar which is sound and as complete as possible.",
        "• A reversible grammar provides, by design, the match between system's analysis and generation capabilities, which is especially important in interactive systems.",
        "A discrepancy in this capacity may mislead the user, who tends to assume that what is generated as output is also acceptable as input, and vice-versa.",
        "• Finally, a bidirectional system can be expected to be more robust, easier to maintain and modify, and altogether more perspicuous.",
        "In the work reported here we concentrated on unification-based formalisms, in particular Definite Clause Grammars (Pereira & Warren, 1980), which can be compiled dually into PROLOG parser and generator, where the generator is obtained from the parser's code with the inversion procedure described below.",
        "As noted by Dymetman and Isabelle (1988), this transformation must involve rearranging the order of literals on the right-hand side of some clauses.",
        "We noted that the design of the string grammar (Sager, 1981) makes it more suitable as a basis of a reversible system than other grammar designs, although other grammars can be \"normalized\" (Strzalkowski, 1989).",
        "We also would like to point out that our main emphasis is on the problem of",
        "reversibility rather than generation, the latter involving many problems that we don't deal with here (see, e.g. Derr & McKeown, 1984; McKeown, 1985)."
      ]
    },
    {
      "heading": "RELATED WORK",
      "text": [
        "The idea that a generator for a language might be considered as an inverse of the parser for the same language has been around for some time, but it was only recently that more serious attention started to be paid to the problem.",
        "We look here only very briefly at some most recent work in unification-based grammars.",
        "Dymetman and Isabelle (1988) address the problem of inverting a definite clause parser into a generator in context of a machine translation system and describe a top-down interpreter with dynamic selection of AND goals' (and therefore more flexible than, say, left-to-right interpreter) that can execute a given DCG grammar in either direction depending only upon the binding status of arguments in the top-level literal.",
        "This approach, although conceptually quite general, proves far too expensive in practice.",
        "The main source of overhead comes, it is pointed out, from employing the trick known as goal freezing (Colmerauer, 1982; Naish, 1986), that stops expansion of currently active AND goals until certain variables get instantiated.",
        "The cost, however, is not the only reason why the goal freezing techniques, and their variations, are not satisfactory.",
        "As Shieber et al.",
        "(1989) point out, the inherently top-down character of goal freezing interpreters may occasionally cause serious troubles during execution of certain types of recursive goals.",
        "They propose to replace the dynamic ordering of AND goals by a mixed top-down/bottom-up interpretation.",
        "In this technique, certain goals, namely those whose expansion is defined by the so-called \"chain rules\"2, are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached.",
        "In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying the chain rules in a backward manner.",
        "This technique, still substantially more expensive than a fixed-order top-down interpreter, does not by itself guarantee that we can use the underlying grammar formalism bidirectionally.",
        "The reason is that in order to achieve bidirectionality, we need either to impose a proper static ordering of the \"non-chain\" AND 1 Literals on the right-hand side of a clause create AND goals; literals with the same predicate names on the left-hand sides of different clauses create OR goals.",
        "a A chain rule is one where the main binding-carrying argument is passed unchanged from the left-hand side to the right.",
        "For example, assert (P) --> aubj (P1) , verb (P2) , obi (P1 P ) is a chain rule with respect to the amument P. goals (i.e., those which are not responsible for making a rule a \"chain rule\"), or resort to dynamic ordering of such goals, putting the goal freezing back into the picture.",
        "In contrast with the above, the parser inversion procedure described in this paper does not require a runtime overhead and can be performed by an off-line compilation process.",
        "It may, however, require that the grammar is normalized prior to its inversion.",
        "We briefly discuss the grammar normalization problem at the end of this paper."
      ]
    },
    {
      "heading": "IN AND OUT ARGUMENTS",
      "text": [
        "Arguments in a PROLOG literal can be marked as either \"in\" or \"out\" depending on whether they are bound at the time the literal is submitted for execution or after the computation is completed.",
        "For example, in tovo ( [to, eat, fish] , T4, InPrEnyjohn]],P3) the first and the third arguments are \"in\", while the remaining two are \"out\".",
        "When tovo is used for generation, i.e.,",
        "then the last argument is \"in\", while the first and the third are \"out\"; T4 is neither \"in\" nor \"out\".",
        "The information about \"in\" and \"out\" status of arguments is important in determining the \"direction\" in which predicates containing them can be runs.",
        "Below we present a simple method for computing \"in\" and \"out\" arguments in PROLOG fiterals.4 An argument X of literal pred(• • • X • • - ) on the rhs of a clause is \"in\" if (A) it is a constant; or (B) it is a function and all its arguments are \"in\"; or (C) it is \"in\" or \"out\" in some previous literal on the rhs of the same clause, i.e., /(Y) r (X,Y),pred (X); or (D) it is \"in\" in the head literal L on ills of the same clause.",
        "An argument X is \"in\" in the head literal L = pred ( - • • X • • ) of a clause if (A), or (B), or (E) L is the top-level literal and X is \"in\" in it (known a priori); or (F) X occurs more than once in L and at",
        "least one of these occurrences is \"in\"; or (G) for every literal Li= pred ( • • • Y • • • ) unifiable with L on the rhs of any clause with the head predicate predi different than pred, and such that Y unifies with X, Y is \"in\" in Li.",
        "A similar algorithm can be proposed for computing \"out\" arguments.",
        "We introduce \"unknwn\" as a third status marker for arguments occurring in certain recursive clauses.",
        "An argument X of literal pred ( • • • X • • • ) on the rhs of a clause is \"out\" if (A) it is \"in\" in pred( • • • X • • ); or (B) it is a functional expression and all its arguments are either \"in\" or \"out\"; or (C) for every clause with the head literal pred( • • • Y • • • ) unifiable with pred( • • • X • • • ) and such that Y unifies with X, Y is either \"in\", \"out\" or \"unknwn\", and I is marked \"in\" or \"out\" in at least one case.",
        "An argument X of literal pred( • • • X - - • ) on the lhs of a clause is \"out\" if (D) it is \"in\" in pred( • • • X • • • ); or (E) it is \"out\" in literal pred 1( • • • X • • • ) on the rhs of this clause, providing that predi* pred;5 if predi= pred then X is marked \"unknwn\".",
        "Note that this method predicts the \"in\" and \"out\" status of arguments in a literal only if the evaluation of this literal ends successfully.",
        "In case it does not (a failure or a loop) the \"in\"/\"out\" status of arguments becomes irrelevant."
      ]
    },
    {
      "heading": "COMPUTING ESSENTIAL ARGUMENTS",
      "text": [
        "Some arguments of every literal are essential in the sense that the literal cannot be executed successfully unless all of them are bound, at least partially, at the time of execution.",
        "For example, the predicate tovo(T1,T4,P1,P3) that recognizes \"to+verb+object\" object strings can be executed only if either Ti or P3 is bound.6 7 If tovo is used to parse then Ti.",
        "must be bound; if it is used to generate then P3 must be bound.",
        "In general, a literal may have several alternative (possibly overlapping) sets of essential arguments.",
        "If all arguments in any one of such sets of essential arguments are bound,",
        "An argument is considered fully bound is it is a constant or it is bound by a constant; an argument is partially bound if it is, or is bound by, a functional expression (not a variable) in which at least one variable is unbound.",
        "then the literal can be executed.",
        "Any set of essential arguments which has the above property is called essential.",
        "We shall call a set MSEA of essential arguments a minimal set of essential arguments if it is essential, and no proper subset of MSEA is essential.",
        "A collection of minimal sets of essential arguments (MSEA's) of a predicate depends upon the way this predicate is defined.",
        "If we alter the ordering of the rhs literals in the definition of a predicate, we may also change its set of MSEA's.",
        "We call the set of MSEA's existing for a current definition of a predicate the set of active MSEA's for this predicate.",
        "To run a predicate in a certain direction requires that a specific MSEA is among the currently active MSEA's for this predicate, and if this is not already the case, then we have to alter the definition of this predicate so as to make this MSEA become active.",
        "Consider the following abstract clause defining predicate Ri:",
        "Suppose that, as defined by (D1), Ri has the set MS; = (m • • of active MSEA's, and let MRi MSi be the set of all MSEA for Ri that can be obtained by permuting the order of literals on the right-hand side of (D1).",
        "Let us assume further that Ri occurs on rhs of some other clause, as shown below:",
        "We want to compute MS, the set of active MSEA's for P, as defined by (C1), where s 0, assuming that we know the sets of active MSEA for each R• on the rhs.s If s=0, that is P has no rhs in its definition, then if P (X 1, • • - ,X„) is a call to P on the rhs of some clause and X* is a subset of (X1, • • • ,X,,) then X* is a MSEA in P if X* is the smallest set such that all arguments in X* consistently unify (at the same time) with the corresponding arguments in at most 1 occurrence of P on the lhs anywhere in the program.9 MSEA's of basic predicates, such as contest, are assumed to he known a priori; MSEA's for recursive predicates are first computed from non-recursive clauses.",
        "9 The at most 1 requirement is the strictest possible, and it can be relaxed to at most a in specific applications.",
        "The choice of n may depend upon the nature of the input language being processed (it may be n-degree ambiguous), and/or the cost of backing up from unsuccessful calls.",
        "For example, consider the words every and all: both can he translated into a single universal quantifier, but upon generation we face ambiguity.",
        "If the representation from When s 1, that is, P has at least one literal on the rhs, we use the recursive procedure MSEAS to compute the set of MSEA's for P. providing that we already know the set of MSEA's for each literal occurring on the rhs.",
        "Let T be a set of terms, that is, variables and functional expressions, then VAR (7') is the set of all variables occurring in the terms of T. Thus VAR(Lf (X), Y ,g (c,f (Z),X)D = [X,Y,Z).",
        "We assume that symbols X; in definitions (C1) and (D1) above represent terms, not just variables.",
        "The following algorithm is suggested for computing sets of active MSEA's in P where i",
        "(1) Start with VP = VAR ((X 1, - • • ,X,,)), MSEA = 0, i=1, and OUT = 0.",
        "When the computation is completed.",
        "MS is bound to the set of active MSEA's for P. (2) Let MR I be the set of active MSEA's of R 1, and let MRU I be obtained from MR1 by replacing all variables in each member of MR1 by their corresponding actual arguments of R1 on the rhs of (C1).",
        "(3) If RIP then for every In i,k E MRU1 if every argument Y, e i.k is always unifiabk with its corresponding argument X, in P then remove m Lk from MRU 1.",
        "For every set m - = M 1,k L--)",
        "(X , where K1,1 is an argument in R1 such that it is not already in m and it is not always unthabk with its corresponding argument in P, and m 1.k1 is not a superset of any other in Li remaining in MRU 1, add m Lki to MRU1.1°",
        "(4) For each m e MRE (1=1 • • • r1) compute",
        "which we generate is devoid of any constraints on the lexical number of surface words, we may have to tolerate multiple choices, at some point.",
        "Any decision made at this level as to which arguments are to be essential, may affect the reversibility of the grammar.",
        "An argument Y is ahvayv unifiable with an argument X if they unify regardless of the possible bindings of any variables occurring in Y (variables standardized apart), while the variables °c-cursing in X are unbound.",
        "Thus, any term is always unifiable with a variable; however, a variable is not always unifiable with a non-variable.",
        "For example, variable Xis not always unifiable with f (Y) because if we substitute g (Z) for X then the so obtained terms do not unify.",
        "The purpose of including steps (3) and (7) is to eliminate from consideration certain 'obviously' 01-formed recursive clauses.",
        "A more elaborate version of this condition is needed to take care of less obvious cases.",
        "(5) For each ILL/ e MP1 we do the following: (a) assume that is \"in\" in R1; (b) compute set OUTid of \"out\" arguments for R1', (c) call MSEAS (MS i,j,111, J,VP , 2,0UT 1,1); (d) assign MS := u MS J.",
        "(6) In some i-th step, where 1<is, and MSEA =",
        "let's suppose that MR, and MRU are the sets of active MSEA's and their instantiations with actual arguments of Ri, for the literal R on the rim of (C1).",
        "(7) If R, = P then for every rn,, E MRU if every argument Y, E is always unifiable with its corresponding argument X, in P then remove Mi.",
        "', from MRU,.",
        "For every set mi,„i = mi,„ u (Xij) where X1,1 is an argument in R, such that it is not already in mi.. and it is not always unifiable with its corresponding argument in P and is not a superset of any other mo remaining in MRU,, add nt,,„i to MRU 1.",
        "(8) Again, we compute the set MP; = j I j=1 • • • r,), where tt,,i = (VAR (m,J) – OUT,_1,k), where OUT,_i.k is the set of all \"out\" arguments in literals R1 to R1_1.",
        "(9) For each laid remaining in MP, where i5s do the following: (a) if tti = 0 then: (i) compute the set OUTi of \"out\" arguments of Ri; (ii) compute the union OUT := OUTi U OUT,; (iii) call MSEAS VP ,i +1 ,OUT,,i); (b) otherwise, if tki 0 then find all distinct minimal size sets v, ç VP such that whenever the arguments in v, are \"in\", then the arguments in tt, j are \"out\".",
        "If such vs's exist, then for every v, do: (i) assume v, is \"in\" in P; (ii) compute the set OUT, of \"out\" arguments in all literals from R1 to R•; (iii) call MSEAS (c) otherwise, if no such v, exist, MS,,i := 0.",
        "(10) Compute MS :=",
        "The procedure presented here can be modified to compute the set of all MSEA's for P by considering all feasible orderings of literals on the rhs of (C1) and using information about all MSEA's for R s. This modified procedure would regard the rhs of (Cl) as an unordered set of literals, and use various heuristics to consider only selected orderings."
      ]
    },
    {
      "heading": "REORDERING LITERALS IN CLAUSES",
      "text": [
        "When attempting to expand a literal on the rhs of any clause the following basic rule should be",
        "observed: never expand a literal before at least one its active MSEA's is \"in\", which means that all arguments in at least one MSEA are bound.",
        "The following algorithm uses this simple principle to reorder rhs of parser clauses for reversed use in generation.",
        "This algorithm uses the information about \"in\" and \"out\" arguments for literals and sets of MSEA's for predicates.",
        "If the \"in\" MSEA of a literal is not active then the rhs's of every definition of this predicate is recursively reordered so that the selected MSEA becomes active.",
        "We proceed top-down altering definitions of predicates of the literals to make their MSEA's active as necessary.",
        "When reversing a parser, we start with the top level predicate pars_gen (S, P) assuming that variable P is bound to the regularized parse structure of a sentence.",
        "We explicitly identify and mark P as \"in\" and add the requirement that S must be marked \"out\" upon completion of rhs reordering.",
        "We proceed to adjust the definition of pars_gen to reflect that now P) is an active MSEA.",
        "We continue until we reach the level of atomic or non-reversible primitives such as concat, member, or dictionary lookup routines.",
        "If this top-down process succeeds at reversing predicate definitions at each level down to the primitives, and the primitives need no redefinition, then the process is successful, and the reversed-parser generator is obtained.",
        "The algorithm can be extended in many ways, including inter-clausal reordering of literals, which may be required in some situations (Strzalkowski, 1989).",
        "INVERSE(\"head old-rhs\",ins,outs); ins and outs are subsets of VAR(head) which are \"in\" and are required to be \"out\", respectively) begin compute M the set of all MSEA's for head; for every MSEA m e M do begin OUT := 0; if m is an active MSEA such that mcins then begin compute \"out\" arguments in head; add them to OUT; if outscOUT then DONE(\"head:-old-rhs\") end else if m is a non-active MSEA and mcins then begin",
        "for every literal L do ML (done only once during the inversion) repeat mark \"in\" old-rhs-1 arguments which are either constants, or marked \"in\" in head, or marked \"in\", or \"out\" in new-rhs; select a literal L in old-rhs-1 which has an \"in\" MSEA mL and if mL is not active in L then either M = 0 or m E ML; set up a backtracking point containing all the remaining alternatives to select L from old-rhs-1; if L exists then begin if m is non-active in L then begin if ML = 0 then ML := ML L.) (mL); for every clause \"Ll rhsu\" such that LI has the same predicate as L do begin INVERSE('L1 rhsu\",ML,0); if GIVEUP returned then backup, undoing all changes, to the latest backtracking point and select another alternative end end; compute \"in\" and \"out\" arguments in L; add \"out\" arguments to OUT;",
        "backup, undoing all changes, to the latest backtracking point and select another alternative; if no such backtracking point exists then"
      ]
    },
    {
      "heading": "THE IMPLEMENTATION",
      "text": [
        "We have implemented an interpreter, which translates Definite Clause Grammar dually into a parser and a generator.",
        "The interpreter first transforms a DCG grammar into equivalent PROLOG code, which is subsequently inverted into a generator.",
        "For each predicate we compute the minimal sets of essential arguments that would need to be active if the program were used in the generation mode.",
        "Next, we rearrange the order of the right hand side literals for each clause in such a way that the set of essential arguments in each literal is guaranteed to be bound whenever the literal is chosen for expansion.",
        "To implement the algorithm efficiently, we compute the 2 16 minimal sets of essential arguments and reorder the literals in the right-hand sides of clauses in one pass through the parser program.",
        "As an example, we consider the following rule in our DCG grammar:\"",
        "When translated into PROLOG, it yields the following clause in the parser: assertion (S,L1, L2) : - sa (Si, 1.1, L3) subject (Sb, L3, L4) , sa (S2, L4,L5) , verb (V, L5, L6) , Sb:np:number V:number, sa (S3, L6,L7) , object (0, V, Vp, Sb, Sp, L7 , LS) Eta (S4,L8,L2) , S:verb:head Vp:head,"
      ]
    },
    {
      "heading": "S:verb:number V:number, S:tense W:tense,0:tensel, S:subject :: Sp, S:object :: 0:core, S:sa",
      "text": [
        "[S1:sa,S2:sa,S3:sa,0:sa,S4:sa] The parser program is now inverted using the algorithms described in previous sections.",
        "As a result, the assertion clause above is inverted into a generator clause by rearranging the order of the literals on its right-hand side.",
        "The literals are examined from the left to right: if a set of essential arguments is bound, the literal is put into the output queue, otherwise the n The grammar design is based upon string grammar (Sager, 1981).",
        "Nonterrninal sa stands for a string of sentence adjuncts, such as prepositional or adverbial phrases; : : is a PRoLoh-defined predicate.",
        "We show only one rule of the grammar due to the lack of space.",
        "literal is put into the waiting stack.",
        "In the example at hand, the literal sa (S1 Ll , L3) is examined first.",
        "Its MSEA is (Si.",
        "), and since it is not a subset of the set of variables appearing in the head literal, this set cannot receive a binding when the execution of assertion starts.",
        "It may, however, contain \"out\" arguments in some other literals on the right-hand side of the clause.",
        "We thus remove the first sa literal from the clause and place it on hold until its MSEA becomes fully instantiated.",
        "We proceed to consider the remaining literals in the clause in the same manner, until we reach S : verb : head : : Vp: head.",
        "One MSEA for this literal is (S ), which is a subset of the arguments in the head literal.",
        "We also determine that S is not an \"out\" argument in any other literal in the clause, and thus it must be bound in assertion whenever the clause is to be executed.",
        "This means, in turn, that S is an essential argument in assertion.",
        "As we continue this process we find that no further essential arguments are required, that is, (s) is a MSEA for assertion.",
        "The literal s :verb : head : Vp: head is output and becomes the top element on the right-hand side of the inverted clause.",
        "After all literals in the original clause are processed, we repeat this analysis for all those remaining in the waiting stack until all the literals are output.",
        "We add prefix g to each inverted predicate in the generator to distinguish them from their non-inverted versions in the parser.",
        "The inverted assertion predicate as it appears in the generator is shown below.",
        "A single grammar is thus used both for sentence parsing and for generation.",
        "The parser or the generator is invoked using the same top-level predicate pars_gen (3,P) depending upon the binding status of its arguments: if S is bound then the parser is invoked, if P is bound the generator is called.",
        "[verbItake].",
        "[subject, [np,[headljanel.",
        "[numberlsingular], [classInstudent], [tpos], [aposl.",
        "[modifier, null] ] , [object, [np, [head!",
        "course] 1 [number I singular] , [class I ncourse] , [tpos I a] , (apes), [modifier, null] ] I, [sa, [1, [] , [1 • C], Inn ."
      ]
    },
    {
      "heading": "S = [jane,takes,a,course] yes GRAMMAR NORMALIZATION",
      "text": [
        "Thus far we have tacitly assumed that the grammar upon which our parser is based is written in such a way that it can be executed by a top-down interpreter, such as the one used by PROLOG.",
        "If this is not the case, that is, if the grammar requires a different kind of interpreter, then the question of invertibility can only be related to this particular type of interpreter.",
        "If we want to use the inversion algorithm described here to invert a parser written for an interpreter different than top-down and left-to-right, we need to convert the parser, or the grammar on which it is based, into a version which can be evaluated in a top-down fashion.",
        "One situation where such normalization may be required involves certain types of non-standard recursive goals, as depicted schematically below.",
        "If vp is invoked by a top-down, left-to-right interpreter, with the variable P instantiated, and if P3.",
        "is the essential argument in comp]., then there is no way we can successfully execute the first clause, even if we alter the ordering of the literals on its right-hand side, unless, that is, we employ the goal skipping technique discussed by Shieber et al.",
        "However, we can easily normalize this code by replacing the first two clauses with functionally equivalent ones that get the recursion firmly under control, and that can be evaluated in a top-down fashion.",
        "We assume that P is the essential argument in v (A, P) and that A is \"out\".",
        "The normalized grammar is given below.",
        "vp(A,P) 7 v(B,P),vpl(B,A).",
        "vpl(f(S,P1),A) -] vp1(13,A),compl(P1).",
        "vpl(A,A).",
        "v(A,P) -] lex.",
        "In this new code the recursive second clause will be used so long as its first argument has a form frot.13), where a and fi are fully instantiated terms, and it will stop otherwise (either succeed or fail depending upon initial binding to A).",
        "In general, the fact that a recursive clause is unfit for a top-down execution can be established by computing the collection of minimal sets of essential arguments for its head predicate.",
        "If this collection turns out to be empty, the predicate's definition need to he normalized.",
        "Other types of normalization include elimination of some of the chain rules in the grammar, especially if their presence induces undue non-determinism in the generator.",
        "We may also, if necessary, tighten the criteria for selecting the essential arguments, to further enhance the efficiency of the",
        "generator, providing, of course, that this move does not render the grammar non-reversible.",
        "For a further discussion of these and related problems the reader is referred to (Strzalkowski, 1989)."
      ]
    },
    {
      "heading": "CONCLUSIONS",
      "text": [
        "In this paper we presented an algorithm for automated inversion of a unification parser for natural language into an efficient unification generator.",
        "The inverted program of the generator is obtained by an off-line compilation process which directly manipulates the PROLOG code of the parser program.",
        "We distinguish two logical stages of this transformation: computing the minimal sets of essential arguments (MSEA's) for predicates, and generating the inverted program code with INVERSE.",
        "The method described here is contrasted with the approaches that seek to define a generalized but computationally expensive evaluation strategy for running a grammar in either direction without manipulating its rules (Shieber, 1988), (Shieber et al., 1989), (Wedekind, 1989), and see also (Naish, 1986) for some relevant techniques.",
        "We have completed a first implementation of the system and used it to derive both a parser and a generator from a single DCG grammar for English.",
        "We note that the present version of INVERSE can operate only upon the declarative specification of a logic grammar and is not prepared to deal with extra-logical control operators such as the cut."
      ]
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": [
        "Ralph Grishman and other members of the Natural Language Discussion Group provided valuable comments to earlier versions of this paper.",
        "We also thank anonymous reviewers for their suggestions.",
        "This paper is based upon work supported by the Defense Advanced Research Project Agency under Contract N00014-85-K-0163 from the Office of Naval Research."
      ]
    },
    {
      "heading": "REFERENCES",
      "text": []
    }
  ]
}
