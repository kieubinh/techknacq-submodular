{
  "info": {
    "authors": [
      "Yves Schabes",
      "K. Vijay-Shanker"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P90-1035",
    "title": "Deterministic Left to Right Parsing of Tree Adjoining Languages",
    "url": "https://aclweb.org/anthology/P90-1035",
    "year": 1990
  },
  "references": [
    "acl-J87-1004",
    "acl-P88-1032"
  ],
  "sections": [
    {
      "heading": "DETERMINISTIC LEFT TO RIGHT PARSING OF TREE ADJOINING LANGUAGES*",
      "text": []
    },
    {
      "heading": "Abstract",
      "text": [
        "We define a set of deterministic bottom-up left to right parsers which analyze a subset of Tree Adjoining Languages.",
        "The LR parsing strategy for Context Free Grammars is extended to Tree Adjoining Grammars (TAGs).",
        "We use a machine, called Bottom-up Embedded Push Down Automaton (BEPDA), that recognizes in a bottom-up fashion the set of Tree Adjoining Languages (and exactly this set).",
        "Each parser consists of a finite state control that drives the moves of a Bottom-up Embedded Pushdown Automaton.",
        "The parsers handle deterministically some context-sensitive Tree Adjoining Languages.",
        "In this paper, we informally describe the BEPDA then given a parsing table, we explain the LR parsing algorithm.",
        "We then show how to construct an LR(0) parsing table (no lookahead).",
        "An example of a context-sensitive language recognized deterministically is given.",
        "Then, we explain informally the construction of SLR(1) parsing tables for BEPDA.",
        "We conclude with a discussion of our parsing method and current work."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "LR(k) parsers for Context Free Grammars (Knuth, 1965) consist of a finite state control (constructed given a CFG) that drives deterministically with k lookahead symbols a push down stack, while scanning the input from left to right.",
        "It has been shown that they recognize exactly the set of languages recognized by deterministic push down automata.",
        "LR(k) parsers for CFGs have been proven useful for compilers as well as recently for natural language processing.",
        "For natural language processing, although LR(k) parsers are not powerful enough,",
        "The set of Tree Adjoining Languages is a strict superset of the set of Context Free Languages (CFLs).",
        "For example, the cross serial dependency construction in Dutch can be generated by a TAG.",
        "I Walters (1970), R6vesz (1971), Turnbull and Lee (1979) investigated deterministic parsing of the class of context-sensitive languages.",
        "However they used Turing machines which recognize languages much more powerful than Tree Adjoining Languages.",
        "So far no deterministic bottom-up parser has been proposed for any member of the class of the so-called \"mildly context sensitive\" formalisms (Joshi, 1985) in which Tree Adjoining Grammars fal1.2 Since the set of Tree Adjoining Languages (TALs) is a strict superset of the set of Context Free Languages, in order to define LR-type parsers for TAGs, we need to use a more powerful configuration then a finite state automaton driving a push down stack.",
        "We investigate the design of deterministic left to right bottom up parsers for TAGs in which a finite state control drives the moves of a Bottom-up Embedded Push Down Stack.",
        "The class of corresponding non-deterministic automata recognizes exactly the set of TALs.",
        "We focus our attention on showing how a bottom-up embedded pushdown automaton is deterministically driven given a parsing table.",
        "To illustrate the building of a parsing table, we consider the simplest case, i.e. building of LR(0) items and the corresponding LR(0)",
        "parsing table for a given TAG.",
        "An example for a TAG generating a context-sensitive language is given in Figure 5.",
        "Finally, we consider the construction of SLR(1) parsing tables.",
        "We assume that the reader is familiar with TAGs.",
        "We refer the reader to Joshi (1987) for an introduction to TAGs.",
        "We will assume that the trees can be combined by adjunction only."
      ]
    },
    {
      "heading": "2 Automata Models of Tags",
      "text": [
        "Before we discuss the Bottom-up Embedded Pushdown Automaton (BEPDA) which we use in our parser, we will introduce the Embedded Pushdown Automaton (EPDA).",
        "An EPDA is similar to a pushdown automaton (PDA) except that the storage of an EPDA is a sequence of pushdown stores.",
        "A move of an EPDA (see Figure 1) allows for the introduction of bounded pushdowns above and below the current top pushdown.",
        "Informally, this move can be thought of as corresponding to the adjoining operation move in TAGs with the pushdowns introduced above and below the current pushdown reflecting the tree structure to the left and right of the foot node of an auxiliary being adjoined.",
        "The spine (path from root to foot node) is left on the previous stack.",
        "The generalization of a FDA to an EPDA whose storage is a sequence of pushdowns captures the generalization of the nature of the derived trees of a CFG to the nature of derived trees of a TAG.",
        "From Thatcher (1971), we can observe that the path set of a CFG (i.e. the set of all paths ftom root to leaves in trees derived by a CFG) is a regular set.",
        "On the other hand, the path set of a TAG is a CR.",
        "This follows from the nature of the adjoining operation of TAGs, which suggests stacking along the path from root to a leaf.",
        "For example, as we traverse down a path in a tree 7 (in Figure 1), if adjunction, say by occurs then the spine of fi has to be traversed before we can resume the path in 7."
      ]
    },
    {
      "heading": "3 Bottom-up Embedded Pushdown Automaton3",
      "text": [
        "For any TAG G. an EPDA can be designed such that its moves correspond to a top-down parse of a string generated by G (EPDA characterizes exactly the set of Tree Adjoining Languages, Vijay- Shanker, 1987).",
        "If we wish to design a bottom-up parser, say by adopting a shift reduce parsing strategy, we have to consider the nature of a reduce move of such a parser (i.e. using EPDA storage).",
        "This reduce move, for example applied after completely considering an auxiliary tree, must be allowed to 'remove' some bounded pushdowns above and below some (not necessarily bounded) pushdown.",
        "Thus (see Figure 2), the reduce move is like the dual of the wrapping move performed by an EPDA.",
        "Therefore, we introduce Bottom-up Embedded Pushdown Automaton (BEPDA), whose moves are dual of an EPDA.",
        "The two moves of a BEPDA are the unwrap move depicted in Figure 2 – which is an inverse of the wrap move of an EPDA – and the introduction of new pushdowns on top of the previous pushdown (push move).",
        "In an EPDA, when the top pushdown is emptied, the next pushdown automatically becomes the new top pushdown.",
        "The inverse of this step is to allow for the introduction of new pushdowns above the previous top pushdown.",
        "These are the two moves allowed in a BEPDA, the various steps in our parsers are sequences of one or more such moves.",
        "Due to space constraints, we do not show the equivalence between BEPDA and EPDA apart from noting that the moves of the two machines are dual of each other."
      ]
    },
    {
      "heading": "4 LR Parsing Algorithm",
      "text": [
        "An LR parser consists of an input, an output, a sequence of stacks, a driver program, and a parsing table that has three parts (ACTION.",
        "GOTOright and GOTOf„t).",
        "The parsing program is the same for all LR parsers, only the parsing tables change from one grammar to another.",
        "The parsing program reads characters from the input one character at a time.",
        "The program uses the sequence of stacks to store states.",
        "The parsing table consists of three parts, a parsing action function ACTION and two gob o functions GOTOright and GOTOf „t.",
        "The program driving the LR.",
        "parser first determines the state i currently on top of the top stack and the current input token ar.",
        "Then it consults the ACTION table entry for state i and token 3 The need to use bottean-up version of an RDA in LR style parsing of TAGs was suggested to us by Bernard Lang and David Weir.",
        "Also their suggestions played an instrumanal role in the definition of BBPDA, for example restriction on the moves allowed.",
        "at..",
        "The entry in the action table can have one of the following five values:",
        "• Shift j (sj), where j is a state; • Resume Right of 6 at address dot (rs6(dot)), where 6 is an elementary Wee and dot is the address of a node in 6; • Reduce Root of the auxiliary tree p in which the last adjunction on the spine was performed at address star (rd/3(star); • Accept (arc); • Error, no action applies, the parsers rejects the input string (errors are associated with empty table entries).",
        "The function GOTOright and GOTO,,,üt take a state i and an auxiliary tree /3 and produce a state j.",
        "An example of a parsing table for a grammar generating L = {anbnecncin In 0} is given in Figure 5.",
        "We denote an instantaneous description of the BEFDA by a pair whose first component is the sequence of pushdowns and whose second component is the unexpanded input: (11tm • • •till • • - - • • sw, arar-Ei \" .anS) In the above sequence of pushdowns, the stacks are piled up from left to right.",
        "II stands for the bottom of a stack.",
        "sw is the top element of the top stack, s1 is the bottom element of the top stack, t1 is the top element of the bottom stack and tm is the bottom element of the bottom stack.",
        "The initial configuration of the parser is set to: (110, al • anS) where 0 is the start state and al • - - an$ is the input string to be read with an end marker ($).",
        "278 Suppose the parser reaches the configuration: (lltm • • 'till ' ' lliw • • ar (4.14 • • • anS) The next move of the parser is determined by reading a,., the current input token and the state i on top of the sequence of stacks, and then consulting the parsing table entry for ACTIONN, ad.",
        "The parser keeps applying the move associated with ACTIONk, ad until acceptance or war occurs.",
        "The following moves are possible: (i) ACTION[i, = shift state j (sj).",
        "The parser executes a push move, entering the configuration: (him • • till • Iliw ' ' •i1Ii,ar-Fi • an$) (ii) ACITON[i, = resume right of 6 at address dot (rs6Odot).",
        "The parser is coming to the right and below of the node at address dot in 6, say t, on which an auxiliary tree has been adjoined.",
        "The information identifying the auxiliary tree is in the sequence of stacks and must be recovered.",
        "There are two cases: Case 1: ri does not subsume a foot node.",
        "Let k be the number of terminal symbols subsumed by 77.",
        "Before applying this move, the current configuration looks like: ar an$) The k top first stacks are merged into one stack and the stack Ilm is pushed on top of it, where rn= GOTOloot[ik , for some auxiliary tree f3 that can be adjoined in 6 at 9, and the parser enters the configuration:",
        "Case 2: subsumes the foot node of 6.",
        "Let k (resp.",
        "V) be the number of terminal symbols to the right (resp.",
        "to the left) of the foot node subsumed by n. Before applying this move, the configuration looks like; (11' • • • • •Ilnillsr..- sillik - • • PIP, ar • • an$) the right of it.",
        "The four positions of the dot are anno-The k' stacks below the k + 2th stack from the top tated by la, lb, ra, rb (resp.",
        "left above, left below, right as well as the k +1 top stacks are rewritten onto the above, right below): In practice, only two dot k+2 stack and the stack Ilrn is pushed on top of it, positions can be used (to the left and to the right of where ra = GOTOf oot[nk,+i, i3] for some auxiliary a node).",
        "However, for sake of simplicity, we will use tree # that can be adjoined in 5 at rj, and the parser four different dot positions.",
        "A dotted tree is defined enters the configuration: as a tree with exactly one dotted symbol.",
        "Furthermore, (II .• • • sink.",
        ".. • n ik •i1ifrn, ar • • • a„53) some nodes in the dotted tree can be marked with a star.",
        "(iii) ACTIONp, = reduce root of an auxiliary tree A star on a node expresses the fact that an adjunction in which the last adjunction on the spine was per has been performed on the corresponding node.",
        "A dot-formed at address star (rdflastar).",
        "The parser hasted tree is referred as [a, dot, pos, stars], where a is a finished the recognition of the auxiliary tree #.",
        "It tree, dot is the address of the dot, pos is the position of must remove all information about f3 and continue the dot (la, lb, ra or rb) and stars is a list of nodes in the recognition of the tree in which [I was adjoined.",
        "a annotated by a star.",
        "The parser executes an unwrap move.",
        "Let k (resp.",
        "Given a dotted tree with the dot above and to the left k) be the number of terminal symbols to the left of the root, we define a tree traversal of a dotted tree (as (resp.",
        "to the right) of the foot node of f3.",
        "Let C be shown in the Figure 3) that will enable us to scan the the node at address star in ig (( = nil if star is not frontier of an elementary tree from left to right while try-set).",
        "Let p be the number of terminal symbols to ing to recognize possible adjunctions between the above the left of the foot node subsumed by C (p = 0 if and below positions of the dot of interior nodes.",
        "= nil).",
        "p + k' + 1 symbols from the top of the sequence of stacks popped.",
        "Then k p single element stacks below the new top stack are unwrapped.",
        "Let j be the new top element of the top stack.",
        "Let m = GOTOright[j,[3].",
        "j is popped and the single element stack urn is pushed on top of the top stack.",
        "By keeping track of the auxiliary trees being reduced, it is possible to output a parse instead of acceptance or an error.",
        "The parser recognizes the derived tree inside out: it extracts recursively the innermost auxiliary tree that has no adjunction performed in it.",
        "5 LR(0) Parsing Tables This section explain how to construct an Lizq parsing table given a TAG.",
        "The construction is an extension of the one used for CFGs.",
        "Similarly to Schabes and Joshi (1988), we extend the notion of dotted rules to trees.",
        "We define the closure operations that correspond to adjunction.",
        "Then we explain how transitions between states are defined.",
        "We give in Figure 5 an example of a finite state automaton used to build the parsing table for a TAG (see Figure 5) generating a context-sensitive language.",
        "We first explain preliminary concepts (originally defined to construct an Earley-type parser for TAGs) that will be used by the algorithm.",
        "Dotted rules are extended to trees.",
        "Then we recall a tree traversal that the algorithm will mimic in order to scan the input from left to right.",
        "A dotted symbol is defined as a symbol associated with a dot above or below and either to the left or to",
        "build as follows.",
        "In states set 0, we put all initial trees with a dot to the left and above the root.",
        "The state is then closed.",
        "Then recursively we build new states with the following transitions (we refer to Figure 5 for an example of such a construction).",
        "• A transition on a (where a is a terminal symbol) from Si to Si occurs if and only if in Si there is a dotted tree [6, dot, la, stars] in which the dot is to the left and above a terminal symbol a; Si consists of the closure of the set of dotted trees of the form [6, dot, ra, stars].",
        "• A transition on #right from Si to Si occurs if in Si there is a dotted tree [6, dot, rb, stars] such that the dot is to the right and below a node on which ,8 can be adjoined; Si consists of the closure of the set of dotted trees of the form [6, dot, ra, stars'].",
        "If the dotted node of [6, dot, rb, stars] is not on the spine of 6, star' consists of all the nodes in star that strictly dominate the dotted node.",
        "When the dotted node is on the spine, stars' consists of all the nodes in star that strictly dominate the dotted node, if there are some, otherwise stars' = {do* • A Skip foot of [3, dot, lb, stars] transition from Si to Si occurs if in Si there is a dotted tree [19, dot, lb, stars] such that the dot is to the left and below the foot node of the auxiliary tree 0; Si consists of the closure of the set of dotted trees of the form [13, dot, rb, stars].",
        "The parsing table is constructed from the FSA built as above.",
        "In the following, we write trans(i, r) for set of states in the FSA reached from state i on the transition labeled by x.",
        "The actions for ACTION(i, a) are:",
        "• Shift j (sc(j)).",
        "It applies iff j E trans(i, a).",
        "511odes on the path from root node to foot node.",
        "280 • Resume Right of [6, dot, rb, stars] (rsO©dot).",
        "It applies iff in state i there is a dotted tree [6, dot, rb, stars], where dot E stars.",
        "• Reduce Root of # (rd0@s2ar).",
        "It applies if in state i there is a dotted tire [13, 0, ra, {star}], where 13 is an auxiliary tree.s • Accept occurs iff a is the end marker (a = $) and there is a dotted tree [a, 0, ra, {star}], where a is an initial tree and the dot is to the right and above the root node.",
        "• Error, if none of the above applies.",
        "The GOTO table encodes the transitions in the FSA on non-terminal symbols.",
        "It is indexed by a state and by ,eright or Ploot, for all auxiliary trees #: j E GOTO(i, label) if there is a transition from i to j on the given label (label E emrioreght'thanfif\"otifl neiascantionauxis tree If entry of the action table, the grammar is not LR(0): there is a conflict of action, the grammar cannot be parsed deterministically without lookahead.",
        "An example of a finite state automaton used for the construction of the LR(0) table for a TAO (trees al, /31 in Figure 5) generating7 L Ian b' e cn d\" In 01, its corresponding parsing table is given and an example of sequences of moves are given in Figure 5.",
        "60 is the address of the root node.",
        "7 In the given TAG (trees al and 131), if we omit and c, we obtain a TAG that is similar to the one for the Dutch cross-serial construction.",
        "This grammar can still be handled by an 1-R(0) parser.",
        "In the trees a and (3, no stand for null adjunction constraint (i.e. no auxiliary tree can be adjoined on a node with null adjunction constraint)."
      ]
    },
    {
      "heading": "6 SLR(1) Parsing Tables",
      "text": [
        "The tables that we have constructed are LR(0) tables.",
        "The Resume Right and Reduce Root moves are performed regardless of the next input token.",
        "The accuracy of the parsing table can be improved by computing lookaheads.",
        "FIRST and FOLLOW can be extended to dotted trees.8 FIRST of a dotted tree corresponds to the set of left most symbols appearing below the subtree dominated by the dotted node.",
        "FOLLOW of a dotted tree defines the set of tokens that can appear in a derivation immediately following the dotted node.",
        "Once FIRST and FOLLOW computed, the LR(0) parsing table can be improved to an SLR(1) table: Resume Right and Reduce Root are applicable only on the input tokens in the follow set of the dotted tree.",
        "For example, the SLR(1) table for the TAG built with trees al and 01 is given in Figure 6.",
        "By associating dotted trees with lookaheads, one can also compute LR(k) items in the finite state automaton in order to build LR(k) parsing tables."
      ]
    },
    {
      "heading": "7 Current Research",
      "text": [
        "The deterministic parsers we have developed do not satisfy an important property satisfied by LR parsers for CFG.",
        "This property is often described as the viable prefix property which states that as long as the portion of the input considered so far leads to some stack configuration (Le.",
        "does not lead to error), it is always possible to find a suffix to obtain a string in the language.",
        "Our parsers do not satisfy this property because the left completion move is not a 'reduce' move.",
        "This move 8Due to the lack of space, we do not define FIRST and FOLLOW.",
        "However, we explain the basic principles used for the computation of FIRST and FOLLOW.",
        "282 applies when we have reached a bottom-left end (to the left of the foot node) of an auxiliary uee, say 8.",
        "If we had considered this move to be a reduce move, then by popping appropriate amount of elements off the storage would allow us to figure out which tree (into which fi was adjoined), say a, to proceed with.",
        "Rather than using this information (that is available in the storage of the BEPDA), by putting left completion in the closure operations, we apply a move that is akin to the predict move of Earley parser.",
        "That is we continue by considering every possible nodes 3 could have been adjoined at, which could include nodes in trees that were not used so far.",
        "However, we do not accept incorrect strings, we only lose the prefix property (for an example see Figure 7).",
        "As a consequence, errors are always detected but not as soon as possible.",
        "The reason why we did not consider the left completion move to be a reduce move is related to the restrictions on moves of BEPDA which is weakly equivalent to TAGs (perhaps also due to the fact that left to right parsing may not be most natural for parsing TAGs which produce trees with context-free path sets).",
        "In CFOs, where there is only horizontal stacking, a single reduction step is used to account for the application of rule in left to tight parsing.",
        "On the other hand, with TAGs, if a tree is used successfully, it appears that a prediction move and more than one reduction move are necessary for auxiliary Wee.",
        "In left to right parsing, a prediction is made to start an auxiliary tree fiat top left end; a reduction is appropriate to recover the node 13 was adjoined at the left completion stage; a reduction is needed again at resume right state to resume the right end of /3; finally a reduction is needed at the right completion stage.",
        "In our algorithm, reductions are used at right resume stage and reduce right state.",
        "Even if a reduction step is applied at left completion stage, an encoding of the fact that left part of 13 (as well as the left part of trees adjoined on the spine of #) has been completed has to be restored in the storage (note in a reduction move of any shift reduce parser for CFGs, any information about the rule used is discarded once reduction step applied).",
        "So far we have not been able to apply a reduction step at the left completion stage, reinsert the left part of ft and yet maintain the correct sequence in the storage so that the right part of /3 can be recovered at the resume right stage.",
        "We are considering alternative strategies for shift reduce parsing with BEPDA as well as considering whether there are other automata models equivalent to TAGs better suited for deterministic left to right parsing of tree-adjoining languages."
      ]
    },
    {
      "heading": "Conclusion",
      "text": [
        "We have introduced a bottom-up machine (Bottom-up Embedded Push Down Automaton) that enabled us to define LR-like parsers for TAGs.",
        "The machine recognizes in a bottom-up fashion exactly the set of Tree Adjoining Languages.",
        "We described the LR parsing algorithm and a method for computing LR(0) parsing tables.",
        "We also mentioned the possibility of building SLR(k) parsing tables by defining the notions of FIRST and FOLLOW sets for TAGs.",
        "As shown for the example, no lookaheads are necessary to parse deterministically the language L = {ann ecn da In > 0}.",
        "If instead of using e, we had the empty string c in the initial tree, LR(0)-like parser will not be enough.",
        "On the other hand SLR(1)-like parser will suffice.",
        "We have noted that our parsers do not satisfy the valid prefix property.",
        "As a consequence, errors are always detected but not as soon as possible.",
        "Similar to the work of Lang (1974) and Tomita (1987) extending I.R parsers for arbitrary CFOs, the LR parsers for TAGs can be extended to solve by pseudo-parallelism the conflicts of moves."
      ]
    }
  ]
}
