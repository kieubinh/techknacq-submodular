{
  "info": {
    "authors": [
      "Massimo Marino"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P90-1038",
    "title": "Bottom-Up Parsing Extending Context-Freeness in a Process Grammar Processor",
    "url": "https://aclweb.org/anthology/P90-1038",
    "year": 1990
  },
  "references": [
    "acl-C88-1080",
    "acl-E87-1037",
    "acl-J79-1047",
    "acl-P81-1001"
  ],
  "sections": [
    {
      "heading": "BOTTOM-UP PARSING EXTENDING CONTEXT-FREENESS IN A PROCESS GRAMMAR PROCESSOR",
      "text": []
    },
    {
      "heading": "ABSTRACT",
      "text": [
        "A new approach to bottom-up parsing that extends Augmented Context-Free Grammar to a Process Grammar is formally presented.",
        "A Process Grammar (PG) defines a set of rules suited for bottom-up parsing and conceived as processes that are applied by a PG Processor.",
        "The matching phase is a crucial step for process application, and a parsing structure for efficient matching is also presented.",
        "The PG Processor is composed of a process scheduler that allows immediate constituent analysis of structures, and behaves in a non-deterministic fashion.",
        "On the other side, the PG offers means for implementing spec/lc parsing strategies improving the lack of determinism innate in the processor."
      ]
    },
    {
      "heading": "I. INTRODUCTION",
      "text": [
        "Bottom-up parsing methods are usually preferred because of their property of being driven from both the input's syntactic/semantic structures and reduced constituents structures.",
        "Different strategies have been realized for handling the structures construction, e.g., parallel parsers, backtracking parsers, augmented context-free parsers (Aho et al., 1972; Grishman, 1976; Winograd, 1983).",
        "The aim of this paper is to introduce a new approach to bottom-up parsing starting from a well known and based framework - parallel bottom-up parsing in immediate constituent analysis, where all possible parses are considered - making use of an Augmented Phrase-Structure Grammar (APSG).",
        "In such environment we must perform efficient searches in the graph the parser builds, and limit as much as possible the building of structures that will not be in the final parse tree.",
        "For the efficiency of the search we introduce a Parse Graph Structure, based on the definition of adjacency of the subtre-es, that provides an easy method of evaluation for deciding at any step whether a matching process can be accomplished or not.",
        "The control of the parsing process is in the hands of an APSG called Process Grammar (PG), where grammar rules are conceived as processes that are applied whenever proper conditions, detected by a process scheduler, exist.",
        "This is why the parser, called PG Processor, works following a non-deterministic parallel strategy, and only the Process Grammar has the power of altering and constraining this behaviour by means of some Kernel Functions that can modify the control structures of the PG Processor, thus improving determinism of the parsing process, or avoiding construction of useless mixtures.",
        "Some of the concepts introduced in this paper, such as some definitions in Section 2., are a development from Grishman (1976) that can be also an introductory reading regarding the description of a parallel bottom-up parser which is, even if under a different aspect, the core of the PG Processor."
      ]
    },
    {
      "heading": "2. PARSE GRAPH STRUCTURE",
      "text": [
        "The Parse Graph Structure (PGS) is built by the parser while applying grammar rules.",
        "Ifs = a, c ; is an input string the initial PGS is composed by a set of terminal nodes <0,5>, <2,a2>,..., <n+1,$>, where nodes 0,n +1 represent border markers for the sentence.",
        "All the next non-terminal nodes are numbered starting from n+2.",
        "Definition 2.1.",
        "A PGS is a triple (NT,NN,T) where NT is the set of the terminal nodes numbers [0, 1, n, n+1 ) ; NH is the set of the non-terminal nodes numbers n+2,... ), and T is the set of the subtrees.",
        "The elements of N, and NT are numbers identifying nodes of the PGS whose structure is defined below, and throughout the paper we refer to nodes of the PGS by means of such nodes number.",
        "Definition 2.2.",
        "If kE /%1,,, the node iE NT labeling a, at the beginning of the clause covered by k is said to be the left corner leaf of k lcI(k).",
        "If ke NT then 1c1(k)=k.",
        "Definition 23.",
        "If he IsIN the node jE NT labeling a, at the end of the clause covered by k is said to be the right corner leaf of k rcl(k).",
        "If ke NT then rcl(k) = k. Definition 2.4.",
        "If ke N, the node he NT that follows the right corner leaf of k rcl(k) is said to be the anchor leaf of k al(k), and al(k) = h = rcl(k)+1.",
        "If ke ( n+1) then al(k) = k+1.",
        "Definition 2.5.",
        "If ke NT the set of the anchored nodes of k an(k) is m(c) = (je N.TuNN I al(j) = k).",
        "From this definition it follows that for every ke NT (0) , an(k) contains at the initial time the node number (k-1).",
        "Definition 2.6. a.",
        "If ke NT the subtree rooted in k T(k) is represented by TOO = <1,1c1(1c),rcl(k),an(k),cat(k)>, where his the root node; Icl(k) = rcI(k)= k; an(k) = ( (k -1)) initially; cat(k) = c, the terminal category of the node.",
        "b.",
        "If he N,4 the subtree rooted in k T(k) is represented by T(k)=<k,IcI(k),Pc1(k),sols(c),cat(k)>, where k is the root node; sons(k) = ,sr) , 51E NTL1NN, I = 1,...,p, is the set of the direct descendants of k; cat(k) = A, a non-terminal category assigned to the node.",
        "From the above definitions the initial PGS for a sentence s=a1a2...a. is: NT= (0,1,...,n,n+1) , Ns= , T= (T(0),T(1),...,T(n),T(n+1)); and: T(0)=<0,0,0, ,$>, ( i 1 ) ,a,> for i=1,... in , and T(n+1)=<n+1, n+1,n+1,(n) ,$>.",
        "With this PGS the parser starts its work reducing new nodes from the already existing ones.",
        "If for some k NN, T(k)=<k,1c1(k),rcl(k), ( s ,sp ,A>, and T(9=rsi,1c1(s),rcl(si),(s11,...,s,0),zi>e T, for i = 1,...,p, are the direct descendants of k, then k has been reduced from sy• • ..sT, by some grammar rule whose reduction rule, as we shall see later, has the form (A4 – z1...zp), and the following holds: kl(k) = rcl(si) =1c14)-1, rcl(s2) =1c1(s3)-1, rcl(sp.1)=1c1(s)-1, rcl(s)= rcl(k).From that we can give the following definition: of the match process the matcher must start from the last scanned or built node zy finding afterwards z2 and z1, respectively, sailing in the PGS right-to-left and passing through adjacent subtrees.",
        "Steps through adjacent subtrees are easily accomplished by using the sets of the anchored nodes in the terminal nodes.",
        "It follows from the above definitions that if ke NI, then the subtrees adjacent to T(k) are given by an(Icl(k)), whereas if he NT then the adjacent subtrees are given by an(k).",
        "The lists of the anchored nodes provide an efficient way to represent the relation of adjacency between nodes.",
        "These sets stored only in the terminal nodes provide an efficient data structure useful for the matcher to accomplish its purpose.",
        "Figure 1 shows a parse tree at a certain time of a parse, where under each",
        "Definition 2.7.",
        "If ( is a set of nodes in the PGS, then their subtrees T(s,),...,T(sp) are said to be adjacent when rcl(si) = Ic1(s61)-1 or, alternatively, al(;) = lc.1(si.1), for i = 1....'p-1.",
        "During a parsing process a great effort is made in finding a set of adjacent subtrees that match a right-hand side of a reduction rule.",
        "Let (M--z, z1 z3)be a reduction rule, then the parser should start a match process to find all possible sets of adjacent subirees such that their categories match z, z2 z.",
        "The parser scans the input string left-to-right, so reductions grow on the left of the scanner pointer, and for the efficiency terminal node there is the corresponding list of the anchored nodes.",
        "A useful structure that can be derived from these sets is an adjacency tree, recursively defined as follows: Definition 2.8.",
        "If (NT,NN,T) is a PGS for an input sentence s, and isi = n, then the adjacency tree for the PGS is so built: - n+1 is the root of the adjacency tree; - for every kE NT (0,1 )uNN, the sons of k are the nodes in an(1c1(k)) unless an(1c1(1c))= (0).",
        "Figure 2 shows the adjacency tree obtained from the partial parse tree in Figure 1.",
        "Any passage from a node k to one of its sons h in the adjacency tree represents a passage from a",
        "subtree T(k) to one of its adjacent subtrees T(h) in the PGS.",
        "Moreover, during a match process this means that a constituent of the right-hand side has been consumed, and matching the first symbol that match process is finished.",
        "The adjacency tree also provides further useful information for optimizing the search during a match.",
        "For every node k, if we consider the longest path from k to a leaf, its length is an upper bound for the length of the right hand side still to consume, and since the sons of k are the nodes in an(lcl(k)), the longest path is always given by the sequence of the terminal nodes from the node 1 to the node kl(k)-1.",
        "Thus its length is just 1c1(k)-1.",
        "Property 2.1.",
        "If (NrNN,T) is a PGS, (Ac – ; _xi)) is a reduction rule whose right-hand side has to be matched, and T(k)e T such that cat(k) = zp, then: a. the string ; zp is matchable iff p kl(k); h. for i = p,...,1, zi is partially matchable to a node Definition 2.10.",
        "If (NT,NN,T) is a PGS, an adjacency digraph can be represented as follows: a. for any ke Nr, k has outgoing arcs directed to the nodes in aria* b. for any he NN, k has one outgoing arc directed to 1c1(k).",
        "In the classic literature the lists of the anchored nodes are called adjacency lists, and are used for representing graphs (Aho et al., 1974).",
        "A graph G=(V,E) can be usually represented by IVI adjacency lists.",
        "In our representation we can obtain an optimization representing an adjacency digraph by n adjacency lists, if n is the length of the sentence, and by EN) simple pointers for accessing the adjacency lists from the non-terminal nodes, with respect to n+INNI adjacency lists for a full representation of an adjacency digraph composed of arcs as in Defmition 2.10.a.",
        "Figure 3 shows how a new non-terminal node is connected in an adjacency digraph, and Figure 4 shows the adjacency •-'' ak 1c1(k) .411- - - - k access from k toki(k) A\" r ark T(k) is adjacent to T(r) 401-1clOc-1) kl(k)44 – rei(k) al(k) = rcl(k)+ hog – ",
        "he NNuNT iff cat(h) = z. and i kl(h).",
        "Property 2.1. along with the adjacency relation provides a method for an efficient navigation within the PGS among the subtrees.",
        "This navigation is performed by the matcher in the PGS as visiting the adjacency tree in a pre-order fashion.",
        "It is easy to see that a pre-order visit of the adjacency tree scans all possible sequences of the adjacent subtrees in the PGS, but Property 2.1 provides a shortcut for avoiding useless passages when matchable conditions do not hold.",
        "When a match ends the matcher returns one or more sets of nodes satisfying the following conditions:"
      ]
    },
    {
      "heading": "Deftnition2.9. A set RS et = (ni,...,np) is a match for a string",
      "text": [
        "iff cat(ni) ;, for i 1,...,p, and T(n) is adjacent to T(ni.",
        "), for i = 1,...,p-1.",
        "The set RSet is called a reduction set.",
        "The adjacency tree shows the hypothetical search space for searching the reduction sets in a PGS, thus it is not a representation of what memory is actually required to store the useful data for such a search.",
        "A more suitable representation is an adjacency directed graph defined by means of the lists of the anchored nodes in the terminal nodes, and by the pointers to the left comer leaf in the non-terminal nodes.",
        "digraph for the parse uce of Figure 1."
      ]
    },
    {
      "heading": "3. PROCESS GRAMMAR",
      "text": [
        "The Process Grammar is an extension of the Augmented Context-Free Grammar such as APSG, oriented to bottom-up parsing.",
        "Some relevant features make a Process Grammar quite different from classical APSG.",
        "1.",
        "The parser is a PG processor that tries to apply the rules in a bottom-up fashion.",
        "It does not have any knowledge about the running grammar but for the necessary structures to access its rules.",
        "Furthermore, it sees only its internal state, the Parse Graph Structure, and works with a non-deterministic strategy.",
        "2.",
        "The rules are conceived as processes that the PG processor schedules somehow.",
        "Any rule defines a reduction rule that does not represent a rewriting rule, but rather a statement for search and construction of new nodes in a bottom-up way within the Parse Graph Structure.",
        "3.",
        "The rules are augmented with some sequences of operations to be performed as in the classical APSG.",
        "In general, augmentations such as tests and actions concern manipulation of linguistic data at syntactic and/or semantic level.",
        "In this paper we are not concerned with this aspect (an",
        "informal description about this is in Marino (1989)), rather we examine some aspects concerning parsing strategies by means of the augmentations.",
        "In a Process Grammar the rules can have knowledge of the existence of other rules and the purpose for which they are defined.",
        "They can call some functions that act as filters on the control structures of the parser for the scheduling of the processes, thus altering the state of the processor and forcing alternative applications.",
        "This means that any rule has the power of changing the state of the processor requiring different scheduling, and the processor is a blind operator that works following a loose strategy such as the non-deterministic one, whereas the grammar can drive the processor altering its state.",
        "In such a way the lack of determinism of the processor can be put in the Process Grammar, implementing parsing strategies which are transparent to the processor.",
        "Definition 3.1.",
        "A Process Grammar PG is a 6-tuple (VDV„,S,R,Vs,F) where: VT is the set of terminal symbols; - VN is the set of non-terminal symbols; - Se V, is the Root Symbol of PG; - R = tri,...,ri) is the set of the niles.",
        "Any rule r. in R is of",
        "the form r. <red(r),st(ri),t(r.),a(r)>, where red(r1) is a reduction rule (Ak-a), Ae VN, etc st(ri) is the state of the rule that can be active or inactive; t(r) and a(r1) are the tests and the actions, respectively; - Vs is a set of special symbols that can occur in a reduction rule and have a special meaning.",
        "A special symbol is el, a null category that can occur only in the left-hand side of a reduction rule.",
        "Therefore, a reduction rule can also have the form (y-a), and in the following we refer to it as e-reduction ; F = J..) is a set of functions the rules can call within their au g men tations .",
        "Such a definition extends classical APSG in some specific ways: first, a Process Grammar is suited for bottom-up parsing; second, rules have a state concerning the applicability of a rule at a certain time; third, we extend the CF structure of the reduction rule allowing null left-hand sides by means of e-reductions; fourth, the set F is the strategic side that should provide the necessary functions to perform operations on the processor structures.",
        "As a matter of fact, the set F can be further structured giving the PG a wider complexity and power.",
        "In this paper we cannot treat a formal extended definition for F due to space restrictions, but a brief outline can be given.",
        "The set F can be defined as F=Fx...L.,F,.",
        "In FK., are all those functions devoted to operations on the processor structures (Kernel Functions), and, in the case of a feature-based system, in F6 are all the functions devoted to the management of feature structures (Marino, 1989).",
        "In what follows we are also concerned with the combined use of e-reductions and the function RA, standing for Rule Activation, devoted to the immediate scheduling of a rule.",
        "RAF a call to it means that the specified rule must be applied, involving the scheduling process we describe in Section 4.",
        "Before we introduce the PG processor we must give a useful definition: Definition 32.",
        "Let re R be a rule with t(r)=Ife;--.",
        ";fuil, a(r)= [fe: .",
        ";C) be sequences of operations in its augmentations, F. Let (ni,...,np) be a reduction set for red(r) = (M-;...zp), and he N, be the new node for A such that T(h) is the new subtree created in the PGS, then we define the Process Environment for t(r) and a(r), denoted briefly by ProcEnv(r), as:",
        "If red(r) is an e-reduction then ProcErt4) = This definition states the operative range for the augmentations of any rule is limited to the nodes involved by the match of the reduction rule."
      ]
    },
    {
      "heading": "4. PG PROCESSOR",
      "text": [
        "Process Scheduler.",
        "The process scheduler makes possible the scheduling of the proper rules to run whenever a terminal node is consumed in input or a new non-terminal node is added to the PGS by a process.",
        "By proper rules we mean all the rules satisfying Property 2.1.a.",
        "with respect to the node being scanned or built.",
        "These rules are given by the sets defined in the following definition: Definition 4.1.",
        "Vce Vt4t..NT such that 3 re R where red(r) = (M-ac), VNu (c) , being c the right corner of the reduction rule, and lad l .5 L, being L the size of the longest right-hand side having c as the right corner, the sets P(c,i), Pd(c,i) for i = 1,...,L, can be built as follows: P(c,i) = (re R I red(r)=(Ak-ac), 1 5 lacl i, st(r)=active) Po(c,i)= [re R I red(r)=(y-ac), 1 5 lacl I, st(r)=active) Whenever a node he NruN, has been scanned or built and k=lcl(h), then the process scheduler has to schedule the rules in P(cat(h),k)uPd(cat(h),k).",
        "In the following this union is also denoted by 1-1(cat(h),k).",
        "Such a rule scheduling allows an efficient realization of the immediate constituent analysis approach within a bottom-up parser by means of a partitioning of the rules in a Process Grammar.",
        "The process scheduler sets up a process descriptor for each rule in Il(cat(h),k) where the necessary data for applying a process in the proper environment are supplied.",
        "In a Process Grammar we can have three main kinds of rules: rules that are activated by others by means of the function RA; e-reduction rules; and standard rules that do not fall in the previous cases.",
        "This categorization implies that processes have assigned a priority depending on their kind.",
        "Thus activated rules have the highest priority, e-reduction rules have an intermediate priority and standard rules the lowest priority.",
        "Rules become scheduled processes whenever a process descriptor for them is created and inserted in a priority queue by the process scheduler.",
        "The priority queue is divided into three stacks, one for each kind of rule, and they form one of the structures of the processor state.",
        "Definition 4.2.",
        "A process descriptor is a triple PD=fr,h,CI where: re R is the rule involved; he NTk..)Nxt.",
        ")[NEL) is either the right corner node from which the matcher starts or NIL; C is a set of adjacent nodes or the empty set.",
        "A process descriptor of the form fr,NlL,(ni,...,nc] is built for an activated rule r and pushed in the stack si.",
        "A process descriptor of the form [r,h,( ]] is built for all the other rules and is pushed either in the stack s, if r is an e-reduction rule or in the stack s, if a standard rule.",
        "Process descriptors of these latter forms are handled by the process scheduler, whereas process descriptors for activated rules are only created and queued by the function RA.",
        "State of Computation.",
        "The PG processor operates by means of an operation Op on some internal structures that define the processor state ProeState, and on the parsing structures accessible by the process environment ProcEnv.",
        "The whole state of computation is therefore given by: [0p,ProcS tate ,ProcEnv] = [Op ,pt,[si,s2,s3],PD,pn,RS et] where ptE NT is the input pointer to the last terminal node scanned; pee NN is the pointer to the last non-terminal node added to the PGS.",
        "For a sentence s=a,...a. the computation starts from the initial state Ibegin,0,[NIL,NIL.NILL NIL,n+1,(1], and terminates when the state becomes [end,n,[NIL,N1L,NIL],NIL,pn,f )1 The aim of this section is not to give a complete description of the processor cycle in a parsing process, but an analysis of the activation mechanism of the processes by means of two main cases of rule scheduling and processing.",
        "Scheduling and Processing of Standard Rules.",
        "Whenever the state of computation becomes as [scan, pt, [N1L,NIL,NIL],N]L,pn,( )1 the processor scans the next terminal node, performing the following operations: scan: scl if pt = n then Op < – end sc2 else pt pt + 1; sc3 schedule gi(cat(p0,1c1(pt))); sc4 Op < – activate.",
        "Step sc4 allows the processor to enter in the state where it determines the first non-empty higher priority stack where the process descriptor for the next process to be activated must be popped off.",
        "Let suppose that cat(pt)=z , and fl(z ,k1(pt)).",
        "(r) where r is a standard rule suet' that red(r)=(A4--z1...zp).",
        "At this point the state is [activate, pt,[NIL,N1L,[r,pt,[ DLNIL,pn,f)] and the processor has to try reduction for the process in the stack ss, thus ON – reduce performing the following statements: reduce: rl PIN – pop (50;",
        "Step r9, where the process scheduler produces process descriptors for all the rules in 1-1(A,Icl(pn)), immediate analysis of the new constituent added to the PGS.",
        "Scheduling and Processing of Rules Activated by e - Reduction Rules.",
        "Let consider the case when an c-reduction rule r activates an inactive rule r' such that: red(r)-=(e14 – zi...z„), a(r)=[RA (r')], red(e(M – z.k...;), 1KILS1Kp, and st(?)=inactive.",
        "When the operation activate has checked that an e-reduction rule has to be activated then 0134 – e-reduce, thus the state of computation becomes: [e- re d u ce ,pt [NM , fr ,m , ( ) ] ,N1L] ( ) ] , and the following statements are performed:",
        "[e red uce,pt, [N1L,NTL ,N1L] ,[rim ,C],pn, ] er4 V rsete C: Er5 RSeu – rset; [e-reduce,pt,[NIL,NIL,NIL],[r,m,[ )],pn,RSet] er6 if t(r) then a(r)==[RA (r')]; [e-reduce,pt,ffr',NIL,(nk,...,n,)],NIL,N1L1, [r,m,( )],pn,RSet] Er7 Op – activate.",
        "In this case, unlike that which the process scheduler does, the function RA performs at step er6 the scheduling of a process descriptor in the stack si where a subset of ProcEnv(r) is passed as the ProcEnv(e).",
        "Therefore, when an e-reduction ruler activates another rule r' the step er2 does the work also for r', and RA just has to identify the ProcEnv of the activated rule inserting it in the process descriptor.",
        "Afterwards, the operation activate checks the highest priority stack s, is not empty, therefore it pops the process descriptor re,NIL,Ink,...,nh)] and Opt--h-reduce that skips the match process applying immediately the rule r': h-reduce: hrl RSetc – C; [h-reduce,pt,[1g1L,N1L,NlL],[r',N1L,( ] ,pn,RS et] hr2 through hr6 as r6 through r10.",
        "From the above descriptions it turns out that the operation activate plays a central role for deciding what operation must run next depending on the state of the three stacks.",
        "The operation activate just has to check whether some process descriptor is in the first non-empty higher priority stack, and afterwards to set the proper operation.",
        "The following statements describe such a work and Figure 5 depicts graphically the connections among the operations defined in this Section.",
        "S. EXAMPLE It is well known that bottom-up parsers have problems in managing rules with common right-hand sides like X --+ ABCD, X --) BCD, X – > CD, X --> D, since some or all of these rules can be fired and build unwanted nodes.",
        "A strategy called top-down filtering in order to circumvent such a problem has been stated, and it is adopted within bottom-up parsers (Kay, 1982; Pratt, 1975; Slocum, 1981; Wiren, 1987) where it simulates a top-down parser together with the bottom-up parser.",
        "The PG Processor must face this problem as well, and the example we give is a Process Grammar subset of rules that tries to resolve it.",
        "The kind of solution proposed can be put in the family of top-down filters as well, taking advantage firstly of using e-reduction rules.",
        "Unfortunately, the means described so far are still insufficient to solve our problem, thus the following definitions introduce some functions that extend the Process Grammar and the control over the PCS and the PG Processor, Definition 5.1.",
        "Let r be a rule of R with red(r)=(y – z1...zp), and RSet= up) be a reduction set for red(r).",
        "Taken two nodes rvie RSet where ri,E NN such that we have cat(n)=z, cat(n)=z, and T(n.), T(n1) are adjacent, i.e., either j=i+1 or j=i-1, then the function Add_Son_Rel of F.. when called in a(r) as Add_Son_Rel (zi,z) has the effect of creating a new parent-son relation between ii,, the parent, and nj, the son, altering the sets sons(n,), and either 1c1(n) or rcl(n.) as follows:",
        "Such a function has the power of making an alteration in the structure of a subtree in the PGS extending its coverage to one of its adjacent subnees.",
        "Definition 5.2.",
        "The function RE of F, standing for Rule Enable, when called in the augmentations of some rule r as RE (r'), where r, r' are in R, sets the state of r' as active, masking the original state set in the definition of r'.",
        "Without entering into greater detail, the function RE can have the side effect of scheduling the just enabled rule r' whenever the call to RE follows the call Add_Son_Rel (X,Y) for some category XE VN,YE V.uVT, and the right corner of red(?)",
        "is X.",
        "Definition 53.",
        "The function RD of F,, standing for Rule Disable, when called in the augmentations of some ruler as RD (r'), where r, r' are in R, sets the state of r' as inactive, masking the original state set in the definition of r'.",
        "We are now ready to put the problem as follows: given, for instance, the following set P1 of productions:",
        "we want to define a set of PG rules having the same coverage of the productions in P1 with the feature of building in any case just one node X in the PGS.",
        "Such a set of rules is shown in Figure 6 and its aim is to create links among the node X and the other constituents just when the case occurs and is detected.",
        "All the possible cases are depicted in Figure 7 in chronological order of building.",
        "The only active rule is r0 that is fired whenever a D is inserted in the PGS, thus a new node X is created by r0 (case (a)).",
        "Since the next possible case is to have a node C adjacent to the node X, the only action of r0 enables the rule rl whose work is to find such an adjacency in the PGS by means of the e-reduction rule red(r1)=(E – C X).",
        "If such a C exists rI is scheduled and applied, thus the actions of r1 create a new link between X and C (ease (b)), and the rule r2 is enabled in preparation of the third possible case where a node B is adjacent to the node X.",
        "The actions of rl disable rl itself before ending their work.",
        "Because of the side effect of RE cited above the rule r2 is always scheduled, and whenever a node B exists then it is applied.",
        "At this point it is clear how the mechanism works and cases (e) and (d) are handled in the same way by the rules r2 and r3, respectively.",
        "As the example shows, whenever the rules r1,r2,r3 are scheduled their task is realized in two phases.",
        "The first phase is the match process of the E-reduction rules.",
        "At this stage it is like when a top-down parser searches lower-level constituents for expanding the higher level constituent.",
        "If this search succeeds the second phase is when the",
        "appropriate links are created by means of the actions, and the advantage of this solution is that the search process terminates in a natural way without searching and proposing useless relations between constituents.",
        "We terminate this Section pointing out that this same approach can be used in the dual case of this example, with a set P2 of productions like: P2 (X – > A, X – > AB, X – › ABC, X ABCD) The exercise of finding a corresponding set of PG rules is left to the reader."
      ]
    },
    {
      "heading": "6. RELATED WORKS",
      "text": [
        "Some comparisons can be made with related works on three main levels: the data structure PGS; the Process Grammar; the PG Processor.",
        "The PGS can be compared with the chart (Kaplan, 1973; Kay, 1982).",
        "The PGS embodies much of the information the chart has.",
        "As a matter of fact, our PGS can be seen as a denotational variant of the chart, and it is managed in a different way by the PG Processor since in the PGS we mainly use classical relations between the nodes of the parse-trees: the dominance relation between a parent and a son node, encoded in the non-terminal nodes; the left-adjacency relation between subtrees, encoded in the terminal nodes.",
        "Note that if we add the right-adjacency relation to the PGS we obtain a structure fully comparable to the chart.",
        "The Process Grammar can embody many kinds of information.",
        "Its structure comes from the general structure stated for the APS G, being very close to the ATN Grammars structure.",
        "On the other hand, our approach proposes that grammar rules contain directives relative to the control of the parsing process.",
        "This is a feature not in line with the current trend of keeping separate control and linguistic restrictions expressed in a declarative way, and it can be found in parsing systems making use of grammars based on situation-action rules (Winograd, 1983); furthermore, our way of managing grammar rules, i.e., operations on the states, activation and scheduling mechanisms, is very similar to that realized in Marcus (1980)."
      ]
    },
    {
      "heading": "7. DISCUSSION AND CONCLUSIONS",
      "text": [
        "The PG Processor is bottom-up based, and it has to try to take advantage from all the available sources of information which are just the input sentence and the grammar structure.",
        "A strong improvement in the parsing process is determined by how the rules of a Process Grammar are organized.",
        "Take, for instance, a grammar where the only active rules are e-reduction rules.",
        "Within the activation model they merely have to activate inactive rules to be needed next, after having determined a proper context for them.",
        "This can be extended to chains of activations at different levels of context in a sentence, thus limiting both calls to the matcher and nodes proliferation in the PGS.",
        "This case can be represented writing (e – crel) (A4--y), reading it as if the e-reduction in the lhs applies then activate the rule with the reduction in the rhs, thus realizing a mechanism that works as a context sensitive reduction of the form (ci.A13( – ct43), easily extendable also to the general case (A]<-71)..",
        ".(A4 – yd.",
        "This is not the only reason for the presence of the s-reduction rules in the Process Grammar.",
        "It also becomes apparent from the example that the e-reduction rules are a powerful tool that, extending the context-freeness of the reduction rules, allow the realization of a wide alternative of techniques, especially when its use is combined together with Kernel Functions such as RA getting a powerful mean for the control of the parsing process.",
        "From that, a parser driven by the input - for the main scheduling - and both by the PG S and the rules - for more complex phenomena - can be a valid",
        "framework for solving, as much as possible, classical problems of efficiency such as minimal activation of rules, and minimal node generation.",
        "Our description is implementation-independent, it is responsive to improvements and extensions, and a first advantage is that it can be a valid approach for realizing efficient implementations of the PG Processor.",
        "Extending the Process Grammar.",
        "In this paper we have described a Process Grammar where rules are augmented with simple tests and actions.",
        "An extension of this structure that we have not described here and that can offer further performance to the parsing process is if we introduce in the PG some recovery actions that are applied whenever the detection of one of the two passible cases of process failure happens in either the match process or the tests.",
        "Consider, for instance, the reduction rule.",
        "Its final aim is to find a process environment for the rule when scheduled.",
        "This leads to say that whenever some failure conditions happen and a process environment cannot be provided, the recovery actions would have to manage just the control of what to do next to undertake some recovery task.",
        "It is easy to add such an extension to the PG, consequently modifying properly the reduction operations of the PG processor.",
        "Other extensions concern the set F,, by adding further control and process management functions.",
        "Functions such as RE and RD can be defined for changing the state of the rules during a parsing process, thus a Process Grammar can be partitioned in clusters of rules that can be enabled or disabled under proper circumstances detected by 'lowlever(c-reduction) rules.",
        "Finally, there can be also some cutting functions that stop local partial parses, or even halt the PG processor accepting or rejecting the input, e.g., when a fatal condition has been detected making the input unparsable, the PG processor might be halted, thus avoiding the complete parse of the sentence and even starting a recovery process.",
        "The reader can refer to Marino (1988) and Marino (1989) for an informal description regarding the implementation of such extensions.",
        "Conclusions.",
        "We have presented a complete framework for efficient bottom-up parsing.",
        "Efficiency is gained by means of: a structured representation of the parsing structure, the Parse Graph Structure, that allows efficient matching of the reduction rules; the Process Grammar that extends APS G by means of the process-based conception of the grammar rules and by the presence of Kernel Functions; the PG Processor that implements a non-deterministic parser whose behaviour can be altered by the Process Grammar increasing the determinism of the whole system.",
        "The mechanism of rule activation that can be realized in a Process Grammar is context-sensitive-based, but this does not increase computational effort since processes involved in the activations receive their process environments - which are computed only once - from the activating rules.",
        "At present we cannot tell which degree of determinism can be got, but we infer that the partition of a Process Grammar in clusters of rules, and the driving role the c-reductions can have are two basic aspects whose importance should be highlighted in the future."
      ]
    },
    {
      "heading": "ACKNOWLEDGMENTS",
      "text": [
        "The author is thankful to Giorgio Satta who made helpful comments and corrections on the preliminary draft of this paper."
      ]
    },
    {
      "heading": "REFERENCES",
      "text": []
    }
  ]
}
