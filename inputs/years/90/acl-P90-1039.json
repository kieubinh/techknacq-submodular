{
  "info": {
    "authors": [
      "Toshikazu Fukushima",
      "Yutaka Ohyama",
      "Hitoshi Miyai"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P90-1039",
    "title": "A Hardware Algorithm for High Speed Morpheme Extraction and Its Implementation",
    "url": "https://aclweb.org/anthology/P90-1039",
    "year": 1990
  },
  "references": [
    "acl-C86-1065",
    "acl-C86-1066",
    "acl-C86-1067",
    "acl-P86-1024"
  ],
  "sections": [
    {
      "heading": "ABSTRACT",
      "text": [
        "This paper describes a new hardware algorithm for morpheme extraction and its implementation on a. specific machine (MEX-./), as the first step toward achieving natural language parsing accelerators.",
        "It also shows the machine's performance, 100-1,000 times faster than a personal computer.",
        "This machine can extract morphemes from 10,000 character Japanese text by searching an 80,000 morpheme dictionary in 1 second.",
        "It can treat multiple text streams, which are composed of character candidates, as well as one text stream.",
        "The algorithm is implemented on the machine in linear time for the number of candidates, while conventional sequential algorithms are implemented combinational time."
      ]
    },
    {
      "heading": "I. INTRODUCTION",
      "text": [
        "Recent advancement in natural language parsing technology has especially extended the word processor market and the machine translation system market.",
        "For further market extension or new market creation for natural language applications, parsing speed-up as well as improving parsing accuracy is required.",
        "First, the parsing speed-up directly reduces system response time required in such interactive natural language application systems as those using natural language interface, speech recognition, Ka.na-to-Kanji conversion, which is the most popular Japanese text input method, and so on.",
        "Second, it also increases the advantage of such applications as machine translation, document proofreading, automatic indexing, and so on, which are used to treat a large amount of documents.",
        "Third, it realizes parsing methods based on larger scale dictionary or knowledge database, which are necessary to improve parsing accuracy.",
        "Until now, in the natural language processing field, the speed-up has depended mainly on performance improvements achieved in sequential processing computers and the development of sequential algorithms.",
        "Recently, because of the further",
        "speeded-up requirement, parallel processing computers have been designed and parallel parsing algorithms (Matsumoto, 1986) (Flans, 1987) (Rytter, 1987) (Fukushima, 1990b) have been proposed.",
        "However, there are many difficult problems blocking efficient practical use of parallel processing computers.",
        "One of the problems is that access conflicts occur when several processors read or write a common memory simultaneously.",
        "Another is the bottleneck problem, wherein commtnication between any two processors is restricted, because of hardware scale limitation.",
        "On the other hand, in the pattern processing field, various kinds of accelerator hardware have been developed.",
        "They are designed for a special purpose, not for general purposes.",
        "A hardware approach hasn't been tried in the natural language processing field yet.",
        "The authors propose developing natural language parsing accelerators, a hardware approach to the parsing speed-up (Fukushima, 1989b) (Fukushirna, 1990a).",
        "This paper describes a new hardware algorithm for high speed morpheme extraction and its implementation on a specific machine.",
        "This morpheme extraction machine is designed as the first step toward achieving the natural language parsing accelerators."
      ]
    },
    {
      "heading": "2 MACHINE DESIGN STRATEGY",
      "text": []
    },
    {
      "heading": "2.1 MORPHEME EXTRACTION",
      "text": [
        "Morphological analysis methods are generally composed of two processes: (1) a morpheme extraction process and (2) a morpheme determination process.",
        "In process (1), all morphemes, which are considered as probably being used to construct input text, are extracted by searching a. morpheme dictionary.",
        "These morphemes are extracted as candidates.",
        "Therefore, they are selected mainly by morpheme conjunction constraint.",
        "Morphemes which actually construct the text are determined in process (2).",
        "The authors selected morpheme extraction as the first process to be implemented on specific hardware, for the following three reasons.",
        "First is that the speed-up requirement for the morphological analysis process is very strong in Japanese",
        "text parsing systems.",
        "This process is necessary for natural language parsing, because it is the first step in the parsing.",
        "However, it is more laborious for Japanese and several other languages, which have no explicit word boundaries, than for English and many European languages (Miyazaki, 1983) (Ohya.ma, 1986) (Abe, 1986).",
        "English text reading has the advantage of including blanks between words.",
        "Figure 1 shows an example of the morpheme extraction process for Japanese text.",
        "Because of the disadvantage inherent in reading difficulty involved in all symbols being strung together without any logical break between words, the morpheme dictionary, including more than 50,000 morphemes in Japanese, is searched at almost all positions of Japanese text to extract morphemes.",
        "The authors' investigation results, indicating that the morpheme extraction process requires using more than 70 % of the morphological analysis process time in conventional Japanese parsing systems, proves the strong requirement for the speed-up.",
        "The second reason is that the morpheme extraction process is suitable for being implemented on specific hardware, because simple character comparison operation has the heaviest percentage weight in this process.",
        "The third reason is that this speed-up will be effective to evade the common memory access conflict problem mentioned in Section 1."
      ]
    },
    {
      "heading": "2.2 STRATEGY DISCUSSION",
      "text": [
        "In conventional morpheme extraction methods, which are the software methods used on sequential processing computers, the comparison operation between one key string in the morpheme dictionary and one sub-string of input text is repeated.",
        "This is one to one comparison.",
        "On the other hand, many to one comparison or one to many comparison is practicable in parallel computing.",
        "Content addressable memories (CAMs) (Chisvin, 1989) (Yamada, 1987) realize the many to one comparison.",
        "One sub-string of input text is simultaneously compared with an key strings stored in a CAM.",
        "However, presently available CAMs have only a. several tens of kilobit memory, which is too small to store data.",
        "for a more than 50,000 morpheme dictionary.",
        "The above mentioned parallel processing computers realize the one to many comparison.",
        "On the parallel processing computers, one processor searches the dictionary at one text position, while another processor searches the same dictionary at the next position at the same time (Nakamura, 1988).",
        "However, there is an access conflict problem involved, as already mentioned.",
        "The above discussion has led the authors to the following strategy to design the morpheme extraction machine (Fnkushima, 1989a).",
        "This strategy is to shorten the one to one comparison cycle.",
        "Simple architecture, which will be described in the next section, can realize this strategy."
      ]
    },
    {
      "heading": "3 A HARDWARE ALGORITHM FOR MORPHEME EXTRACTION 3.1 FUNDAMENTAL ARCHITECTURE",
      "text": [
        "A new hardware algorithm for the morpheme extraction, which was designed with the stratev mentioned in the previous section, is described in this section.",
        "The fundamental architecture, used to implement the algorithm, is shown in Fig. 2.",
        "The main components of this architecture are a dictionary block, a shift register block, an index memory, an address generator and comparators.",
        "The dictionary block consists of character memories (i.e. 1st character memory, 2nd character memory, ... , Nth character memory).",
        "The n-tli character memory (1 < n N) stores nth characters of all key strings in the morpheme diction as shown in Fig. 3.",
        "In Fig. 3, \"M.*\", \"a\", \" \", \"Ii3f9tN\", \"Off\", and so on are Japanese morphemes.",
        "As regarding morphemes shorter than the key length N, predefined remainder symbols fill in their key areas.",
        "In Fig. 3, `gc' indicates the remainder symbol.",
        "The shift register block consists of character registers (i.e. 1st character register, 2nd character register, , Nth character register).",
        "These registers",
        "store the sub-string of input text, which can be shifted, as shown in Fig. 4.",
        "The index memory receives a character from the 1st character register.",
        "Then, it outputs the top address and the number of morphemes in the dictionary, whose 1st character corresponds to the input character.",
        "Because morphemes are arranged in the incremental order of their key string in the dictionary, the pair for the top address and the number expresses the address range in the dictionary.",
        "Figure 3 shows the relation between the index memory and the character memories.",
        "For example, when the shift register block content is as shown in Fig. 4(a), where is stored in the 1st character register, the index memory's output expresses the address range for the morpheme set {\"ef\", gif%e\", \"Mr', s\", \"EFSE11\", in Fig. 3.",
        "The address generator sets the same address to all the character memories, and changes their addresses simultaneously within the address range which the index memory expresses.",
        "Then, the dictionary block outputs all characters constructing one morpheme (key string with length N ) simultaneously at one address.",
        "The comparators are N in number (i.e. 1st comparator, 2nd comparator, ..., Nth comparator).",
        "The nth comparator compares the character in the nth character register with the one from the nth character memory.",
        "When there is correspondence between the two characters, a match signal is output.",
        "In this comparison, the remainder symbol operates as a wild card.",
        "This means that the comparator also outputs a match signal when the nth character memory outputs the remainder symbol.",
        "Otherwise, it outputs a no mageh signal.",
        "The algorithm, implemented on the above described fundamental architecture, is as follows.",
        "• Main procedure",
        "Step 1: Load the top N characters from the input text into the character registers in the shift register block.",
        "Step 2: While the text end mark has not arrived at the 1st character register, implement Procedure 1.",
        "• Procedure 1",
        "Step 1: Obtain the address range for the morphemes in the dictionary, whose 1st character corresponds to the character in the 1st character register.",
        "Then, set the top address for this range to the current address for the character memories.",
        "Step 2: While the current address is in this range, implement Procedure 2.",
        "Step 3: Accomplish a shift operation to the shift register block.",
        "• Procedure 2",
        "For example, Fig. 4(a) shows the sub-string in the shift register block immediately after Step 1 for Main procedure, when the input text is \" 5EN.14.",
        "** LW).",
        "L Step 3 for Procedure 1 causes such movement as (a)--4b), (b) – (c), (c)-4(d), (d) – qe), and so on.",
        "Step 1 and Step 2 for Procedure 1 are implemented in each state for (a), (b), (c), (d), (e), and so on.",
        "In state (a) for Fig. 4, the index memory's output expresses the address range for the morpheme set { uer, HEM% iii3140A,P, \" 101\"} if the dictionary is as shown in Fig. 3.",
        "Then, Step 1 for Procedure 2 is repeated at each address for the morpheme set OK\", \"OM\", Le Opt 1• Figure 5 shows two examples of Step 1 for Procedure 2.",
        "In Fig. 5(a), the current address for the dictionary is at the morpheme \"liff/EN\".",
        "In Fig. 5(b), the address is at the morpheme \"effi N\".",
        "In Fig. 5(a), all of the eight comparators output match signals as the result of the simultaneous comparisons.",
        "This means that the morpheme \"OMR\" has been detected at the top position of the sub-string \"1015Effl.R.",
        "*t 111 L\".",
        "the other hand, in Fig. 5(b)1 seven comparators output match signals, but one comparator, at 2nd position, outputs a no match signal, due to the discord between the two characters, 'Si and '5E'.",
        "This means that the morpheme \"COM\" hasn't been detected at this position."
      ]
    },
    {
      "heading": "3.2 EXTENDED ARCHITECTURE",
      "text": [
        "The architecture described in the previous section treats one stream of text string.",
        "In this section, the architecture is extended to treat multiple text streams, and the algorithm for extracting morphemes from multiple text streams is proposed.",
        "Generally, in character recognition results or speech recognition results, there is a certain amount of ambiguity, in that a character or a syllable has multiple candidates.",
        "Such multiple candidates form the multiple text streams.",
        "Figure 6(a) shows an example of multiple text streams, expressed by a two dimensional matrix.",
        "One dimension corresponds to the position in the text.",
        "The other dimension corresponds to the candidate level.",
        "Candidates on the same level form one stream.",
        "For example, in Fig. 6(a), the character at the 3rd position has three candidates: the 1st candidate is the 2nd one is le' and the 3rd one is 'N'.",
        "The 1st level stream is NOMA...\".",
        "The 2nd level stream is \"liffMe.g...\".",
        "The 3rd level stream is \"OiM# \".",
        "shows the extended architecture.",
        "This extended architecture is different from the fundamental architecture, in regard to the following three points.",
        "First, there are M sets of character registers in the shift register block.",
        "Each set is composed of N character registers, which store and shift the sub-string for one text stream.",
        "Here, M is the number of text streams.",
        "N has already been introduced in Section 3.1.",
        "The text streams move simultaneously in all the register sets.",
        "Second, the nth comparator compares the character from the nth character memory with the M characters at the nth position in the shift register block.",
        "A match signal is output, when there is correspondence between the character from the memory and either of the M characters in the registers.",
        "Third, a selector is a new component.",
        "It changes the index memory's input.",
        "It connects one of the registers at the 1st position to sequential index memory inputs in turn.",
        "This changeover occurs M times in one state of the shift register block.",
        "Regarding the algorithm described in Section 3.1, the following modification enables treating multiple text streams.",
        "Procedure 1 and Procedure 1.5, shown below, replace the previous Procedure 1.",
        "• Procedure 1",
        "Step 1: Set the highest stream to the current ple2v:el Ste While the current level has not exceeded the lowest stream, implement Procedure 1.5.",
        "Step 3: Accomplish a shift operation to the shift register block.",
        "• Procedure 1.5",
        "Step 1: Obtain the address range for the morphemes in the dictionary, whose 1st character corresponds to the character in the register at the 1st position with the current level.",
        "Then, set the top address for this range to the current address for the character memories.",
        "Step 2: While the current address is in this range, implement Procedure 2, Step 3: Lower the current level.",
        "Figure 8 shows an example of Step 1 for Procedure 2.",
        "In this example, all of the eight compare,-tors output the match signal as a result of simulta.neons comparisons, when the morpheme from the dictionary is \"E/15M\".",
        "Characters marked with a circle match the characters from the dictionary.",
        "This means that the morpheme \" 5ffii\" has been detected.",
        "When each character has M candidates, the worst case time complexity for sequential morpheme extraction algorithms is 0(MN).",
        "On the other hand, the above proposed algorithm (Fuhishima's algorithm) has the advantage that the time complexity is 0(M).",
        "Hamaguchi's hardware algorithm (Hamaguchi, 1988), proposed for speech recognition systems, is similar to Fukushima's algorithm.",
        "In Hamaguchi's algorithm, S bit memory space expresses a, set of syllables, when there are S different kinds of syllables ( S = 101 in Japanese).",
        "The syllable candidates at the same position in input phonetic text are located in one 5 bit space.",
        "Therefore, Ham-a,guchi's algorithm shows more advantages, as the full set size of syllables is smaller and the number of syllable candidates is larger.",
        "On the other hand, Ftikushima's algorithm is very suitable for text with a large character set, such as Japanese (more than 5,000 different characters are computer readable in Japanese).",
        "This algorithm also has the advantage of high speed text stream shift, compared with conventional algorithms, including Hamag-a chi's."
      ]
    },
    {
      "heading": "4 A MORPHEME EXTRACTION MACHINE",
      "text": []
    },
    {
      "heading": "4.1 A MACHINE OUTLINE",
      "text": [
        "This section describes a morpheme extraction machine, called MEX-I.",
        "It is specific hardware which realizes extended architecture and algorithm proposed in the previous section.",
        "It works as a backend machine for NEC Personal Computer PC-9801VX (CPU: 80286 or V30, clock: 8MHz or 10MHz).",
        "It receives Japanese text from the host personal computer, and returns morphemes extracted from the text after a bit of time.",
        "The algorithm parameters in MEX-I are as follow.",
        "The key length (the maximum morpheme length) in the dictionary is 8 (i.e. N = 8 ).",
        "The maximum number of text streams is 3 (i.e. M = 1,2,3).",
        "The dictionary includes approximately 80,000 Japanese morphemes.",
        "This dictionary size is popular in Japanese word processors.",
        "The data length for the memories and the registers is 16 bits, corresponding to the character code in Japanese text."
      ]
    },
    {
      "heading": "4.2 EVALUATION",
      "text": [
        "MEX-I works with 10MHz clock (i.e. the clock cycle is 100ns).",
        "Procedure 2, described in Section 3.1, including the simultaneous comparisons, is implemented for three clock cycles (i.e. 300ns).",
        "Then, the entire implementation time for morpheme extraction approximates A xD xLxMx 300ns.",
        "Here, D is the number of all morphemes in the dictionary, L is the length of input text, M is the number of text streams, and A is the indexing coefficient.",
        "This coefficient means the average rate for the number of compared morphemes, compared to the number of all morphemes in the dictionary.",
        "The implementation time measurement results, obtained for various kinds of Japanese text, are plotted in Fig. 10.",
        "The horizontal scale in Fig. 10 is the L x M value, which corresponds to the number of characters in all the text streams.",
        "The vertical scale is the measured implementation time.",
        "The above mentioned 801000 morpheme dictionary was used in this measurement.",
        "These results show performance wherein MEX-I can extract morphemes from 10,000 character Japanese text by searching an 80,000 morpheme dictionary in 1 second.",
        "Figure 11 shows implementation time comparison with four conventional sequential algorithms.",
        "The conventional algorithms were carried out on"
      ]
    },
    {
      "heading": "NEC Personal Computer PC-98X0 (CPU: 80386,",
      "text": [
        "clock: 16MHz).",
        "Then, the 80,000 morpheme clic-tionary was on a memory board.",
        "Implementation time was measured for four different Japanese text samplings.",
        "Each of them forms one text stream, which includes 5,000 characters.",
        "In these measurement results, MEX-I runs approximately 1,000 times as fast as the morpheme extraction program, using the simple binary search algorithm.",
        "It runs approximately 100 times as fast as a program using the digital search algorithm, which has the highest speed among the four algorithms."
      ]
    },
    {
      "heading": "5 CONCLUSION",
      "text": [
        "This paper proposes a new hardware algorithm for high speed morpheme extraction, and also describes its implementation on a. specific machine.",
        "This machine, MEX-I, is designed as the first step toward achieving natural language parsing accelerators, which is a. new approach to speeding up the parsing.",
        "The implementation time measurement results show performance wherein MEX-I can extract morphemes from 10,000 character Japanese text by searching an 801000 morpheme dictionary in 1 second.",
        "When input is one stream of text, it runs 100-1,000 times faster than morpheme extraction programs on personal computers.",
        "It can treat multiple text streams, which are composed of character candidates, as well as one stream of text.",
        "The proposed algorithm is implemented on it in linear time for the number of candidates, while conventional sequential algorithms are implemented in combinational time.",
        "This is aclvanta?eous for character recognition or speech recognition.",
        "Its architecture is so simple that the authors believe it is suitable for VLSI implementation.",
        "Actually, its VLSI implementation is in progress.",
        "A high speed morpheme extraction VLSI will improve the performance of such text processing applications in practical use as Kana-to-Kanii conversion Japanese text input methods and spelling checkers on word processors, machine translation, automatic indexing for text database, text-to-speech conversion, and so on, because the morpheme extraction process is necessary for these applications.",
        "The development of various kinds of accelerator hardware for the other processes in parsing is work for the future.",
        "The authors believe that the hardware approach not only improves conventional parsing methods, but also enables new parsing methods to be designed."
      ]
    },
    {
      "heading": "REFERENCES",
      "text": []
    }
  ]
}
