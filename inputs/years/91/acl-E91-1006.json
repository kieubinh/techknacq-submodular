{
  "info": {
    "authors": [
      "Alberto Lavelli",
      "Giorgio Satta"
    ],
    "book": "Conference of the European Association for Computational Linguistics",
    "id": "acl-E91-1006",
    "title": "Bidirectional Parsing of Lexicalized Tree Adjoining Grammars",
    "url": "https://aclweb.org/anthology/E91-1006",
    "year": 1991
  },
  "references": [
    "acl-C88-2121",
    "acl-P85-1011",
    "acl-P88-1032",
    "acl-P90-1036"
  ],
  "sections": [
    {
      "heading": "BIDIRECTIONAL PARSING OF LEXICALIZED TREE ADJOINING GRAMMARS*",
      "text": []
    },
    {
      "heading": "Abstract",
      "text": [
        "In this paper a bidirectional parser for Lexicalized Tree Adjoining Grammars will be presented.",
        "The algorithm takes advantage of a peculiar characteristic of Lexicalized TAGs, i.e. that each elementary tree is associated with a lexical item, called its anchor.",
        "The algorithm employs a mixed strategy: it works bottom-up from the lexical anchors and then expands (partial) analyses making top-down predictions.",
        "Even if such an algorithm does not improve the worst-case time bounds of already known TAGs parsing methods, it could be relevant from the perspective of linguistic information processing, because it employs lexical information in a more direct way."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Tree Adjoining Grammars (TAGs) are a formalism for expressing grammatical knowledge that extends the domain of locality of context-free grammars (CFGs).",
        "TAGs are tree rewriting systems specified by a finite set of elementary trees (for a detailed description of TAGs, see (Joshi, 1985)).",
        "TAGs can cope with various kinds of unbounded dependencies in a direct way because of their extended domain of locality; in fact, the elementary trees of TAGs are the appropriate domains for characterizing such dependencies.",
        "In (ICroch and Joshi, 1985) a detailed discussion of the linguistic relevance of TAGs can be found.",
        "Lexicalized Tree Adjoining Grammars (Schabes et al., 1988) are a refinement of TAGs such that each elementary tree is associated with a lexical item, called the anchor of the tree.",
        "Therefore, Lexicalized TAGs conform to a common tendency in modem theories of grammar, namely the attempt to embed grammatical information within lexical items.",
        "Notably, the association between elementary trees and anchors improves also parsing performance, as will be discussed below.",
        "Various parsing algorithms for TAGs have been proposed in the literature: the worst-case time complexity varies from 0(n4 log n) (Harbusch, 1990) to 0(n6) (Vijay-Shanker and Joshi, 1985, Lang, 1990, Schabes, 1990) and 0(n9) (Schabes and Joshi, 1988).",
        "`Part of this work was done while Giorgio Satta was completing his Doctoral Dissertation at the University of Padova (Italy).",
        "We would like to thank Yves Schabes for his valuable comments.",
        "We would also like to thank Anne AbelIle.",
        "All errors are of course our own.",
        "As for Lexicalized TAGs, in (Schabes et al., 1988) a two step algorithm has been presented: during the first step the trees corresponding to the input string are selected and in the second step the input string is parsed with respect to this set of trees.",
        "Another paper by Schabes and Joshi (1989) shows how parsing strategies can take advantage of lexicalization in order to improve parsers' performance.",
        "Two major advantages have been discussed in the cited work: grammar filtering (the parser can use only a subset of the entire grammar) and bottom-up information (further constraints are imposed on the way trees can be combined).",
        "Given these premises and starting from an already known method for bidirectional CF language recognition (Satta and Stock, 1989), it seems quite natural to propose an anchor-driven bidirectional parser for Lexicalized TAGs that tries to make more direct use of the information contained within the anchor's.",
        "The algorithm employs a mixed strategy: it works bottom-up from the lexical anchors and then expands (partial) analyses making top-down predictions.",
        "2.",
        "Overview of the Algorithm The algorithm that will be presented is a recognizer for Tree Adjoining Languages: a parser can be obtained from such a recognizer by additional processing (see final section).",
        "As an introduction to the next section, an informal description of the studied algorithm is here presented.",
        "We assume the following definition of TAGs.",
        "Definition 1 A Tree Adjoining Grammar (TAG) is a 5-tuple G=(VN, VE, S, 1, A), where VN is a finite set of non-terminal symbols, VE is a finite set of terminal symbols, SE VN is the start symbol,!",
        "and A are two finite sets of trees, called initial trees and auxiliary trees respectively.",
        "The trees in the set luA are called elementary trees.",
        "We assume that the reader is familiar with the definitions of adjoining operation and foot node (see (Joshi, 1985)).",
        "The proposed algorithm is a tabular method that accepts a TAG G and a string w as input, and decides whether wE L(G).",
        "This is done by recovering (partial) analyses for substrings of w and by combining them.",
        "More precisely, the algorithm factorizes analyses of derived trees by employing a specific structure called state.",
        "Each state retains a pointer to a node n in some tree aE /uA, along with two additional pointers (called !dot and rdot) to n itself or to its children in a.",
        "Let an be a tree obtained from the maximal subtree of a with root n, by means of some adjoining operations.",
        "Informally speaking and with a little bit of simplification, the two following cases are possible.",
        "First, if Idot, rdot*n, state s indicates that the part of an dominated by the nodes between ldot and rdot has already been analyzed by the algorithm.",
        "Second, if Idot=rdot=n, state s indicates that the whole of an has already been analyzed, including possible adjunctions to its root n. Each state s will be inserted into a recognition matrix T, which is a square matrix indexed from 0 to nw, where nw is the length of w. If state s belongs to the component ti j of T, the partial analysis (the part of an) represented by s subsumes the substring of w that starts from position i and ends at position j, except for the items dominated by a possible foot node in an (this is explicitly indicated within s).",
        "The algorithm performs the analysis of w starting from the anchor node of every tree in G whose category is the same as an item in w. Then it tries to extend each partial analysis so obtained, by climbing each tree along the path that connects the anchor node to the root node; in doing this, the algorithm recognizes all possible adjunctions that are present in w. Most important, every subtree yof a tree derived from a luA, such that y dOes not contain the anchor node of a, is predicted and analyzed by the algorithm in a top-down fashion, from right to left (left to right) if it is located to the left (right) of the path that connects the anchor node to the root node in a.",
        "The combinations of partial analyses (states) and the introduction of top-down prediction states is carried out by means of the application of six procedures that will be defined below.",
        "Each procedure applies to some states, trying to \"move\" outward one of the two additional pointers within each state.",
        "The algorithm stops when no state in T can be further expanded.",
        "If some state has been obtained that subsumes the input string and that represents a complete analysis for some tree with the root node of category S. the algorithm succeeds in the recognition."
      ]
    },
    {
      "heading": "3. The Algorithm",
      "text": [
        "In the following any (elementary or derived) tree will be denoted by a pair (N, E), where N is a finite set of nodes and E is a set of ordered pairs of nodes, called arcs.",
        "For every tree o(N, E), we define five functions of N into Nu (I) called father, leftmost child, rightmost-child, left-sibling, and right-sibling (with the obvious meanings).",
        "For every tree ct(N, E) and every node n N, a function domaina is defined such that domaina(n)=13, where fi is the maximal subtree in a whose root is n. 'The symbol \"1\" denotes here the undefined element.",
        "For any TAG G and for every node n in some tree in G, we will write cat(n)=X, XE VNUVE whenever X is the symbol associated to n in G. For every node n in some tree in G, such that cat(n)e VN, the set Adjoin(n) contains all root nodes of auxiliary trees that can be adjoined to n in G. Furthermore, a function r is defined such that, for every tree ae /uA, it holds that r(a)=n, where n indicates the anchor node of a.",
        "In the following we assume that the anchor nodes in G are not labelled by the null (syntactic) category symbol e. The set of all nodes that dominate the anchor node of some tree in /uA will be called Middle-nodes (anchor nodes included); for every tree o(N, E), the nodes neN in Middle-nodes divide a in two (possibly empty) left and right portions.",
        "The set Left-nodes (Right-nodes) is defined as the set of all nodes in the left (right) portion of some tree in /uA.",
        "Note that the three sets Middle-nodes, Left-nodes and Right-nodes constitute a partition of the set of all nodes of trees in /uA.",
        "The set of all foot nodes in the trees in A will be called Foot-nodes.",
        "Let w=al an nw?.1, be a symbol string; we will say that nw is the length of w. Definition 2 A state is defined to be any 8-tuple En, 'dot, lpos, rdot, rpos.fj f, m] such that: n, Mot, rdot are nodes in some tree cze ILA; Ipos,rpose (left, right); Air are either the symbol \"-\" or indices in the input string such that far;",
        "The first component in a state s indicates a node n in some tree a, such that s represents some partial analysis for the subtree domaina(n).",
        "The second component ado may be n or one of its children in a: if Ipos=left, domainaadot) is included in the partial analysis represented by s, otherwise it is not.",
        "The components rdot and rpos have a symmetrical interpretation.",
        "The pair 11, fr represents the part of the input string that is subsumed by the possible foot node in domaina(n).",
        "A binary operator indicated with the symbol ED is defined to combine the components ft. Jr in different states; such an operator is defined as follows: of equals f iff= -, it equals f if -, and it is undefined otherwise.",
        "Finally, the component m is a marker that will be used to block expansion at one side for a state that has already been subsumed at the other one.",
        "This particular technique is called subsumption test and is discussed in (Satta and Stock, 1989).",
        "The subsumption test has the main purpose of blocking analysis proliferation due to the bidirectional behaviour of the method.",
        "Let 1s be the set of all possible states; we will use a particular equivalence relation Q-C_ Is>ds defined as follows.",
        "For any pair of states s, s', sQs' holds if and only if every component in s but the last one (the m component) equals the corresponding component in s'.",
        "The algorithm that will be presented employs the following function.",
        "Definition 3 A function F is defined as follows:2 F: VE P(Is)",
        "The details of the algorithm are as follows.",
        "Algorithm 1 Let G=(VN, VE, S. I, A) be a TAG and let w=a1 anw, n?_1, be any string in VE* .",
        "Let T be a recognition matrix of size (nw+1)x(nw+1) whose components tij are indexed from 0 to nw for both sides.",
        "Develop matrix T in the following way (a new state s is added to some entry in T only if sQsq does not hold for any state sq already present in that entry).",
        "1.",
        "For every state SE F(ad, 15i5.nw, add s to 2.",
        "Process each state s added to some entry in T by means of the following procedures (in any order): Left-expander(s), Right-expander(s), Move-dot-left(s), Move-dot-right(s), Completer(s), Adjoiner(s); until no state can be further added.",
        "3. if s4n, n, left, n, right, -, -]E to,nw for some node n such that cat(n)=S and n is the root of a tree in I, then output(true), else output (false).",
        "The six procedures mentioned above are defined in the following.",
        "for everyand set m=rm in s."
      ]
    },
    {
      "heading": "4. Formal Results",
      "text": [
        "Some definitions will be introduced in the following, in order to present some interesting properties of Algorithm 1.",
        "Formal proofs of the statements below can be found in (Satta, 1990).",
        "Let n be a node in some tree aE/uA.",
        "Each state s=[n, Idol, lpos, rdot, rpos, f, fr, m] in Is identifies a tree forest 0(s) composed of all maximal subtrees in a whose roots are \"spanned\" by the two positions ldot and rdot.",
        "If ldomn, we assume that the maximal subtree in a whose root is Idol is included in 0(s) if and only if /pos=left (the mirror case holds w.r.t.",
        "rdot).",
        "We define the subsumption relation 5. on Is as follows: iff state s has the same first component as state s' and 0(s) is included in 0(s').",
        "We also say that a forest 0(s) derives a forestry (0(s) tv) whenever ty can be obtained from 0(s) by means of some adjoining operations.",
        "Finally, E denotes the immediate dominance relation on nodes of aeluA, and ga) denotes the foot node of a (if ore A).",
        "The following statement characterizes the set of all states inserted in T by Algorithm 1.",
        "Theorem 1 Let n be a node in aE luA and let n' be the lowest node in a such that n 'e Middle-nodes and (n, 06E4; let also s=[n, ldot, lpos, rdot, rpos, nr] be a state in I. Algorithm 1 inserts a state s', s5s', in ti_hij+h,, hi,h2?_0, if and only if one of the following conditions is met: (i) ne Middle-nodes (n'=n) and (P(s) w, where v/ spans ai.+1 ... di (with the exception of string aftf ... afr if ir(a) is included in 0(s)) (see Figure 1); (ii) ne Left-nodes, s=s' , hi=h2=0 and 0(s) 4 w., where ty spans ai+i ... di (with the exception of string afi+i ... at; if It(a) is included in 0(s)).",
        "Moreover, n' is the root of a (maximal) subtree in a such that \"C4/, ty strictly includes t;/ and every tree /3E A that has been adjoined to some node in the path from n' to n spans a string that is included in al ai (see Figure 2); (iii) the symmetrical case of (ii).",
        "lit.",
        "Gianni meets Maria by chance we will propose here the following analysis (see Figure 4): (2)[c. [ip [NI, Gianni] [i. incontrai [vp.",
        "[vp [Maria]]] 6 per casoth]]] Note that the Verb incontra has been moved to the Inflection position.",
        "Therefore, the PP adjunction stretches the dependency between the Verb incontra and its Direct Object Maria.",
        "These cases may raise some difficulties in a context-free framework, because the lack of the head within its constituent makes the task of predicting the object(s) rather inefficient.",
        "Assume a TAG G.(VN, VE, S. I, A), where VN= (IP, I', VP, V', NP), VE= (Gianni, Maria, incontra, PP), I=(a) and A= (/3) (see Figure 3; each node has been paired with an integer which will be used as its address).",
        "In order to simplify the computation, we have somewhat reduced the initial tree a and we have considered the constituent PP as a terminal symbol.",
        "In Figure 4 the whole analysis tree corresponding to (2) is reported.",
        "Let z(a)=5, '4/3)=13; from Definition 3 it follows that: F(5).",
        "( [4, 5, left, 5, right, -, -]), F(13)=([11, 13, left, 11, right, -, -]).",
        "A run of Algorithm 1 on sentence (1) is simplified in the following steps (only relevant steps are reported).",
        "First of all, the two anchors are recognized: 1) s1=[4, 5, left, 5, right, -] is inserted in 11.2 and s2=[11, 13, left, 13, right, -, -] is inserted in 13,4, by line 1 of the algorithm.",
        "Then, auxiliary tree fi is recognized in the following steps: 2) s3=[11, 12, right, 13, right, -, -] is inserted in /3,4 and m is set to rm in state s2, by Case 2 of the move-dot-left procedure; 3) s4=[11, 12, left, 13, right, 2, 3, -] is inserted in t2.4 and m is set to rm in state s3, by Case 3 of the left-expander procedure; 4) s5=[11, 11, left, 13, right, 2, 3, -] is inserted in '2,4 and m is set to rm in state s4, by Case 3 of the move-dot-left procedure; 5) s6=[11, 11, left, 11, right, 2, 3, 1 is inserted in t24 and m is set to lm in state s5, by Case 3 of the move-dot-right procedure.",
        "per caso Figure 3.",
        "After the insertion of state s7=[4, 5, left, 6, left, -, -] in t1,2 by Case 2 of the move-dot-right procedure, the VP node (6) is hypothesized by Case 1 (Step 2, via state s6) of the right-expander procedure with the insertion of state s8=[6, 6, left, 6, left, -] in 12,2.",
        "The whole recognition of node (6) takes place with the insertion of state s9=[6, 6, left, 6, right, -, -] in:t2.3.",
        "Then we have the following step: 6) s10=[6, 6, left, 6, right, -,-1 is inserted in t24, by the adjoiner procedure.",
        "The analysis proceeds working on tree a and reaching a final configuration in which state s11=[1, 1, left, 1, right, -] belongs to tm."
      ]
    },
    {
      "heading": "6. Discussion",
      "text": [
        "Within the perspective of Lexicalized TAGs, known methods for TAGs recognition/parsing present some limitations: these methods behave in a left-to-right fashion (Schabes and Joshi, 1988) or they are purely bottom-up (Vijay-Shanker and Joshi, 1985, Harbusch, 1990), hence they cannot take advantage of anchor information in a direct way.",
        "The presented algorithm directly exploits both the advantages of lexicalization mentioned in the paper by Schabes and Joshi (1989), i.e. grammar filtering and bottom-up information.",
        "In fact, such an algorithm starts partial analyses from the anchor elements, directly selecting the relevant trees in the grammar, and then it proceeds in both directions, climbing to the roots of these trees and predicting the rest of the structures in a top-down fashion.",
        "These capabilities make the algorithm attractive from the perspective of linguistic information processing, even if it does not improve the worst-case time bounds of already known TAGs parsers.",
        "The studied algorithm recognizes auxiliary trees without considering the substring dominated by the foot node, as is the case of the CYK-like algorithm in Vijay-Shanker and Joshi (1985).",
        "More precisely, Case 3 in the procedure Left-expander nondeterministically jumps over such a substring.",
        "Note that the alternative solution, which consists in waiting for possible analyses subsumed by the foot node, would prevent the algorithm from recognizing particular configurations, due to the bidirectional behaviour of the method (examples are left to the reader).",
        "On the contrary, Earley-like parsers for TAGs (Lang, 1990, Schabes, 1990) do care about substrings dominated by the foot node.",
        "However, these algorithms are forced to start at each foot node the recognition of all possible subtre,es of the elementary trees whose roots can be the locus of an adjunction.",
        "In this work, we have discussed a theoretical schema for the parser, in order to study its formal properties.",
        "In practical cases, such an algorithm could be considerably improved.",
        "For example, the above mentioned guess in Case 3 of the procedure Left-expander could take advantage of lookahead techniques.",
        "So far, we have not addressed topics such as substitution or on-line recognition.",
        "Our algorithm can be easily modified in these directions, adopting the same proposals advanced in (Schabes and Joshi, 1988).",
        "Finally, a parser for Lexicalized TAGs can be obtained from Algorithm 1.",
        "To this purpose, it suffices to store elements in Is into the recognition matrix T along with a list of pointers to those en tries that caused such elements to be placed in the matrix.",
        "Using this additional information, it is not difficult to exhibit an algorithm for the construction of the desired parser(s)."
      ]
    }
  ]
}
