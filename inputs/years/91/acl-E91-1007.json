{
  "info": {
    "authors": [
      "Stephen J. Hegner"
    ],
    "book": "Conference of the European Association for Computational Linguistics",
    "id": "acl-E91-1007",
    "title": "Horn Extended Feature Structures: Fast Unification With Negation and Limited Disjunction",
    "url": "https://aclweb.org/anthology/E91-1007",
    "year": 1991
  },
  "references": [
    "acl-J90-1002"
  ],
  "sections": [
    {
      "heading": "HORN EXTENDED FEATURE STRUCTURES: FAST UNIFICATION WITH NEGATION AND LIMITED DISJUNCTIONt",
      "text": [
        "telephone: (802)656-3330 internet: hegner@uvm.edu uucp: ..uunet!uvm-gen!hegner"
      ]
    },
    {
      "heading": "ABSTRACT",
      "text": [
        "The notion of a Horn extended feature structure (11oXF) is introduced, which is a feature structure constrained so that its only allowable extensions are those satisfying some set of Horn clauses in feature term logic.",
        "11oXF's greatly generalize ordinary feature structures in admitting explicit representation of negative and implicational constraints.",
        "In contradistinction to the general case in which arbitrary logical constraints are allowed (for which the best known algorithms are exponential), there is a highly tractable algorithm for the unification of HoXF's."
      ]
    },
    {
      "heading": "1. PRELIMINARY CONCEPTS",
      "text": []
    },
    {
      "heading": "1.1 Unification-based grammar formalisms Unification-based grammar formalisms constitute a cornerstone of many of the most important approaches to natural-language understanding (Shieber, 1986), (Colban, 1988), (Fenstad et al., 1989). The basic idea is that the parser generates a number of partial representations of the total parse, which are subsequently checked for consistency and combined by a second process known as a unifier. A common form of representation for the partial representations is that of feature structures, which are record-like data structures which are allowed to grow in three distinct ways: by adding missing values, by adding attributes, and by coalescing existing attributes (forcing them to be the same). The last operation may lead to cyclic structures, which we do not exclude. If the feature structure S2 is an extension of Si (i.e., Si grows into S2 by application of some sequence of the above rules), we write .91 C S2 and say that Si subsumes S2. Intuitively, if S1 C S2, S2 contains more information than does Si. It is easy to show that C is a partial order on the class of all feature structures.",
      "text": [
        "Each feature structure represents partial information generated during the parse.",
        "To obtain the total picture, these partial components must be combined tThe research reported herein was performed while the author was visiting the COSMOS Computational Linguistics Group of the Mathematics Department at the University of Oslo.",
        "He wishes to thank Jens Erik Fenstad and the members of that group for providing a stimulating research environment.",
        "Particular thanks are due Tore Langholm for many invaluable discussions regarding the interplay of logic, feature structures, and unification.",
        "into one consistent piece of knowledge.",
        "The formal process of unification is precisely this operation of combination.",
        "The most general unifier (mgu) S1 U S2 of feature structures Si and S2 is the least feature structure (under C) which is larger than both S1 and S2.",
        "Such an mgu exists if and only if S1 and S2 are consistent; that is, if and only if they subsume a common feature structure."
      ]
    },
    {
      "heading": "1.2 Unification algorithms and this paper While the idea of a most general unifier is a pleasing theoretical notion, its real utility rest with the fact that there are efficient algorithms for its computation. The fastest known algorithm, identified by Kit-Kaci (1984), runs in time which is, for all practical purposes, linear in the size of the input (i.e., the combined sizes of the structures to be unified). In proposing any extension to the basic framework, a primary consideration must be the complexity of the ensuing unification algorithm. The principal contribution of the research summarized here is to provide an extension of ordinary feature structures, admitting negation and limited disjunction, while at the same time continuing to admit a provably efficient unification algorithm.",
      "text": [
        "Due to space limitations, we must omit substantial background material from this paper.",
        "Specifically, we assume that the reader is familiar with the notation and definitions surrounding feature structures (Shieber, 1986; Fenstail et al., 1989), as well as the traditional unification algorithm (Colban, 1990).",
        "We also have been forced to omit much detail from the description and verification of our algorithm.",
        "A full report on this work will be available in the near future."
      ]
    },
    {
      "heading": "2. UNIFICATION IN THE PRESENCE OF CONSTRAINTS",
      "text": []
    },
    {
      "heading": "2.1 Constraints on feature structures Not every feature structure is a possibility as the ultimate output of the parsing mechanism. Typically, there are constraints which must be observed. One way of ensuring this sort of consistency is to build the checks right into the grammar, so that the feature structures generated are always legitimate substructures of the final output. The CLG formalism (Damas and Varile, 1989) is an example of such a philosophy. In many ways, this is an attractive option, because it provides a",
      "text": [
        "unified context for expressing all aspects of the grammar.",
        "However, this approach has the disadvantage that it limits the use of independent parsing subalgorithms whose results are subsequently unified, since the consistency checks must be performed before the feature structures are presented to the unifier.",
        "Therefore, to maintain such independence, it would be a distinct advantage if some of the constraint checking could be relegated to the unification process.",
        "To establish a formal framework in which this is possible, we must start by extending our notion of a feature structure.",
        "Following the ideas of Moshier and Rounds (1987) and Langholm (1989), we define an extended feature structure to be a pair (N, K) in which Kis a set of feature structures and N is the least ekment of K under the ordering C. (Thus, by definition, Khas a least element, and K determines N.) Think of Nas the \"current\" feature structure, and K as the set of all structures into which N is allowed to grow.",
        "We define (N1, K1) C. (N2, K2) to mean precisely that K2 C /C1.",
        "In other words, the set of all structures which N2 can grow into is a subset of those which N1 can grow into.",
        "(It follows necessarily that N1 C N2 in this case.)",
        "Note that if we identify the ordinary feature structure N with the pair (N, IM N C M)), we precisely recapture ordinary subsumption.",
        "Finally, the notion of unification associated with C. is given by",
        "has a least element M; undefinedotherwise."
      ]
    },
    {
      "heading": "2.2 Logical feature structures with constraints To operate on pairs of the form (N, K) algorithmically, we must have in place an appropriate representation for the set K. There are many possible choices; ours is to let it be the set of all structures satisfying a. set of sentences in a particular logic. The logic which we use is a simple modification of the language of Rounds and Kasper (1986) (see also (Kasper and Rounds, 1990)) admitting negation but only binary path equivalences. Specifically, an atomic feature term is one of the following.",
      "text": [
        "In (a : a), the label a may be T, denoting a missing value.",
        "The notation (a x 13) is borrowed from (Langholm, 1989), and has the same semantics as {a, ,e/} of (Rounds and Kasper, 1986).",
        "A (general) feature term is built up from atomic feature terms using the connectives A, v, and with the usual semantics.",
        "In particular, the negation we use is the classical notion; a structure satisfies (-y) if and only if it does not satisfy v. For any set 4) of feature terms, Mod(l)) denotes the set of all feature structures for which each co E 4' is true.",
        "For a formal definition of satisfaction, we refer the reader to the above-cited references.",
        "Intuitively, any set of terms which defines a consistent rooted, directed graph is satisfiable.",
        "However, let us specifically remark that only nodes with no outgoing edges may have labels other than T, that labels other than T may occur at at most one end point, that no two outgoing edges from the same node may have the same label, and that any term of the form (a : .L) is equivalent to 1, and so inconsistent.",
        "Now we define a logical extended feature structure (LoXF) to be an extended feature structure (N,K) in which K = Mod(41) for some consistent finite set 4' of feature terms.",
        "In particular, Mod(l.) must have a least model.",
        "We also denote this pair by Y(t)) (N+, Mod(4))).",
        "Now Y(4'1) C. F(4'2) reduces to Mod(4'2) C Mod(44), and",
        "has a least element under C; undefinedotherwise.",
        "The identically true term.",
        "The identically false term.",
        "The path (nesting of attributes) a exists and terminates with label a.",
        "The paths a and 13 have a common end point (coalesced end points).",
        "- 34 - exponential in the worst case.",
        "While such work is undeniably of great value, we here propose a companion strategy; namely, we restrict attention to pairs (N, 4') such that the very nature of tlo guarantees a tractable algorithm."
      ]
    },
    {
      "heading": "3. HORN FEATURE LOGIC",
      "text": [
        "In the field of mathematical logic in general, and in the computational logic relevant to computer science in particular, Horn clauses play a very special role (Makowsky, 1987).",
        "Indeed, they form the basis for the programming language Prolog (Sterling and Shapiro, 1986) and the database language Datalog (Geri et al., 1989).",
        "This is due to the fact that while they possess substantial representational power, tractable inference algorithms are well known.",
        "It is perhaps the main thesis of this work that the utility of llorn clauses carries over to computational linguistics as well."
      ]
    },
    {
      "heading": "3.1 Horn feature clauses A feature literal is either an atomic feature term (e.g., (a : a), (a x 19), or 1.) or its negation. A feature clause is a finite disjunction ti vf2v vt, of feature literals. A feature clause is Horn if at most one of the i's's is not negated. A Horn extended feature structure (HoXF) is a LoXF ./(4') such that 4' is a finite set of Horn feature clauses. 3.2 A taxonomy of Horn feature clauses Before moving on to a presentation of algorithms on lIoXF's, it is appropriate to provide a brief sketch of the utility and limits of restricting our attention to collections of Horn clauses. Implication here is classical; as in the case of ordinary propositional logic, we use the notation a1na2A m p to denote the clause",
      "text": [
        "-teri v-,a2V vp.",
        "Horn feature clauses may then be thought of as falling into one of the following four categories.",
        "(111) A clause of the form a, consisting of a single positive literal, is just a fact.",
        "(II2) A clause of the form consisting of a single negative literal, is a negated fact.",
        "In terms of 11oXF's, if --qx E 4', this means that within 1(4'), no extension of N. in which a is true is permitted.",
        "As a concrete example, a constraint stating that a subject may not have an attribute named \"tense\" would be of this form.",
        "(H3) A clause of the form aim:72 ... ani p is called a rule or an implication.",
        "Numerous examples of the utility of implication in linguistics are identified in (Wedekind, 1990, Sec. 1.3).",
        "Kasper's conditional descriptions (Kasper, 1988) are also a form of implication.",
        "More concretely, the requirement that a transitive verb requires a direct object is easily expressed in this form.",
        "(114) A clause of the form ai nay% .. .Aam I is called a compound negation.",
        "The formalization of the constraint that a verb cannot be both intransitive and take a direct object is an example of the use of such a clause.",
        "The type of knowledge which is not recapturable using Horn feature logic is positive disjunction; i.e., formulas of the form cri vcr2, with both cri and a2 feature terms.",
        "Of course, this has nothing in particular to do with feature-term logic, but is well-known limitation of Horn clauses in general.",
        "However, in accepting this limitation, we also obtain many key properties, including tractable inference and the following important property of genericity.",
        "3.3 Totally generic LoXF's Let now 4' be any finite set of feature terms.",
        "We say that (II is totally generic if, for any set 11 of facts (see (H1) above), if Mod(l) U 4i) is nonempty then it contains a least element under C. Intuitively, if we use to define the LoXF 1(4'), total genericity says that however we extend the base feature structure N* (consistently with 4'), we will continue to have a LoXF.",
        "Remarkably, we have the following.",
        "3.4 Theorem A set of feature terms (1) is totally generic if and only if it is equivalent to a set of Horn feature clauses.",
        "Proof outline: This result is essentially a translation of (Makowsky, 1987, Thm.",
        "1.9) to the logic of feature structures.",
        "In words, it says that if (and only if) we work with IloXF's, condition (u2) on page 4 becomes superfluous (except for explicitly identifying the least model.)",
        "0 4.",
        "THE EXTENDED UNIFICATION ALGORITHM It has been shown by Dowling and Gallier (1984) that satisfiability for finite sets of propositional Horn formulas can be tested in time linear in the length of the formulas.",
        "Their algorithms can easily be modified to deliver the least model as well.",
        "Since unification of HoXF's is essentially testing for satisfiability plus identifying the least model (see (u1)-u(2) on the previous page), a natural approach would be to adapt one of their algorithms.",
        "Essentially, this is what we do.",
        "Like theirs, our algorithm is forward chaining, we start with the facts and \"fire\" rules until no more can be fired, or until a contradiction appears.",
        "However, the adaptation is not trivial, because feature-term logic is more expressive than propositional logic.",
        "In particular, feature-term logic contains countably many tautologies which have no correlates in ordinary propositional logic.",
        "The main contribution of our algorithm is to implicitly recapture the full semantics of these tautologies while keeping the time complexity within reasonable bounds.",
        "Due to space limitations, we cannot present the full formality of the rather complex data structures.",
        "Rather, to highlight the key features, we step through an annotated example.",
        "We focus only upon the special problems inherent in the extension to feature-term logic, and assume familiarity with the forward-chaining algorithm in (Dowling and Gallier, 1984) and the graph unification algorithm in (Colban, 1990).",
        "4.1 An example theory and extended feature graphs The set E contains the following eight Horn feature clauses.",
        "(6) (AA : a).",
        "(6) (B : a).",
        "(6) (AA :a)A(B : a) (CCDDG : t).",
        "(6) (A :T)A(C : T) (ABDDG : T).",
        "(es) (AA x B)A(ABDDG : T) (ABDDEF : T).",
        "(es) (ABDD: T)A(B : T) (CCD x ADD).",
        "(T) (CCDD x ABDD)#.",
        "(AC : T).",
        "If we delete the remaining virtual nodes and edges, we obtain the graphical representation of the least model of E."
      ]
    },
    {
      "heading": "4.2 Computing the minimal model of the example Now let us consider the process of actually obtaining the structure of Figure 2 from a In the",
      "text": [
        "We must eventually invoke a unification at the common end point of CCD and ADD.",
        "Such unification implicitly entails the tautology (CCD x ADD) (CCDD ABDD) and permits us to conclude that rule t7 should fire and add (AC: T) to the set of facts of the least model.",
        "The result represented by the final extended feature graph of Figure 2.",
        "Note that rule 6 never fires, and that there are virtual edges and nodes left at the conclusion of the process."
      ]
    },
    {
      "heading": "4.3 A taxonomy of implicit rules for sets of Horn feature clauses As we remarked in the introduction to this section, to correctly adapt forward chaining to the context of 11oXF's, we must implicitly include the semantics of countably many tautologies. These fall into three classes.",
      "text": [
        "(ii) Whenever an atomic term of the form (aft : a) is determined to be true (c0 denotes the concatenation of a and fi), and another term of the form o0- ---,- o o --o:",
        "T) occurs as an antecedent of a horn feature clause, (with either ft not the empty string or else aT), we must be able to automatically make the deduction of the tautology (a() : a) (a : T) to conclude that (a : T) is now true.",
        "We call this node and path subsumption.",
        "In computing the least model of E, the deductions (A fl : a) (A : T) and",
        "(B : a) (B : T) are examples of such rules.",
        "(i2) Whenever we deduce two terms of the form (a : a) and (fi : a) to be true, with a T, we must implicitly realize the semantics of the rule (a : a)A(f3 : a) (a x fl), due to the constraint that non T labels are unique.",
        "We call this label matching.",
        "In computing the least model of E, the deduction (AA : a)A(B : a) (AA x B) is a specific example.",
        "(13) Whenever we coalesce two paths, we must perform local unification on the subgraph rooted at the point of coalescence.",
        "More precisely, if we coalesce the paths a and fl, and the atom (ay : a) is true, we must deduce that both (ay x fly) and (fly : a) are true; i.e., we must implicitly realize the compound rule (a x MA(a-y : a) (a)' x fl-y)A(f/y : a).",
        "This is just a logical representation of local unification.",
        "In computing the least model of E, a specific example is the deduction (CCD x AB D)A(CCDDG : t) (CCDDG ABDDG)A(ABDDG : I).",
        "4.4 Data structures To support these inferences, several specific data structures are supported.",
        "They are sketched below.",
        "(dl) There is the list of clauses.",
        "Each clause has a counter associated with it, indicating the number of literals which remain to be fired before its left-hand side is satisfied.",
        "When this count drops to zero, the clause fires and its consequent becomes true.",
        "012) There is a list of atoms which occur in the antecedents of clauses.",
        "With each literal is associated a set of pointers, one to each clause of which it is an antecedent literal.",
        "When an atom becomes true, the appropriate clauses are notified, so they may decrement their counters.",
        "(d3) The working extended feature structure, as illustrated in Figures 1-4, is maintained throughout.",
        "(d4) For each node in the working extended feature structure, a list of atoms is maintained.",
        "If the node label is a, then each such atom in the list is of the form (a : a), with a a path from the root node to the node under consideration.",
        "When that node becomes actual, that atom is notified that is is now satisfied.",
        "(d5) For each non-T node label a which occurs in some atom, a list of all virtual nodes with that label is maintained.",
        "When one such node becomes actual, the other are checked to see if an inference of the form (i2) should be made.",
        "(d6) For each atom of the fo:m (a x /3) occurring as an antecedent in sonic clause, the nodes at the ends of these paths in the working extended feature structure are endowed with a common tag.",
        "Whenever nodes are coalesced, a check for such common tags is made, so the appropriate atom may he notified that it is now true.",
        "4.5 Independent processes and unification The algorithm also maintains a ready queue of available processes.",
        "These processes are of three types.",
        "A process of the form Actual(a : a), when executed, makes the identified path and label actual in the extended feature graph.",
        "A process of the form Coalesce(ni , n2) coalesces the end points of the two nodes ni and na in the extended feature graph.",
        "A process of the form Unify(n) performs a local unification at the subgraph rooted at node n, using an algorithm such as identified in (Colban, 1990).",
        "All processes in the ready queue commute; they may be executed in any order.",
        "To unify two distinct sets of terms (perhaps generated by independent parts of a parser), we join their two extended feature graphs at the root, merge the corresponding data structures, and add the command Unify(root) to the merged process queue.",
        "In other words, we perform a unification to match common information, and then continue with the inference process."
      ]
    },
    {
      "heading": "4.6 The complexity of the unification algorithm Define the length of a literal to be the number of attribute name and attribute value occurrences in it. Thus, for example, length((AB x CD)) = 4 and leugth((ABCD : a)) = 5. For a set 4) of horn feature clauses, we further define the following quantities.",
      "text": [
        "We then have the following theorem."
      ]
    },
    {
      "heading": "5. CONCLUSIONS, FURTHER DIRECTIONS, AND PROJECT STATUS",
      "text": []
    },
    {
      "heading": "5.1 Conclusions and further directions We have identified lloXF's as an attractive compromise between ordinary feature structures (in which there is no way to express constraints on growth) and full logical feature theories (for which the unification problem is NP-complete). We view HoXF's not as the \"best\" approach, but rather as a tool to be used to build better overall unification-based grammar formalisms. The obvious next step is to develop an integrated framework in which HoXF's are employed to handle negation and the disjunction arising from implication, while other techniques handle more general disjunction and term subsumption (Smolka, 1988). Such an optimized approach could lead to much faster overall handling of negation and disjunction, but, further work is clearly needed to bear this out. 5.2 Status of the project While the algorithm has been spelled out in considerable detail, we have just begun to build an actual implementation of the IloXF unifier in the programming language Scheme. We expect to complete the implementation by the summer of 1991.",
      "text": []
    }
  ]
}
