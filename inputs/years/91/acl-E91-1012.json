{
  "info": {
    "authors": [
      "Rene Leermakers"
    ],
    "book": "Conference of the European Association for Computational Linguistics",
    "id": "acl-E91-1012",
    "title": "Non-Deterministic Recursive Ascent Parsing",
    "url": "https://aclweb.org/anthology/E91-1012",
    "year": 1991
  },
  "references": [],
  "sections": [
    {
      "heading": "ABSTRACT",
      "text": [
        "A purely functional implementation of LR-parsers is given, together with a simple correctness proof.",
        "It is presented as a generalization of the recursive descent parser.",
        "For non-LR grammars the time-complexity of our parser is cubic if the functions that constitute the parser are implemented as memo-functions, i.e. functions that memorize the results of previous invocations.",
        "Memo-functions also facilitate a simple way to construct a very compact representation of the parse forest.",
        "For LR(0) grammars, our algorithm is closely related to the recursive ascent parsers recently discovered by Kruse-man Aretz [1] and Roberts [2].",
        "Extended CF grammars (grammars with regular expressions at the right hand side) can be parsed with a simple modification of the LR-parser for normal CF grammars."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "In this paper we give a purely functional implementation of LR-parsers, applicable to general CF grammars.",
        "It will be obtained as a generalization of the well-known recursive descent parsing technique.",
        "For LR(0) grammars, our result implies a deterministic parser that is closely related to the recursive ascent parsers discovered by Kruseman Aretz [1] and Roberts [2].",
        "In the general non-deterministic case, the parser has cubic time complexity if the parse functions are implemented as memo-functions [3], which are functions that memorize and reuse the results of previous invocations.",
        "Memo-functions are easily implemented in most programming languages.",
        "The notion of memo-functions is also used to define an algorithm that constructs a cubic representation for the parse forest, i.e. the collection of parse trees.",
        "It has been claimed by Tomita that non-deterministic LR-parsers are useful for natural language processing.",
        "In [4] he presented a discussion about how to do nondeterministic LR-parsing, with a device called a graph-structured stack.",
        "With our parser we show that no explicit stack manipulations are needed; they can be expressed implicitly with the use of appropriate programming language concepts.",
        "Most textbooks on parsing do not include proper correctness proofs for LR-parsers, mainly because such proofs tend to be rather involved.",
        "The theory of LR-parsing should still be considered underdeveloped, for this reason.",
        "Our presentation, however, contains a surprisingly simple correctness proof.",
        "In fact, this proof is this paper's major contribution to parsing theory.",
        "One of its lessons is that the CF grammar class is often the natural one to proof parsers for, even if these parsers are devoted to some special class of grammars.",
        "If the grammar, is restricted in some way, a parser for general CF grammars may have properties that enable smart implementation tricks to enhance efficiency.",
        "As we show below, the relation between LR-parsers and LR-grammars is of this kind.",
        "Especially in natural language processing, standard CF grammars are often too limited in their strong generative power.",
        "The extended CF grammar formalism, allowing rules to have regular expressions at the right hand side, is a useful extension, for that reason.",
        "It is not difficult to generalize our parser to cope with extended grammars, although the application of LR-parsing to extended CF grammars is well-known to be problematic [5]• We first present the recursive descent recognizer in a way that allows the desired generalization.",
        "Then we obtain the recursive ascent recognizer and its proof.",
        "If the grammar is LR(0) a few implementation tricks lead to the recursive ascent recognizer of ref.",
        "[1].",
        "Subsequently, the time and space complexities of the recognizer are analysed, and the algorithm for constructing a cubic representation for parse forests is given.",
        "The paper ends with a discussion of extended CF grammars."
      ]
    },
    {
      "heading": "2 Recursive descent",
      "text": [
        "Consider CF grammar G, with terminals VT and nonterminals VN.",
        "Let V = VN U VT. A well-known top-down parsing technique is the recursive descent parser.",
        "Recursive descent parsers consist of a number of procedures, usually one for each non-terminal.",
        "Here we present a variant that consists of functions, one for each item (dotted rule).",
        "We use the unorthodox embracing operator [•] to map each item to its function: (we use greek letters for arbitrary elements of V')",
        "where N is the set of integers, or a subset (0...n.or ), with nmas the maximum sentence length.",
        "The functions are to meet the following specification:",
        "with xi ...x „ the sentence to be parsed.",
        "A recursive implementation for these functions is given by (b E VT, B E",
        "We keep to the custom of omitting existential quantification (here for k, 6) in definitions, of this kind.",
        "The proof is elementary and based on",
        "If we add a grammar rule S' S to G, with S' ft V then S --o* xi...xn is equivalent to n E [S1 o .S](0).",
        "The recursive descent recognizer works for any CF grammar except for grammars for which 3,1,,,p(A Ao, --o• An For such left-recursive grammars the recognizer does not terminate, as execution of [A –+ .a](i) will lead to a call of itself.",
        "The recognition is not a linear process in general: the function calls [A a./37](i) lead to calls [B –+ .6](i) for all values of 6 such that B –+ 6 is a grammar rule."
      ]
    },
    {
      "heading": "3 The ascent recognizer",
      "text": [
        "One way to make the recognizer more deterministic is by combining functions corresponding to a number of competing items into one function.",
        "Let the set of all items of G be given by Subsets of IG, are called states, and we use q to be an arbitrary state.",
        "We associate to each state q a function, reusing the above operator [•],",
        "As above, the function reports which parts of the sentence can be derived.",
        "But as the function is associated to a set q of items, it has to do so for each item in q.",
        "If we define the initial state qo = {S' –+ .S}, now S xi ...x. is equivalent to (S' .S, n) E [qo](0).",
        "Before proceeding, we need a couple of definitions.",
        "Let ini(q) be the set of initial items for state q, that are derived from q by the closure operation:",
        "The double arrow denotes a left-most-symbol rewriting Ba C fila, using a non-c rule B C/3.",
        "The transition function goto is defined by (B E V) goto(q, B) = fA a B.flIA a.13$ E (q U ini(q))} Also define",
        "f inal(A a 13) = (1/31 = 0) with B E V, and 1)31 the number of symbols in /9 (with lei = 0).",
        "A recursive ascent recognizer may be obtained by relating to each state q not only the above [q], but also a function that we take to be the result of applying operator [•] to the state:",
        "This is equivalent to the earlier version because we may replace the clause B c by B --■ .c E ini(q).",
        "Indeed, if state q has item A cr.# and if there is a left-most-symbol derivation /3 * B7 then all items B –0 .A are included in ini(q).",
        " – For establishing the correctness of [q] notice that * B7 either contains zero steps, in which case /3 = Thy, or it contains at least one step:",
        "Also, as before, 0 • C7 implies that all items C are in ini(q), and the existence of C .Bb in ini(q)",
        "In the computation of [qo](0), functions are needed only for states in the canonical collection of LR(0) states [6] for G, i.e. for every state that can be reached from the initial state by repeated application of the got° function.",
        "Note that in general the state 0 will be among these, and that both [0](i) and [0](B, i) are empty sets for all i > 0 and B E V."
      ]
    },
    {
      "heading": "4 Deterministic variants",
      "text": [
        "One can prove that, if the grammar is LR(0), each recognizer function for a canonical LR(0) state results in a set with at most one element.",
        "The functions for nonempty q may in this case be rephrased as [q](i) if, for some I, I E qAfinal(I) then return ((I,1)) else if B .c E ini(q) then return [q](B, i)",
        "let (I, j) be the unique element of [goto(q, B)](i).",
        "Then: if pop(I) E q then return {(pop(I), j)} else return fq1(11is(1), j) fi fi Reversely, the implementations of [q](i) and [q](B , i) of the previous section can be seen as non-deterministic versions of the present formulation, which therefore provides an intuitive picture that may be helpful to understand the non-deterministic parsing process in an operational way.",
        "Each function can be replaced by a procedure that, instead of returning a function result, assigns the result to a global (set) variable.",
        "As this set variable may contain at most one element, it can be represented by three variables, a boolean b, an item R and an integer 1.",
        "If a function would have resulted in the set {(I, j)}, the global variables are set to b = TRUE, R = I and i = j.",
        "A function value 0 is represented by b= FALSE.",
        "Also the arguments of the functions are superfluous now.",
        "The role of argument i can be played by the global variable with the same name, and lhs(R) can be used instead of argument B of [q].",
        "Consequently, procedure [0] becomes a statement b := FALSE, whereas for non-empty q one gets the procedures (keeping the names [q] and [q], trusting no confusion will arise): [q]: if, for some I, I E g A f inal(I) then R := I else if B E ini(q) then R := B (.",
        "; [q]",
        "Note that these procedures do not depend on the details of the right hand side of R. Only the number of symbols before the dot is relevant for the test \"pop(R) E q\".",
        "Therefore, R can be replaced by two variables X E V and an integer 1, making the following substitutions in the previous procedures:",
        "After these substitutions, one gets close to the recursive ascent recognizer as it was presented in [1].",
        "A recognizer that is virtually the same as in [Ills obtained by replacing the tail-recursive procedure [q] by an iterative loop.",
        "Then one is left with one procedure for each state.",
        "While parsing there is, at each instance, a stack of activated procedures that corresponds to the stacks that are explicitly maintained in conventional implementations of deterministic LR-parsers."
      ]
    },
    {
      "heading": "5 Complexity",
      "text": [
        "For LL(0) grammars the recursive descent recognizer is deterministic and works in linear time.",
        "The same is true of the ascent recognizer for LR(0) grammars.",
        "In the general, non-deterministic, case the recursive descent and ascent recognizers need exponential time unless the functions are implemented as memo-functions [3].",
        "Memo-functions memorize for which arguments they have been called.",
        "If a function is called with the same arguments as before, the function returns the previous result without recomputing it.",
        "In conventional programming languages memo-functions are not available, but they can easily be implemented.",
        "Devices like graph-structured stacks [4], parse matrices [7], or well-formed substring tables [8], are in fact low-level realizations of the abstract notion of memo-functions.",
        "The complexity analysis of the recognizers is quite simple.",
        "There are O(n) different invocations of parser functions.",
        "The functions call at most 0(n) other functions, that all result in a set with 0(n) elements (note that there exist only 0(n) pairs (I, j) with I E IG, i < j < n).",
        "Merging these sets to one set with no duplicates can be accomplished in 0(n2) time on a random access machine.",
        "Hence, the total time-complexity is 0(n3).",
        "The space needed for storing function results is 0(n) per invocation, i.e. 0(n2) for the whole recognizer.",
        "The above considerations only hold if the parser terminates.",
        "The recursive descent parser terminates for all grammars that are not left-recursive.",
        "For the recursive ascent parser, the situation is more complicated.",
        "if the grammar has a cyclic derivation B B, the execution of [q](B, i) leads to a call of itself.",
        "Also, there may be a cycle of transitions labeled by non-terminals that derive c, e.g. if goto(q, B) = q A B f, so that the execution of [q](i) leads to a call of itself.",
        "There are non-cyclic grammars that suffer from such a cycle (e.g. S SSb, S c).",
        "Hence, the ascent parser does not terminate if the grammar is cyclic or if it leads to a cycle of transitions labeledby non-terminals that derive e. Otherwise, execution of [q](B, i) can only lead to calls of [p](i) with p q and to calls of [q](C, k), such that either k > i orC--oeBACO B.",
        "As there are only finitely many such p, C, the parser terminates.",
        "Note that both the recursive descent and ascent recognizer terminate for any grammar, if the recognizer functions are implemented as memo-functions with the property that a call of a function with some arguments yields 0 while it is under execution.",
        "For instance, if execution of [q](i) leads to a call of itself, the second call is to yield 0.",
        "A remark of this kind, for the recursive descent parser, was first made in ref.",
        "[8].",
        "The recursive descent parser then becomes virtually equivalent to a version of the standard Earley algorithm [9] that stores items A -+ a./3 in parse matrix entry 71, if /3 – +' instead of storing it if a --+• xs+1...x,.",
        "The space required for a parser that also calculates a parse forest, is dominated by this forest.",
        "We show in the next section that it may be compressed into a cubic amount of space.",
        "In the complexity domain our ascent parser beats its rival, Tomita's parsing method [4], which is non-polynomial: for each integer k there exists a grammar such that the complexity of the Tomita parser is worse than nk.",
        "In addition to the complexity as a function of sentence length, one may also consider the complexity as a function of grammar size.",
        "It is clear that both time and space complexity are proportional to the number of parsing procedures.",
        "The number of procedures of the recursive descent parser is proportional to the number of items, and hence a linear function of the grammar size.",
        "The recursive ascent parser, however, contains two functions for each LR-state and is hence proportional to the size of the canonical collection of LR(0) states.",
        "In the worst case, this size is an exponential function of grammar size, but in the average natural language case there seems to be a linear, or even sublinear, dependence [4]."
      ]
    },
    {
      "heading": "6 Parse forest",
      "text": [
        "Usually, the recognition process is followed by the construction of parse trees.",
        "For ambiguous grammars, it becomes an issue how to represent the set of parse trees as compactly as possible.",
        "Below, we describe how to obtain a cubic representation in cubic time.",
        "We do so in three steps.",
        "In the first step, we observe that ambiguity often arises locally: given a certain context CH, there might be several parse subtrees ti...tk (all deriving the same substring from the same symbol A) that fit in that same context, leading to the parse trees C[11], C[12], ... ,C[tk] for the given string xi...x..",
        "Instead of representing these parse trees separately, repeating each time the context C, we can represent them collectively as C[{ t1, tk)].",
        "Of course, this idea should be applied recursively.",
        "Technically, this leads to a kind of treelike structure in which each child is a set of substructures rather than a single one.",
        "The sharing of context can be carried one step further.",
        "If we have, in one and the same context, a number of applied occurrences of a production rule A ail which share also the same parse forest for a, we can represent the context of A cv# itself and the common parse forest for a only once and fit the set of parse forests for /3 into that.",
        "Again this idea has to be applied recursively.",
        "Technically, this leads to a binary representation of parse trees, with each node having at most two sons, and to the application of the context sharing technique to this binary representation.",
        "These two ideas are captured by introducing a function f with the interpretation that f(fi,i,j) represents the parse forest of all derivations from p E V* to x,4.1...x.„ for all i, j such that 0 < i < j < n. The following recursive definitions fix the parse forest representation formally:",
        "i<k<jAA – +'x;+I...xkAB/3 – +'xk+l...x1},for all A, B E V .",
        "The representation for the set of parse trees is then just f(S, 0, n).",
        "We now come to our third step.",
        "Suppose, for the moment, that the guards a x,+1...x, and the like, occurring above, can be evaluated in some way or another.",
        "Then we can use function f to compute the representation of the set of parse trees for sentence If we make use of memo-functions to avoid repeated computation of a function applied to the same arguments, we see that there are at most 0(n2) function evaluations.",
        "If we represent function values by references to the set representations rather than by the sets themselves, the most complicated function evaluation consumes an additional amount of storage that is O(n): for j – i + 1 values of k we have to perform the construction of a pair of (copies of) two references, costing a unit amount of storage each.",
        "Therefore, the total amount of space needed for the representation of all parse trees is 0(n3).",
        "The evaluation of the guards a ...xi etc.",
        "amounts exactly to solving a collection of recognition problems.",
        "Note that a top-down parser is possible that merges the recognition and tree-building phases, by writing",
        "the other cases for f being left unchanged.",
        "Note the similarity between the recognizing part of this algorithm and the descent recognizer of section 2.",
        "Again, this parser is a cubic algorithm if we use memo-functions.",
        "Another approach is to apply a bottom-up recognizer first and derive from it a set P containing triples (13, j) only if /3 and at least those triples j) for which the guards /I are evaluated during the computation of f(S, 0,n) (i.e., for each derivation S 21...ZkA21+1•••Xn x1...xhafix34.1.••xn – 0* ...x,i3x3.4.1...xn xi...in, the triples (l, i, j) and (A, k, j) should be in P).",
        "The simplest way to obtain such P from our recognizer is to assume an implementation of memo-functions that enables access to the memoized function results, after executing [0](0).",
        "Then one has the disposal of the set {(ft, j)1[q](i) was invocated and",
        "Note, however, that no pairs (A .Q, j) are included in [q](i) (except if A = S').",
        "We remedy this with a slight change of the specifications of [q] and [q], defining",
        "A recursive implementation of the recognition functions now is",
        "If we define, for this revised recognizer,",
        "the other cases for f being left unchanged again.",
        "There exists a representation of P in quadratic space such that the presence or absence of an arbitrary triple can be decided upon in unit time.",
        "As a result, the time complexity of f (S, 0, n) is cubic."
      ]
    },
    {
      "heading": "7 Extended CF grammars",
      "text": [
        "An extended CF grammar consists of grammar rules with regular expressions at the right hand side.",
        "Every extended CF grammar can be translated into a normal CF grammar by replacing each right hand side by a regular (sub)grammar.",
        "The strong generative power is different from CF grammars, however, as the degree of the nodes in a derivation tree is unbounded.",
        "To apply our recognizer directly to extended grammars, a few of the foregoing definitions have to be revised.",
        "As before, a grammar rule is written A a, but with a now a regular expression with N. symbols (elements of V).",
        "Defining Ta = 1...N. and T. = 0...N., regular expression a can be characterized by 1. a mapping 1;60, : T;4\" – V associating a grammar symbol to each number.",
        "2„ a function succor : 2T.",
        ";,- mapping each number to its set of successors.",
        "The regular expression can start with the symbols corresponding to the numbers in succ.(0).",
        "3, a set a. E 2T°' of numbers of symbols the regular expression can end with.",
        "Note that 0 is not associated to a symbol in V and is not a possible element of succa(k).",
        "It can be element of as though, in which case there is an empty path through the regular expression.",
        "We define an item as a pair (A a, k), with the interpretation that number k is 'just before the dot'.",
        "The correspondence with dotted rules is the following.",
        "Let a = Bi...Bi, then a is a simple regular expression characterized by 4a(k) = 13k, succ.",
        "(k) = {k + 1} if 0 < k < 1, succ.",
        "(1) = 0, and a.",
        "= {l}.",
        "Item (A a, 0) corresponds to the initial item A – 0 .a and (A a, k) to the dotted-rule item with the dot just after Bk.",
        "The predicate final for the new kind of items is defined by final((A a, k)) = (k E cra) Given a set q of items, we define",
        "The function pop becomes set-valued and the transition function can be defined in terms of it (remember: V = ini(q)):",
        "The initial state qo is f(S' S, 0)), and a sentence xi is grammatical if ((S' –+ S, 0), n) E [0](0).",
        "The recognizer is deterministic if",
        "1. there is no shift-reduce or reduce-reduce conflict, i.e. every state has at most one final item, and in case it has a final item it has no items (A a, j) with k E succ„,(j) A ¢a(k) E VT. 2. for all reachable states q, q fl ini(q) = 0, and for all",
        "I there is at most one J E q such that J E pop(l).",
        "In the deterministic case, the analysis of section 4 can be repeated with one exception: extended grammar items can not be represented by a non-terminal and an integer that equals the number of symbols before the dot, as this notion is irrelevant in the case of regular expressions.",
        "In standard presentations of deterministic LR-parsing this leads to almost unsurmountable problems [5]."
      ]
    },
    {
      "heading": "8 Conclusions",
      "text": [
        "We established a very simple and elegant implementation of LR(0) parsing.",
        "It is easily extended to LALR(k) parsing by letting the functions [q] produce pairs with final items only after inspection of the next k input symbols.",
        "The functional LR-parser provides a high-level view of LR-parsing, compared to conventional implementations.",
        "A case in point is the ubiquitous stack, that simply cor-respon4 to the procedure stack in the functional case.",
        "As the proof of a functional LR-parser is not hindered by unnecessary implementation details, it can be very compact.",
        "Nevertheless, the functional implementation is as efficient as conventional ones.",
        "Also, the notion of memo-functions is an important primitive for presenting algorithms at a level of abstraction that can not be achieved without them, as is exemplified by this paper's presentation of both the recognizers and the parse forests.",
        "For non-LR grammars, there is no reason to use the complicated Tomita algorithm.",
        "If indeed nondeterministic LR-parsers beat the Earley algorithm for some natural language grammars, as claimed in [4], this is because the number of LR(0) states may be smaller than the size of /G for such grammars.",
        "Evidently, for the grammars examined in [4] this advantage compensates the loss of efficiency caused by the non-polynomiality of Tomita's algorithm.",
        "The present algorithm seems to have the possible advantage of Tomita's parser, while being polynomial.",
        "Acknowledgement A considerable part of this research was done in collaboration with Lex Augusteyn and Frans Krusernan Aretz.",
        "Both are colleagues at Philips Research."
      ]
    }
  ]
}
