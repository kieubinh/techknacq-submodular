{
  "info": {
    "authors": [
      "Fernando Pereira"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P91-1032",
    "title": "Finite-State Approximation of Phrase Structure Grammars",
    "url": "https://aclweb.org/anthology/P91-1032",
    "year": 1991
  },
  "references": [
    "acl-J82-3004",
    "acl-J89-4001",
    "acl-P85-1018"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Phrase-structure grammars are an effective representation for important syntactic and semantic aspects of natural languages, but are computationally too demanding for use as language models in real-time speech recognition.",
        "An algorithm is described that computes finite-state approximations for context-free grammars and equivalent augmented phrase-structure grammar formalisms.",
        "The approximation is exact for certain context-free grammars generating regular languages, including all left-linear and right-linear context-free grammars.",
        "The algorithm has been used to construct finite-state language models for limited-domain speech recognition tasks."
      ]
    },
    {
      "heading": "1 Motivation",
      "text": [
        "Grammars for spoken language systems are subject to the conflicting requirements of language modeling for recognition and of language analysis for sentence interpretation.",
        "Current recognition algorithms can most directly use finite-state acceptor (FSA) language models.",
        "However, these models are inadequate for language interpretation, since they cannot express the relevant syntactic and semantic regularities.",
        "Augmented phrase structure grammar (APSG) formalisms, such as unification-based grammars (Shieber, 1985a), can express many of those regularities, but they are computationally less suitable for language modeling, because of the inherent cost of computing state transitions in APSG parsers.",
        "The above problems might be circumvented by using separate grammars for language modeling and language interpretation.",
        "Ideally, the recognition grammar should not reject sentences acceptable by the interpretation grammar and it should contain as much as reasonable of the constraints built into the interpretation grammar.",
        "However, if the two grammars are built independently, those goals are difficult to maintain.",
        "For this reason, we have developed a method for constructing automatically a finite-state approximation for an APSG.",
        "Since the approximation serves as language model for a speech-recognition front-end to the real parser, we require it to be sound in the sense that the it accepts all strings in the language defined by the APSG.",
        "Without qualification, the term \"approximation\" will always mean here \"sound approximation.\"",
        "If no further constraints were placed on the closeness of the approximation, the trivial algorithm that assigns to any APSG over alphabet E the regular language E* would do, but of course this language model is useless.",
        "One possible criterion for \"goodness\" of approximation arises from the observation that many interesting phrase-structure grammars have substantial parts that accept regular languages.",
        "That does not mean that the grammar rules are in the standard forms for defining regular languages (left-linear or right-linear), because syntactic and semantic considerations often require that strings in a regular set be assigned structural descriptions not definable by left or right-linear rules.",
        "A useful criterion is thus that if a grammar generates a regular language, the approximation algorithm yields an acceptor for that regular language.",
        "In other words, one would like the algorithm to be exact for APSGs yielding regular languages.1 While we have not proved that in general our method satisfies the above exactness criterion, we show in Section 3.2 that the method is exact for left-linear and right-linear grammars, two important classes of context-free grammars generating regular languages."
      ]
    },
    {
      "heading": "2 The Algorithm",
      "text": [
        "Our approximation method applies to any context-free grammar (CFG), or any unification-based grammar (Shieber, 1985a) that can be fully expanded into a context-free grammar.",
        "The resulting FSA accepts all the sentences accepted by the input grammar, and possibly some non-sentences as well.",
        "The current implementation accepts as input a form of unification grammar in which features can take only atomic values drawn from a specified finite set.",
        "Such grammars can only generate context-free languages, since an equivalent CFG can be obtained by instantiating features in rules in all possible ways.",
        "The heart of our approximation method is an algorithm to convert the LR(0) characteristic machine M(G) (Aho and Ullman, 1977; Backhouse, 1979) of a CFG G into an FSA for a superset of the language L(G) defined by G. The characteristic machine for a CFG G is an FSA for the viable prefixes of G, which are just the possible stacks built by the standard shift-reduce recognizer for G when recognizing strings in L(G).",
        "This is not the place to review the characteristic machine construction in detail.",
        "However, to explain the approximation algorithm we will need to recall the main aspects of the construction.",
        "The states of M(G) are sets of dotted ',des A a • /3 where A --+ a# is some rule of G. M(G) is the determinization by the standard subset construction (Aho and Ullman, 1977) of the FSA defined as follows:",
        "• The initial state is the dotted rule S' where S is the start symbol of G and S' is a new auxiliary start symbol.",
        "• The final state is 5' S. • The other states are all the possible dotted rules of G. • There is a transition labeled X, where X is a terminal or nonterminal symbol, from dotted rule A a • X13 to A aX • #.",
        "• There is an c-transition from A a • BP to",
        "B -7, where B is a nonterminal symbol and B 7 a rule in G.",
        "M(G) can be seen as the finite state control for a nondeterministic shift-reduce pushdown recognizer R(G) for G. A state transition labeled by a terminal symbol x from state s to state s' licenses a shift move, pushing onto the stack of the recognizer the pair (s, x).",
        "Arrival at a state containing a completed dotted rule A a• licenses a reduction move.",
        "This pops from the stack as many pairs as the symbols in a, checking that the symbols in the pairs match the corresponding elements of a, and then takes the transition out of the last state popped s labeled by A, pushing (s, A) onto the stack.",
        "(Full definitions of those concepts are given in Section 3.)",
        "The basic ingredient of our approximation algorithm is the flattening of a shift-reduce recognizer for a grammar G into an FSA by eliminating the stack and turning reduce moves into c-transitions.",
        "It will be seen below that flattening 71(G) directly leads to poor approximations in many interesting cases.",
        "Instead, M(G) must first be unfolded into a larger machine whose states carry information about the possible stacks of R(G).",
        "The quality of the approximation is crucially influenced by how much stack information is encoded in the states of the unfolded machine: too little leads to coarse approximations, while too much leads to redundant automata needing very expensive optimization.",
        "The algorithm is best understood with a simple example.",
        "Consider the left-linear grammar G1",
        "M(Gi) is shown on Figure 1.",
        "Unfolding is not required for this simple example, so the approximating FSA is obtained from M(G1) by the flattening method outlined above.",
        "The reducing states in M(G1), those containing completed dotted rules, are states 0, 3 and 4.",
        "For instance, the reduction at state 4 would lead to a transition on nonter",
        "minal A, to state 2, from the state that activated the rule being reduced.",
        "Thus the corresponding &transition goes from state 4 to state 2.",
        "Adding all the transitions that arise in this way we obtain the FSA in Figure 2.",
        "From this point on, the arcs labeled with nonterminals can be deleted, and after simplification we obtain the deterministic finite automaton (DFA) in Figure 3, which is the minimal DFA for L(Gi).",
        "If flattening were always applied to the LR(0) characteristic machine as in the example above, even simple grammars defining regular languages might be inexactly approximated by the algorithm.",
        "The reason for this is that in general the reduction at a given reducing state in the characteristic machine transfers to different states depending on context.",
        "In other words, the reducing state might be reached by different routes which use the result of the reduction in different ways.",
        "Consider for example the grammar G2"
      ]
    },
    {
      "heading": "S aX a I lab X – + c",
      "text": [
        "which accepts just the two strings aca and bcb.",
        "Flattening M(G2) will produce an FSA that will also accept acb and bca, an undesirable outcome.",
        "The reason for this is that the &transitions leaving the reducing state containing X c. do not distinguish between the different ways of reaching that state, which are encoded in the stack of 72.(G2).",
        "One way of solving the above problem is to unfold each state of the characteristic machine into a set of states corresponding to different stacks at that state, and flattening the corresponding recognizer rather than the original one.",
        "However, the set of possible stacks at a state is in general infinite.",
        "Therefore, it is necessary to do the unfolding not with respect to stacks, but with respect to a finite partition of the set of stacks possible at the state, induced by an appropriate equivalence relation.",
        "The relation we use currently makes two stacks equivalent if they can be made identical by collapsing loops, that is, removing portions of stack pushed between two arrivals at the same state in the finite-state control of the shift-reduce recognizer.",
        "The purpose of collapsing loops is to \"forget\" stack segments that may be arbitrarily repeated.3 Each equivalence class is uniquely defined by the shortest stack in the class, and the classes can be constructed without having to consider all the (infinitely) many possible stacks."
      ]
    },
    {
      "heading": "3 Formal Properties",
      "text": [
        "In this section, we will show here that the approximation method described informally in the previous section is sound for arbitrary CFGs and is exact for left-linear and right-linear CFGs.",
        "In what follows, G is a fixed CFG with terminal vocabulary E, nonterminal vocabulary N, and start symbol S; V = EUN."
      ]
    },
    {
      "heading": "3.1 Soundness",
      "text": [
        "Let M be the characteristic machine for G, with state set Q, start state so, set of final states F, and transition function 6 :Sx V S. As usual, transition functions such as b are extended from input symbols to input strings by defining 6(s, c) = s and b(s, a13) = 6(6(s, a), #).",
        "The shift-reduce recognizer R. associated to M has the same states, start state and final states.",
        "Its configurations are triples (s,cr, w) of a state, a stack and an input string.",
        "The stack is a sequence of pairs (s, X) of a state and a symbol.",
        "The transitions of the shift-reduce recognizer are given as follows:",
        "3Since possible stacks can be shown to form a regular language, loop collapsing has a direct connection to the pumping lemma for regular languages.",
        "in s, s\" = s and r is empty, or (2) A 0 X1 Xn.",
        "is a completed dotted rule in s, T = (81, JC1) • • (s,,, Xn) and s\" = si.",
        "The initial configurations of R are (so, c, w) for some input string w, and the final configurations are (s, (so, S), c) for some state s E F. A derivation of a string w is a sequence of configurations co, ,C, such that co = (so, c, w), Cm = (s, (so, S), c) for some final state s, and ci_i F ci for 1 <i < n. Let s be a state.",
        "We define the set Stacks(s) to contain every sequence (so, X0).",
        ".",
        ".",
        "(sk, Xk) such that si = O(si-i, Xi-i),1 < i < k and s = b(sk , X k).",
        "In addition, Stacks(so) contains the empty sequence c. By construction, it is clear that if (s, a, w) is reachable from an initial configuration in R, then a E Stacks(s).",
        "A stack congruence on R is a family of equivalence relations s--, on Stacks(s) for each state s E S such that if a a , el.'",
        "and b(s, X) = s' then (s, X) cr(s, X).",
        "A stack congruence partitions each set Stacks(s) into equivalence classes [a], of the stacks in Stacks(s) equivalent to a under Es.",
        "Each stack congruence E on R induces a corresponding unfolded recognizer R. .",
        "The states of the unfolded recognizer are pairs (s, [a] „) , notated more concisely as [o]s, of a state and stack equivalence class at that state.",
        "The initial state is [fro, and the final states are all Ecd.",
        "with s E F and cr E Stacks(s).",
        "The transition function b= of the unfolded recognizer is defined by baaar , X) = [a (s, X)]6(8.x) That this is well-defined follows immediately from the definition of stack congruence.",
        "The definitions of dotted rules in states, configurations, shift and reduce transitions given above carry over immediately to unfolded recognizers.",
        "Also, the characteristic recognizer can also be seen as an unfolded recognizer for the trivial coarsest congruence.",
        "Unfolding a characteristic recognizer does not change the language accepted:",
        "Proof: We show first that any string w accepted by R. is accepted by R.. Let do, ..., dm be a derivation of w in 1Z.",
        "Each di has the form = ([pds.",
        "ai, ui), and can be mapped to an R configuration d = (s;, erhui), where = c and ((s, C), X) = r(s, X).",
        "It is straightforward to verify that do, , dm is a derivation of w in 1Z.",
        "Conversely, let w E L(G), and co, ,Cm be a derivation of w in R, with ci = (si, ui).",
        "We define ë, = er,, ui), where e = c and",
        "Thus we have = = with 6.",
        "(kti-113 , x) = [ads .",
        "Thus, by definition of shift move, F ei in R..",
        "Assume now that ci-i c, is a reduce move in R. Then u, = ui_1 and we have a state s in R, a symbol A E N,a stack a and a sequence r of state-symbol pairs such that",
        "and either",
        "(a) A – .isins;_1,s=s;_jandr=c,or (b) A .",
        "Xn.",
        "is in si-i",
        "We now define a pair sequence f to play the same role in R. as r does in R. In case (a) above, f = c. Otherwise, let 7-1 = c and ri =",
        "(Ear.lq.,,G)) • a(gi, Xi) • • • (gi_i, Xi_i) (krrir', Xi) •• ([or], Xn) • f",
        "which by construction of f immediately entails that 'di is a reduce move in R.. 0 For any unfolded state p, let Pop(p) be the set of states reachable from p by a reduce transition.",
        "More precisely, Pop(p) contains any state p' such that there is a completed dotted rule A a. in p and a state ID\" such that 6.",
        "(p\" , a) = p and 5=(p\", A) = p'.",
        "Then the flattening F of R. is a nondeterministic FSA with the same state set, start state and final states as R. and nondeterministic transition function 0 defined as follows:",
        "• If 5.",
        "(p, x) = p' for some x E E, then p' E Os (P) r) • If p' E Pop(p) then p' E c).",
        "Let co, Cm be a derivation of string w in R, and put ci = (gi, ai, wi), and pi = wp.. By construction, if ci-1 ci is a shift move on z = xwi), then 8.",
        "(pi_i, x) = P, and thus pi E x).",
        "Alternatively, assume the transition is a reduce move associated to the completed dotted rule A a.. We consider first the case a 0 c. Put a = Xi ...Xn.",
        "By definition of reduce move, there is a sequence of states r1, , rn and a stack a such that a•_i = Xf) • • • (rn, Xn), = (ri , A), 6(ri, A) = gi, and b(ri, for 1 <j < n. By definition of stack congruence, we will then have bE gariri , Xj) = [ari+in+1 where ri = c and ri = (ri, XI) Xj_i) for j > 1.",
        "Furthermore, again by definition of stack congruence we have b=([ar , A) = pi.",
        "Therefore, pi E Pokpi-i) and thus pi E ().",
        "A similar but simpler argument allows us to reach the same conclusion for the case a = c. Finally, the definition of final state for R. and makes pm a final state.",
        "Therefore the sequence P0,.",
        "• • , Prn is an accepting path for w in F. We have thus proved",
        "Finally, we should show that the stack collapsing equivalence described informally earlier is indeed a stack congruence.",
        "A stack T is a loop if T = (81, Xi) ... (8k, Xk) and 8(sk,Xk) = si.",
        "A stack a collapses to a stack a' if a = pry, a' = pv and r is a loop.",
        "Two stacks are equivalent if they can be collapsed to the same stack.",
        "This equivalence relation is closed under suffixing, therefore it is a stack congruence."
      ]
    },
    {
      "heading": "3.2 Exactness",
      "text": [
        "While it is difficult to decide what should be meant by a \"good\" approximation, we observed earlier that a desirable feature of an approximation algorithm would be that it be exact for a wide class of CFGs generating regular languages.",
        "We show in this section that our algorithm is exact both for left-linear and for right-linear context-free grammars, which as is well-known generate regular languages.",
        "The proofs that follow rely on the following basic definitions and facts about the LR(0) construction.",
        "Each LR(0) state s is the closure of a set of a certain set of dotted rules, its core.",
        "The closure [R] of a set R of dotted rules is the smallest set of dotted rules containing R that contains B whenever it contains A --+ a • B0 and B 7 is in G. The core of the initial state so contains just the dotted rule S' .5.",
        "For any other state s, there is a state s' and a symbol X such that s is the closure of the set core consisting of all dotted rules A aX • 0 where A a • Xf3 belongs to s'."
      ]
    },
    {
      "heading": "3.3 Left-Linear Grammars",
      "text": [
        "In this section, we assume that the CFG G is left-linear, that is, each rule in G is of the form A Bi3 or A -+ 0, where A, B E N and E E.",
        "Proof: By Proposition 2, L(G) C L(T).",
        "Thus we need only show L(F) C L(G).",
        "The proof hinges on the observation that each state s of M(G) can be identified with a string",
        "Clearly, this is true for so = [S' --+ •S], with ao = c. The core a of any other state s will by construction contain only dotted rules of the form A -■ a • /3 with a 0 c. Since G is left linear, i3 must be a terminal string, ensuring that s = [a].",
        "Therefore, every dotted rule A a • fl in s must result from dotted rule A P •af3 in so by the sequence of transitions determined by a (since M(G) is deterministic).",
        "This means that if A a • fl and A' a' • )3' are in s, it must be the case that = a'.",
        "In the remainder of this proof, let a = s whenever a = To go from the characteristic machine M(G) to the FSA .1\", the algorithm first unfolds M(G) using the stack congruence relation, and then flattens the unfolded machine by replacing reduce moves with &transitions.",
        "However, the above argument shows that the only stack possible at a state s is the one corresponding to the transitions given by a, and thus there is a single stack congruence state at each state.",
        "Therefore, M(G) will only be flattened, not unfolded.",
        "Hence the transition function for the resulting flattened automaton F is defined as follows, where a E NE* U Es, a E E, and A E N:",
        "The start state of .1-is e. The only final state is We will establish the connection between Y derivations and G derivations.",
        "We claim that if there is a path from to g labeled by w then either there is a rule A 4 a such that w = xy and S Ay axy, or a = S and w = c. The claim is proved by induction on 1wi.",
        "For the base case, suppose ite!",
        "= 0 and there is a path from ei to .9 labeled by w. Then w = c, and either a = S, or there is a path of c-transitions from Cr to S. In the latter case, S A c for some A E N and rule A -•■ c, and thus the claim holds.",
        "Now, assume that the claim is true for all Ital < k, and suppose there is a path from er to S labeled w', for some WI = k. Then w' = aw for some terminal a and iwi < k, and there is a path from Fa to g labeled by w. By the induction hypothesis, S Ay otaxiy, where A °tax' is a rule and x'y = w (since aa S).",
        "Letting x = ax', we have the desired result.",
        "If w E L(F), then there is a path from ë to S' labeled by w. Thus, by claim just proved, S Ay xy, where A x is a rule and w = xy (since c S).",
        "Therefore, S w, so w E L(G), as desired.",
        "0"
      ]
    },
    {
      "heading": "3.4 Right-Linear Grammars",
      "text": [
        "Let R be the shift-reduce recognizer for G. The key fact to notice is that, because G is right-linear, no shift transition may follow a reduce transition.",
        "Therefore, no terminal transition in .F may follow an c-transition, and after any c-transition, there is a sequence of c-transitions leading to the final state [5' S•].",
        "Hence .1 has the following kinds of states: the start state, the final state, states with terminal transitions entering or leaving them (we call these reading states), states with c-transitions entering and leaving them (prefinal states), and states with terminal transitions entering them and (-transitions leaving them (crossover states).",
        "Any accepting path through F will consist of a sequence of a start state, reading states, a crossover state, prefinal states, and a final state.",
        "The exception to this is a path accepting the empty string, which has a start state, possibly some prefinal states, and a final state.",
        "The above argument also shows that unfolding does not change the set of strings accepted by because any reduction in R. (or c-transition in .7\"), is guaranteed to be part of a path of reductions (c-transitions) leading to a final state of R. (..r).",
        "Suppose now that w = wi wn is accepted by T. Then there is a path from the start state so through reading states si, , sn -1, to crossover state sn, followed by &transitions to the final state.",
        "We claim that if there there is a path from si to sn labeled wi+i wn, then there is a dot",
        "ted rule A x • yB in si such B z and yz = wn, where A E N, BENU E*, y, z E E*, and one of the following holds: (a) x is a nonempty suffix of w1 (b) x = c, A\" A, A' 4 x' • A\" is a dotted rule in si, and x' is a nonempty suffix of w1 Or (c) x = c, si =S, and S A.",
        "We prove the claim by induction on n - i.",
        "For the base case, suppose there is an empty path from",
        "s„ to sn.",
        "Because s, is the crossover state, there must be some dotted rule A – ■ x• in s„.",
        "Letting y = z = B = e, we get that A x • yB is a dotted rule of sn and B= z.",
        "The dotted rule A x • yB must have either been added to sn by closure or by shifts.",
        "If it arose from a shift, x must be a nonempty suffix of w1 ... tun.",
        "If the dotted rule arose by closure, x = c, and there is some dotted rule A' 4 x' • A\" such that A\" .",
        "and x is a nonempty suffix of w1 Now suppose that the claim holds for paths from s• to sn, and look at a path labeled wi wn from si_1 to sn.",
        "By the induction hypothesis, A x • yB is a dotted rule of s, where B z, us = .",
        ".",
        "wn, and (since si 0 so), either x is a nonempty suffix of w1 wi or x = c, A' 4 a' • A\" is a dotted rule of si, A\" 4' A, and x' is a nonempty suffix of w1 w•.",
        "In the former case, when x is a nonempty suffix of wi wi, then x = wi wi for some 1< j < i.",
        "Then A .wi • yB is a dotted rule of si, and thus A 4 wi wi_i • wiyB is a dotted rule of If j < I – 1, then w1 ...w1_1 is a nonempty suffix of wi .",
        ".",
        ".w_i, and we are done.",
        "Otherwise, wi wi_i = e, and so A 4 •wiyB is a dotted rule of 81_1.",
        "Let y' = way.",
        "Then A •VB is a dotted rule of /4_1, which must have been added by closure.",
        "Hence there are nonterminals A' and A\" such that A\" '4 A and A' 'A\" is a dotted rule of where x' is a nonempty suffix of wi wi_i.",
        "In the latter case, there must be a dotted rule A' ...wi_1 'wA\" in si_i.",
        "The rest of the conditions are exactly as in the previous case.",
        "Thus, if w = W1 ...wn is accepted by F, then there is a path from so to sn labeled by wi .. • wn.",
        "Hence, by the claim just proved, A x yB is a dotted rule of sn, and B z, where yz = wi • • • wn = w. Because the si in the claim is so, and all the dotted rules of si can have nothing before the dot, and x must be the empty string.",
        "Therefore, the only possible case is case 3.",
        "Thus, S A 4 yz = w, and hence w E L(G).",
        "The proof that the empty string is accepted by .F only if it is in L(G) is similar to the proof of the claim.",
        "0"
      ]
    },
    {
      "heading": "4 A Complete Example",
      "text": [
        "The appendix shows an APSG for a small fragment of English, written in the notation accepted by the current version of our grammar compiler.",
        "The categories and features used in the grammar are described in Tables 1 and 2 (categories without features are omitted).",
        "Features enforce person-number agreement, personal pronoun case, and a limited verb subcategorization scheme.",
        "Grammar compilation has three phrases: (i) construction of an equivalent CFG, (ii) approximation, and (iii) determinization and minimization of the resulting FSA.",
        "The equivalent CFG is derived by finding all full instantiations of the initial APSG rules that are actually reachable in a derivation from the grammar's start symbol.",
        "In the current implementation, the construction of the equivalent CFG is is done by a Prolog program, while the approximator, determinizer and minimizer are written in C. For the example grammar, the equivalent CFG has 78 nonterminals and 157 rules, the unfolded and flattened FSA 2615 states and 4096 transitions, and the determinized and minimized final DFA 16 states and 97 transitions.",
        "The runtime for the whole process is 4.91 seconds on a Sun SparcStation 1.",
        "Substantially larger grammars, with thousands of instantiated rules, have been developed for a speech-to-speech translation project.",
        "Compilation times vary widely, but very long compilations appear to be caused by a combinatorial explosion in the unfolding of right recursions that will be discussed further in the next section."
      ]
    },
    {
      "heading": "5 Informal Analysis",
      "text": [
        "In addition to the cases of left-linear and right-linear grammars discussed in Section 3, our algorithm is exact in a variety of interesting cases, including the examples of Church and Patil (1982), which illustrate how typical attachment ambiguities arise as structural ambiguities on regular string sets.",
        "The algorithm is also exact for some self-embedding grammars4 of regular languages, such as"
      ]
    },
    {
      "heading": "S aS I Sb I c",
      "text": [
        "defining the regular language a* cb* A more interesting example is the following simplified grammar for the structure of English noun",
        "The symbols Art, N, PN and P correspond to the parts of speech article, noun, proper noun and preposition.",
        "From this grammar, the algorithm derives the DFA in Figure 4.",
        "As an example of inexact approximation, consider the the self-embedding CFG",
        "for the nonregular language eV', n > 0.",
        "This grammar is mapped by the algorithm into an FSA accepting e I a+b+.",
        "The effect of the algorithm is thus to \"forget\" the pairing between a's and Vs mediated by the stack of the grammar's characteristic recognizer.",
        "Our algorithm has very poor worst-case performance.",
        "First, the expansion of an APSG into a CFG, not described here, can lead to an exponential blow-up in the number of nonterminals and rules.",
        "Second, the subset calculation implicit in the LR(0) construction can make the number of states in the characteristic machine exponential on the number of CF rules.",
        "Finally, unfolding can yield another exponential blow-up in the number of states.",
        "However, in the practical examples we have considered, the first and the last problems appear to be the most serious.",
        "The rule instantiation problem may be alleviated by avoiding full instantiation of unification grammar rules with respect to \"don't care\" features, that is, features that are not constrained by the rule.",
        "The unfolding problem is particularly serious in grammars with subgrammars of the form",
        "It is easy to see that the number of unfolded states in the subgrammar is exponential in n. This kind of situation often arises indirectly in the expansion of an APSG when some features in the right-hand side of a rule are unconstrained and thus lead to many different instantiated rules.",
        "In fact, from the proof of Proposition 4 it follows immediately that unfolding is unnecessary for right-linear grammars.",
        "Ultimately, by dividing the grammar into non-mutually recursive (strongly connected) components and only unfolding center-embedded components, this particular problem could be avoided.5 In the meanwhile, the problem can be circumvented by left factoring (1) as follows:"
      ]
    },
    {
      "heading": "6 Related Work and Conclusions",
      "text": [
        "Our work can be seen as an algorithmic realization of suggestions of Church and Patil (1980; 1982) on algebraic simplifications of CFGs of regular languages.",
        "Other work on finite state approximations of phrase structure grammars has typically relied on arbitrary depth cutoffs in rule application.",
        "While this is reasonable for psycholinguistic modeling of performance restrictions on center embedding (Pulman, 1986), it does not seem appropriate for speech recognition where the approximating FSA is intended to work as a filter and not reject inputs acceptable by the given grammar.",
        "For instance, depth cutoffs in the method described by Black (1989) lead to approximating FSAs whose language is neither a subset nor a superset of the language of the given phrase-structure grammar.",
        "In contrast, our method will produce an exact FSA for many interesting grammars generating regular languages, such as those arising from systematic attachment ambiguities (Church and Patil, 1982).",
        "It important to note, however, that even when the result FSA accepts the same language, the original grammar is still necessary because interpreta5 We have already implemented a version of the algorithm that splits the grammar into strongly connected components, approximates and minimizes separately each component and combines the results, but the main purpose of this version is to reduce approximation and determinization costs for some grammars.",
        "tion algorithms are generally expressed in terms of phrase structures described by that grammar, not in terms of the states of the FSA.",
        "Although the algorithm described here has mostly been adequate for its intended application – grammars sufficiently complex not to be approximated within reasonable time and space bounds usually yield automata that are far too big for our current real-time speech recognition hardware – it would be eventually of interest to handle right-recursion in a less profligate way.",
        "In a more theoretical vein, it would also be interesting to characterize more tightly the class of exactly approximable grammars.",
        "Finally, and most speculatively, one would like to develop useful notions of degree of approximation of a language by a regular language.",
        "Formal-language-theoretic notions such as the rational index (Boason et al., 1981) or probabilistic ones (Soule, 1974) might be profitably investigated for this purpose."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We thank Mark Liberman for suggesting that we look into finite-state approximations and Pedro Moreno, David Roe, and Richard Sproat for trying out several prototypes of the implementation and supplying test grammars."
      ]
    },
    {
      "heading": "References",
      "text": []
    },
    {
      "heading": "Appendix – APS G Formalism and Example",
      "text": [
        "Nonterminal symbols (syntactic categories) may have features that specify variants of the category (eg.",
        "singular or plural noun phrases, intransitive or transitive verbs).",
        "A category cat with feature constraints is written cant , .",
        ", cm] .",
        "Feature constraints for feature f have one of the forms",
        "where v is a variable name (which must be capitalized) and c, ci, .. • , c,, are feature values.",
        "All occurrences of a variable v in a rule stand for the same unspecified value.",
        "A constraint with form (2) specifies a feature as having that value.",
        "A constraint of form (3) specifies an actual value for a feature, and a constraint of form (4) specifies that a feature may have any value from the specified set of values.",
        "The symbol \"!” appearing as the value of a feature in the right-hand side of a rule indicates that that feature must have the same value as the feature of the same name of the category in the left-hand side of the rule.",
        "This notation, as well as variables, can be used to enforce feature agreement between categories in a rule,",
        "Symbol Category Features s sentence n (number), p (person) np noun phrase n, p, c (case) vp verb phrase n, p, t (verb type) args verb arguments t det determiner n n noun n pron pronoun n, 13, c v verb n, p, t",
        "Feature Values n (number) s (singular), p (plural) p (person) 1 (first), 2 (second), 3 (third) c (case) s (subject), o (nonsubject) t (verb type) i (intransitive), t (transitive), d (ditransitive)",
        "for instance, number agreement between subject and verb.",
        "It is convenient to declare the features and possible values of categories with category declarations appearing before the grammar rules.",
        "Category declarations have the form cat calif fi = (vii, viki) J. giving all the possible values of all the features for the category.",
        "The declaration start cat.",
        "declares cat as the start symbol of the grammar.",
        "In the grammar rules, the symbol prefixes terminal symbols, commas are used for sequencing and \"I\" for alternation.",
        "start s. cat sttEn=(s,p) '13=(1,2,3)].",
        "cat npltErt=(s,p),p=(1,2,3),c=(s,o)].",
        "cat vp*En=(s,p),p=(1,2,3),type=(i,t,d)].",
        "cat argetEtype=(i,t ,d)].",
        "cat detttEn=(s,p)).",
        "cat nit(n=(s,p)).",
        "cat pron*En=(541),P=(1,2,3),c=(s,o)).",
        "cat v*En=(s,p),p=(1,2,3),type=(i,t,d)]."
      ]
    }
  ]
}
