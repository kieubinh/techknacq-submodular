{
  "info": {
    "authors": [
      "Jochen Dorre"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P91-1033",
    "title": "Feature Logic With Weak Subsumption Constraints",
    "url": "https://aclweb.org/anthology/P91-1033",
    "year": 1991
  },
  "references": [
    "acl-C88-1061",
    "acl-P86-1038"
  ],
  "sections": [
    {
      "heading": "FEATURE LOGIC WITH WEAK SUBSUMPTION CONSTRAINTS",
      "text": []
    },
    {
      "heading": "ABSTRACT",
      "text": [
        "In the general framework of a constraint-based grammar formalism often some sort of feature logic serves as the constraint language to describe linguistic objects.",
        "We investigate the extension of basic feature logic with subsumption (or matching) constraints, based on a weak notion of subsumption.",
        "This mechanism of one-way information flow is generally deemed to be necessary to give linguistically satisfactory descriptions of coordination phenomena in such formalisms.",
        "We show that the problem whether a set of constraints is satisfiable in this logic is decidable in polynomial time and give a solution algorithm."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Many of the current constraint-based grammar formalisms, as e.g. FUG [Kay 79, Kay 85], LFG [Kaplan/Bresnan 82], HPSG [Pollard/Sag 87], PATR-II [Shieber et al.",
        "83] and its derivates, model linguistic knowledge in recursive feature structures.",
        "Feature (or functional) equations, as in LFG, or feature terms, as in FUG or STUF [Bouma et al.",
        "88], are used as constraints to describe declaratively what properties should be assigned to a linguistic entity.",
        "In the last few years, the study of the formal semantics and formal properties of logics involving such constraints has made substantial progress [Kasper/Rounds 86, Johnson 87, Smolka 88, Smolka 89], e.g., by making precise which sublanguages of predicate logic it corresponds to.",
        "This paves the way not only for reliable implementations of these formalisms, but also for extensions of the basic logic with a precisely defined meaning.",
        "The extension we present here, weak subsumption constraints, is a mechanism of one-way information flow, often proposed for a logical treatment of coordination in a feature-based unification grammar.1 It can 'Another application would be type inference in a grammar formalism (or programming language) that be informally described as a device, which enables us to require that one part of a (solution) feature structure has to be subsumed (be an instance of) another part.",
        "Consider the following example of a coordination with \"and\", taken from [Shieber 89].",
        "(1) Pat hired [NP a Republican] and [NP a banker].",
        "(2) *Pat hired [NP a Republican] and [AP proud of it].",
        "Clearly (2) is ungrammatical since the verb \"hire\" requires a noun phrase as object complement and this requirement has to be fulfilled by both coordinated complements.",
        "This subcategorization requirement is modeled in a unification-based grammar generally using equations which cause the features of a complement (or parts thereof encoding the type) to get unified with features encoding the requirements of the respective position in the subcategorization frame of the verb.",
        "Thus we could assume that for a coordination the type-encoding features of each element have to be \"unified into\" the respective position in the subcategorization frame.",
        "This entails that the coordinated elements are taken to be of one single type, which then can be viewed as the type of the whole coordination.",
        "This approach works fine for the verb \"hire\", but certain verbs, used very frequently, do not require this strict identity.",
        "(3) Pat has become [NP a banker] and [Ap very conservative].",
        "(4) Pat is [Ap healthy] and [pp of sound mind].",
        "The verb \"become\" may have either noun-phrase or adjective-phrase complements, \"to be\" allows prepositional and verb phrases in addition, and these may appear intermixed in a coordination.",
        "In order to allow for such \"polymorphic\" type requirements, we want to"
      ]
    },
    {
      "heading": "uses a type discipline with polymorphic types.",
      "text": [
        "state, that (the types of) coordinated arguments each should be an instance of the respective requirement from the verb.",
        "Expressed in a general rule for (constituent) coordination, we want the structures of coordinated phrases to be instances of the structure of the coordination.",
        "Using subsumption constraints the rule basically looks like this:",
        "A similar treatment of constituent coordination has been proposed in [Kaplan/Maxwell 88], where the coordinated elements are required to be in a set of feature structures and where the feature structure of the whole set is defined as the generalization (greatest lower hound w.r.t.",
        "subsumption) of its elements.",
        "This entails the requirement stated above, namely that the structure of the coordination subsumes those of its elements.",
        "In fact, it seems that especially in the context of set-valued feature structures (cf. [Rounds 88]) we need some method of inheritance of constraints, since if we want to state general combination rules which apply to the set-valued objects as well, we would like constraints imposed on them to affect also their members in a principled way.",
        "Now, recently it turned out that a feature logic involving subsumption constraints, which are based on the generally adopted notion of subsumption for feature graphs is undecidable (cf. [DOrre/Rounds 90]).",
        "In the present paper we therefore investigate a weaker notion of subsumption, which we can roughly characterize as relaxing the constraint that an instance of a feature graph contains all of its path equivalencies.",
        "Observe, that path equivalencies play no role in the subcategorization requirements in our examples above."
      ]
    },
    {
      "heading": "2 Feature Algebras",
      "text": [
        "In this section we define the basic structures which are possible interpretations of feature descriptions, the expressions of our feature logic.",
        "Instead of restricting ourselves to a specific interpretation, like in [Kasper/Rounds 86] where feature structures are defined as a special kind of finite automata, we employ an open-world semantics as in predicate logic.",
        "We adopt most of the basic definitions from [Smolka 89].",
        "The mathematical structures which serve us as interpretations are called feature algebras.",
        "We begin by assuming the pairwise disjoint sets of symbols L, A and V, called the sets of features (or labels), atoms (or constants) and variables, respectively.",
        "Generally we use the letters f, g, h for features, a, b,c for atoms, and x, y, z for variables.",
        "The letters s and 2 always denote variables or atoms.",
        "We assume that there are infinitely many variables.",
        "A feature algebra A is a pair (D4, .A) consisting of a nonempty set DA (the domain of A) and an interpretation •A defined on L and A such that",
        "• aA E DA for a E A.",
        "(atoms are constants) • If a b then aA V. (unique name assumption) • If f is a feature then fA is a unary partial function on DA.",
        "(features are functional) • No feature is defined on an atom.",
        "Notation.",
        "We write function symbols on the right following the notation for record fields in computer languages, so that f(d) is written df.",
        "If f is defined at d, we write df I, and otherwise df T. We use p,q,r to denote strings of features, called paths.",
        "The interpretation function •A is straightforwardly extended to paths: for the empty path e, € A is the identity on DA; for a path p = pA is the unary partial function which is the composition of the functions fiA f, where fiA is applied first.",
        "A feature algebra of special interest is the Feature Graph Algebra F, since it is canonical in the sense that whenever there exists a solution for a formula in basic feature logic in some feature algebra then there is also one in the Feature Graph Algebra.",
        "The same holds if we ex",
        "tend our logic to subsumption constraints (see [Diirre/Rounds 90]).",
        "A feature graph is a rooted and connected directed graph.",
        "The nodes are either variables or atoms, where atoms may appear only as terminal nodes.",
        "The edges are labeled with features and for every node no two outgoing edges may be labeled with the same feature.",
        "We formalize feature graphs as pairs (so, E) where so E V UA is the root and EC V x L x (V U A) is a set of triples, the edges.",
        "The following conditions hold:",
        "1.",
        "If so E A, then E = 0.",
        "2.",
        "If(x,f,․)artd(x,f,2)areinE,thens – i.",
        "3.",
        "If (z, f, s) is in E, then E contains edges leading from the root so to the node z.",
        "Let G = (zo, E) be a feature graph containing an edge (zo, f, a).",
        "The subgraph under f of G (written GI f) is the maximal graph (a, E') such that E' C E. Now it is clear how the Feature Graph Algebra .7\" is to be defined.",
        "DF is the set of all feature graphs.",
        "The interpretation of an atom al.",
        "is the feature graph (a, 0), and for a feature f we let Gf-7 = f, if this is defined.",
        "It is easy to verify that .7\" is a feature algebra.",
        "Feature graphs are normally seen as data objects containing information.",
        "From this viewpoint there exists a natural preorder, called sub-gumption preorder, that orders feature graphs according to their informational content thereby abstracting away from variable names.",
        "We do not introduce subsumption on feature graphs here directly, but instead we define a subsumption order on feature algebras in general.",
        "Let A and B be feature algebras.",
        "A simulation between A and B is a relation A C DA x DB satisfying the following conditions:",
        "1. if (aA,d) E A then d = a, for each atom a, and 2. for any d E DA, e E DB and f E L: if dfA 1 and (d,e) E A, then e fB and (dfA,efB) E A.",
        "Notice that the union of two simulations and the transitive closure of a simulation are also simulations.",
        "A partial homomorphism 7 between A and B is a simulation between the two which is a partial function.",
        "If A = B we also call y a partial endomorphism.",
        "Definition.",
        "Let A be a feature algebra.",
        "The (strong) subsumption preorder CA and the weak subsumption preorder EA of A are defined as follows:",
        "• d (strongly) subsumes e (written d EA e) if there is an endomorphism y such that 7(d) = e. • d weakly subsumes e (written d CA e) if there is a simulation A such that dAe.",
        "It can be shown (see [Smolka 89]) that the subsumption preorder of the feature graph algebra coincides with the subsumption order usually defined on feature graphs, e.g. in [Kasper/Rounds 86].",
        "Example: Consider the feature algebra depicted in Fig. 2, which consists of the elements {1, 2, 3, 4, 5, a, b} where a and b shall be (the pictures of) atoms and 1, g, i and j shall be features whose interpretations are as indicated.",
        "Now, element 1 does not strongly subsume 3, since for 3 it does not hold, that its f-value equals its g-value.",
        "However, the simulation A demonstrates that they stand in the weak subsumption relation: 1 C 3."
      ]
    },
    {
      "heading": "3 Constraints",
      "text": [
        "To describe feature algebras we use a relational language similar to the language of feature descriptions in LFG or path equations in PATR-II.",
        "Our syntax of constraints shall allow for the forms xp yq, xp = a, xp yq where p and q are paths (possibly empty), a E A, and z and y are variables.",
        "A feature clause is a finite set of constraints of the above forms.",
        "As usual we interpret constraints with respect to a variable assignment, in order to make sure that variables are interpreted uniformly in the whole set.",
        "An assignment is a mapping a of variables to the elements of some feature alge",
        "bra.",
        "A constraint 0 is satisfied in A under assignment a, written (A, a) 0, as follows: (A, a) zp yq iff a(x)pA = a(y)qA (A, a) xp 4 a if a(x)pA = aA (A, a) xpEyg if a(z)PA EA a(V)e. The solutions of a clause C in a feature algebra A are those assignments which satisfy each constraint in C. Two clauses C1 and C2 are equivalent iff they have the same set of solutions in every feature algebra A.",
        "The problem we want to consider is the following: Given a clause C with symbols from V, L and A, does C have a solution in some feature algebra?",
        "We call this problem the weak semiunification problem in feature algebras.2"
      ]
    },
    {
      "heading": "4 An Algorithm",
      "text": []
    },
    {
      "heading": "4.1 Presolved Form",
      "text": [
        "We give a solution algorithm for feature clauses based on normalization, i.e. the goal is to define a normal form which exhibits unsatisfiability and rewrite rules which transform each feature clause into normal form.",
        "The normal form we present here actually is only half the way to a solution, but we show below that with the use of a standard algorithm solutions can be generated from it.",
        "First we introduce the restricted syntax of the normal form.",
        "Clauses containing only constraints of the following forms are called simple: x f y, x s, z y where s is either a variable or an atom.",
        "Each feature clause can be restated in linear time as an equisatisfiable simple feature clause whose solutions are extensions of the solutions of the original clause, through the introduction of auxiliary variables.",
        "This step is trivial.",
        "A feature clause C is called presolved if it is simple and satisfies the following conditions.",
        "2 The analogous problem for (strong) subsumption constraints is undecidable, even if we restrict ourselves to finite feature algebras.",
        "Actually, this problem could be shown to be equivalent to the semiunification problem for rational trees, i.e. first-order terms which may contain cycles.",
        "The interested reader is referred to [Thirre/Rounds 90].",
        "Cl.",
        "If x y is in C, then z occurs exactly once in C. C2.",
        "If zf y and zf z are in C, then y = z. C3.",
        "HzEy and y z are in C, then z E z is in C (transitive closure).",
        "C4.",
        "If x y and z f 4 z' and yf 4 y' are in C, then z' y' is in C (downward propagation closure).",
        "In the first step our algorithm attempts to transform feature clauses to presolved form, thereby solving the equational part.",
        "In the simplification rules (cf.",
        "Fig.",
        "3) we have adapted some of Smolka's rules for feature clauses including complements [Smolka 89].",
        "In the rules [x/s]C denotes the clause C where every occurrence of z has been replaced with s, and 0 & C denotes the feature clause {0} U C provided 0 fl C.",
        "2. for every non-normal simple feature clause one of the rewrite rules applies, S. there is no infinite chain C 4 CI 4 C2 • • •",
        "Proof.",
        "The first part can be verified straightforwardly by inspecting the rules.",
        "The same holds for the second part.",
        "To show the termination claim first observe that the application of the last two rules can safely be postponed until no one of the others can apply any more, since they only introduce subsumption constraints, which cannot feed the other rules.",
        "Now, call a variable x isolated in a clause C, if C contains an equation z y and z occurs exactly once in C. The first rule strictly increases the number of isolated variables and no rule ever decreases it.",
        "Application of the second and third rule decrease the number of equational constraints or the number of features appearing in C, which no other rule increase.",
        "Finally, the last two rules strictly increase the number of subsumption constraints for a constant set of variables.",
        "Hence, no infinite chain of rewriting steps may be produced.",
        "We will show now, that the presolved form can be seen as a nondeterministic finite automaton 'Part of this proof has been directly adapted from [Smolka 89].",
        "with e-moves and that we can read off solutions from its deterministic equivalent, if that is of a special, trivially verifiable, form, called clash-free."
      ]
    },
    {
      "heading": "4.2 The Transition Relation 6c of a Presolved Clause C",
      "text": [
        "The intuition behind this construction is, that subsumption constraints basically enforce that information about one variable (and the space reachable from it) has to be inherited by (copied to) another variable.",
        "For example the constraints x E y and xi, 2.= a entail that also yp = a has to hold.4 Now, if we have a constraint z E y, we could think of actually copying the information found under x to y, e.g. x f x' would be copied to yf y', where yl is a new variable, and z' would be linked to y' by z' E y'.",
        "However, this treatment is hard to control in the presence of cycles, which always can occur.",
        "Instead of actually copying we also can regard a constraint x E y as a pointer from y back to x leading us to the information which is needed to construct the local solution of y.",
        "To extend this view we regard the whole presolved clause C as a finite automaton: take variables and atoms as nodes, a feature constraint as an arc labeled with the feature, constraints z s and y E as e-moves from z to a or y.",
        "We can show then that C is unsatisfiable if there is some z from which we reach atom a via path p such that we can also reach b(0 a) via p or there is a path starting from z whose proper prefix is p. Formally, let NFA .Arc of presolved clause C be 4 From this point of view the difference between weak and strong subsumption can be captured in the type of information they enforce to be inherited.",
        "Strong subsumption requires path equivalences to be inherited (x E y and xp xq implies yp yq), whereas weak subsumption does not.",
        "defined as follows.",
        "Its states are the variables occurring in C (Vc) plus the atoms plus the states qp and the initial state q0.",
        "The set of final states is Vc U {qp}.",
        "The alphabet of Arc is VcuLUAu{e}.6 The transition relation is defined as follows:6 {(go, x, x) I x E Vc}",
        "As usual, let ic be the extension of 5c to paths.",
        "Notice that xpa E L(A(c) if (x, p, a) E ic • The language accepted by this automaton contains strings of the forms xp or xpa, where a string zp indicates that in a solution a the object a(x)pA should be defined and zpa tells us further that this object should be aA.",
        "A set of strings of (V x L*)U (V x L* x A) is called clash-free iff it does not contain a string zpa together with xpb (where a 0 b) or together with zpf.",
        "It is clear that the property of a regular language L of being clash-free with respect to L and A can be read off immediately from a DFA D for it: if 1, contains a state q with 6(q, a) E F and either 8(q,b) E F (where a 0 b) or 6(q, f) E F, then it is not clash-free, otherwise it is.",
        "We now present our central theorem.",
        "Theorem 2 Let Co be a feature clause, C its presolved form and .Aic the NFA as constructed",
        "Proof.",
        "see Appendix A.",
        "Now the algorithm consists of the following simple or well-understood steps:",
        "1: (a) Solve the equational constraints of C, which can be done using standard unification methods, exemplified by rules 1) to 3).",
        "(b) Make the set of weak subsumption constraints transitively and \"downward\" closed (rules 4) and 5)).",
        "2: The result interpreted as an NFA is made deterministic using standard methods and tested of being clash-free."
      ]
    },
    {
      "heading": "4.3 Determining Clash-Freeness Directly",
      "text": [
        "For the purpose of proving the algorithm correct it was easiest to assume that clash-freeness is determined after transforming the NFA of the presolved form into a deterministic automaton.",
        "However, this translation step has a time complexity which is exponential with the number of states in the worst case.",
        "In this section[A we consider a technique to determine clash-freeness directly from the NFA representation of the presolved form in polynomial time.",
        "We do not go into implementational details, though.",
        "Instead we are concerned to describe the different steps more from a logical point of view.",
        "It can be assumed that there is still room left for optimizations which improve efficiency.",
        "In a first step we eliminate all the e-transitions from the NFA M. We will call the result still fic.",
        "For every pair of a variable node x and an atom node a let .Arc[x, a] be the (sub-)automaton of all states of .11rc reachable from x, but with the atom a being the only final state.",
        "Thus, .Arc[x, a] accepts exactly the language of all strings p for which xpa E L(Arc).",
        "Likewise, let .Arc[x,rd be the (sub-)automaton of all states of Arc reachable from z, but where every atom node besides a is in the set of final states as well as every node with an outgoing feature arc.",
        "The set accepted by this machine contains every string p such that xpb E L(Arc), (b a) or xpf E L(A/c).",
        "If and only if the intersection of these two machines is empty for every x and a, L(A(c) is clash-free."
      ]
    },
    {
      "heading": "4.4 Complexity",
      "text": [
        "Let us now examine the complexity of the different steps of the algorithm.",
        "We know that Part la) can be done (using the efficient union/find technique to maintain equivalence classes of variables and vectors of features for each representative) in nearly linear time, the result being smaller or of equal size than Co. Part lb) may blow up the clause to a size at most quadratic with the number of different variables n, since we cannot have more subsumption constraints than this.",
        "For every new subsumption constraint, trying to apply rule 4) might involve at most 2n membership test to check whether we are actually adding a new constraint, whereas for rule 5) this number only depends on the size of L. Hence, we stay within cubic time until here.",
        "Determining whether the presolved form is clash-free from the NFA representation is done in three steps.",
        "The e-free representation of Arc does not increase the number of states.",
        "If n, a and I are the numbers of variables, atoms and features resp.",
        "in the initial clause, then the number of edges is in any case smaller than (n a)2 • I, since there are only n I a states.",
        "This computation can be performed in time of an order less than o((n + a)3).",
        "Second, we have to build the intersections for Al.c[x, a] and N.c[x,Ti] for every z and a. Intersection of two NFAs is done by building a crossproduct machine, requiring maximally o((n + a)l • I) time and space.",
        "The test for emptiness of these intersection machines is again trivial and can be performed in constant time.",
        "Hence, we estimate a total time and space complexity of order n • a • (n a)4 • I.",
        "71'1118 is an estimate for the number of edges, since the number of states is below (n a)2.",
        "As usual, we assume appropriate data structures where we can neglect the order of access times.",
        "Probably the space (and time) complexity can be reduced further, since we actually do not need the representations of the intersection machines besides for testing, whether they can accept anything."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We proposed an extension to the basic feature logic of variables, features, atoms, and equational constraints.",
        "This extension provides a means for one-way information passing.",
        "We have given a simple, but nevertheless completely formal semantics for the logic and have shown that the satisfiability (or unification) problem in the logic involving weak subsumption constraints is decidable in polynomial time.",
        "Furthermore, the first part of the algorithm is a surprisingly simple extension of a standard unification algorithm for feature logic.",
        "We have formulated the second part of the problem as a simple property of the regular language which the outcome of the first part defines.",
        "Hence, we could make use of standard techniques from automata theory to solve this part of the problem.",
        "The algorithm has been proved to be correct, complete, and guaranteed to terminate.",
        "There are no problems with cycles or with infinite chains of subsumption relations as generated by a constraint like z E xf.a The basic algorithmic requirements to solve the problem being understood, the challenge now is to find ways how solutions can be found in a more incremental way, if we already have solutions for subsets of a clause.",
        "To achieve this we plan to amalgamate more closely the two parts algorithms, for instance, through implementing the check for clash-freeness also with the help of (a new form of) constraints.",
        "It would be interesting also from a theoretical point of view to find out how much of the complexity of the second part is really necessary."
      ]
    },
    {
      "heading": "Acknowledgment",
      "text": [
        "I am indebted to Bill Rounds for reading a first draft of this paper and pointing out to me a way to test dash-freeness in polynomial time.",
        "Of course, any remaining errors are those of the author.",
        "I would also like to thank Gert Smolka for giving valuable comments on the first draft."
      ]
    },
    {
      "heading": "References",
      "text": []
    },
    {
      "heading": "Appendix A: Proof of Theorem 2",
      "text": [
        "Now let the elements of the domain be, besides interpretations of atoms, just those objects (partial functions) which can be reached by application of some features to some a(x).",
        "• DA = {a(x)qA I xEITc,qEL*} U {aA I aEA}.",
        "To see that DA is finite, we first observe that the domain of each a(x) is a regular set UP I rPaEgc,aEA}) and the range is finite.",
        "Now, for a regular set R call {p I qpER} the suffix language of R with respect to string q.",
        "It is clear, that there are only finitely many suffix languages, since each corresponds to one state in the minimal finite automaton for R. But then also the number of partial functions \"reachable\" from an a(x) is finite, since the domain of a(x)qA is a suffix language of the domain of a(x).",
        "We now show that given 1) the model (A, a) satisfies all constraints in C. • If x a E C: xa E L(.A.G) (e, a) E a(x).",
        "Now we know from 1) that no other pair is in a(x), i.e. a(x) = aA.",
        "• If x y E C: Since x occurs only once in",
        "i.e. z' is the last state before f is consumed on a path consuming /pa.",
        "But now, since e-moves on such a chain correspond to subsumption constraints (none of the variables in the chain is isolated) and since C is transitively closed for subsumption constraints, C has to contain a constraint x' E x.",
        "But the last condition for normal form now tells us, that also y' E y is in C, implying (y,e,y') E (Sc.",
        "Hence,",
        "As in case 1) we have a(x)pA = aA.",
        "From (x,pf,y) E we get a(y) EA a(x)(pf)A , which entails that fA has to be defined for a(x)pA , a contradiction.",
        "This completes the proof."
      ]
    }
  ]
}
