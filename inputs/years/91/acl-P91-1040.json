{
  "info": {
    "authors": [
      "Mikio Nakano"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P91-1040",
    "title": "Constraint Projection: An Efficient Treatment of Disjunctive Feature Descriptions",
    "url": "https://aclweb.org/anthology/P91-1040",
    "year": 1991
  },
  "references": [
    "acl-C86-1018",
    "acl-C90-3013",
    "acl-E89-1013",
    "acl-P87-1033",
    "acl-P88-1035"
  ],
  "sections": [
    {
      "heading": "DISJUNCTIVE FEATURE DESCRIPTIONS",
      "text": []
    },
    {
      "heading": "Abstract",
      "text": [
        "Unification of disjunctive feature descriptions is important for efficient unification-based parsing.",
        "This paper presents constraint projection, a new method for unification of disjunctive feature structures represented by logical constraints.",
        "Constraint projection is a generalization of constraint unification, and is more efficient because constraint projection has a mechanism for abandoning information irrelevant to a goal specified by a list of variables."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Unification is a central operation in recent computational linguistic research.",
        "Much work on syntactic theory and natural language parsing is based on unification because unification-based approaches have many advantages over other syntactic and computational theories.",
        "Unification-based formalisms make it easy to write a grammar.",
        "In particular, they allow rules and lexicon to be written declaratively and do not need transformations.",
        "Some problems remain, however.",
        "One of the main problems is the computational inefficiency of the unification of disjunctive feature structures.",
        "Functional unification grammar (FUG) (Kay 1985) uses disjunctive feature structures for economical representation of lexical items.",
        "Using disjunctive feature structures reduces the number of lexical items.",
        "However, if disjunctive feature structures were expanded to disjunctive normal form (DNF)1 as in definite clause grammar (Pereira and Warren 1980) and Kay's parser (Kay 1985), unification would take exponential time in the number of disjuncts.",
        "Avoiding unnecessary expansion of disjunction is important for efficient disjunctive unification.",
        "Kasper (1987) and Eisele and DOrre (1988) have tackled this problem and proposed unification methods for disjunctive feature descriptions.",
        "IDNF has a form 01 v 02 V Os V... v On, where 4,, includes no disjunctions.",
        "These works are based on graph unification rather than on term unification.",
        "Graph unification has the advantage that the number of arguments is free and arguments are selected by labels so that it is easy to write a grammar and lexicon.",
        "Graph unification, however, has two disadvantages: it takes excessive time to search for a specified feature and it requires much copying.",
        "We adopt term unification for these reasons.",
        "Although Eisele and Diirre (1988) have mentioned that their algorithm is applicable to term unification as well as graph unification, this method would lose term unification's advantage of not requiring so much copying.",
        "On the contrary, constraint unification (CU) (Hasida 1986, Tuda et al.",
        "1989), a disjunctive unification method, makes full use of term unification advantages.",
        "In CU, disjunctive feature structures are represented by logical constraints, particularly by Horn clauses, and unification is regarded as a constraint satisfaction problem.",
        "Furthermore, solving a constraint satisfaction problem is identical to transforming a constraint into an equivalent and satisfiable constraint.",
        "CU unifies feature structures by transforming the constraints on them.",
        "The basic idea of CU is to transform constraints in a demand-driven way; that is, to transform only those constraints which may not be satisfiable.",
        "This is why CU is efficient and does not require excessive copying.",
        "However, CU has a serious disadvantage.",
        "It does not have a mechanism for abandoning irrelevant information, so the number of arguments in constraint-terms (atomic formulas) becomes so large that transformation takes much time.",
        "Therefore, from the viewpoint of general natural language processing, although CU is suitable for processing logical constraints with small structures, it is not suitable for constraints with large structures.",
        "This paper presents constraint projection (CP), another method for disjunctive unifica-tion.â€¢The basic idea of CP is to abandon information irrelevant to goals.",
        "For example, in",
        "bottom-up parsing, if grammar consists of local constraints as in contemporary unification-based formalisms, it is possible to abandon information about daughter nodes after the application of rules, because the feature structure of a mother node is determined only by the feature structures of its daughter nodes and phrase structure rules.",
        "Since abandoning irrelevant information makes the resulting structure tighter, another application of phrase structure rules to it will be efficient.",
        "We use the term projection in the sense that CP returns a projection of the input constraint on the specified variables.",
        "We explain how to express disjunctive feature structures by logical constraints in Section 2.",
        "Section 3 introduces CU and indicates its disadvantages.",
        "Section 4 explains the basic ideas and the algorithm of CP.",
        "Section 5 presents some results of implementation and shows that adopting CP makes parsing efficient."
      ]
    },
    {
      "heading": "2 Expressing Disjunctive Feature",
      "text": []
    },
    {
      "heading": "Structures by Logical Constraints",
      "text": [
        "This section explains the representation of disjunctive feature structures by Horn clauses.",
        "We use the DEC-10 Prolog notation for writing Horn clauses.",
        "First, we can express a feature structure without disjunctions by a logical term.",
        "For example, (1) is translated into (2).",
        "posy ( 1) agr num sing' per 3rd subj agr [ rerm tncf (2) cat(v, agr(sing,3rd), cat(_,agr(sing,3rd),_)) The arguments of the functor cat correspond to the pos (part of speech), agr (agreement), and subj (subject) features.",
        "Disjunction and sharing are represented by the bodies of Horn clauses.",
        "An atomic formula in the body whose predicate has multiple definition clauses represents a disjunction.",
        "For example, a disjunctive feature structure (3) in FUG (Kay 1985) notation, is translated into (4).",
        "-pos n agr [num sing' pos v subj [agr [1] agr 0",
        "(4) p(cat(v,Agr,cat(_,Agr,_))) not_3s(Agr).",
        "p(cat(n,agr(sing,3rd),_)).",
        "not_3s(agr(sing,Per)) :-1st_or_2nd(Per).",
        "not_3s(agr(plural, _)).",
        "1st_or_2nd(1st).",
        "1st_or_2nd(2nd).",
        "Here, the predicate p corresponds to the specification of the feature structure.",
        "A term p(X) means that the variable X is a candidate of the disjunctive feature structure specified by the predicate p. The ANY value used in FUG or the value of an unspecified feature can be represented by an anonymous variable 'J.",
        "We consider atomic formulas to be constraints on the variables they include.",
        "The atomic formula lst_or_2nd(Per) in (4) constrains the variable Per to be either 1st or 2nd.",
        "In a similar way, not_3s(Agr) means that Agr is a term which has the form agr(Num,Per), and that Num is sing and Per is subject to the constraint lst_or_2nd(Per) or that Num is plural.",
        "We do not use or consider predicates without their definition clauses because they make no sense as constraints.",
        "We call an atomic formula whose predicate has definition clauses a constraint-term, and we call a sequence of constraint-terms a constraint.",
        "A set of definition clauses like (4) is called a structure of a constraint.",
        "Phrase structure rules are also represented by logical constraints.",
        "For example, If rules are binary and if L, R, and N stand for the left daughter, the right daughter, and the mother, respectively, they stand in a ternary relation, which we represent as psr(L,R,M).",
        "Each definition clause of psr corresponds to a phrase structure rule.",
        "Clause (5) is an example.",
        "(5) psr(Subj , cat (v ,Agr ,Subj) , cat(s,Agr,_)).",
        "Definition clauses of psr may have their own bodies.",
        "If a disjunctive feature structure is specified by a constraint-term p(X) and another is specified by q(Y), the unification of X and Y is equivalent to the problem of finding X which satisfies (6).",
        "(6) Cp(X),q(X)]",
        "Thus a unification of disjunctive feature structures is equivalent to a constraint satisfaction problem.",
        "An application of a phrase structure rule also can be considered to be a constraint satisfaction problem.",
        "For instance, if categories of left daughter and right daughter are stipulated by ci (L) and c2(R), computing a mother category is equivalent to finding M which satisfies constraint (7).",
        "(7) Cci(L),c2(R),psr(L,R,14)] A Prolog call like (8) realizes this constraint",
        "satisfaction.",
        "(8) :-cl(L),c2(R),psr(L,R,M), assert(c3(M)),fail.",
        "This method, however, is inefficient.",
        "Since Prolog chooses one definition clause when multiple definition clauses are available, it must repeat a procedure many times.",
        "This method is equivalent to expanding disjunctions to DNF before unification."
      ]
    },
    {
      "heading": "3 Constraint Unification and Its Problem",
      "text": [
        "This section explains constraint unification2 (Hasida 1986, Tuda et al.",
        "1989), a method of disjunctive unification, and indicates its disadvantage."
      ]
    },
    {
      "heading": "3.1 Basic Ideas of Constraint Unification",
      "text": [
        "As mentioned in Section 1, we can solve a constraint satisfaction problem by constraint transformation.",
        "What we seek is an efficient algorithm of transformation whose resulting structure is guaranteed satisfiability and includes a small number of disjuncts.",
        "CU is a constraint transformation system which avoids excessive expansion of disjunctions.",
        "The goal of CU is to transform an input constraint to a modular constraint.",
        "Modular constraints are defined as follows.",
        "(9) (Definition: modular) A constraint is modular, if 1. every argument of every atomic formula is a variable, 2. no variable occurs in two distinct places, and 3. every predicate is modularly defined.",
        "A predicate is modularly defined if the bodies of its definition clauses are either modular or NIL.",
        "For example, (10) is a modular constraint, while (11), (12), and (13) are not modular, when all the predicates are modularly defined.",
        "(10) Ep(X,Y),q(2,107 (11) tp(X,X)) (12) Cp(X,Y),q(Y.2)] (13) Cp(f(a),g(Z))]",
        "Constraint (10) is satisfiable because the predicates have definition clauses.",
        "Omitting the proof, a modular constraint is necessarily satisfiable.",
        "Transforming a constraint into a modular one is equivalent to finding the set of instances which satisfy the constraint.",
        "On the contrary, non-modular constraint may not be satisfiable.",
        "When",
        "a constraint is not modular, it is said to have dependencies.",
        "For example, (12) has a dependency concerning Y.",
        "The main ideas of CU are (a) it classifies constraint-terms in the input constraint into groups so that they do not share a variable and it transforms them into modular constraints separately, and (b) it does not transform modular constraints.",
        "Briefly, CU processes only constraints which have dependencies.",
        "This corresponds to avoiding unnecessary expansion of disjunctions.",
        "In CU, the order of processes is decided according to dependencies.",
        "This flexibility enables CU to reduce the amount of processing.",
        "We explain these ideas and the algorithm of CU briefly through an example.",
        "CU consists of two functions, namely, modularize(constraint) and integrate(constraint).",
        "We can execute CU by calling modularize.",
        "Function modularize divides the input constraint into several constraints, and returns a list of their integrations.",
        "If one of the integrations fails, modularization also fails.",
        "The function integrate creates a new constraint-term equivalent to the input constraint, finds its modular definition clauses, and returns the new constraint-term.",
        "Functions modularize and integrate call each other.",
        "Let us consider the execution of (14).",
        "(14) modularize( [p(X,Y),q(Y,Z),p(A,B),r(*),r(C)))",
        "The predicates are defined as follows.",
        "(15) p(f (A) ,C):-r(A),r(C).",
        "(16) p(a,b).",
        "(17) q(a,b).",
        "(18) q(b,a).",
        "(19) r(a).",
        "(20) r(b).",
        "The input constraint is divided into (21), (22), and (23), which are processed independently (idea (a)).",
        "(21) [p(X,Y),q(Y,Z)) (22) [p(A,B),r(A)] (23) Cr(C)]",
        "If the input constraint were not divided and (21) had multiple solutions, the processing of (22) would be repeated many times.",
        "This is one reason for the efficiency of CU.",
        "Constraint (23) is not transformed because it is already modular (idea (b)).",
        "Prolog would exploit the definition clauses of r and expend unnecessary computation time.",
        "This is another reason for CU's efficiency.",
        "To transform (21) and (22) into modular constraint-terms, (24) and (25) are called.",
        "(24) integrate(Cp(X,Y) ,q(Y ,Z)]) (25) integrate(Ep(A,B),r(A)))",
        "Since (24) and (25) succeed and return cO(X,Y,Z)4 and ci(A,B), respectively, (14) returns (26).",
        "(26) [cO(X,Y,Z),c1(A,B),r(C)] This modularization would fail if either (24) or (25) failed.",
        "Next, we explain integrate through the execution of (24).",
        "First, a new predicate c0 is made so that we can suppose (27).",
        "(27) cO(X,Y,Z)<=>p(X,Y),q(Y,Z) Formula (27) means that (24) returns cO(X,Y,Z) if the constraint [p(X,Y),q(Y,Z)] is satisfiable; that is, cO(X,Y,Z) can be modularly defined so that cO(X,Y,Z) and p(X,Y),q(Y,Z) constrain X, Y, and Z in the same way.",
        "Next, a target constraint-term is chosen.",
        "Although some heuristics may be applicable to this choice, we simply choose the first element p(X,Y) here.",
        "Then, the definition clauses of p are consulted.",
        "Note that this corresponds to the expansion of a disjunction.",
        "First, (15) is exploited.",
        "The head of (15) is unified with p(X,Y) in (27) so that (27) becomes (28).",
        "(28) cO(f (A) ,C,Z)<=r(A) ,r(C) ,q(C,Z)",
        "The term p(f(A),C) has been replaced by its body r(A),r(C) in the right-hand side of (28).",
        "Formula (28) means that cO(f (A) ,C,Z) is true if the variables satisfy the right-hand side of (28).",
        "Since the right-hand side of (28) is not modular, (29) is called and it must return a constraint like (30).",
        "As a result, (24) returns cO(X,Y,Z) because its definition clauses are made.",
        "All the Horn clauses made in this CU invoked by (14) are shown in (36).",
        "(36) c0(f(A),C,Z):-r(A),c2(C,Z).",
        "c0(a,b,Z):-c3(Z).",
        "c2(a,b).",
        "c2(b,a).",
        "c3(a).",
        "cl(a,b).",
        "When a new clause is created, if the predicate of a term in its body has only one definition clause, the term is unified with the head of the definition clause and is replaced by the body.",
        "This operation is called reduction.",
        "For example, the second clause of (36) is reduced to (37) because c3 has only one definition clause.",
        "(37) c0(a,b,a).",
        "CU has another operation called folding.",
        "It avoids repeating the same type of integrations so that it makes the transformation efficient.",
        "Folding also enables CU to handle some of the recursively-defined predicates such as member and append."
      ]
    },
    {
      "heading": "3.2 Parsing with Constraint Unification",
      "text": [
        "We adopt the CYK algorithm (Aho and Ullman 1972) for simplicity, although any algorithms may be adopted.",
        "Suppose the constraint-term cat_n_m(X) means X is the category of a phrase from the (n 1)th word to the mth word in an input sentence.",
        "Then, application of a phrase structure rule is reduced to creating Horn clauses like (38).",
        "cat_k_m(R), psr(L,R,M)]).",
        "(2<m<1, 0<n<m -2, n 1<k<m - 1, where I is the sentence length.)",
        "The body of the created clause is the constraint returned by the modularization in the right-hand side.",
        "If the modularization fails, the clause is not created."
      ]
    },
    {
      "heading": "3.3 Problem of Constraint Unification",
      "text": [
        "The main problem of a CU-based parser is that the number of constraint-term arguments increases as parsing proceeds.",
        "For example, cat_0_2(M) is computed by (39).",
        "(39) modularize(Ccat_0_1(L), cat_1_2(R), psr(L,R,M))) This returns a constraint like [cO(L,R,M)].",
        "Then",
        "Next, suppose that (40) is exploited in the following application of rules.",
        "Then (42) will be called.",
        "(42) rnodu/arize(CcO(L,R,M), cat _2_3 (R1) , psr(M,R1,M1)]) It returns a constraint like cl(L,R,M,R1,M1).",
        "Thus the number of the constraint-term arguments increases.",
        "This causes computation time explosion for two reasons: (a) the augmentation of arguments increases the computation time for making new terms and environments, dividing into groups, unification, and so on, and (b) resulting structures may include excessive disjunctions because of the ambiguity of features irrelevant to the mother categories."
      ]
    },
    {
      "heading": "4 Constraint Projection",
      "text": [
        "This section describes constraint projection (CP), which is a generalization of CU and overcomes the disadvantage explained in the previous section."
      ]
    },
    {
      "heading": "4.1 Basic Ideas of Constraint Projection",
      "text": [
        "Inefficiency of parsing based on CU is caused by keeping information about daughter nodes.",
        "Such information can be abandoned if it is assumed that we want only information about mother nodes.",
        "That is, transformation (43) is more useful in parsing than (44).",
        "Constraint Ec3(M)] in (43) must be satisfiable and equivalent to the left-hand side concerning M. Since [c3(M)) includes only information about H, it must be a normal constraint, which is defined in (45).",
        "(45) (Definition: Normal) A constraint is normal if (a) it is modular, and (b) each definition clause is a normal definition clause; that is, its body does not include variables which do not appear in the head.",
        "For example, (46) is a normal definition clause while (47) is not.",
        "(46) p(a,X): â€“ r(X).",
        "(47) q(X): â€“ s(X,Y).",
        "The operation (43) is generalized into a new operation constraint projection which is defined in (48).",
        "(48) Given a constraint C and a list of variables which we call goal, CP returns a normal constraint which is equivalent to C concerning the variables in the goal, and includes only variables in the goal.",
        "â€¢ Symbols used: â€“ X, Y, ...; lists of variables.",
        " â€“ P, Q, ...; constraint-terms or sometimes \"fail\".",
        " â€“ P, Q, ...; constraints or sometimes \"fail\".",
        " â€“ H, E, ...; lists of constraints.",
        "â€¢ project(P, X) returns a normal constraint (list of atomic formulas) on X.",
        "1.",
        "If P = NIL then return NIL.",
        "2.",
        "If X = NIL,",
        "If not(satisfiable(P)), then return \"fail\", Else return NIL.",
        "3.",
        "H := divide(P).",
        "4.",
        "Hâ€ž., := the list of the members of H which include variables in X.",
        "5.",
        "II, := the list of the members of H other than the members of Hi.. 6.",
        "For each member R. of Hes.",
        "If not(satisfiable(R)) then return \"fail\" 7.",
        "S := NIL.",
        "8.",
        "For each member T of â€“ V := intersection(X, variables appearing in T).",
        " â€“ R := normalize(T, V).",
        " â€“ If R = \"fail\", then return \"fail\", Else add R to S. 9.",
        "Return S. â€¢ normalize(S, V) returns a normal constraint-term (atomic formula) on V. 1.",
        "If S does not include variables appearing in V, and S consists of a modular term, then Return S. 2.",
        "S := a member of S that includes a variable in V. 3.",
        "S' := the rest of S. 4.",
        "C := a term cn(v1, v2, ..., vn).",
        "where vl, vn are all the members of V and c,â€ž is a new functor.",
        "5. success-flag := NIL.",
        "6.",
        "For each definition clause H :- B. of the predicate of S:",
        " â€“ 0 := mgu(S, H).",
        " â€“ If 0 = fail, go to the next definition clause.",
        " â€“ X := a list of variables in CO. â€“ Q := project(append(B0, S'0), X).",
        " â€“ If Q = fail, then go to the next definition clause Else add CO:-Q. to the database with reduction.",
        "7.",
        "If success-flag = NIL, then return \"fail\", else return C.",
        "â€¢ mgu returns the most general unifier (Lloyd 1984).",
        "â€¢ divide(P) divides P into a number of constraints which share no variables and returns the list of the constraints.",
        "â€¢ satisfiable(P) returns T if P is satisfiable, and NIL otherwise.",
        "(satisfiable is a slight modification of modularize of Cu.)",
        "CP also divides input constraint C into several constraints according to dependencies, and transforms them separately.",
        "The divided constraints are classified into two groups: constraints which include variables in the goal, and the others.",
        "We call the former goal-relevant constraints and the latter goal-irrelevant constraints.",
        "Only goal-relevant constraints are transformed into normal constraints.",
        "As for goal-irrelevant constraints, only their satisfiability is examined, because they are no longer used and examining satisfiability is easier than transforming This is a reason for the efficiency of CP."
      ]
    },
    {
      "heading": "4.2 Algorithm of Constraint Projection",
      "text": [
        "CP consists of two functions, project (constraint, goal (variable list)) and normalize (constraint, goal(variable list)), which respectively correspond to modularize and integrate in CU.",
        "We can execute CP by calling project.",
        "The algorithm of constraint projection is shown in Figure 14.",
        "We explain the algorithm of CP through the execution of (49).",
        "(49) project( [p(X,Y),q(Y,Z),p(A,B),r(A),r(C)], EX ,C3)",
        "The predicates are defined in the same way as (15) to (20).",
        "This execution is illustrated in Figure 2.",
        "First, the input constraint is divided into (50), (51) and (52) according to dependency.",
        "(50) [p(X,Y),q(Y,Z)) (51) [p(A,B),r(A)] (52) [r(C)]",
        "Constraints (50) and (52) are goal-relevant because they include X and C, respectively.",
        "Since *Since the current version of CP does not have an operation corresponding to folding, it cannot handle recursively-defined predicates.",
        "(51) is goal-irrelevant, only its satisfiability is examined and confirmed.",
        "If some goal-irrelevant constraints were proved not satisfiable, the projection would fail.",
        "Constraint (52) is already normal, so it is not processed.",
        "Then (53) is called to transform (50).",
        "(53) normalize([p(X,Y),q(Y,Z)], [X])",
        "The second argument (goal) is the list of variables that appear in both (50) and the goal of (49).",
        "Since this normalization must return a constraint like [cO(X)], (49) returns (54).",
        "(54) EcO(X),r(C)] This includes only variables in the goal.",
        "This constraint has a tighter structure than (26).",
        "Next, we explain the function normalize through the execution of (53).",
        "This execution is illustrated in Figure 3.",
        "First, a new term c0 (X) is made so that we can suppose (55).",
        "Its arguments are all the variables in the goal.",
        "The normal definition of c0 should be found.",
        "Since a target constraint must include a variable in the goal, p(X,Y) is chosen.",
        "The definition clauses of p are (15) and (16).",
        "(15) p(t (A) ,C) :-r(A),r(C) (16) p(a,b) .",
        "The clause (15) is exploited at first.",
        "Its head is unified with p(X,Y) in (55) so that (55) becomes (56).",
        "(If this unification failed, the next definition clause would be exploited.)",
        "(56) c0(f (A))4=>r(A) ,r(C) , q(C , Z) The right-hand side includes some variables which",
        "do not appear in the left-hand side.",
        "Therefore, (57) is called.",
        "(57) project( Cr ( A) , r (C) , q(C , Z)] , [A]) This returns r(A), and (58) is created.",
        "(58) c0(f(A)):-r(A).",
        "Second, (16) is exploited and (59) is created in the same way.",
        "(59) c0(a).",
        "Consequently, (53) returns cO(X) because some definition clauses of CO have been created.",
        "All the Horn clauses created in this CP are shown in (60).",
        "(60) c0(f (A)) :-r(A).",
        "c0(a).",
        "Comparing (60) with (36), we see that CP not only is efficient but also needs less memory space than CU."
      ]
    },
    {
      "heading": "4.3 Parsing with Constraint Projection",
      "text": [
        "We can construct a CYK parser by using CP as in (61).",
        "cat_k_m(R), psr(L,R,10], NJ).",
        "(2<m</, 0<n<m â€“ 2, n-1-1<k<m â€“ 1, where / is the sentence length.)",
        "For a simple example, let us consider parsing the sentence \"Japanese work.\" by the following projection.",
        ").",
        "Since the first of argument of the projection is satisfiable, it returns NIL.",
        "Therefore, (74) is created, and (75) is created since the right-hand side of (71) returns cl (Tense).",
        "Thus CP can be applied to CYK parsing, but needless to say, CP can be applied to parsing algorithms other than CYK, such as active chart parsing."
      ]
    },
    {
      "heading": "5 Implementation",
      "text": [
        "Both CU and CP have been implemented in Sun Common Lisp 3.0 on a Sun 4 sparc station 1.",
        "They are based on a small Prolog interpreter written in Lisp so that they use the same non-disjunctive unification mechanism.",
        "We also implemented three CYK parsers that adopt Prolog, CU, and CP as the disjunctive unification mechanism.",
        "Grammar and lexicon are based on HPSG (Pollard and Sag 1987).",
        "Each lexical item has about three disjuncts on average.",
        "Table 1 shows comparison of the computation time of the three parsers.",
        "It indicates CU is not as efficient as CP when the input sentences are long.",
        "Input sentence CPU time (sec.)",
        "Prolog CU CP He wanted to be a doctor.",
        "3.88 6.88 5.64 You were a doctor when you were young.",
        "29.84 19.54 12.49 I saw a man with a telescope on the hill.",
        "(out of memory) 245.34 17.32 He wanted to be a doctor when he was a student.",
        "65.27 19.34 14.66"
      ]
    },
    {
      "heading": "6 Related Work",
      "text": [
        "In the context of graph unification, Carter (1990) proposed a bottom-up parsing method which abandons information irrelevant to the mother structures.",
        "His method, however, fails to check the inconsistency of the abandoned information.",
        "Furthermore, it abandons irrelevant information after the application of the rule is completed, while CP abandons goal-irrelevant constraints dynamically in its processes.",
        "This is another reason why our method is better.",
        "Another advantage of CP is that it does not need much copying.",
        "CP copies only the Horn clauses which are to be exploited.",
        "This is why CP is expected to be more efficient and need less memory space than other disjunctive unification methods.",
        "Hasida (1990) proposed another method called dependency propagation for overcoming the problem explained in Section 3.3.",
        "It uses Iran-sclausal variables for efficient detection of dependencies.",
        "Under the assumption that information about daughter categories can be abandoned, however, CP should be more efficient because of its simplicity."
      ]
    },
    {
      "heading": "7 Concluding Remarks",
      "text": [
        "We have presented constraint projection, a new operation for efficient disjunctive unification.",
        "The important feature of CP is that it returns constraints only on the specified variables.",
        "CP can be considered not only as a disjunctive unification method but also as a logical inference system.",
        "Therefore, it is expected to play an important role in synthesizing linguistic analyses such as parsing and semantic analysis, and linguistic and non-linguistic inferences."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "I would like to thank Kiyoshi Kogure and Akira Shimazu for their helpful comments.",
        "I had precious discussions with KOichi Hasida and Hiroshi Tuda concerning constraint unification."
      ]
    }
  ]
}
