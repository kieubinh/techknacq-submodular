{
  "info": {
    "authors": [
      "Marc Dymetman"
    ],
    "book": "Workshop on Reversible Grammar in Natural Language Processing",
    "id": "acl-W91-0104",
    "title": "Inherently Reversible Grammars, Logic Programming and Computability",
    "url": "https://aclweb.org/anthology/W91-0104",
    "year": 1991
  },
  "references": [
    "acl-C88-2128",
    "acl-C90-2051",
    "acl-C90-3017",
    "acl-P83-1021",
    "acl-P89-1002",
    "acl-P90-1027",
    "acl-W91-0110"
  ],
  "sections": [
    {
      "heading": "ABSTRACT",
      "text": [
        "This paper attempts to clarify two distinct notions of \"reversibility\": (i) Uniformity of implementation of parsing and generation, and (ii) reversibility as an inherent (or intrinsic) property of grammars.",
        "On the one hand, we explain why grammars specified as definite programs (or the various related \"unification grammars\") lead to uniformity of implementation.",
        "On the other hand, we define different intrinsic reversibility properties for such grammars – the most important being finite reversibility, which says that both parsing and generation are finitely enumerable (see text) – and give examples and counterexamples of grammars which possess or do not possess these intrinsic properties.",
        "We also show that, under a certain \"moderation\" condition on linguistic description, finite enumer-ability of parsing is equivalent to finite enumerability of generation."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "From the linguist's point of view, a grammar is a formal device which defines a recursively enumerable set of well-formed linguistic structures, each having, among other aspects, a phonological content (or, when dealing with written text, a string content) and a semantic content.",
        "Such a device is completely neutral as regards its uses for parsing (recovering semantic content from string content) or generation (recovering string content from semantic content).",
        "From the computational linguist's point of view, on the other hand, the problem is how to implement such a grammar both as a parsing program and as a generation program, in such a way that these programs exactly reflect the content of the grammar.",
        "This we will call the reversibility problem.",
        "Let us assume, for specificity, that the grammar has been presented as a definite program (a Prolog program).'",
        "Then the reversibility problem has a simple solution: use a complete interpreter for definite programs – for instance a top-down interpreter having a breadth-first search procedure2 – and directly use the grammar as the program both for parsing and for generation.",
        "In the parsing mode, for any given string x, the program will enumerate all semantics yi, y2, ... assigned to it by the grammar, and similarly, in the generation mode, for any given semantics y, the program will enumerate all semantics xl, x2, ... assigned to it by the grammar.",
        "This is a striking property of definite programs: they are reversible in the sense that they naturally lead to uniformity of implementation of the parsing and generation modes (see §4).",
        "So the reversibility problem is solved, and we can spend the next few years skimming through Fodor's (not Jerry's) guides in travel bookstores?",
        "Not quite.",
        "First, the standard depth-first interpreter for definite programs is an incomplete one, and this problem must be circumvented in some way.",
        "Second, and more crucially, even when using a complete interpreter, parsing (and similarly generation) does not in general terminate: the program may well enumerate yl, y2, ... ad infinitum.",
        "This is even true if, in fact, there are only a finite number of solutions yi , y2, ... , yk, or even, in the extreme case, no solution at all: the program may not be \"aware\" that it has at some point already exhausted all the solutions that it will eventually 1We could have made some other choice, for instance some unification grammar formalism.",
        "The advantage of using definite programs in the present discussion is that they embody the whole unification paradigm in its purest form, that unification of terms is conceptually simpler (and less prone to misunderstandings) than unification of DAGs, and that the denotational and operational semantics of definite programs have been thoroughly studied.",
        "find, and go on eternally looking for new solutions.",
        "The source of this problem can be more or less severe: It may simply be due to the grammar's implementation as'a certain program, or it may be intrinsic to the grammar.",
        "If it is not intrinsic to the grammar, one may attempt some kind of program transformation on the grammar – for 'instance a local transformation as goal reordering in clause bodies [4, 16], or a global transformation as left-recursion elimination [5, 3] 3 – in order to get a parsing program which displays a finite behavior.4 If such a transformation is possible in principle, we say that, intrinsically, the grammar has a finitely enumerable parsing problem.5 One example of a class of grammars which respect this crucial condition is provided by offline-parsable DCGs, once compiled as definite programs (see [9]).6 We have limited the former discussion to the case of parsing.",
        "The case of generation is treated in a parallel fashion, and one can similarly define the conditions in which a grammar is said to have an intrinsically finitely enumerable generation problem.",
        "When a grammar is such that it has a finitely enumerable parsing problem and a finitely enumerable generation problem, we call the grammar inherently finitely reversible.",
        "When this is the case, it is by definition possible to find a program P„ for parsing and a (not necessarily identical) program Pg for generation such that, for any string x, Pi, enumerates all associated semantics y and terminates, and, for any semantics y, Pg enumerates all associated strings x and terminates.",
        "Inherent finite reversibility is the concept which, in my opinion, permit us to capture formally the intuitive notion that a certain grammar is, or is not, \"reversible\".",
        "30r more generally', any transformation exploiting theorems provable of the, grammar.",
        "Another instance of this technique is provided by the addition of conservative guides in [5], which \"strengthen\" the grammar on the basis of properties inferable from its form.",
        "4 Another popular approach is to use a special-purpose interpreter, exploiting i properties of the grammar known a priori.",
        "[18] and [14] use this approach in the case of generation (see below)."
      ]
    },
    {
      "heading": "2 Definite programs and computation",
      "text": []
    },
    {
      "heading": "2.1 Denotational and operational se",
      "text": [
        "mantics of a definite program; complete and incomplete interpreters A definite program P is a finite set of clauses of the form (non-unit clauses):",
        "where the the p,pi are predicate symbols and the Tij are terms over a certain Herbrand universe of ground terms H. We will suppose that, among the predicates p defined by P, one, r, is privileged and plays the role of the \"main predicate\" in the program.",
        "We will assume that r is of arity one.7"
      ]
    },
    {
      "heading": "2.1.1 Denotational semantics",
      "text": [
        "The denotational, or declarative, semantics of program P can be defined as the least fixed point of a certain operator on Herbrand interpretations which we will not describe here (see [7]).",
        "Informally, the denotations of the predicate symbols p are defined as nary relations p(xi, , xn) over H, built as the limit of a bottom-up process which starts from the unit clauses and uses the non-unit clauses to add new instances to each relation.",
        "In particular, this process defines the unary relation r(x) on H, which we shall call the denotational semantics of the main predicate r relative to program P. Let T be a term over H; We define the specialization of r(X) on T as the relation rT(x) on H defined by:",
        "where C is the relation of subsumption.",
        "In case the term T is a variable X, we say that X is the trivial specialization, and we note that the relation rx(x) is identical to the relation r(x)."
      ]
    },
    {
      "heading": "2.1.2 Operational semantics",
      "text": [
        "While the denotational semantics of P is an intrinsic property of P, its operational semantics is defined relative to some interpreter.",
        "For our purposes, we will informally define an interpreter as a computational mechanism:",
        "which is input a definite program P, as well as a query ?r(T) – where r is P's main predicate and T a term over H – and which outputs a finite or infinite \"list of answers\": Tk,...",
        "The Tk's are terms over H, ground or not, whose ground instances provide the \"solutions\" to query ?r(T).",
        "If the list of answers is infinite, the interpreter will not stop; If it is finite the interpreter may or may not stop: if it does, we will say that the interpreter terminates on query ?r(T).",
        "Consider now the relation 4, on H defined by: 4.",
        "(x)dae-fxET1 VxE7'2V•-•VxETkV•-• We say that 4. is the operational semantics of the main predicate r of P, for specialization T, relative to interpreter intpr.",
        "Keeping the same notations as above, consider now the denotational semantics r(x) of r relative to P, and consider its specialization rT(x).",
        "Interpreter intpr is said to be sound if one has, for any P, r, T: VX E H i4(x) rT(x); and to be complete if:",
        "the branches – maybe leading to success – to the right of this branch in the search-tree [7, pp.",
        "59-60].",
        "By contrast, a top-down, breadth-first interpreter, i.e. one which explores nondeterministic choices (between the different clauses competing for resolution of the same atomic goal) in parallels is complete [7, pp.",
        "59].",
        "The naive bottom-up interpreter, which in essence directly calculates the denotational semantics of P, and filters a posteriori the semantics r(x) through the constraint that the solutions unify with T, is also a complete algorithm."
      ]
    },
    {
      "heading": "2.2 Computational behavior of a",
      "text": [
        "definite program relative to an interpreter We now consider a program P, having r as main predicate, the denotation of r relative to P being the relation r(x) on H. We also consider a specialization T, i.e. a term on H. We will compare the denotational content of P to its computational behavior, and describe three possibilities: (i) P enumerates r on T, (ii) P discovers r on T, and (iii) P finitely enumerates r on T. The interpreter is supposed to be fixed beforehand.",
        "We say that:",
        "• P enumerates r on specialization T if: VX E H <=;., rT(x), in other words, if its list of answers: T1, T2, • •Tk • • • exactly \"covers\" the denotational semantics rT 9 • P discovers r on specialization T if:",
        "Soundness is a minimal requirement for an interpreter, and we will always assume it, but completeness is a requirement which is not always met in practice."
      ]
    },
    {
      "heading": "2.1.3 Complete and incomplete interpreters",
      "text": [
        "The \"standard\" interpreter for definite programs uses a top-down, depth-first search algorithm.",
        "It is sound but not complete.",
        "Its non-completeness is due to the fact that it is depth-first: if its search-tree contains infinite branches, the interpreter will be \"caught\" in the first one and will never explore",
        "1.",
        "P enumerates r on T; 2.",
        "If rT is the uniformly false relation on H, then P terminates on T.1° • P finitely enumerates r on specialization T if: 1.",
        "P enumerates r on T;",
        "2.",
        "P terminates on T.11 We simply say that P enumerates (discovers, finitely enumerates) r if P enumerates (discovers, finitely enumerates) r on the trivial specialization X.",
        "We have the obvious entailments: P finitely enumerates r on T P discovers",
        "• on T P enumerates r on T.",
        "It is often the case that one is interested in the computational properties of a given definite program relative to a certain class of specializations.",
        "For instance, when using a grammar – given as a definite program – for parsing, one will consider all queries where some of the variables are ground (the string to parse) and others (the semantic form) are not, and one will want to consider the computational properties Of the program relative to this class of specializations.",
        "When using the definite program for generation, one will be interested in another class of specializations, and will want to consider the computational properties of the program relative to that class of specializations.",
        "Let S = {T} be a set of (not necessarily ground) terms on H, indeed by a finite or infinite set I.",
        "We call S a class of specializations.",
        "We say that:",
        "• P enumerates r on S if, for all T E S, P enumerates r on T; • P discovers r on S if, for all TE S,P discovers r on T; • P finitely enumerates r on S if, for all T E S, P finitely enumerates r on T.",
        "The mutual entailments between these properties are similar to the ones given in (1)."
      ]
    },
    {
      "heading": "2.3 Intrinsic computational properties of a definite program",
      "text": [
        "Let $ be a class of specializations, and let r(x) be an arbitrary unary relation on H. We suppose here that programs are evaluated with respect to a sound and complete interpreter, which has been fixed once and for 0, and we say that:",
        "• r is enumerabk on S if there exists a definite program P which enumerates r on S. • r is discoverable on S if there exists a definite program P which discovers r on S.",
        "11 In particular, the relation rT is, loosely speaking, \"finitely representable as a union of terms T1, 7'2, • • • Ti,\" and the program is \"aware\", at a certain point, that it has exhausted the possible answers.",
        "• r is finitely enumerable on S if there exists a definite program P which finitely enumerates r on S.",
        "These three notions, taken together, constitute a \"computability hierarchy\" where enumerability is the weakest condition, discoverability is an intermediary condition, and finite enumerability is the strongest condition.",
        "These computability conditions can be described more intuitively in the following way:12 • r is enumerable on S if there exists a program P such that, for any TE S,P is able, given infinite time, to find terms T1, T2 , • • • such that:",
        "• r is discoverable on S if there exists a program P which is furthermore able to decide in finite time, for any T E S, if there actually exists an x such that: r(x)Ax CT • r is finitely enumerable on S if there exists a program P which is furthermore able to find in finite time, for any T E S, terms Ti , T2, • • • , Tk such that:",
        "Vx H r(x) AxE T -4=> sET1VxET2••-\\./xEn Let {X} be the set having for only element the trivial specialization X; {X} is called the trivial class of specializations.",
        "We will simply say that r is enumerable (resp.",
        "discoverable, finitely enumerable) if r is enumerable (resp.",
        "discoverable, finitely enumerable) on the trivial class {X}.",
        "Let G = H be the set of all ground terms of H. G is called the class of ground specializations.",
        "The following properties – which we will not prove here – establish links between the notions that we have just defined and the classical notions of recursively enumerable relations and recursive relations:",
        "• is a recursively enumerable relation on H",
        "12 Note that these definitions critically depend on the relative scopes of quantifiers 3P VT E S .",
        ": it is essential that program P be the same for all specializations T in S.",
        "r is a recursive relation on H iff r is discov- (3) erable on the class of ground specializations g iff r is finitely enumerable on the class of ground specializations G ."
      ]
    },
    {
      "heading": "3 Grammars and their computational uses",
      "text": [
        "Let X#Y denote, in infix notation, the term #(X, Y).",
        "In the context of this paper, we take a grammar to be a definite program G having as its main predicate the unary predicate r, and we will assume that the clauses defining r are of the form:",
        "X will be called the \"p-parameter\", Y the \"gparameter\".",
        "Generally, the p-parameter will represent a character string, and the g-parameter a semantic form.13"
      ]
    },
    {
      "heading": "3.1 Six computational problems",
      "text": [
        "A grammar can be used either to enumerate well-formed structures or to check whether certain fully instantiated values of the parameters can be accepted.",
        "We distinguish six computational problems (grouped into four types) which can be solved with a grammar: p-enumeration, p-acceptation, g-enumeration, g-acceptation, bi-enumeration, bi-acceptation.",
        "These problems are defined, together with comments on their computational properties, using the terminology of §2.3.",
        "This permits us to characterize the different positions a given grammar can occupy on the \"computability hierarchy\" – enumerability/discoverability/finite enumerability – relatively to each of these problems.",
        "The p-enumeration problem or parsing problem is the problem of enumerating, for any fixed ground term x, all ground terms y such that r(x#y).",
        "The p-acceptation problem or decision problem for parsing is the problem of checking, for any fixed ground term x, whether there exists a ground term y such that r(x#y) is true.",
        "The same specialization class is associated with both these problems, namely the class GP = {x#Y}zEff consisting in all the terms x#Y where 13We thus take r to be a unary relation which \"encodes\" a binary relation.",
        "This is unessential, but permits us to use the concepts of the previous section, developed for unary relations, without having to generalize them to nary relations.",
        "x is any ground term, and Y is a certain variable (whose name is indifferent).",
        "Let's consider in turn, with respect to GP, the different positions the grammar – or equivalently, its denotational semantics r – can occupy on the computational hierarchy, from strongest to weakest: Finite enumerability When r is finitely enumerable on gr , it is in theory possible to find a program P such that, for any given (ground) value x of the p-parameter (the string), the program enumerates all the solutions to the parsing problem and terminates.",
        "These solutions are given implicitly as a finite list of answers TY1, , TYk: the TYi's are terms whose ground instances y are the looked-for values of the g-parameter (the semantics associated with string x by the grammar).",
        "We also say that, with the grammar at hand, p-enumeration is finitely enumerable, or simply, that parsing is finitely enumerable.",
        "This is an inherent property of the grammar, and, in practice, this property does not necessarily entail that finding a program P to exploit will be obvious.\"",
        "For instance, offline-parsable grammars [9] can be shown to possess a finitely enumerable parsing problem, but algorithms which are able to make use of this property are by no means trivial [9, 13, 415 Discoverability If r is not finitely enumerable on GP, it may still be discoverable on P. By definition, this means that it is possible to find a program P such that, for any given (ground) value x of the p-parameter, if there is no value y of the g-parameter corresponding to x, then the program will \"recognize\" this fact in finite time and terminate with an empty list of answers; if, on the other hand, there are solutions y corresponding to x, then the program will enumerate them, but maybe not terminate.",
        "If this property holds, we also say that with the grammar at hand, p-enumeration is discoverable, or, simply, parsing is discoverable.",
        "One can easily prove (although we will not do it here) that this property is equivalent to the decidability (in the classical sense) of the p-acceptation problem.",
        "In other words: 14 See footnote 17.",
        "15 These papers do not use the concept (or, a fortiori, the terminology) \"finite entunerability of parsing\", which, to my knowledge, appears here for the first time (see however [6], for the related notion of \"Universal Parsing Problem\").",
        "Enumerability By the definition of a grammar as being a recursively enumerable mechanism, and by property (2), r is enumerable on any specialization class, and in particular on P.",
        "The g-enumeration 'problem or generation problem is the problem of enumerating, for any fixed ground term y, all ground terms x such that r(x#y).",
        "The g-acceptation problem or decision problem for generation is the problem of checking, for any fixed ground term y, whether there exists a ground term x such that r(x#y) is true.",
        "The specialization class is associated with both these problems is the class gg = pc#0„, consisting in all the terms X#y where y is any ground term, and X is a certain variable (whose name is indifferent).",
        "The situation is exactly symmetrical to the case of p-enumeration and p-acceptation, and we can define, in the same way, the notions: \"generation is finitely enumerable\" and \"generation is discover-able\" (which is equivalent to \"g-acceptation is de-cidable\")."
      ]
    },
    {
      "heading": "3.1.3 bi-enumeration",
      "text": [
        "The 6i-enumeration, problem is the problem of enumerating all ground, terms x, y such that r(x#y).",
        "The specialization class associated with this problem is the class' TRIV = {X#Y } which contains the single term X#Y.",
        "For non-degenerate grammars, it is not the case that r is finitely enumerable on TRIV, for this would entail in particular that any string recognized by the grammar is subsumed under one of the terms in a fixed finite set of terms T1, • .",
        "• , T. This is a slightly weaker property than saying that there are finitely many strings recognized by the grammar, but is still a very unlikely property for a grammar.",
        "On the other hand, by definition, r is enumerable on TRIV.",
        "It can be shown easily that it is also discoverable on TRIV .17 16 An immediate consequence of this property (linking the p-enumeration problem with the p-acceptation problem) is the fact that a grammar which is finitely enumerable for parsing has a decidable p-acceptation problem.",
        "The converse is clearly false (see §6 for a counter-example).",
        "17 This is because: (i) In case the grammar generates nothing, there is a trivial program which, on query"
      ]
    },
    {
      "heading": "3.1.4 bi-acceptation",
      "text": [
        "The bi-acceptation problem is the problem of checking, for any fixed ground terms x and y, whether r(x#y) is true.",
        "The specialization class associated with this problem is the set G {x#y}z,yEH of ground specializations.",
        "It can be shown that r is finitely enumerable on G if it is discoverable on G if the relation r on H is recursive in the classical sense.",
        "When this is the case, one says that bi-acceptation is decidable.",
        "Again, by property (2), r is enumerable on any specialization class, and in particular on g. REMARK.",
        "Suppose that parsing is finitely enumerable, that is, r is finitely enumerable on GP.",
        "This obviously implies that r is also finitely enumerable on G. Therefore, one has: parsing is finitely enumerable bi-acceptation is decidable; and, by the same reasoning: generation is finitely enumerable bi-acceptation is decidable.",
        "On the other hand, the weaker property that p-acceptation is decidable (or similarly, that g-acceptation is decidable) does not seem to entail that bi-acceptation is decidable."
      ]
    },
    {
      "heading": "4 Definite programs, uniformity of implementation, and reversibility",
      "text": [
        "It is sometimes stated that various grammatical formalisms, based on a variant or another of unification, are \"reversible\".",
        "It should more properly be said that they are \"well-adapted\" to reversible grammar implementations.",
        "The paradigmatic case of a grammar given as a definite program G makes this especially clear.",
        "We know, from the discussion of §3.1.1 and §3.1.2, that we always have: (i) r is enumerable ?r(X#Y), produces an empty list of answers and terminates and (ii) if this is not the case, then the grammar itself may serve as an enumerating program (perhaps a non-terminating one).",
        "Note that this does not entail that by looking at the grammar, one is actually able – even in principle – to decide which of these two situations actually holds!",
        "This is an extreme instance of the remark made above (in the discussion of finite enumerability of parsing) that the existence in principle of a program meeting certain criteria does not imply that it is obvious, or indeed possible, to find such a program.",
        "on GP and (ii) r is enumerable on GC; we therefore know that there exist programs Pp and Pg which enumerate r respectively on GP and GC.",
        "But in fact we have more: if we use a sound and complete interpreter, we can simply take Pp Pg G. This follows from the fact that, by definition, relatively to such an interpreter, G enumerates rT , for any specialization T (see §2.1.1):",
        "• G enumerates r on GP; • G enumerates r on GG.",
        "To be more concrete, suppose that we use a complete top-down interpreter; Its behavior will be along the following lines:",
        "1.",
        "On query ?r(X#Y), the interpreter returns the (generally infinite) list of answers",
        "Tl,T2,...,Tk,... where each Ti is a term of the form Ai#131; The (generally infinite) \"union\" of these terms \"exactly covers\" the query;",
        "2.",
        "On a query of the form ?r(x#Y), where x is a ground term, the interpreter returns the list of answers",
        "TIU(x#Y),T2U(x#Y),... ,TkU(x#Y),... where U is the operator of term unification, and where, with some abuse of notation, only the terms TiU(x#Y) for which unification is possible actually appear in the list; 3.",
        "On a query of the form ?r(X#y), where y is a ground term, the interpreter returns the list of answers TIU(X#y), T2U(X#y), , TkU(X#y), (with the same abuse of notation as above).",
        "This is a rather striking property of definite programs: different \"input modes\" can be implemented using one and the same interpreter and one and the same program.",
        "(This property strongly contrasts with other programming paradigms, for instance functional or imperative ones.",
        "Programs of these types typically map an input x to an output y, and, while it is indeed true that, for a given y, the set of xi which can serve as its input is recursively enumerable, the interpreter that could implement the (nondeterministic) mapping y x would have to be widely different from the \"normal\" interpreter for the language at hand.)",
        "However, \"reversibility\" in this sense only means uniformity of implementation for different modes of use of a grammar.",
        "Intrinsic finite reversibility which is defined in the next section, gives a much stronger criterion of grammar reversibility."
      ]
    },
    {
      "heading": "5 Inherently reversible grammars",
      "text": [
        "We say that a grammar G is (inherently) finitely reversible if, in the terminology of §3.1.1 and §3.1.2, G is such that:",
        "1. parsing is finitely enumerable; 2. generation is finitely enumerable.",
        "In other words, G is finitely reversible if there exists a program Pp for parsing and a (not necessarily identical) program Pg for generation such that, relative to some sound and complete interpreter:18",
        "1.",
        "On a query of the form ?r(x#Y), where x is any ground term, Pp returns a finite list of answers x#T1, x#T2, , x#Tk and stops.",
        "2.",
        "On a query of the form ?r(X#y), where y is any ground term, Pg returns a finite list of answers",
        "and stops.",
        "In order to guarantee that a grammar is finitely reversible, some strong assumptions must be made on its form.",
        "An example of such assumptions is provided by the class of Lexical Grammars described in [5].19 Lexical grammars are presented as definite programs.",
        "They all share the same core of rules, which describe basic compositionality assumptions (string compositionality, syntactic compositionality, semantic compositionality), but may have different lexicons, which contain all the more specific linguistic knowledge.",
        "The hypotheses made on string compositionality in Lexical Grammars are simply that sister constituents concatenate their strings; they entail that parsing is finitely enumerable.",
        "The hypotheses on semantic compositionality are related to functional application and composition in categorial grammars (see e.g. [15]).",
        "They entail that generation is finitely enumerable.",
        "A lexical grammar G is therefore finitely reversible.",
        "This does not imply that it can be used directly for parsing and for generation, but only, as seen previously, that there exist two programs Pp and Pg implementing G respectively for parsing and for generation.",
        "These programs are each obtained by a technique of adding to the grammar some redundant knowledge – respectively a conservative guide for parsing and aconservaiive guide for generation – and by applying a left-recursion elimination transformation (see [5]).",
        "6 Some counterexamples to finite reversibility and a \"moderation\" condition on linguistic description Fig.1 sums up graphically some of the relations which have been established in §3 between the computational problems associated with a grammar.",
        "The full arrows indicate entailments which have been established.",
        "The dotted arrows relate to a rather obvious question: What are the connections between the computational properties of parsing and those of generation?",
        "For instance, does the finite enumerability of parsing entail the finite enumerability of generation?",
        "If not, does it at least entail that g-acceptation is decidable?",
        "(The same questions can be asked in the reverse direction.)",
        "The answer is that, if no further assumptions are made (see below §6.3), then there are no connections.",
        "To show this, we now sketch one example which shows that finite enumerability of parsing does not even entail that g-acceptation is decidable."
      ]
    },
    {
      "heading": "6.1 A \"grammar\" related to Matiya-sevich's theorem",
      "text": [
        "Matiyasevich's theorem [2, p. 116] provides – among other things – a negative solution to Hilbert's tenth problem: \"Does there exist an algorithm capable of solving all diophantine equations?",
        "\", a diophantine equation being a multivariable polynomial in integer coefficients and whose variables range over N.2° Let K be a recursively enumerable, but non-recursive, subset of N. One corollary of Matiya-sevich's theorem is the following property [2, p. 127-28]: There exists a polynomial q(zi,...",
        ",z.)",
        "in integer coefficients such that K is the set of values taken by q, for z1, , zn ranging over all integers.",
        "This corollary can be exploited to give an example of a \"grammar\" which has a finitely enumerable parsing problem, but such that its g-acceptation problem is not decidable.",
        "Consider the relation r(x#y) which is true iff: (i) x is a string encoding any instance (for z1, , zn ranging over the integers) of the expression q(zi,... ,z,), using the symbols 0, , 9, '4r% `C, `r, etc., and (ii) y is a term encoding the integer resulting from the arithmetical evaluation of q(zi,... ,z).",
        "This relation can easily be described 20 The actual statement of Matiyasevich's theorem is stronger: \"Every partially decidable predicate is diophan-tine\" [2, p. 116].",
        "by a \"grammar\" G: This grammar checks the well-formedness of string x, and calculates its \"semantics\" y.21 G has the following properties:",
        "• parsing is finitely enumerable: there is a program (namely G itself) finitely enumerating r on GP.",
        "In effect, for any string x, this programs checks x for well-formedness and calculates the (single) \"semantics\" y resulting from the evaluation of x.",
        "• g-acceptation is not decidable.",
        "Indeed, the problem of g-acceptation is the problem of deciding, for any given integer y, whether y is in the image of polynomial q, that is, whether y belongs to K. But K is a non-recursive set, hence the conclusion."
      ]
    },
    {
      "heading": "6.2 A \"grammar\" related to the undecidability of first-order logic",
      "text": [
        "I will only very broadly sketch this example, which I think may provide useful insights on the importance of constraining \"string compositionality\" in a grammar.",
        "Consider ordered pairs (z,y) of (ground) terms where x is a string encoding a certain first-order logic tautology, and y (the \"semantics\") is a derivation of x using a certain fixed set of axiom schemata and rules of inference for a complete system of first-order logic.",
        "Let's assume for simplicity that the given rules of inference always have two premises and one conclusion.22 A grammar G can be defined along the following general lines.",
        "The clauses of G correspond to the system's axiom schemata and rules of inference.",
        "Each clause corresponding to an axiom schema of name as defines \"terminal constituents\" (x, as(x)), where string x is any instance of schema as; each clause corresponding to an inference rule of name ir takes two \"constituents\" (x, y) and (x2, Y2), and, if applicable (which is checked on the basis of strings x1 and x2), builds a new constituent (x, y), where x is the string obtained from xi and x2 according to ir, and where y is a new derivation tree ir(x, Yi, y2).",
        "We have the following properties: • generation is finitely enumerable: The generation problem is the problem, given a derivation 21 This requires defining addition and multiplication of integers inside G, which presents no special problem.",
        "22See for instance [8, p. 43-44] which describes a system having the two rules of inference E-11-21.i and at-T (where x is free in p).",
        "The second rule has one premise, but can easily be viewed as having two, if the premise True is added to its original premise.",
        "tree y, of enumerating all formulas x that are associated with it.",
        "But y contains an explicit representation of x, so that generation is trivially finitely enumerable.",
        "• p-acceptation is not decidable: The p-acceptation problem is the problem of checking if a string x can be derived from the axioms and the inference rules of the system.",
        "That is, it is the problem of checking if x is a tautology of first-order logic.",
        "By Church's undecidability result, this problem is undecidable."
      ]
    },
    {
      "heading": "6.3 Under a \"moderation\" condition",
      "text": [
        "on linguistic description, parsing is finitely enumerable if generation is The two counterexamples that we have just given have one property in common: the p-parameter can stay \"small\", while the g-parameter grows indefinitely \"large\", or conversely the g-parameter can stay small while the p-parameter grows indefinitely large.",
        "For instance, in the first counter-example, for a given value of y, there is no way to bound a priori the sizes of the integers zi, ... , z„ that may produce this y; in the second counter-example, there is similarly no way to bound a priori the sizes of proofs y for a given formula x.",
        "In order to characterize this phenomenon formally, we will define a notion of \"moderation\" for a grammar G, defined as a definite program over the Herbrand universe H. As previously r is the unary relation representing the denotational semantics of G. If a is a ground term in H, let us call size of this term, and denote by size(a), the number of nodes in a. Grammar G will be called moderate if there exist total recursive functions f : N --■ N, and g :N – +N, such that:",
        "A size(x) .5. g(size(y)).",
        "We have the following property: JIG is moderate, then, relative to G, parsing is finitely enurnerable if generation is (4) finitely enumerable.",
        "Let us briefly sketch the proof: Suppose that parsing is finitely enumerable, then we know (see §3.1.4) that bi-acceptation is decidable.",
        "On the other hand, for any fixed ground term y, there are only finitely many ground terms x in H such that size(x) <",
        "g(size(y)).",
        "Therefore, we can finitely enumerate all these x's, and for each of them, decide whether r(x, y) holds.",
        "This shows that generation is finitely enumerable.",
        "The converse is proven in the same way.",
        "Moderation might be claimed to be a \"natural\" constraint to impose on grammars used for \"legitimate\" linguistic purposes: One might want to argue that, in natural language, complexity of expression is a rather direct reflection of complexity of meaning.",
        "For eXarnple, semantic rules which reduced \"you love him or you don't\" to 'true', or \"how much is 6 times 7 ?\"",
        "to '?x.",
        "(x = 42)' would seem to be ruled out as valid linguistic descriptions.",
        "But we will not further pursue these tricky questions here."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "Thanks to Pierre Isabelle, Francois Perrault, Patrick Saint-Dizier, Tomek Strzalkowski and Gertjan van Noord for their comments on an earlier version of this paper.",
        "English and content have bigly suffered from my lacking time to impose, as usual, its reading on Elliott Macklovitch."
      ]
    },
    {
      "heading": "Appendix",
      "text": [
        "Examples of finitely reversible grammars that are inherently difficult to reverse In this appendix, we give two examples of grammars that, although they are finitely reversible, are such that one mode is easy, while the reverse mode has a high degree of complexity.",
        "These examples are closely parallel, in the context of complexity, to the examples of section 6, which were concerned with computability.",
        "Number products, cryptography and reversibility Consider the binary relation r(x#y) which is true if x is a string of the form:",
        "where N and M are strings, interpreted as integers, of O's and l's and '*' is interpreted as multiplication, and where y is an integer equal to the product of M and N.23 We impose a priori that integers M and N be strictly greater than 1.",
        "This relation can be defined by a \"grammar\" G: this essentially simply involves constraining the \"syntax\" of x and defining multiplication by a set of definite clauses.",
        "Implementing r in p-enumeration mode is easy: it involves verifying that x is well-formed, and computing its product according to specification G; In fact, G itself can be used for that purpose, using a standard interpreter.",
        "On the other hand, efficiently implementing r in g-enumeration mode is extremely difficult, whatever the interpreter, program transformations, mathematical properties of prime factorization, ..., which are brought to the task.",
        "The fact that it is so difficult is the basis of the best known \"public key cryptography\" algorithm, RSA [11].",
        "NP-complete problems and reversibility A NP-complete problem is, informally, a problem for which solutions can be checked in polynomial time (relative to the length of the problem), but which requires more than polynomial time for the discovery of a solution [11.24 For specificity, let us focus on one NP-complete problem, namely the \"3-colorability problem\" which consists, given a certain graph x, in finding a coloring y for x using blue, green and red, in such a way that vertices sharing a common arc have different colors.",
        "It is possible to state the problem as a definite program G, whose main relation is of the form r(x#y), x and y being suitable term encodings for the graph x and for the solution y.",
        "The solution y can be considered as implicitely containing a description of graph x.",
        "It is obvious that g-acceplation is computationally easy (polynomial): it consists in verifying that the coloring y respects the coloring condition.",
        "On the other hand, p-acceptation is computationally costly: it consists in checking whether graph x has a solution, a problem which is at the present time believed to require exponential time."
      ]
    }
  ]
}
