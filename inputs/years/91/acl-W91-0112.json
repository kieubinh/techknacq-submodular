{
  "info": {
    "authors": [
      "Tomek Strzalkowski"
    ],
    "book": "Workshop on Reversible Grammar in Natural Language Processing",
    "id": "acl-W91-0112",
    "title": "A General Computational Method for Grammar Inversion",
    "url": "https://aclweb.org/anthology/W91-0112",
    "year": 1991
  },
  "references": [
    "acl-C88-2128",
    "acl-C88-2150",
    "acl-C90-2019",
    "acl-C90-2022",
    "acl-C90-2033",
    "acl-C90-2051",
    "acl-C90-2052",
    "acl-C90-2060",
    "acl-C90-3017",
    "acl-E89-1032",
    "acl-J90-1004",
    "acl-P84-1018",
    "acl-P90-1027"
  ],
  "sections": [
    {
      "heading": "ABSTRACT",
      "text": [
        "A reversible grammar is usually understood as a computational or linguistic system that can be used both for analysis and generation of the language it defines.",
        "For example, a directive pars_gen(Sent,Forin) would assign, depending upon the binding status of its arguments, the representation in (Toronto,chased (Fido,John)) to the sentence Fido chased John in Toi;onto, or it would produce one of the several possible paraphrases of this sentence given its representation.",
        "Building such bidirectional systems has long been considered critical for various natural language processing tasks, especially in machine translation.",
        "This paper presents a general computational method for automated inversion of a unification-based parser for natural language into an efficient generator.",
        "It clarifies and expands the results of earlier work on reversible grammars by this author and the others.",
        "A more powerful version of the grammar inversion algorithm is developed with a special emphasis being placed on the proper treatment of recursive ' rules.",
        "The grammar inversion algorithm described here is at the core of the Japanese-English machine translation project currently under development at NYU."
      ]
    },
    {
      "heading": "REVERSIBLE GRAMMARS",
      "text": [
        "A reversible grammar is usually understood as a computational or linguistic system that can be used both for analysis and generation of the language it defines.",
        "For example, a directive pars_gen(Sent,Form) would assign, depending upon the binding status of its arguments, the representation in (Toronto,chased (Fido ,John)) to the sentence F ido chased John in Toronto, or it would produce one of the several possible paraphrases of this sentence given its representation.",
        "In the last several years, there have been a growing amount of research activity in reversible grammars for natural language, particularly in connection with machine translation work, and in natural language generation.",
        "Development of reversible grammar systems is considered desirable for variety of reasons that include their immediate use in both parsing and generation, a reduction in the development and maintenance effort, soundness and completeness of linguistic coverage, as well as the match between their analysis and synthesis capabilities.",
        "These properties are important in any linguistic system, especially in machine translation, and in various interactive natural language systems where the direction of communication frequently changes.",
        "In this paper we are primarily interested in the computational aspects' of reversibility that include bidirectional evaluation and dual compilation of computer grammars, inversion of parsers into efficient generators, and derivation of \"generating-versions\" of existing parsing algorithms.",
        "Some of the recent research in this area is reported in (Calder et al., 1989; Dymetman and Isabelle, 1988; Dymetman et al., 1990; Estival, 1990; Hasida and Isizaki, 1987; Ishizaki, 1990; Shieber, 1988; Shieber et al., 1990; Strzalkowski, 1990a-c; Strzalkowski and Peng, 1990; van Noord, 1990; and Wedckind, 1988).",
        "Dymetman and Isabelle (1988) describe a top-down interpreter for definite clause grammars that statically reorders clause literals according to a hand-coded specification, and further allows for dynamic selection of AND goals2 during execution, using the technique known as the goal freezing (Colmerauer, 1982; Naish, 1986).",
        "Shieber et al.",
        "(1990) propose a mixed top-down/bottom-up interpretation, in which certain goals, namely those whose expansion is defined by the so-called \"chain rules\",3 are not expanded during the top-down phase of the interpreter, but instead they are passed over until a nearest non-chain rule is reached.",
        "In the bottom-up phase the missing parts of the goal-expansion tree will be filled in by applying For linguistic aspects of reversible grammars, see (Kay, 1984; Landsbergen, 1987; Neuman, 1990; Steedman, 1987).",
        "2 Literals on the right-hand side of a clause create AND goals; literals with the same predicate names on the left-hand sides of different clauses create OR goals.",
        "A chain rule is one where the main binding-carrying argument (the \"head\") is passed unchanged from the left-hand side to the right.",
        "For example, assert(P) --> subj(P1),verb(P2),obj(P1,P2,P), is a chain rule with respect to the argument P, assuming that P is the 'head' argument.",
        "the chain rules in a backward manner.",
        "This technique, known as 'head-driven' evaluation, can be applied quite profitably to various grammar compilation tasks, including the inverse computation, but it requires that the underlying grammar is given in a form where the information about the semantic heads in nonterminals is made explicit.",
        "In addition, the procedure, as described in (Shieber et al., 1990), makes no attempt to impose a proper ordering of the \"nonchain\" goals, which may have an adverse effect on the generator efficiency.",
        "The grammar inversion method described in this paper transforms one set of PROLOG clauses (representing a parser, eg.)",
        "into another set of clauses (representing a generator) using an off-line compilation process.",
        "The generator is thus just another PROLOG program that has the property of being an inverse of the parser program, that is, it performs inverse computation.5 A unification grammar is normally compiled into PROLOG to obtain an executable program (usually a parser).",
        "Subsequently, the inversion process takes place at the PROLOG code level, and is therefore independent of any specific grammar formalism used.",
        "The obtained inverted program has been demonstrated to be quite efficient, and we noted that the same technique can be applied to parser/generator optimization.",
        "Our method is also shown to deal adequately with recursive clauses that created problems in purely top-down compilation.",
        "The inter-clausal inversion procedure discussed here effects global changes in goal ordering by moving selected goals between clauses and even creating new clauses.",
        "The net effect is similar to that achieved in the head-driven evaluation, except that no explicit concept of 'head' or 'chain-rule' is used.",
        "The algorithm has been tested on a substantial coverage PROLOG grammar for English derived form the PROTEUS Parser Grammar (Grishman, 1986), and the Linguistic String Grammar for English (Sager,"
      ]
    },
    {
      "heading": "IN AND OUT ARGUMENTS IN LITERALS",
      "text": [
        "Literals in the grammar clauses can be marked for the \"modes\" in which they are used.",
        "When a literal is submitted to execution then those of its arguments which are bound at that time are called the \"in\" arguments.",
        "After the computation is complete, some of the previously unbound arguments may become bound; these are called the \"out\" arguments.",
        "For example, in concataa,b],[cAl],Z), which is used for list concatenation, the first two arguments are \"in\", while the third is \"out\".",
        "The roles are reversed when concat is used for decomposition, as in concat(X,Y4a,b,c,d1).",
        "In the literal subject(Al ,A2.NUM,P), taken from an English grammar, Al and A2 are input and output strings of words, NUM is the number of the subject phrase, and P is the final translation.",
        "When the grammar is used for parsing, the \"in\" argument is Al; the \"out\" arguments are A2, NUM and P; when it is used for generation, the \"in\" argument is P; the \"out\" arguments are Al and NUM.",
        "In generation, A2 is neither \"in\" nor \"out\".",
        "\"In\" and \"out\" status of arguments in a PROLOG program can be computed statically at compile time.",
        "The general algorithm has been described in (Strzalkowski, 1990c; Strzalkowski and Peng, 1990),"
      ]
    },
    {
      "heading": "ESSENTIAL ARGUMENTS: AN EXTENSION",
      "text": [
        "The notion of an essential argument in a PROLOG literal has been first introduced in (Strzalkowski, 1989), and subsequently extended in (Strzalkowski, 1990bc; Strzalkowski and Peng, 1990).",
        "In short, X is an essential argument in a literal p ( • • X • ) if X is required to be \"in\" for a successful evaluation of this literal.",
        "By a successful evaluation of a literal we mean here the execution that is guaranteed to stop, and moreover, that will proceed along an optimal path.",
        "For instance, an evaluation of the goal mem (a,L), with an intention to find a list L of which a is a member, leads to a non-terminating execution unless L's value is known.",
        "Likewise, a request to generate a main verb in a sentence when the only information we have is its root form (or \"logical form\") may lead to repeated access to the lexicon until the \"correct\" surface form is chosen.",
        "Therefore, for a lexicon access goal, say acclex (Word,F eats ,Root), it is reasonable to require that both Feats and Root are the essential arguments, in other words, that the set (Feat,Root) is a minimal set of essential arguments, or a MSEA, for acclex.",
        "The following procedure computes the set of active",
        "p is returned in MS. (2) For 1=1, • • • 4, let MR; be the set of active MSEA's of ri, and let MRU; = (m41 I j=1 • • • r;) be obtained from MR; by replacing all variables by their corresponding actual arguments of ri.",
        "(3) Compute the set MP; = (pti,i I j=1 • r; )1, where = (VAR (mii) – OUT;_i,k), where OUTi_i,k is the set of all ''out\" arguments in literals 1'1 to (4) For each go in MP; where do the following: (a) if KJ = 0 then: (i) compute set OUTi of \"out\" arguments of ; (ii) compute OUTiJ := OUTi u OUTi_i,k; (iii) call"
      ]
    },
    {
      "heading": "MSEAS(MS0,14...1,k,VP,i+1,0U7'0);",
      "text": [
        "otherwise, if gi 0 then find all distinct minimal size sets v, c VP such that whenever the arguments in v, are \"in\", then the arguments in 1.ki are \"out\".",
        "If such v,'s exist, then for every v, do:",
        "(i) assumeiv, is \"in\" in p; (ii) compute the set OUTo, of \"out\" arguments in all literals from r1 to r1; (iii) call (c) otherwise, if no such v, exist, MS; := 0.",
        "(5) Compute MS := u"
      ]
    },
    {
      "heading": "j=1..r",
      "text": [
        "'Active MSEA's are those existing with a given definition of a predicate.",
        "Other, non-active MSEA's can be activated when the clauses making up this definition are altered in some way.",
        "The procedure can be straightforwardly augmented to compute all MSEAs (Strzalkowski, 1990c).",
        "'For i =1 the sets of essential arguments are selected so as to minimize the number of possible solutions to I.",
        "As a simple example consider the following clause: sent(P) vp(N,P),np(N).",
        "Assuming that MSEA'S for vp and np are (P) and (N), respectively, and that N is \"out\" in vp, we can easily compute that (P) is the MSEA in sent.",
        "To see it, we note that MRUI for vp is ((P)) and, therefore, that 11.1.1 = (P).",
        "Next, we note that MRU2 for np is ((N)), and since OUTLI from vp is (N), we obtain that g2 = 0, and subsequently that (P) is the only MSEA in sent.",
        "The procedure presented above is sufficient in many cases, but it cannot properly handle certain types of recursive definitions.",
        "Consider, for example, the problem of assigning the set of MSEA's to mem(Elem,List), where mem (list membership) is defined as follows:",
        "The MSEAS procedure assigns MS =f (Elem),(List)), we note however, that the first argument of mem cannot alone control the recursion in the first clause since the right-hand side (rhs) literal would repeatedly unify with the clause head, thus causing infinite recursion.",
        "This consideration excludes (Elem) from the list of possible MSEAs for mem.",
        "In (Strzalkowski, 1989) we introduced the directed relation always unifiable among terms, which was informally characterized as follows.",
        "A term X is always unifiable with term Y if they unify regardless of any bindings that may occur in X, providing that variables in X and Y are standardized apart, and that Y remains unchanged.",
        "According to this definition any term is always unifiable with a variable, while the opposite is not necessarily true.",
        "For example, the variable X is not always unifiable with the functional term f(Y) because binding X with g(Z) will make these two terms non-unifiable.",
        "This relation can be formally characterized as follows: given two terms X and Y we say that Y is always unifiable with X (and write A r.Y) if the unification of X and Y yields Y, where the variables occurring in X and Y have been standardized apart.\") Since 5 describes a partial order among terms, we can talk of its transitive closure ?.",
        "Now we can augment the MSEAS procedure with the following two steps (to be placed between steps (2) and I° So defined, the relation always unifiable becomes an inverse of another relation: less instantiated, hence the particular direction of S sign.",
        "(3)) that would exclude certain MSEAs from recursive clauses.",
        "If ri = p then for every mi E MRUi if for every argument Yi E mi.., where Yi is the /-th argument in ri, and Xi is the /-th argument in p, we have that X/5* Yi then remove m from MRUi.",
        "For every set mi.„i = u (Zi.i), where 41 is the j-th argument in ri such that it is not already in m1 it is not the case that Y15 Z41, where Yi is a j-th argument in p, if m1,, is not a superset of any other mid remaining in MRUi, then add to MRUI.",
        "In order for the MSEAS procedure to retain its practical significance we need to restrict the closure of 5 to be defined only on certain special sets of terms that we call ordered series.\" It turns out that this restricted relation is entirely sufficient in the task of grammar inversion, if we assume that the original grammar is itself well-defined.",
        "ri1, • ,rik be an ordered subset of the literals on the right-hand side of this clause.",
        "Let rik+1 be either a literal to the right of r or the head literal p. The ordered set of terms <Y0,X1,Y1, • ,Xk,Yk,Xk.,.i> is an argument series iff the following conditions are met",
        "(1) Xic.fi is an argument in ri5+1; (2) for every 1=1 • • k, Xi is different from any Xi for] <i; (3) for every j=1 • • k, X and Yi are arguments to rii, that is, rii(- • XJ,Y • -), such that if Xi is \"in\" then Yi is \"out\" 12; and (4) for every j43 • • k, either Xi.0=Y1 or X1.414 (Yi) or Yi=f ()Cf.\"), where f (X) denotes a term containing a subterm X.",
        "Note that this definition already ensures that the argument series obtained between X0 and Xk+1 is the shortest one.",
        "As an example, consider the following clauses: \" A similar concept of guide-structure is introduced in (Dymetman et al., 1990), however the ordered series is less restrictive and covers a larger class of recursive programs.",
        "12 Yi may be partially \"out\"; see (Strzalkowski, 1990c) for the definition of delayed \"out\" status.",
        "Assuming that the argument X in the literal vp (X) on the left-hand side (lhs) of the first clause is \"in\", we can easily check that <X,X,Y,Y> constitutes an argument series between arguments of vp in the first clause."
      ]
    },
    {
      "heading": "DEFINITION 2 (weakly ordered series)13",
      "text": [
        "An argument series <Y0,X1,Y1, • • • ,Xk,YkXk.i> in the clause p : – ri • r„ is weakly ordered iff Y05*X1,4.1 [or Xk.4.15*Y0], where 5* is a closure of 5_ defined as follows:",
        "(1) for every i=1 • • k, such that ri – • Xi,Yi • • ) there exists a clause rii( • • • ,X,Y, • • ): – si, • • • ,s„„ where X and Y unify with X and Yi, respectively, such that X5*Y [or Y5*X]; (2) for every • • k, Xi.,4=Yi or X.1 =1 (V) [or",
        "Looking back at the definition of mem (Elem,List) we note that the first (recursive) clause contains two ordered series.",
        "The first series, <Elem,Elem>, is not ordered (or we may say it is ordered weakly in both directions), and therefore Elem on the left-hand side of the clause will always unify with Elem on the right, thus causing non-terminating recursion.",
        "The other series, <First I List] ,List>, is ordered in such a way that [First IList] will not be always unifiable with List, and thus the recursion is guaranteed to terminate.",
        "This leaves (List) as the only acceptable MSEA for mem.",
        "Consider now the following new example:",
        "Note that the series <X,X,Y,Y > in the first clause is ordered so that X5*Y.",
        "In other words, Y in vp on the rhs is always unifiable with X on the lhs.",
        "This means that a non-terminating recursion will result if we attempt to execute the first clause top-down.",
        "On the other hand, it may be noted that since the series is ordered in one direction only, that is, we don't have Y5*X, we could invert it so as to obtain Y5*X, but not X?Y.",
        "To accomplish this, it is enough to swap the arguments in the clause defining np, thus redirecting the recursion.",
        "The revised program is guaranteed to",
        "terminate, providing that vp's argument is bound, which may be achieved by further reordering of goals.I4 The ordered series relation is crucial in detecting and removing of non-terminating left-recursive rules of the grammar.",
        "The first of the following two algorithms finds if an argument series is ordered in a specified direction, without performing a partial evaluation of goals.",
        "The second algorithm shows how a directed series can be inverted.",
        "ALGORITHM 1 (finding if YO?",
        "'Xk+1 (weakly)) Given an argument series <Y0 ,X ,Y1 ' • • ,Xk, YkXk.fi > do the following:",
        "(1) Find if for every i=0 • • • k, either X,4.1=Y, or (Y,); if the answer is negative, return NO and quit.",
        "(2) For every i=1 • • • k, find a clause",
        " – • X,Y • • • ) S1, • • such that X and Yj unify with X and Y, respectively, and there is a leading series <X • • Y> such that Y.",
        "Return NO if no such clause is found, and quit.",
        "(3) In the special case when k:), i.e., p has no right-hand side, Y0aX if either Y0--X, or Xi =,/ (Yo).",
        "If this is not the case return NO, and quit.",
        "(4) Otherwise, return YES.",
        "When ALGORITHM I returns a YES, it has generated an ordered path (i.e., the series with all the necessary subseries) between X0 and Xki.i to prove it.",
        "If this path is ordered in one direction only, that is, there exists at least one pair of adjacent elements Xi and Yi within this path such that either X,=f (Y1) or Yr-f (X), but not Xi=yi, then we say that the path is properly ordered.",
        "In addition, if we force ALGORITHM 1 to generate all the paths for a given series, and they all turn out to be properly ordered, then we will say that the series itself is properly ordered.",
        "We can attempt to invert a properly ordered path, but not the one which is only improperly ordered, i.e., in both directions.",
        "Therefore, for a series to be invertible all its paths must be properly ordered, though not necessarily in the same direction.\" ALGORITHM 2 (inverting properly ordered series) Given a clause p r 1, • • ,r„, and an argument",
        "Recursion defi;ed with respect to improperly ordered series is considered ill-formed.",
        "series <Y0,X1,Y1 , • • ,Xk,YkXk4.1> such that it is properly (weakly) ordered as X0?Xk4.1 [or 0], invert it as follows: (1) For each rij(- • ,X1,Yi, • • • ) appearing on the rhs of the clause, find all clauses rii( • • ,X,Y, • • ) s 1, • • ,s„, such that X and Y unify with X; and Yj, respectively, and there is a proper ordering X1C.",
        "*Y [or Ken (2) Recursively invert the series <X • • • Y>; for the special case where m=0, that is, rei clause has no rhs, exchange places of X and Y.",
        "(3) For every pair of Y1 and X,4.1 (i=0 • • • k), if either Yi=f (Xj.4.1) or X14.1=f (Y,), where f is fully instantiated, exchange Yi with Xi+1, and do nothing otherwise.",
        "We now return to the MSEAS procedure and add a new step (2C), that will follow the two steps (2A) and (2B) discussed earlier.",
        "The option in (2C) is used when the expansion of a MSEA rejected in step (2A) has failed in (2B).",
        "In an earlier formulation of this procedure an empty MSEA was returned, indicating an non-executable clause.",
        "In step (2C) we attempt to rescue those clauses in which the recursion is based on invertible weakly ordered series.",
        "(2C) Find an argument Y, E a t-th argument of ri, such that X,?",
        "Y, where X, is the t-th argument in the head literal p and the series <X, • • Y1> is properly ordered.",
        "If no such Y, is found, augment mi,„ with additional arguments; quit if no further progress is possible.16 Invert the series with Awolumm 2, obtaining a strongly ordered series <X', • • • Y',> such that Replace V, with r, in mi,„ and add the resulting set to At this point we may consider a specific linguistic example involving a generalized left-recursive production based on a properly ordered series.I7",
        "\"As in step (213) we have to maintain the minimality of",
        "We concentrate here on the clause [2], and note that there are three argument series between the vp literals: < V/ , V/ >, <Args, [Csem I Args ]>, and <Vsem,Vsem > , of which only the second one is invertible.",
        "We also note that in clause [3], the collection of MSEAs for vp include ( V/ ) and (Vsem), where V1 represents the surface string, and Vsem its \"semantics\".",
        "When we use this grammar for generation, (V1) is eliminated in step (2A) of the MSEAS procedure, while (Vsem), is rescued in step (2C), where it is augmented with Args which belongs to the invertible series.",
        "We obtain a new set (Args',Vsem), which, if we decide to use it, will also alter the clause [2] as shown below.18",
        "This altered clause can be used in the generator code, but we still have to solve the problem of having the [Csem I Args] bound, in addition to Vsem.19 It must be noted that we can no longer meaningfully use the former \"in\" status (if there was one) of this argument position, once the series it heads has been inverted.",
        "We shall return to this problem shortly."
      ]
    },
    {
      "heading": "INTRA-CLAUSAL INVERSION",
      "text": [
        "The following general rule is adopted for an effective execution of logic programs: never expand a goal before at least one of its active MSEAs is \"in\".",
        "This simple principle can be easily violated when a program written to perform in a given direction is used to run \"backwards\", or for that matter, in any other direction.",
        "In particular, a parser frequently cannot be used as a generator without violating the MSEA-binding rule.",
        "This problem is particularly acute within a fixed-order evaluation strategy, such as that of PROLOG.",
        "The most unpleasant consequence of disregarding the above rule is that the program may go into an infinite loop and have to be aborted, which happens surprisingly often for non-trivial size Is In our inversion algorithm we would not alter the clause until we find that the MSEA needs to be used.",
        "19 Vsem is expected to be \"in\" during generation, since it carries the \"semantics\" of vp, that is, provides the input to the generator.",
        "programs.",
        "Even if this does not happen, the program performance can be seriously hampered by excessive guessing and backtracking.",
        "Therefore, in order to run a parser in the reverse, we must rearrange the order in which its goals are expanded.",
        "This can be achieved in the following three steps:"
      ]
    },
    {
      "heading": "PROCEDURE INVERSE",
      "text": [
        "(1) Compute \"in\" and \"out\" status of arguments for the reversed computation.",
        "If the top-level goal parse (String,Sem) is used to invoke a generator, then Semis initially \"in\", while String is expected to have \"out\" status.",
        "(2) Compute sets of all (active and non-active) MSEAs for predicates used in the program.",
        "(3) For each goal, if none of its MSEAs is \"in\" then move this goal to a new position with respect to other goals in such a way that at least one of its MSEAs is \"in\".",
        "If this \"in\" M SEA is not an active one, recursively invert clauses defining the goal's predicate so as to make the MSEA become active.",
        "In a basic formulation of the inversion algorithm the movement of goals in step (3) is confined to be within the right-hand sides of program clauses, that is, goals cannot be moved between clauses.",
        "The inversion process proceeds top-down, starting with the top-level clause, for example parse (String,Sem) : – sent (String, [],Sem).",
        "The restricted movement inversion algorithm INVERSE has been documented in detail in (Strzalkowski, 1990ac).",
        "It is demonstrated here on the following clause taken from a parser program, and which recognizes yes-no questions:",
        "When rewriting this clause for generation, we would place object first (it has P \"in\", and A3, PI, P2 \"out\"), then subject (it has the essential PI \"in\", and A2 and Num \"out\"), and finally verb (its MSEA is either (Al) ) or (Num,P2), the latter being completely \"in\" now).",
        "The net effect is the following generator clause:\"",
        "INVERSE works satisfactorily for most grammars, but it cannot properly handle certain types of clauses \" Note that the surface linguistic string is not generated from the left to the right.",
        "where no definite ordering of goals can be achieved even after redefinition of goal predicates.",
        "This can happen when two or more literals wait for one another to have bindings delivered to some of their essential arguments.",
        "The extended MSEAS procedure is used to define a general inversion procedure INTER-CLAUSAL to be discussed next.",
        "INTER-CLAUSAL INVERSION Consider again the example given at the end of the section on essential arguments.",
        "After applying MSEAS procedure we find that the only way to save MSEA (Args,Vsem) is to invert the series <Args,[Csem I Args]> between vp literals.",
        "This alters the affected clause [2] as shown below (we show also other clauses that will be affected at a later stage):21",
        "In order to use the second clause for generation, we now require [CsemlArgs] to be \"in\" at the head literal vp.",
        "This, however, is not the case since the only input we receive for generation is the binding to Sem in clause [1], and subsequently, Vsem in [2], for example, ? – sent (chased (Fido,John)).",
        "Therefore the code still cannot be executed.",
        "Moreover, we note that clause [1] is now deadlocked, since neither vp nor np can be executed first.",
        "22 At this point the only remaining option is to use interclausal ordering in an effort to inverse [1].",
        "We move v from the rhs of [3] to [1], while np travels from [1] to [3].",
        "The following new code is obtained (the second argument in the new vp' can be dropped, and the new MSEA for vp' is"
      ]
    },
    {
      "heading": "(Args)):23",
      "text": [
        "The string variables VI, V2, etc.",
        "are dropped for clarity.",
        "n There are situations when a clause would not appear deadlocked but still require expansion, for example if we replace"
      ]
    },
    {
      "heading": "III by seni(Sem,Ssem) :-Ivp(Ssem,Sem), with Ssem bound in sent. This clause is equivalent to sent(Sem,Ssem) :-",
      "text": [
        "Vsemm--Ssem,vp(Vsem,Sem), but since the series in 121 has been inverted we can no longer meaningfully evaluate the rhs literals in the given order.",
        "In fact we need to evaluate vp first which cannot be done until Vsem is bound.",
        "\" An alternative is to leave Eli intact (except for goal ordering) and add an \"interface\" clause that would relate the old vp to the new vp'.",
        "In such case the procedure would generate an additional argument for vp'in order to return the final value of Args which needs to be passed to np.",
        "This code is executable provided that Semis bound in sent.",
        "Since Args is \"out\" in v, the recursion in [21 is well defined at last.",
        "The effect of the interclausal ordering is achieved by adopting the INTERCLAUSAL procedure described below.",
        "The procedure is invoked when a deadlocked clause has been identified by INVERSE, that is, a clause in which the right-hand side literals cannot be completely ordered."
      ]
    },
    {
      "heading": "PROCEDURE INTERCLAUSAL(DLC)",
      "text": [
        "[Inter-clausal inversion]",
        "(1) Convert the deadlocked clause into a special canonical form in which the clause consists exclusively of two types of literals: the unification goals in the form X =Y where X is a variable and Y is a term, and the remaining literals whose arguments are only variables (i.e.,",
        "no constants or functional terms are allowed).",
        "Any unification goals derived from the head literal are placed at the front of the rhs.",
        "In addition, if p ( • • • X • • ) is a recursive goal on the rhs of the clause, such that X is an \"in\" variable unifiable with the head of an inverted series in the definition of p, then replace X by a new variable X/ and insert a unification goal X/.X.",
        "The clause in [1] above is transformed into the following form:",
        "(2) Select one or more non-unification goals, starting with the \"semantic-head\" goal (if any), for static expansion.",
        "The \"semantic-head\" goal is the one that shares an essential argument with the literal at the head of the clause.",
        "Recursive clauses in the definitions of goal predicates should never be used for expansion.",
        "In the example at hand, vp can be expanded with [3].",
        "(3) Convert the clauses to be used for goal expansion into the canonical form.",
        "In our example [3] needs no conversion.",
        "(4) Expand deadlocked goals by replacing them with appropriately aliased right-hand sides of the clauses selected for expansion.",
        "In effect we perform a partial evaluation of these goals.",
        "Expanding vp in [1] with [3] yields the following new",
        "(5) Find an executable order of the goals in the expanded clause.",
        "If not possible, expand more goals by recursively invoking INFERCLAUSAL, until the clause can be ordered or no further expansion is possible.",
        "In our example [la] can be ordered as follows:",
        "(6) Break the expanded clause back into two (or more) \"original\" clauses in such a way that: (a) the resulting clauses are executable, and (b) the clause which has been expanded is made as general as possible by moving as many unification goals as possible out to the clause(s) used in expansion.",
        "In our example v (Args,Sem) has to remain in [lb], but the remainer of the rhs can be moved to the new vp' clause.",
        "We obtain the following clauses (note that clause [2] has thus far remained unchanged throughout this process):",
        "(7) Finally, simplify the clauses and return to the standard form by removing unification goals.",
        "Remove superfluous arguments in literals.",
        "The result are the clauses [1'] to [31 above."
      ]
    },
    {
      "heading": "CONCLUSIONS",
      "text": [
        "We described a general method for inversion of logic grammars that transforms a parser into an efficient generator using an off-line compilation process that manipulates parser's clauses.",
        "The resulting \"inverted-parser\" generator behaves as if it was \"parsing\" a structured representation translating it into a well-formed linguistic string.",
        "The augmented grammar compilation procedure presented here is already quite general: it appears to subsume both the static compilation procedure of Strzalkowski (1990c), and the head-driven grammar evaluation technique of Shieber et al.",
        "(1990).",
        "The process of grammar inversion is logically divided into two stages: (a) computing the collections of minimal sets of essential arguments (MSEAs) in predicates, and (b) rearranging the order of goals in the grammar so that at least one active MSEA is \"in\" in every literal when its expansion is attempted.",
        "The first stage also includes computing the \"in\" and \"out\" arguments.",
        "In the second stage, the goal inversion process is initialized by the procedure INVERSE, which recursively reorders goals on the right-hand sides of clauses to meet the MSEA-binding requirement.",
        "Deadlocked clauses which cannot be ordered with INVERSE are passed for the interclausal ordering with the procedure INTERCLAUSAL.",
        "Special treatment is provided for recursive goals defined with respect to properly ordered series of arguments.",
        "Whenever necessary, the direction of recursion is inverted allowing for \"backward\" computation of these goals.",
        "This provision eliminates an additional step of grammar normalization.",
        "In this paper we described the main principles of grammar inversion and discussed some of the central procedures, but we have mostly abstracted from implementation level considerations.",
        "A substantial part of the grammar inversion procedure has been implemented, including the computation of minimal sets of essential arguments, and is used in a Japanese-English machine translation system?\" ACKNOWLEDGEMENTS This paper is based upon work supported by the Defense Advanced Research Project Agency under Contract N00014-904-1851 from the Office of Naval Research, and by the National Science Foundation under Grant IRI-89-02304.",
        "Thanks to Marc Dymetman, Patrick Saint-Dizier, and Gertjan van Noord for their comments on an earlier version of this paper."
      ]
    },
    {
      "heading": "REFERENCES",
      "text": []
    }
  ]
}
