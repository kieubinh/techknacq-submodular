{
  "info": {
    "authors": [
      "Wil Janssen",
      "Mannes Poel",
      "Klaas Sikkel",
      "Job Zwiers"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C92-1058",
    "title": "The Primordial Soup Algorithm a Systematic Approach to the Specification of Parallel Parsers",
    "url": "https://aclweb.org/anthology/C92-1058",
    "year": 1992
  },
  "references": [],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "A general framework for parallel parsing is presented, which allows for a unified, systematic approach to parallel parsing.",
        "The Primordial Soup Algorithm creates trees by allowing par-, tial parse trees to combine arbitrarily.",
        "13y adding constraints to the general algorithm, a large class of parallel parsing strategies can be defined.",
        "This is exemplified by CYK, (bottom-up) Earley and de Vreught Az Honig parsers.",
        "From such a parsing strategy algorithms for various machine architectures can be derived in a systematic way."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "In this paper we present a general framework for parallel parsing algorithms.",
        "Parsing can be seen as a process in which a set of partial parse trees is recognized.",
        "One starts with the productions as elementary trees.",
        "Small trees can be combined into larger trees, yielding ever larger and larger structures, until completed parses for a particular target sentence are produced.",
        "We envisage the set of recognized trees as a kind of primordial soup.",
        "Small trees float around and if they fit together they can be combined into a larger tree.",
        "This is, in a nutshell, the Primordial Soup paradigm.",
        "In the most general approach, trees can combine in arbitrary ways.",
        "That is, a new tree can be created from two existing trees if there is a partial overlap between the trees.",
        "The overlapping part is unified.",
        "Tree creation is non-destructive, in the sense that a tree can be used more than once for the production of a larger tree.",
        "Or, to put it in a different way, the initial soup contains an abundant amount of raw material.",
        "Thus all relevant trees can actually be created.",
        "The Primordial Soup Algorithm can be refined into a variety of parsing strategies by adding constraints, either on the allowed type of trees or on the way in which existing trees can be combined.",
        "A parsing strategy specifies which trees will be recognized, without bothering to specify control and data structures that must be added in order to arrive at practical implementations.",
        "For the development of parallel implementations, the (initial) absence of control structure is an asset, as decisions about system architecture can be deferred to a later stage when the strategy has been fleshed out in more detail.",
        "Our specification of the Primordial Soup Algorithm allows for a systematic derivation of implementations of parsing strategies as is shown in a more detailed technical report [JPSZ].",
        "These derivations are carried out within a partial order framework as introduced in [JPZI.",
        "In the restricted space available here we concentrate on the Primordial Soup Algorithm as a framework for the specification of parsing strategies.",
        "In section 2 the Primordial Soup Algorithm is introduced, exemplified by a CYK-like approach.",
        "In section 3, the formalism is slightly extended so as to allow for the description of almost any parallel or sequential parser."
      ]
    },
    {
      "heading": "2 The Primordial Soup",
      "text": []
    },
    {
      "heading": "The Primordial Soup Algorithm will be introduced after some remarks about notation and parsers. We show that the algorithm is a generalization of well-known parsing strategies, 2.1 Preliminaries",
      "text": [
        "We use the following notational conventions.",
        "Nonterminals are denoted by A, 13, E N; terminals are denoted by a , b, C E. We write V for A' U Y, with typical elements X, Y, .",
        "Terminal strings are denoted by s, t, u, v,w, E :;*, AC:l'ES DE COLING-92, NAN1ES, 23-28 Aorn 19924 7 3PRoc.",
        "oF COLANG-92, NANTES, AUG. 23-28, 1992 if aLlr' = p for a subtree r' of T, then T' is replaced by p."
      ]
    },
    {
      "heading": "3.2 Some general restrictions",
      "text": [
        "As discussed in 2.3, we do not want to recognize all trees leading to parses of arbitrary strings.",
        "We introduced the general idea that a tree is allowed only if the terminal part of the yield extends to the sentence.",
        "For the CYK algorithm, this simple criterion is fine.",
        "In general, however, it is too restrictive, in the sense that some familiar parsing algorithms cannot handle it.",
        "Suppose, for example, that a tree (A -.4 aB) is extended with a production (B--^liCd) into (A abCd).",
        "In principle, this should only be allowed if ab and d occur in w in this order.",
        "A parser which uses only local information, e.g. an LR(1) parser, cannot determine whether a terminal d occurs somewhere in the string, perhaps after a large substring produced by C. We will use a rather more subtle scheme to match the yield of a tree against the sentence, so as to allow for refinement into arbitrary parsing algorithms.",
        "Having a tree (A-s-oaB) we can check that a occurs in w and mark the leaf a accordingly.",
        "Marking a leaf is denoted by underlining the terminal symbol.",
        "The tree (A -.4 aB) can be extended to (A-s-44(B--bCd)) = (A,4 abCd) and then to (A.,4 abCd), irrespective of whether d occurs in the string at all.",
        "The notion of marking terminals with occurrences in the string fits quite well to parsing natural languages, rather than tin-interpreted context-free grammars.",
        "In practical NI, parsing, the word categories rather than the individual words are used as terminals, although they are in fact pre-terminals.",
        "Using the word categories as terminals, a marked terminal is a word category applied to a word from the sentence.",
        "As an example, consider the sentence the bird flies.",
        "The initial soup might contain:",
        "Word categories need not be uniquely defined.",
        "In this case the word flies fits into two categories.",
        "A tree (NP the noun) could be combined with (nounMies), yielding a noun phrase the flies.",
        "This tree is ruled out by extends, however, as the flies does not extend to the bird flies.",
        "In summary, we distinguish two types of initial trees: initial(r)production(r) V rnarker(r), production((A.a)) V A--.a E P marker((a.o.))",
        "V a E T, a in the sentence.",
        "The extends predicate can be defined so as to apply to strings of markings (i.e. words) rather than terminals.",
        "Furthermore, if we do not want to construct arbitrarily large trees with a non marked yield, we can define df allowed(r) extends(yield(r),w) A !yield< iwi.",
        "Finally, allowing arbitrary tree construction with superposition (\"-.)",
        "rather than composition (), a general version of the operator A is given by A(S)d-4 {p Er ESAa E S A allowed(p)}.",
        "The algorithm is now given by",
        "For acyclic grammars (i.e., grammars that do not allow a derivation A-4i A), only a finite number of trees can be constructed, hence the algorithm is guaranteed to halt.",
        "When a grammar is cyclic, an infinite number of parses exist.",
        "Every finite (subtree of a) parse will be found within a finite number of steps.",
        "From the point of efficiency, the above algorithm isn't sensible at all.",
        "Its strength, however, derives from the fact that a very large class of parallel parsing algorithms can be defined as specializations, by constraining the general algorithm in various ways.",
        "Some examples will be given shortly.",
        "AMES DE COLING-92, NANTES, 23-28 Ad) r 1992 377 PRoc.",
        "op COLING-92, NAN'rEs, AUG. 23-28, 1992 to parsing algorithms, producing partial parse trees of the form (A--^ (a ai.+.1 ai) 0) and (A--^et (0--^a:+1\" ai) 7), respectively."
      ]
    },
    {
      "heading": "2.3 The Primordial Soup Algorithm",
      "text": [
        "VH is by no means the most general algorithm.",
        "As the ultimate generalization we can allow any tree in T. The top is a nonterminal and the leaves can be any symbol in V; a tree may or may not be part of a parse for ta Initially we start with elementary trees that correspond to the productions in our grammar.",
        "New trees can be added by merging (copies of) existing trees which agree on their common parts.",
        "This can be seen as some kind of unification process on parse trees.",
        "The string is parsed when a tree r (S al a) is produced; the algorithm terminates when no new trees can be added.",
        "Metaphorically speaking, one can think of the initial set of trees as a primordial soup in which small structures react with each other, creating ever larger and more complicated structures.",
        "We therefore call it the Primordial Soup Algorithm.",
        "Superficially, it may resemble the unification space of Vosse and Kempen [VIC], who think of molecules floating in a test-tube and entering into chemical bonds with other molecules.",
        "The paradigms are different however, as in the primordial soup, unlike the test-tube, raw material abounds and and multiple copies of any structure can be created.",
        "The most general version of the Primordial Soup Algorithmallowing to combine trees by unification of arbitrary overlapping parts--is a formalism in which a wide variety of parsing algorithms can be specified with great ease.",
        "Before that, we first formalize a slightly limited, but somewhat easier version of the Primordial Soup Algorithm.",
        "The algorithm starts of with an initial set of recognized trees S consisting of trees corresponding to the productions in our grammar.",
        "New trees can be added to S by taking combinations of existing trees.",
        "The simplest way to combine trees is the following.",
        "Let a = ceB-y) S and T (B-) S. We can unify the leaf B in a with the root B in T, yielding a new tree (A -, a (B This tree is denoted by (1.4T.",
        "The (partial) function < : TB X Tbt-,Tbt is called composition.",
        "Note that there can be multiple occurrences of B in yield(a), which means that Cf<T need not be determined uniquely.",
        "Also, we will use the operator < in a liberal way, allowing more than one extension to be made at the same time.",
        "Let = (A-s, aoBictiB2a2) and ri = (Bi,,+13i).",
        "We write a <117-1, for the tree (Aao (BI--401)0i (Bz 'N-,flz) as), using < as a polyadic operator with one left-hand argument and an arbitrary number of right-hand arguments.",
        "As initial contents of the primordial soup, we take the trees (A*a) corresponding to productions A*a E P. Such a tree (A^a) is called a production tree or a production for short.",
        "We define an operator A : 2T--42T that yields all new trees that can be composed from the contents of the soup by A(S)dg fcr<Pri, rk E {a, 7-1, , rk} C This definition of A has one shortcoming, however.",
        "Rather than all parses for all sentences we only want the parses for one particular sentence w E E*.",
        "In general, this problem is tackled by redefining A as A(S)ti fa<ITI, , rk CT I{a,Ti, ,rk} CS A allowed(a<ri, 'TO} in which a predicate allowed specifies which trees are allowed to be added.",
        "Which trees can be discarded right away, and which ones should be added to the soup?",
        "As we are only interested in trees that can be extended to parses for some specific sentence w, the terminal part of the yield should be extendable to w. That is, w can be produced from yield(r) by replacing every nonterminal in r with some string of terminals.",
        "Formally, for terminal strings s E E* we define extends (s , t)]1L,L.",
        "5(tusv), i.e. s is a substring of t.For strings in V* containing at least one nonterminal, we define extends recursively as erten ds (a.13 , t)as E Y*(extends(asfi, t)).",
        "Finally we define allowed (r )extends (yield (r ), w), in accordance with the informal definition given above.",
        "Note, however, that we still may create an infinite number of useless trees, simply by not adding terminals to the yield!",
        "If yield(r) C N* then allowed(r) holds: each leaf can be extended to E, and the empty string is indeed a substring of a.",
        "In 3.2 we will see how tins problem can be tackled in general; here we will only regard a subclass of T that does not contain trees with arbitrarily large nonterminal yields.",
        "Acres DE COUNG-92, Morro, 23-28 Athr 1992375 PHOC.",
        "OF COLING-92, NAN rEs, AUG. 23-28, 1992 We have concentrated on context-free grammars for the sake of simplicity.",
        "It should be clear, though, that extension to various types of unification grammars is straightforward."
      ]
    },
    {
      "heading": "3.3 Different breeds of trees",
      "text": [
        "As we have seen in the CYK example, complete trees are an important class of trees.",
        "But, having introduced markers, it is obvious that we consider a tree to be complete only if the entire yield has been marked.",
        "Therefore we redefine",
        "The baobab is an African tree that has branches from which roots originate, supporting the roof.",
        "Such roots grow out to additional trunks.",
        "3.4 CYK revisited The only addition to our previous specification of CYK is that it should produce trees with marked yields.",
        "To that end, we can define an initial step"
      ]
    },
    {
      "heading": "3.5 Bottom-Up Earley",
      "text": [
        "The BUE algorithm is defined for arbitrary context-free grammars.",
        "It is usually described as a recognition algorithm.",
        "An item [i, A-40.0, ji denotes the fact that aa,1 a, has been recognized.",
        "From ji, j] and [j, k] a new item lc] can be derived.",
        "We will define the algorithm on trees, rather than items.",
        "Trees of the form (A--^ (a,^ v) )3) are recognized for v ai+i a, a substring of w. Acres DE COLLNG-92, NANTES, 23-28 Aoirr 1992378 PROC.",
        "OF COLING-92, NANTES, Auc.",
        "23-28, 1992 arbitrary strings by a, 0, E V. Let G = (N, E, P, S) be a context free grammar, Let is al a E E* be the sentence.",
        "While executing an arbitrary parsing algorithm, we maintain a set of trees that might be sub trees of a parse for to.",
        "Let ,ibt be the class of finitely branching trees, in which all nodes have a label from some universal class of symbols.",
        "Let T(G) C .ibt be the class of trees that can be constructed from P; i.e., if some node is labelled A and its children X1, , X, then A-0(1 X E P. We will usually write T for T(G); individual trees are denoted p, a, r, E T. We write root(r) for the label of the root of a tree r. The yield of a tree r, denoted by yield(r), is defined as the concatenation of the labels of the leaves.",
        "Clearly, yield(r) E V. Note that leaves labelled a (generated by empty productions) are not visible in the yield as E disappears in concatenation.",
        "A tree T is a parse tree for is if root(r) = S and yield(r) = w. For arbitrary is E E* a subclass T, c 7 is defined that contains trees r with yield(r) = ai cti for some substring ai al of w. T is called the set of subparses of w. The root of a subparse need not be S, it can be any nonterminal A E N. As a convenient notation for trees we write r = (A ,* a) for an arbitrary tree with A = root(r) and a = yield(r).",
        "In general (A a) is not uniquely determined, as every derivation Ara defines a tree (A a).",
        "If we want to stress that a derivation afiry can be obtained as A-1- a.137+ a07 we write (A-,4 (B,..^ 0) 7) for the tree (A,-..-+a0-y).",
        "Thus the tree notation is generalized into (A-41 ), where is either a leaf or a subtree.",
        "This simple tree notation is extended with the following conventions: A tree (A,-* a) corresponding to a single-step derivation Aa is also denoted as (A---^a).",
        "This corresponds to a production A---^a E P. As a convenient shorthand, a tree a (B7 ^-07) (B.",
        "^-0.)",
        "will be abbreviated to (A',-+ a (B7 &* 13].",
        "fi.)",
        "-Y)"
      ]
    },
    {
      "heading": "2.2 Various bottom-up parsers",
      "text": [
        "Our basic approach results from a generalization of various bottom-up parsing algorithms.",
        "The oldest and perhaps best known of these is the Cocke-Younger-Kasami (CYK) algorithm [You].",
        "It requires the grammar to be in Chomsky Normal Form, i.e., productions have the form A---^13C or A--^a.",
        "If we have trees 7-1 (13--^ ai+1 ak) and r2 -= (C-,*ak.4.1.. aj) and if there is a production A.",
        "*BC E P, we can construct a larger tree (A.-,*ai+2 ai) from r1 and 7-2.",
        "This can be continued until (S--^ ai a) has been derived, or no new trees can be constructed.",
        "The CYK algorithm is usually described as a recognizer, rather than a parser.",
        "A recognition algorithm collects a set of items that denote the existence of trees, rather than trees themselves.",
        "If it is deduced that A4`cti+i a2 (without having constructed a corresponding tree), this will be denoted by an item [A.--^ a,+2 ail.",
        "In general, an item [A,..-^ al denotes the existence of one or more trees (A-,.",
        "* a).",
        "The string is is grammatically correct if and only if an item [S,-+ w] can be recognized.",
        "The CYK algorithm recognizes items of the form [A -sh ai+i ai].",
        "For notational convenience, such an item is usually written as [i, A, j].",
        "Thus we get the conventional description of CYK recognition: An item [ti, A, j] can be recognized iff [i, B , k] and [k,C, j] have been recognized previously for some i < Jr <j and A--+BC C P. Several recognition and parsing algorithms deal with arbitrary context-free grammars along the same line as CYK, involving some more technicalities for handling productions of arbitrary length, including a-productions.",
        "For example, a bottom-up variant of Earley's recognition algorithm [Ear, GHR] recognizes items of the form [i, A---pa.13,,j] denoting the fact that a*a,4.1 a3.",
        "That is, the first part of a production has been recognized.",
        "If 0 = a, i.e. the item is of the form A-4a.,,j], the entire production has been recognized; such an item denotes the existence of a tree (A --^ ao_i a,).",
        "We call this algorithm Bottom-Up Earley (BUE) in the sequel; the top down filter of Earley's algorithm has been deleted so as to allow parallel bottom-up, rather than left-to-right processing of the string.",
        "Still, BUE recognizes each individual nonterminal in left-to-right manner, for which there is no a priori reason.",
        "De Vreught and Honig [dVH] describe a similar, more general algorithm (which we abbreviate VH), using double dotted items [i, A-4a.0.1',.ij where ,0*ai-Fi a.",
        "In this case 0 corresponds to a part of the string that has been recognized, whereas a and y still need to be recognized.",
        "Both BUE and VH can easily be extended ACTES DE COL1NG-92, NANTES, 23-28 /win 1992374 PROC.",
        "Or COLING-92, NANTEs, AUG. 23-28, 1992 We define the set of Earley trees E c T",
        "A allowed(a From the definition of e it follows that t <Ir E E if complete(r) and the leftmost unmarked symbol of yield(a) is root(r).",
        "The soundness follows from the definitions and completeness is trivially proven with induction on the size of the tree, hence the algorithm is correct."
      ]
    },
    {
      "heading": "3.6 De Vreught and Honig's algorithm",
      "text": [
        "The VH algorithm also uses complete trees and palm trees, with the difference that the trunk of a palm tree does not necessarily cover the leftmost part of the roof.",
        "We define a set V of trees, analogously to the set of Earley trees by"
      ]
    },
    {
      "heading": "4 Conclusions",
      "text": [
        "The Primordial Soup paradigm facilitates the specification of parsing strategies, i.e., high-level specifications or parsing algorithms, without explicit control flow and data structures.",
        "A specification without control flow is a good basis for the design of a parallel implementation, as it allows a further refinement of the design before any decision on architecture is taken.",
        "For more details, see [JPSZ], where this has been exemplified with a design for a parallel CYK parser, using the Primordial Soup paradigm and the formalism introduced in (JPZI.",
        "The Primordial Soup framework can be used to design new parsing algorithms by mixing features of existing algorithms.",
        "For example, the Earley operator for tree composition in combination with the De Vreught 86 Honig set of allowed trees yields a generalized Earley parser that has been rigorously defined in only two lines.",
        "The specification of parsing strategies is given in a formalism closely resembling predicate logic.",
        "This makes it almost trivial to derive prototype implementations in (parallel) logic programming languages like Prolog or Parlog [JPSZI."
      ]
    },
    {
      "heading": "References",
      "text": []
    },
    {
      "heading": "2.4 Specifying parse strategies",
      "text": [
        "More specific and more useful instances of the algorithm can be defined by imposing restrictions on the trees to be added.",
        "A strategy is a characterization of trees that are to be added to the primordial soup S under some additional constraints.",
        "Different constraints specify different strategies.",
        "We call it strategy, rather than algorithm, as no control structure is specified explicitly.",
        "For the sake of simplicity we assume that A(S) is added all at once, but it should be understood that, if so desired, only a subsets of A(S) need be added at each step.",
        "A strategy can be refined into a (parallel or sequential) algorithm by adding control structure and data structures so as to keep track of intermediate results in an efficient manner.",
        "For examples of the design of parsing algorithms from such strategies, see PPSZ].",
        "Parsing strategies can be characterized by two types of restrictions: on the types of trees allowed in the soup and on the operators that create new trees from existing ones.",
        "Both kinds of restrictions are interchangeable most of the time; if trees are allowed to combine only in some specific way, the set of generated trees will be restricted, and vice versa.",
        "As a simple example, we will specify a strategy for the CYK parser.",
        "To that end, we define an additional predicate complete(r)tf yield(r) E E* i.e., a tree is complete if its yield does not contain any nonterminal.",
        "Such a tree can only be used as a right-hand side argument of a composition.",
        "Recalling that the CYK algorithm is defined only for grammars in Chomsky Normal Form (i.e., productions are of the type ABC and Am), we can define the CYK strategy by AcyK(S) {o<ri, ry complete(a 72) A allowed(a 47-1,7-7)1 Apart from the initial production trees, S will only contain trees of the form (A ai+1 ai).",
        "The complete predicate specifies that newly created trees have a terminal yield; this must be a subtring of w due to the allowed predicate.",
        "It is trivial to verify that all such trees are added to S in due course.",
        "Hence the specification of CYK is sound and complete."
      ]
    },
    {
      "heading": "3 Other parse strategies",
      "text": [
        "We redefine the Primordial Soup Algorithm from section 2 in a more general manner, and show its power and elegance by specifying the parsing strategies of Bottom-Up Earley, De Vreught Honig and some variants of CYK."
      ]
    },
    {
      "heading": "3.1 Unification and superposition",
      "text": [
        "In section 2 we used only the composition operator cl to create new trees from existing ones.",
        "Composition can be seen as a specific case of superposition, in which arbitrary overlapping parts of trees can be unified.",
        "We will first define unification, which is a special case of superposition in which the roots of two trees are mapped onto each other, for the definition of unification, we use the derivation operator for trees.",
        "If r = (A %4 aBry) and ci = (A ol(13^ f3)7), we write A tree is called an extension of T if r=u, where '1` means applying the derivation zero or more times.",
        "Now two trees T and cc unify if a tree p exists that is an extension of both a and r. I.e., unify(a,r) tf 3p E (r p A p) .",
        "p is called an upper bound of T and a.",
        "Furthermore, if a and r unify, there is a unique least upper bound, denoted by rUa, satisfying if r*p and cr* p then rficr*p .",
        "rtJa is called the unification of T and a .",
        "Note that the roots of T and a coincide in rUa.",
        "Unification can be generalized to superposition by allowing the root of one tree to be unified with an arbitrary node of the other tree, under the constraint that the overlapping parts of both trees are be identical; see Figure 1.",
        "This superposition operator is denoted by .",
        "Note that, in general, superposition is not uniquely determined.",
        "Hence it is defined as a function : .Tbt x Tbt-42\"`, whereas unification is defined as a partial function U : .Tbt x .Fbt---4..Tbt.",
        "For a more formal definition, see [JPSZ].",
        "Acres COLING-92, Norms, 23-28 Aofrr 1992376 PROC.",
        "OF COL1NG-92, NANTES, AUG. 23-28, 1992"
      ]
    }
  ]
}
