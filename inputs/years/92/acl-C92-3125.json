{
  "info": {
    "authors": [
      "Harvey Abramson"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C92-3125",
    "title": "A Logic Programming View of Relational Morphology",
    "url": "https://aclweb.org/anthology/C92-3125",
    "year": 1992
  },
  "references": [
    "acl-C86-1065"
  ],
  "sections": [
    {
      "text": [
        "discussing \"efficiency\" it is very important to be very precise as to where the efficiency lies and what it consists of.",
        "Finite state processing is linear in the sense that a properly implemented finite state machine will be able to decide whether a string of length n is acceptable or not in a time which is 0(n), ie, for large enough n, a linear multiple of n. For small values of n, depending on how much bookkeeping has to be clone, \"finite state algorithms\" may perform worse than algorithms which are formally 0(n2) or higher.",
        "Any processing in addition to recognition may involve time factors which arc more than linear.",
        "This entirely leaves aside the question of the user friendliness of the finite state computing paradigm, a question of how \"efficient\" in human terms it is to use finite state methods.",
        "Anyone who has tried to implement finite state automata of substantial size directly (as in Koskenniemi's original implementation, the first KIMMO systems, and KIMMO-PC) will have realised that programming finite state machines is distastefully akin to directly programming Turing machines.",
        "A substantial amount of software is necessary in order to provide a development, debugging and maintenance environment for easy use of the finite state computing paradigm.",
        "There also remains the theoretical question as to the adequacy of finite state morphological descriptions for all, or even most, human languages.",
        "However, this is a topic we shall not venture into in this paper.",
        "In our method, a relatively small Prolog program generates logic programming clauses from relational morphology rules.",
        "The generated clauses (at least in the experiments so far) are readable and it is easy to correlate the generated clause and the original morphological rule, thus promoting debugging.",
        "The standard debugging tools of Prolog systems (at the very least, sophisticated tracing facilities) seem sufficient to deal with rule debugging, and the readability of the generated clauses should help in the maintenance and transference of morphological programs.",
        "Thus, front the software engineering point of view, logic programming is a more sophisticated, higher-level programming paradigm than finite state methods.",
        "Also, should finite state descriptions in the end prove inadequate, or even inconvenient, for all of morphology, logic programming provides expressive power for reasonable extension of the notation of relational morphology rules.",
        "The current availability of Prolog compilers, even for small machines, provides another increment of speedy execution of the generated programs.",
        "Many of the morphological rules produce logic program clauses in which checking of the lexical and surface elements and contexts reduce to unification followed by a recursive call of the morphology predicate.",
        "Compiled Prolog abstract machine code for such clauses is usually very compact.",
        "Prolog compiler indexing mechanisms often make it possible to access the correct clause to be applied in constant time.",
        "Notational Aspects.",
        "Our tableau notation for relational morphology rules is as follows:",
        "which expresses the relation between a lexical and a surface unit ([ex and Surface, respectively), provided that the left and right contexts at both the lexical and surface levels (LexLeft, LexRight, SurfaceLeft, and SurfaceRight) are satisfied.",
        "Another kind of relational morphology rule which is allowed is: LexLeft => Lex <= LexRight<:> SurfaceLeft => Surface <= SurfaceRight which expresses a relationship between Lex and Surface providing that the left and right contexts at the lexical and surface levels are different from those specified by LexLeft, LexRight, SurfaceLeft, and SurfaceRight.",
        "This means that either LexLeft or LexRight is not satisfied, and also that either SurfaceLeft or SurfaceRight is not satisfied.",
        "More compact notation is also accepted, for example:",
        "In the case where a pair of lexical and surface contexts are identical, or if the lexical and surface elements arc identical, they need not be repeated.",
        "Such compressed rules as the following are also allowed: Left <= Element => Right.",
        "Left => Element <= Right.",
        "Sets of symbols may be specified: set(vowel,[a,e,i,o,u]).",
        "Lexical entries may be specified as follows: lcat=noun,root= craps).",
        "lexicon:: (cat=--noun,root= piano).",
        "'Ibis feature notation is that used in the author's Definite Feature Grammars (Abramson 1991).",
        "Logical reading of relational morphology rules.",
        "Corresponding to a set of relational morphology rules, a binary predicate morphology/2 specifies the relation between a lexical and a surface stream of characters: molphology(LexStream,SurfaceStream).",
        "In order to specify the logic program clause which corresponds to a relational morphology rule, we have to manipulate the left and right lexical and surface contexts.",
        "We can find the right contexts within LexStrewn and SurfaceStream, but we have to provide a specification of the left contexts, and we do this by defining the above binary predicate morphology/2 in terms of a quaternary predicate morphology/4: morphology(LexStream,SurfaceStream, LeftLexStream,LeftSurfaceStream).",
        "A two-level morphological analysis of Rumanian.",
        "Texas Linguistics Forum 22:253-270, Koskenniemi, K. 1983.",
        "Two-level morphology: a general computational model for word-loon recognition and production.",
        "Publication No.",
        "11 Helsinki: University of Helsinki Department of General Linguistics.",
        "Lun, S. 1983.",
        "A two-level morphological analysis of French.",
        "Texas Linguistics Forum 22:271-278.",
        "Sasaki Main, Y.",
        "1983.",
        "A two-level nun phological analysis of Japanese.",
        "Texas Linguistics Forum 22:229- 252.",
        "Appendix.",
        "Elementary formation of plurals in English.",
        "In addition to specifying characters such as s, x, etc., we can also define sequences of characters noted as lists [s,t1], not(character), not(sequence of characters).",
        "in(con) means any member of the set con, whereas it(X,char e) is a member of the set char _c assigned to the variable X for unification in another part of the rule.",
        "'+' is used as a morpheme boundary, 0 is used as the null symbol, 'it' is used as an endmarker, and is used to specify a don't care context.",
        "By providing a complete specification of context we could remove any consideration of ordering of the rules.",
        "However, it is convenient to depart slightly from an order free formalism by allowing default rules such as our last one with don't care contexts which spe,cify what happens to symbols not dealt with in any of the aforementioned rules, to appear at the end.",
        "(*)morphology([], [I, A, 11).",
        "(0) morphology([-r, s, MA], [e, s,[AC], [xID]) :- morphologyas, IIIAI, Is, MB], [i-, AC], le, x1111).",
        "(I) morphologya+, s, MA], [e, s, #111], [2:1C], [alp]) :- morphologyas, itIA1, [s, 1d131, l+, 7.1C1, [e, alD1).",
        "(2) morphology([-r, s,s, MB], [yIC], [i113]) morphology[s, #1A], Is, #1111,1+, yIC], [e, ilD]).",
        "(3) morphology(' i, s, #1A], fe, s, #1131, I sIC1, [sID]) :- mot phologyas, dIAl, IS, #1111,[4, sIC], [e, sIDD (4) nimphology(1+, s, itIA], [e, s, #1111,loIDD morphology(' s, #1/1.1, Is, #1131, [+, ICI, [e, olD]).",
        "(5) morphologya+, s, diAl, Fe, s, #113], [h, elC], [11, cID]) :- inorphology(Ls, MAI, Is, #1131, [+, Ii, cIC], [e, ii, cID]).",
        "(6) morphologY(I+, s, MA], le, s, #1111, [11, sIC],[11, sip]) :- Inorphologyas, MA], [s, #1131, t, Ii, sIC], [e, Ii, sIDI).",
        "(7) morphologyay, +IA], 'MTh C, [DIE]) :- con(D),Enorphology0+1A1, 14, yIC], [i, DIE]).",
        "(8) moiphology([+, s, illAJ, [s, #111], C, D) :-"
      ]
    },
    {
      "heading": "Abstract",
      "text": [
        "We use the more abstract term \"relational morphology\" in place of the usual \"two-level morphology\" in order to emphasize an aspect of Koskenniemi's work which has been overlooked in favor of implementation issues using the finite state paradigm, namely, that a mathematical relation can be specified between the lexical and surface levels of a language.",
        "Relations, whether finite state or not, can be computed using any of several paradigms, and we present a logical reading of a notation for relational morphological rules (similar to that of Koskenniemi's) which can in fact be used to automatically generate Prolog program clauses.",
        "Like die finite state implementations, the relation can be computed in either direction, either from the surface to the lexical level, or vice versa.",
        "At the very least, this provides a morphological complement to logic grammars which deal mainly with syntax and semantics, in a programming environment which is more user-friendly than the finite state programming paradigm.",
        "The morphological rules often compile simply into unification of the arguments in the generated morphology predicate followed by a recursive call of the said predicate.",
        "Further speed can be obtained when a Prolog compiler, rather than an interpreter, is used for execution.",
        "Introduction.",
        "Kimmo Koskenniemi's so called \"two- level model\" of computational morphology (1983) in which phonological rules are implemented as finite state transducers has been the subject of a great deal of attention.",
        "The two-level model is based partly on earlier work of Johnson (1972), who considered that a set of \"simultaneous\" phonological rules could be represented by such a transducer, and of Kaplan and Kay (1983) who thought that ordered generative rules could be implemented as a cascading sequence of such transducers.",
        "Koskenniemi in fact implemented the phonological rules by a set of finite state tranducers running in parallel, rather than by a single large finite state machine into which many cascading machines could be combined.",
        "Subsequent to Koskenniemi's original work, there was a LISP-based implementation called KIMMO (ICartunnen 1983), and two-level descriptions of English, Rumanian, French and Japanese (Kartunrien and Wittenburg, Khan, Lun, Sasaki Alam 1983).",
        "A later LISP based implementation by Dalrymple et al. (1987) called DKIMMO/TWOL helped the user by converting two-level rules into finite state transducers: in earlier implementations, and in the recent PC-KIMMO system (Antwortli 1990), it was the user's task to generate the machines from two-level descriptions.",
        "However one very important contribution of Koskenniemi to morphology, namely the notion that there is a relation between the surface and lexical \"levels\", has been somewhat overlooked by itnplernentation issues having to do with the conversion of two-level rules into finite state automata in the various KIMMO systems.",
        "The two-level rules according to this notion, unlike the rules of generative morphology which transform representations from one level to representations in the other, express a correspondence between lexical and surface levels.",
        "Furthermore since no directionality is implied in the definition of a relation, unlike generative rules, the same set of two-level rules applies both in going from surface to lexical levels and vice versa.",
        "Rather than being procedural rules, they are declarative.",
        "Consequently, any correct implementation of the two-level rules is a relational program which can be used either analytically or generatively.",
        "We will henceforth, in order to emphasize the fact that a relation is being defined by them, refer to relational morphology rules rather than to the mathematically neutral term \"two-level rules\".",
        "Despite the recognition that relational morphology rules are declarative, the main emphasis in using them has been obscured by the original finite state implementation technique.",
        "Recently, Bear (1986) has interpreted such rules directly, using Prolog as an implementation language.",
        "This, although an improvement on finite state implementations from the point of view of debugging and clarity, still misses an important aspect of relational morphology rules as a declarative notation, namely that if relational morphology rules define a relation between surface and lexical levels, then that relation can be specified and implemented using any of several different relational programming paradigms.",
        "In this paper, we will show that logic programming, which can be viewed as a relational programming paradigm, can be used to give a declarative reading to morphological rules.",
        "Further, because of the execution model for logic programs, embodied in various logic programming languages such as Prolog, the declarative reading also has a convenient procedural reading.",
        "That is, each relational morphological rule may be thought of as corresponding to or generating a logic program clause.",
        "The entire set of logic program clauses generated from the relational morphological rules, coupled with some utility predicates, then constitutes a morphological analyser which can either be used as a stand alone program or which can be coupled as a module to other linguistic tools to build a natural language processing system.",
        "Since the rules have been transformed into logic program clauses, they gain in speed of execution over Bear's interpretive method, and further speed can be gained by compiling these clauses using existing Prolog compilers.",
        "At the very least, this provides a morphological complement to logic grammars (Abramson and Dahl 1989) which deal mainly with syntax and semantics, in a programming environment which we believe is more user-friendly than the finite state programming paradigm.",
        "It may be argued that this is a step backwards from the linear efficiency of finite state processing.",
        "body which is only a recursive call of the same predicate are efficiently handled by Prolog compilers.",
        "Clause 7 is similar except that it also involves a check to see that the first character in the left surface context is a consonant.",
        "Set definitions such as: generate unit clauses: con(b)., con(c).,con(z).",
        "In clause 7, if D in con(D) is instantiated (as it is since the D represents a left context which has already been seen), code generated for this by Prolog compilers amounts to something like an indexed table lookup which takes place in constant time.",
        "Similar remarks apply to clause 10 where it is checked that A is a member of the set char_e.",
        "Clause 8 involves a combination of a unification check for the right context, and a check that the left context does not consist of any of the specified strings.",
        "Here, in order for the morphology clauses to work in both the analytical and generating directions, the negation must be logically safe notation, i.e., the arguments to the negation must be grounded.",
        "Logically safe negation involves the use of delaying evaluation of the negation until all arguments have been grounded.",
        "Clause 9 which involves a negative context, makes sure, using safe negation, that either the right context is not [s,'#') or that the left context does not match any of the substrings in the specified set.",
        "Sample execution: ?- morphology(P,cries).",
        "fail.%no.",
        "3- morphology('fox+s',P).",
        "P = foxes ?- morphology('piano+s',P).",
        "P pianoes;%one plural form for some nouns %which end in \"o\"",
        "The same clauses for the predicates morphology/2 and morphology/4 are used in solving goals in both directions."
      ]
    }
  ]
}
