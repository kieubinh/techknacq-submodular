{
  "info": {
    "authors": [
      "David Weir"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P92-1018",
    "title": "Linear Context-Free Rewriting Systems and Deterministic Tree-Walking Transducers",
    "url": "https://aclweb.org/anthology/P92-1018",
    "year": 1992
  },
  "references": [
    "acl-P87-1015"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We show that the class of string languages generated by linear context-free rewriting systems is equal to the class of output languages of deterministic tree-walking transducers.",
        "From equivalences that have previously been established we know that this class of languages is also equal to the string languages generated by context-free hypergraph grammars, multicomponent tree-adjoining grammars, and multiple context-free grammars and to the class of yields of images of the regular tree languages under finite-copying top-down tree transducers."
      ]
    },
    {
      "heading": "Introduction",
      "text": [
        "In [9] a comparison was made of the generative capacity of a number of grammar formalisms.",
        "Several were found to share a number of characteristics (described below) and the class of such formalisms was called linear context-free rewriting systems.",
        "This paper shows how the class of string languages generated by linear context-free rewriting systems relates to a number of other systems that have been studied by formal language theorists.",
        "In particular, we show that the class of string languages generated by linear context-free rewriting systems is equal to the class of output languages of deterministic tree-walking transducers [1].",
        "A number of other equivalences have already been established.",
        "In [10] it was shown that linear context-free rewriting systems and multicomponent tree adjoining grammars [6] generate the same string languages.",
        "The multiple context-free grammars of [7] are equivalent to linear context-free systems.",
        "This follows *I would like to thank Joost Engelfriet for drawing my attention to context-free hypergraph grammars and their relationship to deterministic tree-walking automata.",
        "from the fact that multiple context-free grammars are exactly that subclass of the linear context-free rewriting systems in which the objects generated by the grammar are tuples of strings.",
        "The class of output languages of deterministic tree-walking transducers is known to be equal to the class of yields of images of the regular tree languages under finite-copying top-down tree transducers [4] and in [3] it was shown that it also equal to the string languages generated by context-free hypergraph grammars [2, 5].",
        "We therefore have a number of characterizations of the same class of languages and results that have been established for the class of languages associated with one system carry over to the others.",
        "This is particularly fruitful in this case since the output languages of deterministic tree-walking transducers have been well studied (see [4]).",
        "In the remainder of the paper we describe linear context-free rewriting systems and deterministic tree-walking transducers and outline the equivalence proof.",
        "We then describe context-free hypergraph grammars and observe that they are a context-free rewriting system."
      ]
    },
    {
      "heading": "Linear Context-Free Rewriting Systems",
      "text": [
        "Linear context-free rewriting systems arose from the observation that a number of grammatical formalisms share two properties.",
        "1.",
        "Their derivation tree sets can be generated by a context-free grammar.",
        "2.",
        "Their composition operations are size-preserving,",
        "i.e., when two or more substructures are combined only a bounded amount of structure is added or deleted.",
        "Examples of formalisms that satisfy these conditions are head grammars [8], tree adjoining grammars [6], multicomponent tree adjoining grammars [6] and context-free hypergraph grammars.",
        "It was shown [9] that a system satisfying the above conditions generates languages that are semilinear and can be recognized in polynomial time.",
        "The definition of linear context-free rewriting systems is deliberately not specific about the kinds of structures being manipulated.",
        "In the case of head grammars these are pairs of strings whereas tree adjoining grammars manipulate trees and context-free hypergraph grammars manipulate graphs.",
        "In [9] size-preserving operations are defined for arbitrary structures in terms of properties of the corresponding functions over the terminal yield of the structures involved.",
        "The yield is taken to be a tuple of terminal strings.",
        "We call the function associated with a composition operation the yield function of that operation.",
        "The yield function of nf of a composition operation f gives the yield of the structure f(cl, (dots, cn) based on the yield of the structures , cn.",
        "Let E be an alphabet of terminal symbols.",
        "f is an nary linear regular operation over tuples of strings in E if it can be defined with an equation of the form",
        "where each ki > 0, n > 0 and each ti is a string of variables (x's) and symbols in E and where the equation is regular (all the variables appearing on one side appear on the other) and linear (the variables appear only once on the left and right).",
        "For example, the operations of head grammars can be define with the equations':",
        "where n > 0, f E F , and A, Ai, • .",
        "• , E VN • With a grammatical formalism we associate an interpretation function m that maps symbols in F onto the formalism's composition operations.",
        "For example, in a typical head grammar the set F might include { W, Cl, C2 } where m(W) = wrap, m(C1) = concl and m(C2) = conc.",
        "A formalism is a linear context-free rewriting system (lcfrs) if every grammar can be expressed as a gcfg and its interpretation function m maps symbols onto operations whose yield functions are linear regular operations.",
        "In order to simplify the remaining discussion we assume that m maps directly onto the yield functions themselves.",
        "The language L(G) generated by a gcfg G = (VN , S, F, P) with associated interpretation function m is defined as",
        "where",
        "• A v. m(f) if A f() EP • A m(f)(ti, • • • , tn)",
        "We denote the class of all languages generated by lcfrs as LCFRL."
      ]
    },
    {
      "heading": "Deterministic Tree-Walking Transducers",
      "text": [
        "A deterministic tree-walking transducer is an automaton whose inputs are derivation trees of some context-free grammar.",
        "The automaton moves around the tree starting at the root.",
        "At each point in the computation, depending on the label of the current node and the state of the finite state control, the automaton moves",
        "Equivalence In this section we outline a two part proof that OUT(DTWT) = LCFRL.",
        "up, down or stays at the current node and outputs a string.",
        "The computation ends when the machine tries to move to the parent of the root node.",
        "We denote a deterministic tree-walking transducer (dtwt) by M = (Q, G, A, 6,0, F) where",
        "A is a finite set of output symbols, :Qx(VNUVT) QxDx A* is the transition function where",
        "A configuration of M is a 4-tuple w) where q E Q is the current state, 7 is the derivation tree of G under consideration, y is a node in 7 or I (where can be thought of as the parent of the root of 7), and w E A* is the output string produced up to that point in the computation.",
        "We have (q, 77, w) FM (qi ww,) if the label of y is X, 6(q, X) = (q' ,d, Iv') such that when d = stay then 71 = y, when d = d(i) then y' is the ith child of y (if it exists), and when d = up then if is the parent of n (1' if 7/ is the root of 7).",
        "The output language OUT(M) of M is the set of strings: { w E A* I (0,7, nr, e) (qf, 7, w), qj E F and 7 is a derivation tree of G with root yr} where 1-14 is the reflexive transitive closure of FM.",
        "We denote the class of all languages OUT(M) where M is a dtwt as OUT(DTWT).",
        "Consider the dtwt",
        "where G = ({S} ,{e} ,S,{S A,A--+e}) and the relevant component of 6 is defined as follows.",
        "Consider a dtwt M = (Q, E, G, A, 6,0, F) where G = (VN,VT , S, P).",
        "For convenience we assume that M is a dtwt without stay moves (see Lemma 5.1 in [3] for proof that this can be done).",
        "Given a derivation tree of G, and a node y in this tree, we record the strings contributed to the output between the first and last visit to nodes in the subtree rooted at y.",
        "These contributed terminal strings can be viewed as a k tuple where k is the number of times that the transducer enters and then leaves the subtree.",
        "For each production X X1 X72 in P and each p E Q we call C((X, p, •) (Xi, c, 0) .",
        ".",
        ".",
        "(X„ , c, 0)) C((21,1),.)",
        " – 0.",
        "(X1, e, 0) • • • (X, 0)) simulates all subcomputations of M that start in state p at a node labelled X that has been expanded using the production X --+ Xn.",
        "The node labelled A may be visited several times, but each time the machine must be in a different state (otherwise, being deterministic, it would loop indefinitely).",
        "The sequence of visits is recorded as a string of states.",
        "The component of the rule that is underlined indicates which of the children or parent is currently being visited.",
        "The call CgX, a, 0) (Xi , ai ii) • • • (Xn , an, in)) is made when a computation is being simulated in which the node labelled A has been visited 'al times (a!",
        "denotes the length of a) such that on the ith visit the machine was in the state indicated by the ith symbol in a. ai, , an are used in a similar way to encode the state of the machine during visits to each child node.",
        "0 is a string of terms that is used to encode the output produced between the first and last visit to the subtree rooted at the node labelled A.",
        "Ultimately, it has the form .t1 • ... tk.",
        "where each ti encodes the composition of the ith component of the tuple.",
        "The notation used for each ti is identical to that used in the equations used to define lcfrs composition operations given earlier, i.e., each ti is a string of output symbols and x's.",
        "i1,..., in are used to encode the number of times that a given child has been visited from above.",
        "This gives the number of times the subtree rooted at that node has been visited and, hence, encodes which component of the tuple was completed most recently.",
        "Thus, for each j, 1 < j < n, the simulation has moved from the parent to the jth child",
        "times.",
        "This number is used to determine which component of the tuple derived from the jth node should contribute to the parent's current component.",
        "When a move is made from the parent node to the jth child we add the variable xj,i,4.1 to the term currently being constructed for the parent node.",
        "In other words, the next component of the parent output is the ii + I th component of its jth child.",
        "The call C((X, a, 0)",
        "• • • (Xj, ai, ii) • • • (Xn, an, in))",
        "sumulates the machine visiting the jth child of a node expanded using the rule X – + Xn.",
        "From M the gcfg G' is constructed such that G' = (Vk , S', F, P') where",
        "and the procedure C determines P' and F where for each production A – + X1 ...Xn in P and each p E Q we call C((A,P, .)",
        "(X1, € • 0) • • • (Xn,e, 0)) In addition, for each a E VT and each p E Q we call C((a, p, •)) c C is defined as follows.",
        "Case I.",
        "C((X , ap, – +(Xial, ii) .",
        ".",
        ".",
        "(Xn, an, in)) Note that if n = 0 then X E VT, otherwise, X E VN.",
        "If b(p, X) = (q, up, w) then (X , ap) f((Xl,a1.",
        "), ,(Xn, an)) EP' for a new function f E F where m(f) is defined by (ti,...,tk) where 0w• = •t1 • ... • te.",
        "(note that when i = 0 for some j then (x1, , xj3) will appear as c), in addition, for each p' in Q that does not appear in ap call C((X,app' , Ow.)",
        "--+(Xial, ii) .",
        ".",
        ".",
        "(Xn, a, in)) Note that • has been placed after Ow.",
        "This indicates that we have finished with the current component of the tuple.",
        "Otherwise, if b(p, X) = (q, d(j),w) and 1 < j < n then call",
        "Note that if Xi E VT then it is not possible for the machine to move down the tree any further.",
        "Note that 0 will end with xj,j, and the iith compoent of the yield at X, will end in w.",
        "This simulates the next visit to this node (which must be from below) in the (guessed) state p'.",
        "In addition to the productions added by C, include in P' the production S' (S,qoaqf) for each qf E F and a E Q* such that aoaqf is non-repeating and b(q, S) = (qf , up, w) for some w where q is the last symbol in qoa.",
        "A complete proof would establish that the following equivalence holds.",
        "if and only if there is a derivation tree 7 of G with root rh• labelled A such that a = al ...an for some al , .",
        ".",
        ".",
        ", an E Q+ and for each i (1< i < n) (pi,7,71, 0111 (qi,7,1,wi) where ai = pa= for some E Q*.",
        "Consider the application of this construction to example the dtwt given earlier.",
        "The grammar contains the following productions (where productions containing useless nonterminals have been omitted).",
        "(S, 40403) ((it, gogiq2q3))",
        "where fi((x1,1, x1,2)) (A, goqiq2q3) i2((A, goqi 420)) where f2((xt,i, x1,2)) = cx1,2d)",
        "where 140 = (c, e).",
        "By renaming nonterminal we get the four productions",
        "Consider the gcfg G = (VN , S, F, P) and mapping rn that interprets the symbols in F. Without loss of generality we assume that no nonterminal appears more than once on the right of a production and that for each A E VN there is some rank (A) = k such that only k-tuples are derived from A.",
        "We define a dtwt M = (Q, E, G', VT, b, go, F) where G' is a context-free grammar that generates derivation trees of G in the following way.",
        "A derivation involving the use of a production 7r will be represented by a tree whose root is labelled by 7r = A 4 f(Ai , An) with n subtrees encoding the derivations from A1, , An.",
        "The roots of these subtrees will be labelled by the n productions used to rewrite the A1, , An.",
        "Let",
        "The dtwt M walks around a derivation tree 7 of G' in such a way that it outputs the yield of 7.",
        "Each subtree of 7 rooted at a node 77 labelled by the production 7r will be visited on k = rank(Ths(70) occasions by M. During the ith visit to the subtree M will output the ith component of the tuple.",
        "We therefore include in Q k states {l,.",
        ", k } that are used to keep track of which tuple is being considered.",
        "This will generally involve visiting children of 71 as determined by the equation used to define function used in 7r.",
        "Additional states in Q are used to keep track of these visits as follows.",
        "When the /th child of 71 has finished its mth component, M will move back up to ij in state (A1, m).",
        "Since no nonterminal appears twice on the right of a production it is possible for M to determine the value of 1 from A1 while at 9.",
        "For each production ir = A f(Ai, , An) E P where f is interpreted as the function defined by the",
        "we include the following components in the definition of 6.",
        "For each i (1 < i < k)",
        "• if ti = wsifinO, where w is a possibly empty terminal string then let b(i, 7r) = (m, down(1), w) • if ti = w (in which case it is time to move up the tree) let",
        "where (q, move, w) is determined as follows.",
        "For some unique 1 we know that B is the /th nonterminal on the right-hand side of rr.",
        "There is a unique ti such that = O1ximiwO2 where w is a possibly empty string of terminals.",
        "Case 1: 02 is empty In this case the ith component of the current node is complete.",
        "Thus, q = (lhs(70 , 0 and move = up.",
        "Case 2: 02 begins with the variable In this case the machine M must find the m'th component of the l'th child.",
        "Thus, q = m' and move = d(/').",
        "It should be clear that the start state qo should be 1 and the set of final states F = 1(8 , rank (S)) } A complete proof would involve verifying that the following equivalence holds.",
        "(Aa) (wi • , wn) if and only if there is a derivation tree 7 of G' with root rir labelled 7r such that lhs(70 = A and for each i (1 <i < n) (i, 7/r, E) 1-714 ((A, i), t, wi) We apply the construction to the grammar produced in the illustration of the first construction.",
        "First, we name the productions of the grammar",
        "The construction gives a machine in which the function 6 is defined as follows.",
        "The context-free grammar whose derivation trees are to be transduced has the following productions.",
        "We denote a hypergraph as a five tuple H = (V, E, E, incident, label) where ✓ is a finite set of nodes, E is a finite set of edges,",
        "A string can be encoded with a string hypergraph [5].",
        "The string bcaab is encoded with the following graph."
      ]
    },
    {
      "heading": "Context-Free Hypergraph Grammars",
      "text": [
        "In this section we describe context-free hypergraph gramars since they are an example of a lcfrs involving the manipulation of graphs.",
        "zThe class of string languages generated by context-free hypergraph grammars is equal to OUT(DTWT) [3] and the above result shows that they are also equal to LCFRS.",
        "A directed hypergraph is similar to a standard graph except that its (hyper)edges need not simply go from one node to another but may be incident with any number of nodes.",
        "If an edge is incident with n nodes then it is a n-edge.",
        "The n nodes that are incident to some edge are linearly ordered.",
        "For example, in the figure below, dots denote nodes and labelled square boxes are edges.",
        "The edge labelled a is a 3 edge, the edge labelled b is a 2-edge and the edge labelled c is a 1-edge.",
        "When the number of nodes incident to an edge exceeds 2, numbered tentacles are used to indicate the nodes that are incident to the edge.",
        "The numbers associated with the tentacles coming from an edge indicate the linear order of the nodes that are incident to that edge.",
        "2-edges are shown in the standard way and 1-edges can be used as a way of associating labels with nodes as shown.",
        "• ----ID.",
        "• • ----1•• • •",
        "We denote a context-free hypergraph grammar (cfhg) as four tuple G = (VN ,VT , S, P) where VN is a finite nonterminal alphabet, VT is a finite terminal alphabet,",
        "Consider the application of a production e H to a graph H' at a node et in H' with the same nonterminal label as e. The resulting graph is obtained from H' by replacing e' by the graph H with e removed from it.",
        "This involves merging of nodes.",
        "In particular, the ith node incident with e is merged with the ith node incident with e'.",
        "We require that all edges with the same label have the same number of incident nodes.",
        "A derivation begins with a graph containing a single edge labelled S and no edges.",
        "A derivation is completed when there are no nonterminal nodes in the graph.",
        "The string language associated with a cfhg G is denoted STR(G).",
        "The class of languages generated by all cfhg is denoted STR(CFHG).",
        "Due to lack of space, rather than a complete formal definition of cfhg derivations, we present an illustrative example.",
        "Consider the three productions shown below.",
        "Note that the edge on the left-hand-side of the production is indicated with a double box.",
        "It is clear from their definition that cfhg satisfy the conditions for being a lefts given earlier.",
        "As has been observed [3] it is possible to represent the set of derivations of a given cfhg with a set of trees that can be generated by a context-free grammar.",
        "The composition operation of cfhg in which a node is replaced by a graph is clearly size-preserving since it does not involve duplication or deletion of an unbounded number of nodes or edges.",
        "a Below we show the steps in a derivation of the string aabbccdd involving these productions.",
        "Note that the set of graphs derived corresponds to the string language { an bn Ca dn n > O}."
      ]
    },
    {
      "heading": "Additional Remarks",
      "text": [
        "We end by elaborating on the relationship between lcfrs, dtwt and cfhg in terms of the following complexity measures.",
        "• The maximum of rank(A) nonterminals A of a gcfg.",
        "Let LCFRLk be the class of languages generated by gcfg of some lcfrs whose nonterminals have rank k or less, i.e., derive at most k tuples.",
        "• The crossing number of a dtwt M. This is the maximum number of times that it visits any given subtree of an input tree.",
        "Let OUT(DTWTk) be the class of languages output by dtwt whose crossing number does not exceed k. • The maximum number of tentacles of the nonter",
        "minals of a cfhg.",
        "Let STR(CFHGk) be the class of languages associated with cfhg whose nonterminals have at most k tentacles.",
        "It has been shown (Theorem 6.1 in [3]) that OUT(DTWTk) = STR(CFHG2k) = STR(CFHG2k+i) It can be seen from the above constructions that LCFRLk = OUT(DTWTk) = STR(CFHG2k) = STR(CFHG2k+i)"
      ]
    }
  ]
}
