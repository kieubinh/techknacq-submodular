{
  "info": {
    "authors": [
      "Olivier Bouche",
      "Jan Van Eijck",
      "Olivier Istace"
    ],
    "book": "Conference of the European Association for Computational Linguistics",
    "id": "acl-E93-1009",
    "title": "A Strategy for Dynamic Interpretation: A Fragment and an Implementation",
    "url": "https://aclweb.org/anthology/E93-1009",
    "year": 1993
  },
  "references": [],
  "sections": [
    {
      "text": [
        "To see how the imperative style comes in, consider the treatment of indefinite descriptions (or: existential phrases).",
        "Existential quantifiers are viewed dynamically as random assignment statements followed by tests.",
        "The translation of the natural language phrase 'a man' becomes something like:",
        "The first part of this statement can be viewed as a random assignment to register x, the second part as a test on the value of x.",
        "This sequence of instructions is performed against the background of a database, i.e., a model of first order logic.",
        "The sequence succeeds if the database contains (representations of) men, and it can succeed in as many ways as there are men available in the database.",
        "The motivating examples for the shift from static to dynamic representation have to do with pronoun binding.",
        "The translation of phrases like 'a man' in terms of assignments of values to registers makes it possible to treat binding of pronouns across sentence boundaries (the next sentence can start with 'He' to pick up the reference to 'a man').",
        "The nice thing about the treatment in terms of assignment is that the scope of the existential quantification is not closed off at the end of a sentence, as used to be the case for NL systems that employ static representation (in terms of the existential quantifiers of predicate logic, with their irritating closing brackets)."
      ]
    },
    {
      "heading": "Abstract",
      "text": [
        "The strategy for natural language interpretation presented in this paper implements the dynamics of context change by translating natural language texts into a meaning representation language consisting of (descriptions of) programs, in the spirit of dynamic predicate logic (DPL) [5].",
        "The difference with DPL is that the usual DPL semantics is replaced by an error state semantics [2].",
        "This allows for the treatment of unbound anaphors, as in DPL, but also of presuppositions and presupposition projection.",
        "The use of this dynamic interpretation strategy is demonstrated in an implementation of a small fragment of natural language which handles unbound pronoun antecedent links, where it is assumed that the intended links are indicated in the input string, and uniqueness presuppositions of definite descriptions.",
        "The implementation consists of a syntax module which outputs parse trees, a semantic module mapping parse trees to DPL representations, a representation processor which determines truth conditions, falsity conditions and presupposition failure conditions, and an evaluator of these conditions in a database model.",
        "The implementation uses the logic programming language GOdel [6], an experimental successor of Prolog, with similar functionality and expressiveness, but with an improved declarative semantics.",
        "Recently, it has become clear that dynamic representation has some other interesting features: It becomes possible to give an account of presupposition failure phenomena in terms of the definition of an error state semantics for the dynamic representation language [3; 2].",
        "Presupposition failure occurs for example if one tries to interpret \"John's wife is unhappy\" in a situation where John is not married.",
        "A more natural treatment of tense becomes possible.",
        "A sequence of sentences in the past tense like \"A man walked in.",
        "He sat down.",
        "He ordered a drink\" etc, is represented using subsequent assignments of values (time intervals) to a dedicated time register t [10].",
        "The dynamic representation language can be analysed with tools that were originally designed for analysing imperative programming languages, namely the tools for precondition reasoning from Hoare logic or dynamic logic [11].",
        "Precondition reasoning for dynamic predicate logic with standard semantics was introduced in [4].",
        "Precondition reasoning gives the truth conditions of DPL representations in the form of formulas of first order logic (FOL).",
        "When applied to the error state semantics of DPL, precondition reasoning can also be used to find the presupposition failure conditions of DPL representations as FOL formulas.",
        "We provide an integrated treatment of syntax and semantics of a small fragment of natural language and test this by implementing it.",
        "The syntax of our toy grammar is a version of categorial grammar with feature unification.",
        "The semantics uses DPL representations, with an error state semantics which is reflected in the rules for precondition reasoning implemented in the precondition module.",
        "This module generates predicate logical formulas expressing the weakest preconditions of success, failure or error of the DP L representations.",
        "In detail, our interpretation strategy consists of the following steps:",
        "1.",
        "Parsing a sentence or text and building a representation tree of its structure.",
        "2.",
        "Translating the parse tree into a DPL program.",
        "3.",
        "Using precondition reasoning to compute preconditions as formulas of FOL.",
        "4.",
        "Simplifying the preconditions using a simplifier for FOL formulas.",
        "5.",
        "Evaluating the resulting formulas in a database model.",
        "The current implementation produces for an input text within the grammar fragment: a LaTeX form report containing the sentence, the parse tree, the DPL translation, the precondition of success, the precondition of failure and the precondition of error, all in simplified form, and the result of evaluation in the database."
      ]
    },
    {
      "heading": "2 Dynamic Predicate Logic 2.1 Informal discussion",
      "text": [
        "DPL meaning representations for natural language sentences can be viewed as procedures or programs with a relational semantics.",
        "The programs that represent the meanings are interpreted as relations between input states and output states.",
        "A state is a mapping from variables to values in a model (in our simple set-up all variables are of the same type).",
        "The representation for an example sentence such as \"John saw a man\" is a program which associates John with a variable x, a man with a variable y, and first checks whether the value of x equals John, next puts a value in y which satisfies the predicate of being a man, and finally checks whether the values of x and y are such that the first saw the second.",
        "Thus, the representation of \"John saw a man\" is a program which relates input states where a is mapped to John to output states where x is mapped to John and y is mapped to some man seen by John.",
        "If the evaluation takes place in a model where John saw several men, then there are several possible output states.",
        "If the evaluation takes place in a model where John saw no men at all, then there is no output.",
        "A program that yields no output for a given input fails for that input.",
        "A program yielding at least one output for a given input succeeds for that input.",
        "A program which yields at most one output for a given input is deterministic for that input.",
        "A program which yields more than one output for a given input is indeterministic for that input.",
        "The example \"John saw a man\" shows that indefinite descriptions may give rise to indeterministic programs.",
        "Deterministic programs that do not change their input are called test programs.",
        "If a test program succeeds, its output equals its input.",
        "The sentence \"John saw him\" would give rise to a test program.",
        "Assuming that the variable x,y are used for the subject and object of the sentence, respectively, the program will succeed for any input with x mapped to John and y mapped to some male individual seen by John.",
        "In this case success means that the output state equals the input state.",
        "The program will fail for any other input.",
        "All basic programs of DPL are tests; they do not change their input, and they succeed if the values of terms are in a specified relation and fail otherwise.",
        "Indeterminism in DPL arises from assignment programs.",
        "The assignment program for an indefinite description a man will assign a new value to a variable x and succeed for any value of a which is a man.",
        "This is called indefinite assignment.",
        "The assignment program for a definite description the manager gives a value to a variable if and only if there is only one possible value in the model under consideration.",
        "Complex programs can be formed by means of negation, implication and sequential composition.",
        "Negation and implication always form tests, but se62 quential composition does not.",
        "Sequential compositions are tests if and only if the component programs are tests."
      ]
    },
    {
      "heading": "2.2 Syntax",
      "text": [
        "For ease of exposition we will assume there are no function symbols in the DPL representation language, so the terms of DPL are either constants or variables.",
        "Let C be the set of constants, V the set of variables, and assume c E C, v E V. DPL terms t ::= c I v. Assume a set of relation symbols R with arities.",
        "Then the programs of DPL are given by the following BNF definition.",
        "DPL programs ir ::= t = t I Rt t I (ir; 7r) I (7r 7) (-17) nv 7 I IV : We will use man, see as the relation symbols that translate \"man\", \"see\", and so on.",
        "Thus, (1) is a DPL program.",
        "(1)(71v2: man(v2); see(v2, v4)) We will omit outermost brackets and brackets in sequential compositions like ((in; 7 2);r3).",
        "This is harmless, for sequential composition is associative.",
        "Also, we will abbreviate qv : v = t as v := t. This abbreviation is natural, as the sequential composition of random assignment to v and test for equality with t boils down to assigning the value of t to v."
      ]
    },
    {
      "heading": "2.3 Indices for Antecedents and Anaphors",
      "text": [
        "In the natural language fragment we treat, we use co-indexing to indicate intended anaphoric links.",
        "We follow Barwise [1] in using superscripts for antecedents and subscripts for anaphors.",
        "(2)A man walked in.",
        "He smiled.",
        "If we intend the pronoun in (2) to refer to the subject of the first sentence, we indicate this intention as follows.",
        "(3)A man' walked in.",
        "Hei The superscript on the indefinite noun phrase indicates that this NP acts as an antecedent for NPs with the same index as a subscript.",
        "The subscript on the pronoun indicates the antecedent to which the pronoun is linked.",
        "The use of subscripts and superscripts is necessary because noun phrases can act as anaphors and antecedents at the same time.",
        "(4)A man' walked in.",
        "Another man walked out.",
        "He2 was angry.",
        "In example (4) the noun phrase another man is anaphorically constrained by an antecedent noun phrase a man (it must have a different referent), and at the same time acts as antecedent for the second occurrence of a man.",
        "The superscripts and subscripts refer to the variables we employ in the translation of the noun phrases.",
        "Superscripts correspond to variables that get assigned a value in the translation, subscripts to variables that are simply used.",
        "Sentence (5) will get translated as (6) (tense is ignored, here and hereafter, for ease of exposition).",
        "Turning now to definite descriptions, the natural translation of example (11) is (12).",
        "In the error state semantics for DPL that we have in mind for this, (12) gives error in every model where there is no unique man.",
        "It is clear that in most cases this is too strong.",
        "Still, we do not think this is a serious problem for our general approach.",
        "It seems to be a linguistic fact that definite descriptions often are used in a context-dependent way, to designate a unique referent in a very specific context, which however is not made fully explicit.",
        "One context where (11) makes perfect sense is a situation where John and some other male individual are present, and where it is left implicit that John is excluded from the context where the reference is unique.",
        "In such cases we propose to read the definite description as uniquely satisfying the description plus the extra condition of being non-identical with some constraining antecedent, in this case the subject of the sentence.",
        "This strategy boils down to reading (11) as (13).",
        "(13)Johnl saw the other man?.",
        "Here the determiner the otheri is treated similarly to anotheri.",
        "This gives translation (14).",
        "see (vi, v2).",
        "In many cases another mechanism seems to be at work.",
        "(15)A man walked in.",
        "John saw the man.",
        "Example (15) has a natural reading where the definite description is anaphorically linked to an antecedent.",
        "We propose to make such implicit anaphoric links explicit, as in (16).",
        "(16)A manl walked in.",
        "John2 saw the man?.",
        "If we provide the right translation instruction for such anaphoric uses of the, we arrive at translation",
        "This gives the ma4 the meaning: the unique man that is equal to vi, with v3 available for later reference to this individual.",
        "It seems to us that this gives the correct result, in the present case and in lots of other cases.",
        "In the case of (18) we still run into trouble, however.",
        "(18)The man with the hat smiled.",
        "Here, the natural translation is (19).",
        "smi/e(vi).",
        "This translation contains a definite assignment tv2 hat(v2), so it seems to assume that there is a unique hat in the domain of discourse, which is perhaps a bit too strong.",
        "There are at least the following two ways out.",
        "One is by handwaving.",
        "Just remark that in descriptions like the man with the golden gun, the second definite article is not quite as definite as it looks, and the description is in fact idiomatic for the more strictly correct the man with a golden gun.",
        "The other escape is to add an epicycle to the analysis, in order to achieve that man1 with' the hat2 translates into (20).",
        "We provisionally opt for the first solution.",
        "2.4 Semantics The standard DPL semantics maps input states to sets of possible output states.",
        "Let a model M = (M, I), where M is the domain and I the interpretation function for a set of constants and relation symbols be given.",
        "Then the set of states is the set of functions MV, and the standard semantics for DPL is given by a function Hm p(mV).",
        "In order to capture the uniqueness presuppositions of definite descriptions, we replace the standard semantics by an error state semantics.",
        "In a Russellian account of definite descriptions, \"The king of France is bald\" when evaluated with respect to the state of affairs in 1905 or 1993 is false, for there is no unique referent for the description.",
        "But it is much more natural to follow Frege, Strawson and the majority of the linguistic community in assuming that statements involving \"the king of France\", when interpreted with respect to a state of affairs where there is no unique king of France, may be neither true nor false, because they suffer from presupposition failure.",
        "We propose to use an error state semantics to take in account the failure of uniqueness presuppositions of t assignments.",
        "The error state semantics of DPL if given by a function",
        ": (Mv U e) 'P(Mv U c).",
        "In the definition of this function, which follows, e refers to a special error state, A ranges over proper states, B ranges over states in general (including the error state), and A[x := cl] is used for the proper state which is like A, except for the fact that z is mapped to d. 1.",
        "Prlm(e) = {f} 2.",
        "Pti tnIIA4(A) =",
        "if d exists {e}otherwise.",
        "More information on this definition can be found in [2].",
        "For present purposes it is sufficient to note that a DPL program can execute in three different ways, when acting on a given input state:",
        "1.",
        "The program reports success by producing at least one proper output state.",
        "For example, the program man (vi) when acting on an input state where v1 refers to John will succeed and return the input state as its only output state.",
        "2.",
        "The program reports failure by not producing any output at all.",
        "For example, the program nvi : woman(vi) will fail for any input state (except e) if there are no women in the model under consideration (its output state set will be empty).",
        "3.",
        "The program reports error by producing c as its only output.",
        "For example, the program Lv1 manager(vi) will produce e for any input state if the model under consideration does not have a unique manager."
      ]
    },
    {
      "heading": "3 Preconditions of DPL programs",
      "text": [
        "Above, we have referred to DPL formulas as programs.",
        "We are now going to use tools for programming language analysis on DPL.",
        "We will use quantified dynamic logic over DPL to describe the preconditions for success, failure and error of DPL programs.",
        "QDL terms t ::= c I v, QDL programs r ::= t = t I Rtt (r; 7r) I (rr) (-vir) I ?iv :tv : r, QDL formulas w ::= t = t I Rt t (So A 50) I 'Cal 3vC1 I (7)S0 I [7]C0-Note that the QDL programs are precisely the DPL programs.",
        "An atomic relation Rti, i, can occur inside a QDL program or as an atomic QDL formula, so we need to distinguish the programs of QDL from the static QDL relations.",
        "We use boldface for the test program Rt, t and italics for the formula Rti -tn.",
        "We omit outermost parentheses as usual, and use T for a formula which is always true, 1 for a formula which is always false.",
        "The semantics of QDL is as for first order logic, with the following clauses for the program modalities added (assume A 0 c): M kA (ir)co if there is some B with B E Prlm(A), B c and M B so.",
        "M kA firbo if for all B E MA4(1) it holds that B c and M Note that (r) and [ir] are not duals.",
        "(r)T expresses the conditions for success of r, [7r].1 the conditions for failure of r. It follows that --.",
        "(7r)T A --N1 expresses the conditions for error.",
        "The following axiom schemata can be used to compute these conditions as formulas of FOL.",
        "1.",
        "(Rt, tr,)co 4-4 (Rti tr, A co).",
        "2.",
        "[Rt, tn]co(Rti tnyo).",
        "3.",
        "(t,ta)cp(ti = t2 A co).",
        "4.",
        "[ti = t2li0(ti = 12 + co).",
        "5.",
        "(71; 72)Co(10 (7r2)so 6. fir' ; ir2b1 4-4 [71][112)9- 7.",
        "(-17)51(S0 A [7]-1-).",
        "8.",
        "[-mica 4-4 ((w)T V (co A [r]..L)).",
        "9.",
        "(IT.1r2)40 4-4 (so A Firait-2)T).",
        "10.",
        "[7r11r2b0 4-4 (([71]((72)T V ..L)) A ([71](10T41)).",
        "11.",
        "(riv : 7r)y,3v(71-)v. 12.",
        "[riv : whoVvfirj4p.",
        "13.",
        "(tv : 7r)co(3!v(7r)T A Bv(ir)co).",
        "14.",
        "[tv : 7r]o 4-4 (3!v(ir)T A Vv((ir)T --+ MO).",
        "The most interesting item of this list is the universal schema for t assignment (item 14).",
        "To see what it means, note that [ir]T expresses that all output states of r are proper.",
        "The schema states that the following are equivalent:",
        "For proper input state A, the program iv r does only have proper output states, and all of these satisfy 4p.",
        "For proper input state A there is precisely one d E M for which r has a proper output on input A[v := d], and for all d' for which r has proper outputs on A[v := d'], all outputs of r on A[v := d'] are proper and satisfy co.",
        "It is not very difficult to see that these are indeed equivalent, so the axiom schema is sound, as are the other axiom schemata.",
        "The axiom schemata can be used to calculate the truth, falsity and error conditions of DPL programs as formulas of FOL.",
        "If we represent a first order model as a database, then evaluation of DPL in a model reduces to evaluation of first order formulas in the database.",
        "An example will make clear how the axioms may be used to compute preconditions of DPL programs as FOL formulas.",
        "Consider example (21) with translation (22).",
        "(21)If a woman is married, her husband looks after her.",
        "Here is the derivation of the truth conditions."
      ]
    },
    {
      "heading": "4 The Implementation",
      "text": [
        "The parser The grammar for our fragment uses categorial feature unification, and the parser is based on standard techniques for such grammars.",
        "The syntax consists of a lexicon, which associates categories with lexical items, a category descriptor which gives definitions of complex categories in terms of simpler categories and some reduction rules.",
        "Basic categories are S without features, and E with features for number, person, case, ninder for up index (= antecedent index) and dindex for down index (= anaphor index).",
        "Complex categories are built with / and \\ and the constraints on feature unification in the usual way.",
        "The index features sin der and dindex also occur on noun phrases and determiners.",
        "Here are some examples of complex categories (* marks the feature values that do not matter).",
        "Some examples of complex category formation: a mans:",
        "=S.",
        "The translator The translator uses A-calculus to translate parse trees into DPL programs.",
        "We could have translated on the fly, building translations while parsing, but the present set-up seemed preferable for reasons of modularity of design.",
        "The translation algorithm makes use of a lexical function mapping pairs consisting of a lexical item with an associated category to A-expressions in the lexicon, along the lines of [9].",
        "Translating a sentence into DPL boils down to lambda reduction of the lambda expression which results from combining the lambda expressions associated with the leaves of the parse tree, according to the rules of functional application dictated by the categorial structure.",
        "Here are some examples of lambda expressions associated with lexical items with categories.",
        "Note that we assume the presence of indices in the lexicon, so we can handle anaphoric links by co-indexing.",
        "For a proper understanding of the translation instructions one should bear in mind the distinction between DPL variables that are used for DPL assignment and lambda calculus variables.",
        "We use lower case for the first and upper case for the latter.",
        "Translation for man, N(Sg): AVI.man(14).",
        "Translation for Johni ,NP(Sg,Third,*,i,*): AVI.vi := J; Vi(vi).",
        "Translation for sees, TV(Sg,Third,Tensed): AVI.(AV2.",
        "(VIAV3.see(V2, V3))).",
        "Translation for is, TV(Sg,Third,Tensed):",
        "Translation for the i j, Det(*,i,j) (the anaphoric use of the): AV1.",
        "(AV2.ivi : (vi = vi; Vivi); V2(vi)).",
        "Translation for if, (S/S)/S: AVI,(AV2.V1V2).",
        "Translation for does, AUX(Sg,Third): AVI.Vi.",
        "In the same way, (26) gets translated into (27).",
        "(26)John' is a man2.",
        "Note that 'is' is treated as in Montague grammar [8].",
        "5 Experiences with the Giiclel Implementation Language The declarative semantics of GOdel improves on the semantics of Prolog: extra-logical predicates (such as var, nonvar, assert, retract, !, .)",
        "are avoided and sometimes replaced by declarative counterparts.",
        "Like Lambda Prolog [7], GOdel is a typed language: it is necessary to declare the type and domain of all functions and predicates (polymorphism is allowed, however).",
        "This convention makes program writing a bit more cumbersome.",
        "For example, we have to declare the type Program for representing a DPL program.",
        "For each DPL statement, it is necessary to define a function to build a Program (example: Piota : Variable * Program k Program).",
        "We also have to declare a type Expression for A-expressions.",
        "Some complications arise from the fact that an expression may contain a DPL program and vice versa.",
        "On the plus side, more errors are detected during compilation, the compiler generates more efficient code, and the typing discipline makes for more legible, comprehensible programs.",
        "Last but not least, the typing discipline has obliged us to think a bit more about the clauses we were writing than we perhaps would have done otherwise.",
        "GOdel has facilities that permit elegant meta programming.",
        "In Prolog the program and the meta program are not independent: the predicates assert and retract modify the program itself in which these predicates occur.",
        "In Gidel, program and meta program are completely independent.",
        "It is possible for a program to load another program, to modify this other program by inserting or retracting predicates, functions or types, and to demonstrate a goal.",
        "In our implementation we use these facilities to represent a model as a logic database and a precondition as a complex goal."
      ]
    },
    {
      "heading": "6 The Program Itself",
      "text": [
        "The main module takes a sentence or text as input and produces a report containing the sentence, the parse tree, the DPL program it gets translated into, and the preconditions.",
        "This module uses the following submodules: the parser module which from a sentence, finds its category and builds its parse tree, the translation module which from the parse tree, computes a representation of a DPL program, the precondition module which from a DPL program, derives the preconditions (this module calls another module to simplify the resulting FOL formulas), the evaluation module which performs a database evaluation.",
        "A lexicon module is called by the first two of these modules.",
        "It contains the words, with their categories and the associated A-expressions."
      ]
    },
    {
      "heading": "6.1 Main module",
      "text": [
        "This module receives a sentence represented by a list of words and parses it, translates it, produces a report, computes preconditions and evaluates these in a given model."
      ]
    },
    {
      "heading": "6.2 Output",
      "text": [
        "This module defines how to output programs, expressions, categories, trees, words, ...",
        "It uses the facilities of GOdel for manipulating text files."
      ]
    },
    {
      "heading": "6.3 Lexicon",
      "text": [
        "The lexicon is defined by a predicate Diet with three arguments: the word itself, a category and an appropriate lambda expression."
      ]
    },
    {
      "heading": "6.4 Parser",
      "text": [
        "The parser employs backtracking and unification in the usual way.",
        "Giidel (as all logic programming languages) has these features built in, which makes it very easy to implement a parser for a simple fragment like ours.",
        "The parsing of a sentence consists of three steps: generate a list of categories corresponding to the sequence of words, reduce the list of categories, test if you have a sentence else retrace your steps and try again.",
        "We use the type categor to represent categories.",
        "It is defined by the constant S and the functions 4number,person,case,uindex,dinder), NP(numbenperson,case,uindex,dindex), N(number), and so on.",
        "The two infix functions / and \\ serve to build new and more complex categories.",
        "Sentences are parsed by building a binary parse tree in bottom-up fashion.",
        "The binary parse trees are represented by a constant Empty and a function A.",
        "Empty represents the empty tree and the function A gives the information at the current node, the left subtree, and the right subtree.",
        "The information content of the nodes is of two kinds: internal nodes carry the result of combining the categories of the subtrees and leaf nodes carry a pair consisting of a word and its category.",
        "The parse trees are built during the reduction of the list of categories, starting with a list of trees corresponding to the words of the sentence.",
        "When we reduce two adjacent categories, we replace the two corresponding trees T1, T2 by a single tree with T1 and T2 as immediate subtrees."
      ]
    },
    {
      "heading": "6.5 Translator",
      "text": [
        "The translator uses two types: Program and Expression.",
        "The first represents a DPL-program, the second a complex A-expression.",
        "We have left the rest of the typing of the lambda expressions implicit.",
        "The definition of programs and lambda expressions is a bit cumbersome, for a A-expression may contain a program and vice versa.",
        "This complication is re fleeted in the rules for substitution and reduction.",
        "For example, it is necessary to define the substitution of an expression for a variable in a program, the free occurrence of a variable in a program, etc.",
        "The rules of reduction are a straightforward rendering of the rules of /3-reduction and 7-reduction in A calculus.",
        "We do not handle a reduction, as we see no need for variable renaming.",
        "The translation process employs the following predicates: Trad This predicate translates a parse tree into a reduced A-expression.",
        "Depending on the information at the current node of the parse tree, a lexical lookup of the translation takes place, or the translation is found by reducing the application of the translations of the left and right subtrees.",
        "Trans This predicate translates a list of parse trees for the sentences of a text into the corresponding",
        "DPL program.",
        "It uses the predicate Trad to translate each sentence, and then links these translations by applications.",
        "Canred This predicates takes a .\\-expression and reduces it using the declarative functional semantics of )-calculus."
      ]
    },
    {
      "heading": "6.6 From DPL to QDL",
      "text": [
        "We have seen that DPL programs are represented as G6del functions.",
        "The reduction of DPL to FOL by means of QDL gets implemented by defining reduction predicates corresponding to the QDL axiom schemata.",
        "These predicates call each other recursively.",
        "FR(Rel(s, v)) is a relational atomic test.",
        "(Rti in) Fequal(tl, t2) is an atomic test of equality of the terms ti and t2.",
        "(ti = t2) Fand(phil, phi2) is the conjunction of two formulas.",
        "((pi A co) For(phil, phi2) is the disjunction of two formulas.",
        "((pi V co2) Fimplic(phl, phi2) is the implication of two formulas.",
        "(wi 4 so2) Fall(V(i), phi) is the expression (Vvicp) Fexist(V(i), phi) is the expression (Jaw) Fonlyone(V(i), phi) is the expression (3!vico) Fnot (phi) is the negation of the formula co. (Y) Fprecexist(pi, phi) is the expression ((7)6o) Fprecuniv(pi, phi) is the expression ([4p) Fpar(pi, phi) is the expression (--.",
        "(r)co A-44p).",
        "In the course of applying these predicates, formulas may get generated with obvious redundancies.",
        "We have defined a formula simplifier to remove some of these.",
        "This improves the readability of the output (the formulas are output in LaTeX format) and the performance of the database lookup on the basis of the conditions.",
        "There is the list of simplifications handled by the module Simple."
      ]
    },
    {
      "heading": "7 Conclusion",
      "text": [
        "The QDL translation discussed above only handles uniqueness presuppositions of definite descriptions.",
        "The method employed is general enough, however, to handle lots of other kinds of presupposition.",
        "Lexical presuppositions, for example, are handled in the error state semantics by a slight revision of the semantic clause for atomic tests.",
        "Being a bachelor presupposes being male and adult, so the test for bachelorhood should give error if it is performed on an entity that does not satisfy the test for being a male adult.",
        "Formally, the revision boils down to this.",
        "Let At be the set of atomic formulae of DPL.",
        "Assume a lexical presupposition function lp : At * DPL mapping each atomic test predicate of the representation language to its associated lexical presupposition, conceived as a program of the representation language.",
        "For example, here are the lexical presuppositions for bachelorhood.",
        "lp(bachelor x) = (male x; adult x).",
        "The semantic clause for atomic relations is modified to take the function lp into account: 2'.",
        "[R(ti tn)])m(A) =",
        "This modified definition gives the success and failure of the relational test modulo the fact that the lexical presupposition of the relational test holds; if the presupposition does not hold then the test results in error.",
        "There is no need for any other changes in the rules, for the projection of lexical presupposition is taken care of by the general principles of error percolation that are already implicit in the semantic clauses.",
        "Thus, the DPL error semantics gives us that (28) presupposes that Jan is male and adult, but that (29) only presupposes that Jan is adult.",
        "(28)Jan is a bachelor.",
        "(29)If Jan' is male, then he, is a bachelor.",
        "The change in the semantic clause for atomic relations is reflected in the calculus by replacing the schemata for Rti tn by the following versions:",
        "1.",
        "(Rti tn)C0 *4 (Ril tn A q, A (IP(Rti 2.",
        "[Rti tn]o 4 (Rti - tn ---+ yo) A (1p(Rt1 inDT).",
        "In the implementation, lexical presupposition is handled by a predicate Lp and a modification of the reduction predicates for the relational test axiom schemata.",
        "Right now, we are extending the fragment to deal with other kinds of presupposition failure, in particular failure of presupposition of aspectual verbs such as start and stop."
      ]
    }
  ]
}
