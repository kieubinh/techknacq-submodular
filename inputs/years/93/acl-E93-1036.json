{
  "info": {
    "authors": [
      "Mark-Jan Nederhof"
    ],
    "book": "Conference of the European Association for Computational Linguistics",
    "id": "acl-E93-1036",
    "title": "Generalized Left-Corner Parsing",
    "url": "https://aclweb.org/anthology/E93-1036",
    "year": 1993
  },
  "references": [
    "acl-C88-1075",
    "acl-E87-1037",
    "acl-E91-1012",
    "acl-J87-1004",
    "acl-P81-1001",
    "acl-P88-1031",
    "acl-P89-1017",
    "acl-P89-1018",
    "acl-P91-1013",
    "acl-P91-1014"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We show how techniques known from generalized LR parsing can be applied to left corner parsing.",
        "The resulting parsing algorithm for context-free grammars has some advantages over generalized LR parsing: the sizes and generation times of the parsers are smaller, the produced output is more compact, and the basic parsing technique can more easily be adapted to arbitrary context-free grammars.",
        "The algorithm can be seen as an optimization of algorithms known from existing literature.",
        "A strong advantage of our presentation is that it makes explicit the role of left-corner parsing in these algorithms.",
        "Keywords: Generalized LR parsing, left corner parsing, chart parsing, hidden left recursion."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Generalized LR parsing was first described by Tomita [Tomita, 1986; Tomita, 1987].",
        "It has been regarded as the most efficient parsing technique for context-free grammars.",
        "The technique has been adapted to other formalisms than context-free grammars in [Tomita, 1988].",
        "A useful property of generalized LR parsing (henceforth abbreviated to GLR parsing) is that input is parsed in polynomial time.",
        "To be exact, if the length of the right side of the longest rule is p, and if the length of the input is n, then the time complexity is 0(nP+1).",
        "Theoretically, this may be worse *Supported by the Dutch Organization for Scientific Research (NWO), under grant 00-62-518 than the time complexity of Earley's algorithm [Earley, 1970], which is 0(n3).",
        "For practical cases in natural language processing however, GLR parsing seems to give the best results.",
        "The polynomial time complexity is established by using a graph-structured stack, which is a generalization of the notion of parse stack, in which pointers are used to connect stack elements.",
        "If nondeterminisrn occurs, then the search paths are investigated simultaneously, where the initial part of the parse stack which is common to all search paths is represented only once.",
        "If two search paths share the state of the top elements of their imaginary individual parse stacks, then the top element is represented only once, so that any computation which thereupon pushes elements onto the stack is performed only once.",
        "Another useful property of GLR parsing is that the output is a concise representation of all possible parses, the so called parse forest, which can be seen as a generalization of the notion of parse tree.",
        "(By some authors, parse forests are more specifically called shared, shared-packed, or packed shared (parse) forests.)",
        "The parse forests produced by the algorithm can be represented using 0(e+1) space.",
        "Efficient decoration of parse forests with attribute values has been investigated in [Dekkers et al., 1992].",
        "There are however some drawbacks to GLR parsing.",
        "In order of decreasing importance, these are: The parsing technique is based on the use of LR tables, which may be very large for grammars describing natural languages.'",
        "Related to this is the large amount of time needed to construct [Purdom, 1974] argues that grammars for programming languages require LR tables which have a size which is about linear in the size of the grammar.",
        "It is generally considered doubtful that similar observations can be made for grammars for natural languages.",
        "a parser.",
        "Incremental construction of parsers may in some cases alleviate this problem [Rekers, 1992].",
        "The parse forests produced by the algorithm are not as compact as they might be.",
        "This is because packing of subtrees is guided by the merging of search paths due to equal LR states, instead of by the equality of the derived nonterminals.",
        "The solution presented in [Rekers, 1992] implies much computational overhead.",
        "Adapting the technique to arbitrary grammars requires the generalization to cyclic graph structured stacks [Nozohoor-Farshi, 19911, which may complicate the implementation.",
        "A minor disadvantage is that the theoretical time complexity worsens if p becomes larger.",
        "The solution given in [Kipps, 1991] to obtain a variant of the parsing technique which has a fixed time complexity of 0(n3), independent of p, implies an overhead in computation costs which worsens instead of improves the time complexity in practical cases.",
        "These disadvantages of generalized LR parsing are mainly consequences of the LR parsing technique, more than consequences of the use of graph structured stacks and parse forests.",
        "Lang [Lang, 1974; Lang, 1988c] gives a general construction of deterministic parsing algorithms from nondeterministic push-down automata.",
        "The produced data structures have a strong similarity to parse forests, as argued in [Billot and Lang, 1989; Lang, 1991].",
        "The general idea of Lang has been applied to other formalisms than context-free grammars in [Lang, 1988a; Lang, 1988b; Lang, 1988d].",
        "The idea of a graph-structured stack, however, does not immediately follow from Lang's construction.",
        "Instead, Lang uses the abstract notion of a table to store information, without trying to find the best implementation for this table.2 One of the parsing techniques which can with some minor difficulties be derived from the construction of Lang is generalized left-corner parsing (henceforth abbreviated to GLC parsing).3 The starting-point is left-corner parsing, which was first formally defined in [Rosenkrantz and Lewis II, 1970].",
        "Generalized left-corner parsing, albeit under a different name, has first been investigated in [Pratt, 2[Sikkel, 1990] argues that the way in which the table is implemented (using a two-dimensional matrix as in case of Earley's algorithm or using a graph-structured stack) is only of secondary importance to the global behaviour of the parsing algorithm.",
        "3 The term \"generalized left-corner parsing\" has been used before in [Demers, 1977] for a different parsing technique.",
        "Demers generalizes \"left corner of a right side\" to be a prefix of a right side which does not necessarily consist of one member, whereas we generalize LC parsing with zero lookahead to grammars which are not LC(0).",
        "1975] .",
        "(See also [Tanaka et al., 1979; Bear, 1983; Sikkel and Op den Akker, 1992].)",
        "In [Shann, 1991] it was shown that the parsing technique can be a serious rival to generalized LR parsing with regard to the time complexities.",
        "(Other papers discussing the time complexity of GLC parsing are [Slocum, 1981; Wiren, 1987].)",
        "A functional variant of GLC parsing for definite clause grammars has been discussed in [Matsumoto and Sugimura, 1987].",
        "This algorithm does not achieve a polynomial time complexity however, because no \"packing\" takes place.",
        "A variant of Earley's algorithm discussed in [Leiss, 1990] also is very similar to GLC parsing although the top-down nature of Earley's algorithm is preserved.",
        "GLC parsing has been rediscovered a number of times (e.g. in [Leermakers, 1989; Leermakers, 1992], [Schabes, 1991], and [Perlin, 1991]), but without any mention of the connection with LC parsing, which made the presentations unnecessarily difficult to understand.",
        "This also prevented discovery of a number of optimizations which are obvious from the viewpoint of left-corner parsing.",
        "In this paper we reinvestigate GLC parsing in combination with graph-structured stacks and parse forests.",
        "It is shown that this parsing technique is not subject to the four disadvantages of the algorithm of Tomita.",
        "The structure of this paper is as follows.",
        "In Section 2 we explain nondeterministic LC parsing.",
        "This parsing algorithm is the starting-point of Section 3, which shows how a deterministic algorithm can be defined which uses a graph-structured stack and produces parse forests.",
        "Section 4 discusses how this generalized LC parsing algorithm can be adapted to arbitrary context-free grammars.",
        "How the algorithm can be improved to operate in cubic time is shown in Section 5.",
        "The improved algorithm produces parse forests in a non-standard representation, which requires only cubic space.",
        "One more class of optimizations is discussed in Section 6.",
        "Preliminary results with an implementation of our algorithm are discussed in Section 7."
      ]
    },
    {
      "heading": "2 Left-corner parsing",
      "text": [
        "Before we define LC parsing, we first define some notions strongly connected with this kind of parsing.",
        "We define a spine to be a path in a parse tree which begins at some node which is not the first son of its father (or which does not have a father), then proceeds downwards every time taking the leftmost son, and finally ends in a leaf.",
        "We define the relation L between nonterminals such that B L A if and only if there is a rule A B a, where a denotes some sequence of grammar symbols.",
        "The transitive and reflexive closure of L is denoted by L*, which is called the left-corner relation.",
        "Informally, we have that B L* A if and only if it is possible",
        "to have a spine in some parse tree in which B occurs below A (or B = A).",
        "We pronounce B L* A as \"B is a left corner of A\".",
        "We define the set GOAL to be the set consisting of S, the start symbol, and of all nonterminals A which occur in a rule of the form B--o a A /3 where a is not c (the empty sequence of grammar symbols).",
        "Informally, a nonterminal is in GOAL if and only if it may occur at the first node of some spine.",
        "We explain LC parsing by means of the small context-free grammar below.",
        "No claims are made about the linguistic relevance of this grammar.",
        "Note that we have transformed lexical ambiguity into grammatical ambiguity by introducing the nonterminals VorN and VorP.",
        "The algorithm reads the input from left to right.",
        "The elements on the parse stack are either nonterminals (the goal elements) or items (the item elements).",
        "Items consist of a rule in which a dot has been inserted somewhere in the right side to separate the members which have been recognized from those which have not.",
        "Initially, the parse stack consists only of the start symbol, which is the first goal, as indicate in Figure 1.",
        "The indicated parse corresponds with one of the two possible readings of \"time flies like an arrow\" according to the grammar above.",
        "We define a nondeterministic LC parser by the parsing steps which are possible according to the following clauses:",
        "la.",
        "If the element on top of the stack is the nonterminal A and if the first symbol of the remaining input is t, then we may remove t from the input and push an item [B o t .",
        "a] onto the stack, provided B e A. lb.",
        "If the element on top of the stack is the non terminal A, then we may push an item [B o .]",
        "onto the stack, provided B L* A.",
        "(The item [B .]",
        "is derived from an epsilon rule B o c.) 2.",
        "If the element on top of the stack is the item [A o a t I3] and if the first symbol of the remaining input is t, then we may remove t from the input and replace the item by the item [A t. fl].",
        "3.",
        "If the topmost two elements on the stack are B [Aa .",
        "], then we may replace the item by an item of the form [C 0 A .",
        "A, provided C L* B.",
        "4.",
        "If the topmost three elements on the stack are [B .",
        "A 7] A [A a .",
        "], then we may replace these three elements by the item [B 0 13 A .",
        "7].",
        "5.",
        "If a step according to one of the previous clauses ends with an item [A oa.BI3] on top of the stack, where B is a nonterminal, then we subsequently push B onto the stack.",
        "6.",
        "If the stack consists only of the two elements S [So a .]",
        "and if the input has been completely read, then we may successfully terminate the parsing process.",
        "Note that only nonterminals from GOAL will occur as separate elements on the stack.",
        "The nondeterministic LC parsing algorithm defined above uses one symbol of lookahead in case of terminal left corners.",
        "The algorithm is therefore deterministic for the LC(0) grammars, according to the definition of LC(k) grammars in [Soisalon-Soininen and Ukkonen, 1979].",
        "(This definition is incompatible with that of [Rosenkrantz and Lewis II, 1970].)",
        "The exact formulation of the algorithm above is chosen to simplify the treatment of generalized LC parsing in the next section.",
        "The strict separation between goal elements and item elements has also been achieved in [Perlin, 1991], as opposed to [Schabes, 1991]."
      ]
    },
    {
      "heading": "3 Generalizing left-corner parsing",
      "text": [
        "The construction of Lang can be used to form deterministic table-driver parsing algorithms from non deterministic push-down automata.",
        "Because left corner parsers are also push-down automata, Lang's construction can also be applied to formulate a deterministic parsing algorithm based on LC parsing.",
        "The parsing algorithm we propose in this paper does however not follow straightforwardly from Lang's construction.",
        "If we applied the construction directly, then not as much sharing would be provided as we would like.",
        "This is caused by the fact that sharing of computation of different search paths is interrupted if different elements occur on top of the stack (or just beneath the top if elements below the top are investigated).",
        "To explain this more carefully we focus on Clause 3 of the nondeterministic LC parser.",
        "Assume the following situation.",
        "Two different search paths have at the same time the same item element [A a on top of the stack.",
        "The goal elements (say B' and B\") below that item element are different however in both search paths.",
        "This means that the step which replaces [A o .]",
        "by [C o A .",
        "fl], which is done for both search paths (provided both C e B' and C e B\"), is done separately because B' and B\" differ.",
        "This is unfortunate",
        "because sharing of computation in this case is desirable both for efficiency reasons but also because it would simplify the construction of a most-compact parse forest.",
        "Related to the fact that we propose to implement the parse table by means of a graph-structured stack, our solution to this problem lies in the introduction of goal elements consisting of sets of nonterminals from GOAL, instead of single nonterminals from GOAL.",
        "As an example, Figure 2 shows the state of the graph-structured stack for the situation just after reading \"time flies\".",
        "Note that this state represents the states of two different search paths of a nondeterministic LC parser after reading \"time flies\", one of which is the state after Step 3 in Figure 1.",
        "We see that the goals NP and VP are merged in one goal element so that there is only one edge from the item element labelled with [VorN * \"flies\" .]",
        "to those goals.",
        "Merging goals in one stack element is of course only useful if those goals have at least one left corner in common.",
        "For the simplicity of the algorithm, we even allow merging of two goals in one goal element if these goals have anything to do with each other with respect to the left-corner relation L*.",
        "Formally, we define an equivalence relation on nonterminals, which is the reflexive, transitive, and symmetric closure of L. An equivalence class of this relation which includes nonterminal A will be denoted by [A].",
        "Each goal element will now consist of a subset of some equivalence class of In the running example, the goal elements consist of subsets of {S, NP, VP, PP}, which is the only equivalence class in this example.",
        "Figures 3 and 4 give the complete generalized LC parsing algorithm.",
        "At this stage we do not want to complicate the algorithm by allowing epsilon rules in the grammar.",
        "Consequently, Clause lb of the non deterministic LC parser will have no corresponding piece of code in the GLC parsing algorithm.",
        "For the other clauses, we will indicate where they can be retraced in the new algorithm.",
        "In Section 4 we explain how our algorithm can be extended so that also grammars with epsilon rules can be handled.",
        "The nodes and arrows in the parse forest are constructed by means of two functions: MAKE_NODE (X) constructs a node with label X, which is a terminal or nonterminal.",
        "It returns (the address of) that node.",
        "A node is associated with a number of lists of sons, which are other nodes in the forest.",
        "Each list represents an alternative derivation of the nonterminal with which the node is labelled.",
        "Initially, a node is associated with an empty collection of lists of sons.",
        "ADD_SUBNODE (in, 1) adds a list of sons 1 to the node In the algorithm, an item element el labelled with [A Xi ... X,, .",
        "a] is associated with a list of nodes deriving X1.....Xm.",
        "This list is accessed by SONS (el).",
        "A list consisting of exactly one node m is denoted by <m>, and list concatenation is denoted by the operator +.",
        "A goal element g contains for every nonterminal A such that A L* P for some P in g a value NODE (g, A), which is the node representing some derivation of A found at the current input position, provided such a derivation exists, and NODE (g, A) is NIL otherwise.",
        "In the graph-structured stack there may be an edge from an item element to a unique goal element, and from a goal in a goal element to a number of item elements.",
        "For item element el, SUCCESSOR (el) yields the unique goal element to which there is an edge from el.",
        "For goal element g and goal P in g, SUCCESSORS (g, P) yields the zero or more item elements to which there is an edge from P in g. The global variables used by the algorithm are the",
        "following.",
        "ao al ... a The symbols in the input string.",
        "i The current input position.",
        "r The root of the parse forest.",
        "It has the value NIL at the end of the algorithm if no parse has been found.",
        "F and Fnezt The sets of goal elements containing goals to be fulfilled from the current and next input position on, respectively.",
        "I and 'next The sets of item elements labelled with [A --- a t ill such that a shift may be performed through t at the current and next input position, respectively.",
        "F The set of pairs (g, A) such that a derivation from A has been found for g at the current input position.",
        "In other words, F is the set of all pairs (g, A) such that NODE (g, A) 0 NIL.",
        "The graph-structured stack (which is initially empty) and the rules of the grammar are implicit global data structures.",
        "In a straightforward implementation, the relation L* is recorded by means of one large 8' x s boolean matrix, where s is the number of nonterminals in the grammar, and s' is the number of elements in GOAL.",
        "We can do better however by using the fact that A L* B is never true if A 76 B.",
        "We propose the storage of L* for every equivalence class of ,--, separately, i.e. we store one t' x t boolean matrix for every class of ;-, with t members, t' of which are in GOAL.",
        "We furthermore need a list of all rules A ,.",
        "X a for each terminal and nonterminal X.",
        "A small optimization of top-town filtering (see also Section 6) can be achieved by grouping the rules in these lists according to the left sides A.",
        "Note that the storage of the relation L* is the main obstacle to a linear-sized parser.",
        "The time needed to generate a parser is determined by the time needed to compute L* and the classes of ,-, which is quadratic in the size of the grammar."
      ]
    },
    {
      "heading": "4 Adapting the algorithm for arbitrary context-free grammars",
      "text": [
        "The generalized LC parsing algorithm from the previous section is only specified for grammars without epsilon rules.",
        "Allowing epsilon rules would not only complicate the algorithm but would for some grammars also introduce the danger of non-termination of the parsing process.",
        "There are two sources of non-termination for non deterministic LC and LR parsing: cyclicity and hidden left-recursion.",
        "A grammar is said to be cyclic if there is some derivation of the form A --++ A.",
        "A grammar is said to be hidden left-recursive if A . B a, B --).",
        "* c, and a ).",
        "* A [3, for some A, B, a, and P. Hidden left recursion is a special case of left recursion where the fact is \"hidden\" by an empty generating nonterminal.",
        "(A nonterminal is said to be nonfalse if it generates the empty string.)",
        "Both sources of non-termination have been studied extensively in [Nederhof and Koster, 1993; Nederhof and Sarbo, 1993].",
        "An obvious way to avoid non-termination for non deterministic LC parsers in case of hidden left recursive grammars is the following.",
        "We generalize the relation L so that B L A if and only if there is a rule A 4 p B [3, where p is a (possibly empty) sequence of grammar symbols such that p .",
        "* c. Clause lb is eliminated and to compensate this, Clauses la and 3 are modified so that they take into account prefixes of right sides which generate the empty string:",
        "la.",
        "If the element on top of the stack is the nonterminal A and if the first symbol of the remaining input is t, then we may remove t from the input and push an item [B 4 p t. a] onto the stack, provided B L* A and p --0.",
        "* c. 3.",
        "If the topmost two elements on the stack are B [A --).",
        "a ], then we may replace the item by an item of the form [C 4 p A .",
        "fi], provided C L* B and p ---).",
        "* c.",
        "These clauses now allow for nonfalse members at the beginning of right sides.",
        "To allow for other non false members we need an extra seventh clause: 4 7.",
        "If the element on top of the stack is the item [A > a B [3], then we may replace this item by the item [A --+ a B .",
        "fi], provided B --,.",
        "* c. The same idea can be used in a straightforward way to make generalized LC parsing suitable for 4Actually, an eighth clause is necessary to handle the special case where S, the start symbol, is nonfalse, and the input is empty.",
        "We omit this clause for the sake of clarity.",
        "for i 0 to n do PARSE_WORD return r, as the root of the parse forest PARSE_WORD: r next 0 'next for all pairs (g, A) E F do",
        "FIND_CORNERS (t):/* cf.",
        "Clause la of the nondeterministic LC parser */ for all goal elements g in F containing goals in class [B] do ofor all rules Aai a such that A E [B] do if A L* P for some goal P in g/* top-down filtering */",
        "hidden left-recursive grammars, similar to the way this is handled in [Schabes, 1991] and [Leermakers, 1992].",
        "The only technical problem is that, in order to be able to construct a complete parse forest, we need precomputed subforests which derive the empty string in every way from nonfalse nonterminals.",
        "This precomputation consists of performing mA MAKE_NODE (A) for each nonfalse nonterminal A, (where mA are specific variables, one for each nonterminal A) and subsequently performing ADD_SUBNODE (mA , <me, , , me, >) for each rule A B1 Bk consisting only of nonfalse non terminals.",
        "The variables TnA now contain pointers to the required subforests.",
        "GLC parsing is guaranteed to terminate also for cyclic grammars, in which case the infinite amount of parses is reflected by cyclic forests, which are also discussed in [Nozohoor-Farshi, 19911."
      ]
    },
    {
      "heading": "5 Parsing in cubic time",
      "text": [
        "The size of parse forests, even of those which are optimally dense, can be more than cubic in the length of the input.",
        "More precisely, the number of nodes in a parse forest is 0(nP+1), where p is the length of the right side of the longest rule.",
        "Using the normal representation of parse forests does therefore not allow cubic parsing algorithms for arbitrary grammars.",
        "There is however a kind of shorthand for parse forests which allows a representation which only requires cubic space.",
        "For example, suppose that of some rule A a /3, the prefix a of the right side derives the same part of the input in more than one way, then these derivations may be combined in a new kind of packed node.",
        "Instead of the multiple derivations from a, this packed node is then combined with the derivations from # deriving subsequent input.",
        "We call packing of derivations from prefixes of right sides subpacking to distinguish this from normal packing of derivations from one nonterminal.",
        "Subpacking has been discussed in [Billot and Lang, 1989; Leiss, 1990; Leermakers, 1991]; see also [Shell, 1976].",
        "Connected with cubic representation of parse forests is cubic parsing.",
        "The GLC parsing algorithm in Section 3 has a time complexity of 0(e+1).",
        "The algorithm can be easily changed so that, with a little amount of overhead, the time complexity is reduced to 0(n3), similar to the algorithms in [Perlin, 1991] and [Leermakers, 1992], and the algorithm produces parse forests with subpacking, which require only 0(n3) space for storage.",
        "We consider how this can be accomplished.",
        "First we define the underlying rule of an item element labelled with [A .",
        "to be the rule A #.",
        "Now suppose that two item elements ell and e12 with the same underlying rule, with the dot at the same position and with the same successor are created at the same input position, then we may perform subpacking for the prefix of the right side before the dot.",
        "From then on, we only need one of the item elements e/i and el2 for continuing the parsing process.",
        "Whether two item elements have one and the same goal element as successors cannot be efficiently veri311 fled.",
        "Therefore we propose to introduce a new kind of stack element which takes over the role of all former item elements whose successors are one and the same goal element and which have the same underlying rule.",
        "We leave the details to the imagination of the reader."
      ]
    },
    {
      "heading": "6 Optimization of top-down filtering",
      "text": [
        "One of the most time-costly activities of generalized LC parsing is the check whether for a goal element g and a nonterminal A there is some goal P in g such that A L* P. This check, which is sometimes called top-down filtering, occurs in the routines FIND_CORNERS and REDUCE.",
        "We propose some optimizations to reduce the number of goals P in g for which A L* P has to be checked.",
        "The most straightforward optimization consists of annotating every edge from an item element labelled with [A 4 a .",
        "fl] to a goal element g with the subset of goals in g which does not include those goals P for which A L* P has already been found to be false.",
        "This is the set of goals in g which are actually useful in top-down filtering when a new item element labelled with [B A .",
        "7] is created during a REDUCE (see the piece of code in REDUCE corresponding with Clause 3 of the nondeterministic LC parser).",
        "The idea is that if A L* P does not hold for goal P in g, then neither does B L* P if A L B.",
        "This optimization can be realized very easily if sets of goals are implemented as lists.",
        "A second optimization is useful if L is such that there are many nonterminals A such that there is only one B with A L B.",
        "In case we have such a non terminal A which is not a goal, then no top-down filtering needs to be performed when a new item element labelled with [B > A. a] is created during a REDUCE.",
        "This can be explained by the fact that if for some goal P we have A L* P, and if A 0 P, and if there is only one B such that A L B, then we already know that B L* P. There are many more of these optimizations but not all of these give better performance in all cases.",
        "It depends heavily on the properties of L whether the gain in time while performing the actual top down filtering (i.e. performing the tests A L* P for some P in a particular subset of the goals in a goal element g) outweighs the time needed to set up extra administration for the purpose of reducing those subsets of the goals."
      ]
    },
    {
      "heading": "7 Preliminary results",
      "text": [
        "Only recently the author has implemented a GLC parser.",
        "The algorithm as presented in this paper has been implemented almost literally, with the treatment of epsilon rules as suggested in Section 4.",
        "A small adaptation has been made to deal with terminals of different lengths.",
        "Also recently, some members of our department have completed the implementation of a GLR parser.",
        "Because both systems have been implemented using different programming languages, fair comparison of the two systems is difficult.",
        "Specific problems which occurred concerning the efficient calculation of LR tables and the correct treatment of epsilon rules for GLR parsing suggest that GLR parsing requires more effort to implement than GLC parsing.",
        "Preliminary tests show that the division of nonterminals into equivalence classes yields disappointing results.",
        "In all tested cases, one large class contained most of the nonterminals.",
        "The first optimization discussed in Section 6 proved to be very useful.",
        "The number of goals which had to be considered could in some cases be reduced to one fifth.",
        "Conclusions We have discussed a parsing algorithm for context free grammars called generalized LC parsing.",
        "This parsing algorithm has the following advantages over generalized LR parsing (in order of decreasing importance).",
        "The size of a parser is much smaller; if we neglect the storage of the relation L*, the size is even linear in the size of the grammar.",
        "Related to this, only a little amount of time is needed to generate a parser.",
        "The generated parse forests are as compact as possible.",
        "Cyclic and hidden left-recursive grammars can be handled more easily and more efficiently (Section 4).",
        "As Section 5 shows, GLC parsing can more easily be made to run in cubic time for arbitrary context-free grammars.",
        "Furthermore, this can be done without much loss of efficiency in practical cases.",
        "Because LR parsing is a more refined form of parsing than LC parsing, generalized LR parsing may at least for some grammars be more efficient than generalized LC parsing.5 However, we feel that this does not outweigh the disadvantages of the large sizes and generation times of LR parsers in general, which renders GLR parsing unfeasible in some natural language applications.",
        "GLC parsing does not suffer from these defects.",
        "We therefore propose this parsing algorithm as a reasonable alternative to GLR parsing.",
        "Because of the small generation time of GLC parsers, we expect this kind of parsing to be particularly appropriate during the development of grammars, when grammars 'The ratio between the time complexities of GLC parsing and GLR parsing is smaller than some constant, which is dependent on the grammar.",
        "change often and consequently new parsers have to be generated many times.",
        "As we have shown in this paper, the implementation of GLC parsing using a graph-structured stack allows many optimizations.",
        "These optimizations would be less straightforward and possibly less effective if a two-dimensional matrix was used for the implementation of the parse table.",
        "Furthermore, matrices require a large amount of space, especially for long input, causing overhead for initialization (at least if no optimizations are used).",
        "In contrast, the time and space requirements of GLC parsing using a graph-structured stack are only a negligible quantity above that of nondeterministic LC parsing if no nondeterminism occurs (e.g. if the grammar is LC(0)).",
        "Only in the worst-case does a graph-structured stack require the same amount of space as a matrix.",
        "In this paper we have not considered GLC parsing with more lookahead than one symbol for terminal left corners.",
        "The reason for this is that we feel that one of the main advantages of our parsing algorithm over GLR parsing is the small sizes of the parsers.",
        "Adding more lookahead requires larger tables and may therefore reduce the advantage of generalized LC parsing over its LR counterpart.",
        "On the other hand, the phenomenon reported in [Billot and Lang, 1989] and [Lankhorst, 1991] that the time complexity of GLR parsing sometimes worsens if more lookahead is used, does possibly not apply to GLC parsing.",
        "For GLR parsing, more lookahead may result in more LR states, which may result in less sharing of computation.",
        "For GLC parsing there is however no relation between the amount of lookahead and the amount of sharing of computation.",
        "Therefore, a judicious use of extra lookahead may on the whole be advantageous to the usefulness of GLC parsing."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "The author is greatly indebted to Klaas Sikkel, Janos Sarbo, Franc Grootjen, and Kees Koster, for many fruitful discussions.",
        "Valuable correspondence with Rene Leermakers, Jan Rekers, Masaru Tomita, and Dick Grune is gratefully acknowledged."
      ]
    }
  ]
}
