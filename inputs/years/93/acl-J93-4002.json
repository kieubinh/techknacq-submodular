{
  "info": {
    "authors": [
      "K. Vijay-Shanker",
      "David Weir"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J93-4002",
    "title": "Parsing Some Constrained Grammar Formalisms",
    "url": "https://aclweb.org/anthology/J93-4002",
    "year": 1993
  },
  "references": [
    "acl-E93-1045",
    "acl-P85-1011",
    "acl-P87-1012",
    "acl-P88-1031",
    "acl-P88-1034",
    "acl-P90-1001"
  ],
  "sections": [
    {
      "text": [
        "In this paper we present a scheme to extend a recognition algorithm for Context-Free Grammars (CFG) that can be used to derive polynomial-time recognition algorithms for a set of formalisms that generate a superset of languages generated by CFG.",
        "We describe the scheme by developing a Cocke-Kasami-Younger (CKY)-like pure bottom-up recognition algorithm for Linear Indexed Grammars and show how it can be adapted to give algorithms for Tree Adjoining Grammars and Combinatory Categorial Grammars.",
        "This is the only polynomial-time recognition algorithm for Combinatory Categorial Grammars that we are aware of.",
        "The main contribution of this paper is the general scheme we propose for parsing a variety of formalisms whose derivation process is controlled by an explicit or implicit stack.",
        "The ideas presented here can be suitably modified for other parsing styles or used in the generalized framework set out by Lang (1990)."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "This paper presents a scheme to extend known recognition algorithms for Context-Free Grammars (CFG) in order to obtain recognition algorithms for a class of grammatical formalisms that generate a strict superset of the set of languages generated by CFG.",
        "In particular, we use this scheme to give recognition algorithms for Linear Indexed Grammars (LIG), Tree Adjoining Grammars (TAG), and a version of Combinatory Categorial Grammars (CCG).",
        "These formalisms belong to the class of mildly context sensitive grammar formalisms identified by Joshi (1985) on the basis of some properties of their generative capacity.",
        "The parsing strategy that we propose can be applied to the formalisms listed as well as others that have similar characteristics (as outlined below) in their derivational process.",
        "Some of the main ideas underlying our scheme have been influenced by the observations that can be made about the constructions used in the proofs of the equivalence of these formalisms and Head Grammars (HG) (Vijay-Shanker 1987; Weir 1988; Vijay-Shanker and Weir 1993).",
        "There are similarities between the TAG and HG derivation processes and that of Context-Free Grammars (CFG).",
        "This is reflected in common features of the parsing algorithms for HG (Pollard 1984) and TAG (Vijay-Shanker and Joshi 1985) and the CKY algorithm for CFG (Kasami 1965; Younger 1967).",
        "In particular, what can happen at each step in a derivation can depend only on which of a finite set of \"states\" the derivation is in (for CFG these states can be considered to be the nonterminal symbols).",
        "This property, which we refer to as the context-freeness property, is important because it allows one to keep only a limited amount of context during the recognition process,",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms Definition 2.1 A LIG, G, is denoted by (VN , VT V1, S, P) where VN is a finite set of nonterminals, VT is a finite set of terminals, VI is a finite set of indices (stack symbols), S E VN is the start symbol, and P is a finite set of productions.",
        "We adopt the convention that a, 0 (with or without subscripts and primes) denote members of 1/7, and 7 denotes a stack symbol.",
        "As usual, A,B,C will denote nonterminals, a, b, c will denote terminals, and u, v, w will denote members of V. Definition 2.2 A pair consisting of a nonterminal, say A, and a string of stack symbols, say a, will be called an object of the grammar and will be written as A (a).",
        "Given a grammar, G, we define the set of objects lic(G) = {A (a) I A E VN, a E 177 }.",
        "We use T to denote strings in (lic(G)UVT)*.",
        "We write A(.. a) to denote the non terminal A associated with an arbitrary stack a with the string on top.",
        "Also, we use A ( ) to denote that an empty stack is associated with A.",
        "The general form of a production in a LIG is: (.. a)w1A1 (ai)w2Ai_i (ai_i) wA ( ai) wi+1A+1 (ai+i) ... An (a)w+1 for n > 0 and w1 , Wn+1 are members of V. Definition 2.3 The derivation relation, >, is defined below.",
        "If the above production is used then for",
        "... An (an) wn-01'2.",
        "We use *> as the reflexive, transitive closure of .",
        "As a result of the linearity in the general form of the rules, we can observe that the stack Oa associated with the object in the left-hand side of the derivation and Oa, associated with one object in the right-hand side have the initial part 0 in common.",
        "In the derivation above, we will say that this object A (Oat) is the distinguished child of A (Oa).",
        "Given a derivation, the distinguished descendant relation is the reflexive, transitive closure of the distinguished child relation.",
        "The language generated by a LIG, G,L(G)= {w So -*G> w}.",
        "A derivation tree for the string abbcabb is given in Figure 1.",
        "Derivation tree for LIG.",
        "In this paper rather than adopting the general form of rules as given above, we restrict our attention to grammars whose rules have the following form.",
        "In fact, this can be easily seen to constitute a normal form for LIG.",
        "1.",
        "A(c) > 6 where 6 E VT U {} and length of a, len (a) > 1.",
        "2.",
        "A ( 7m) 4 Ap ( 1/13) As (as) where m > O.",
        "3.",
        "A (-- 7m)A, (as) Ap ( 'yp) where m > O.",
        "4.",
        "A ( .",
        ".",
        "-yrn)Ap ( 7p) where m > O.",
        "We allow at most two symbols in the right-hand side of productions because we intend to develop CKY-style algorithms.",
        "In the above rules we say that Ap ( -yp) is the primary constituent and A, (as) is the secondary constituent.",
        "Notice also that in a derivation using such a rule, the primary constituent yields the distinguished child.",
        "(In grammatical theories that use a stack of subcategorized arguments, the top of the stack in the primary constituent determines which secondary constituent it can combine with.)"
      ]
    },
    {
      "heading": "2.1 Terminators",
      "text": [
        "Let us consider how we may extend the CKY algorithm for the recognition of LIG.",
        "Given a fixed grammar G and an input al .",
        ".",
        ".",
        "an, the recognition algorithm will complete an n x n array P such that an encoding of A (a) is stored in P [i , d] if and only if A (a) *> a,.The algorithm will operate bottom-up.",
        "For example, if G contains the rule A ( 7m)Ap ( 'Tp) A, (a,) and we find an encoding of Ap (ap-yp) in P [i, dp] and an encoding of A, (a,) in P [i + dp, dd then an encoding of A (ap7i -Y.)",
        "will be stored",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms in P [i, dp + .",
        "What encoding scheme should be used?",
        "The most straightforward possibility would be to store a complete encoding of A (ap7i in P [i, cip + d3].",
        "However, in general, if an object A (a) derives a string of length d then the length of a is 0(d).3 Hence there can be 0(kd) objects that derive a substring of the input (of length d), for some constant k. Hence, the space and time complexity of this algorithm is exponential in the worst case.'",
        "The inefficiency of this approach can be seen by drawing an analogy with the following algorithm for CFG.",
        "Suppose rather than storing sets of nonterminals in each array entry, we store a set of trees containing all derivation subtrees that yield the corresponding substring.",
        "The problem with this is that the number of derivation trees is exponential with respect to the length of the string spanned.",
        "However, there is no need to store derivation trees since in considering the combination of subderivation trees in the CFG, only the nonterminals at the root of the tree are relevant in determining whether there is a production that licenses the combination.",
        "Likewise because of the last-in first-out behavior in the manipulation of stacks in LIG, we will argue that it is not necessary to store the entire stack.",
        "For instance, consider the derivation (depicted by the tree shown in Figure 2) from the point of view of recording the derivation in a bottom-up parser (such as CKY).",
        "Let a node ni labeled B Uhl .",
        ".",
        ".",
        "7k.",
        "7,) be a distinguished descendant of a node n labeled A (0-yi -yk) as shown in the figure.",
        "Viewing the tree bottom-up, let the node n, labeled A (07i ... 7k), be the first node above the node ?A, labeled B (071 'y.",
        "where 7k gets exposed as the top of the stack.",
        "Because of the last-in first-out behavior, every distinguished descendant of n above m will have a label of the form A' (071 -yka) where len (a) > 1.",
        "In order to record the derivation from A (I371 ... 7k) it would be sufficient to store A and .",
        "-yk if we could also access the entry that records the derivation from At (0- y t).",
        "In the entry for 7), using a pointer to the entry for At (07t) would enable the recovery of the stack below the top k symbols, 7i However, this scheme works well only when k > 2.",
        "For instance, when k = 1, suppose we recorded only A,71, and a pointer to entry for At (0- yt).",
        "Suppose that we are looking for the symbol below 71, i.e., the top of 3.",
        "Then it is possible that in a similar way the latter entry could also record just At, 7t, and a pointer to some other entry to retrieve 0.",
        "This situation can occur arbitrarily many times.",
        "Consider the derivation depicted in Figure 3.",
        "In this derivation we have indicated the branch containing only the distinguished descendants.",
        "We will assume that the node labeled D (1371 .. 7k-i7i '7,11' is the closest distinguished descendant of C (1371 ... 7k-17) such that every node between them will have a label of the form C' (0-yial where len (al > 1.",
        "Therefore, any node between that labeled C (O'Yi 7k_0) and B (13-yi .",
        ".",
        ".",
        "-ym) will have a label of the form C\" (07i-yk_la\") where len (a\") > 1.",
        "Now the entries representing derivations from both A(/371 ... 71<-17k) and C 071 ... 7k_170 could point back to the entry for the derivation from At (Mit), whereas the entry for C' (1371 7k1-1 a') will point back to the entry for A (071 N-17k) We shall now formalize these notions by defining a terminator.",
        "3 For instance, consider the grammar in Example 2.1 and the derivation in Figure 1.",
        "In general we can have derivations of the form T (7.-1) *cab\".",
        "However, if there exists productions of the form",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms Definition 2.4 Suppose that we have the derivation tree in Figure 4 that depicts the following derivation: A (0-yi .7k-17) *>.",
        "uB (0717k-17k 7m) w uAt 0370 As (as) w > uvw or similarly: A (071 7k-17)*> uB (1371 .7k-i7t -Ym) w uAs (as) At (0-Yt)w where the following conditions hold"
      ]
    },
    {
      "heading": "2 < k <",
      "text": [
        "The nodes labeled B (0-y .",
        ".",
        ".",
        "7k-17k .",
        "7.)",
        "and At (070 are distinguished descendants of the node labeled A (0-yi ...7k_iy) in the respective trees.",
        "For any distinguished descendent labeled C (a') between the nodes labeled A (071 .. .",
        "-yk_i-y) and B 7k-17k -Ym), cei is of the form /371 .. -yka where ten (a) > 1.",
        "Note that the nodes labeled A (071'-yk_17) and B (MI 'Tk-17k -ym) need not be different.",
        "The node labeled At (0-yt) is the k-terminator of the node labeled A (0-Y1 -Yk-i-Y) When it is clear from context, rather than saying that a node is a terminator of another we will assume that terminators have been defined on objects that participate in a derivation as well.",
        "For instance, in the above derivations, we will say that At (070 is the k-terminator of A (071 -yk_o).",
        "Also when the derivation is clear from context, we will omit the mention of the derivation (or derivation tree).",
        "Additionally, we will say that a node (object) has a terminator, if it has a k-terminator for some k. We will now state some properties of terminators that influence the design of our recognition algorithm.",
        "Definition 2.5 Given a grammar, G, define MCL(G) (Maximum Change in Length) as: MCL(G) = max { m A ( Yi -Ym)TiAp ( -yp) T2 is a production of G Henceforth, we will write MCL since the grammar in question will always be known from context.",
        "Observation 2.1 In a derivation tree, if a node (sayhas a k-terminator (say nt) then it is a distinguished descendant of ?I.",
        "If the node n is labeled A (i3a) (where ten (a) = k) then the node nt must be labeled At (f37t) for some At E VN and -yt E Vt.",
        "Furthermore, 2 <k < MCL.",
        "Observation 2.2 In a derivation tree, if a node has a k-terminator then it has a unique terminator.",
        "Computational LinguisticsVolume 19, Number 4 If ti is the node in question then we are claiming here that not only does it have a unique k-terminator but also that there does not exist k' with k' k such that n has a k'-terminator.",
        "To see why this is the case, let some node 77 have a k-terminator (for some k), say Tit.",
        "Using Observation 2.1 we can assume that they are labeled A (8 v-/Yi 7k-i-Y) and At (0-0, respectively, where we have (k -1) > 1.",
        "From the definition of terminators we can assume that the parent of the terminator, Tit, is a node (say 71') that has a label of the form B (071 ..-ym).",
        "Since (from the definition of terminators) every node between n and 7/' (inclusive) must have a label of the form C (0-yi 7k-i a') where len (a') > 1, it immediately follows that nt is the closest distinguished descendant of 71 such that the length of the stack in the object labeling nt is strictly less than the length of the stack in the object labeling i.",
        "From this, the uniqueness of terminators follows.",
        "Observation 2.3 Consider the derivation A (0'-yi uAt (0'Yt)w uvw where At (13-yt) is the k-terminator of A (071-yk_i-y).",
        "Then for any /3' and v', if At (0'7t) *> v' then we have the derivation A (.13/71 ..",
        ".",
        "*> uAt (13''yt) w *> uv'w where At (0'70 is the k-terminator of A (13' This follows from the fact that the derivation of uAt (0-'t) w from A ( is independent of 0.",
        "Therefore we can replace At (0-Y t) *v by At (0'7) *> v'.",
        "This is a very important property that is crucial for obtaining polynomial-time algorithm.",
        "Note that not all nodes have terminators.",
        "For example, if a node labeled A (a) is the parent of a node labeled a (i.e., corresponding to the use of the production A (a) a where a is a terminal symbol) then obviously this node does not have a terminator.",
        "Definition 2.6 Given a grammar, G, we define MTL(G) (Maximum Length in, Terminal production) as: MTL(G) = max { len (a) I A (a) -> E is a production of G where e c VT U{E} As in the case of MCL, we will use MTL rather than MTL(G).",
        "Observation 2.4 In the derivation A (a) *> w if len (a) > MTL then A (a) has a terminator.",
        "There must be at least two steps in the above derivation since len (a) > MTL.",
        "However, we can assume that the node (say 7)) in question labeled by the object A (a) has a distinguished descendant, say 771, with label B (0) such that B (0) > Therefore, len (0) < MTL and we may rewrite w as uev.",
        "Since len (a) > len (0) we can find the closest distinguished descendant of n labeled C (a') for some C, a' such that len (a') < len (a).",
        "That node is the terminator of n from the arguments made in Observation 2.2.",
        "The above observations will be used in the following sections to explain the way in which we represent derivations in the parsing table.",
        "We conclude this section with an observation that has a bearing on the steps of the recognition algorithm.",
        "where Ap (071 .",
        ".",
        ".",
        "7k-17k) is the distinguished child of A (07i ...NA and At (Mit) is the k-terminator of Ap (07i .",
        "7k-i-Yk) At (07t) is the (k - *terminator of A (071 -yk_i) if and only if k > 2.",
        "If k = 2 then A (/371) has a terminator if and only if At (0-yt) does.",
        "In fact, in this case, if At (070 has a k'-terminator then that terminator is also the k'-terminator of A (137t).",
        "This can be seen by considering the derivation shown in Figure 3 and noting the sharing of the terminator of C (071 ... -yk_i-yn and A (/371 .",
        "N-17k)"
      ]
    },
    {
      "heading": "3. Recognition Algorithms",
      "text": [
        "As in the CKY algorithm we will use a two-dimensional array, P, such that if A (a) *> a, .",
        ".",
        "a,+d_i then a representation of this derivation will be recorded with an encoding of A (a) in P [i, d].",
        "Here we assume that the given input is a1 ... an.",
        "We start our discussion by considering the data structures we use to record such objects and derivations from them."
      ]
    },
    {
      "heading": "3.1 Anatomy of an Entry",
      "text": [
        "We mentioned earlier that the stack in an object can be unboundedly large.",
        "We must first find a compact way to store encodings of such objects whose size is not bounded by the grammar.",
        "In this section we provide some motivation for the encoding scheme used in the recognition algorithm by considering the bottom-up application of the rule and the encoding of the primary constituent: A(7i... 7m)Ap (.. 7p) As (as) The Head.",
        "An object with nonterminal Ap and top of stack 7p will match the primary category of this rule.",
        "Thus, the first requirement is that at least this much of the object must be included in every entry since it is needed to determine if the rule can apply.",
        "This component is denoted (Ap, 7p) and called the head of the entry.",
        "Thus, in general, an entry in P [i , di with the head (A, 7) encodes derivations of a.",
        ".a,+d_i from an object of the form A (0-y) for some EV.",
        "Terminator-pointer.",
        "An encoding of the object Ap (07p) (the primary constituent) that derives the substring a,.",
        ".a,+dp_i (of the input string ch ... an) will be stored in the array element P [i, dp] in our CKY-style recognition algorithms.",
        "Now consider the encoding of Ap (13-yp) for some sufficiently long 07p.",
        "While the head, (AI, 7p), of the entry is sufficient to determine whether the object in question can match the primary category of the rule, we will need to store more information in order that we can determine the content of the rest of the stack.",
        "In the above production, if m 0 then the combination of Ap (137p) and A, (a,) results in A (0).",
        "In order to record the derivation from A (0), we need to know the top symbol in the stack 0, i.e., the symbol below the top of the stack associated with the primary constituent.",
        "We need to recover the identity of",
        "Computational LinguisticsVolume 19, Number 4 this symbol from the encoding of the primary category.",
        "This is why we introduced the notion of terminators.",
        "As mentioned in Section 2.1, terminators can be used to access information about the rest of the stack.",
        "In the encoding of Ap (07), we will store information that allows us to access the encoding of its terminator.",
        "The part of the entry encoding the terminator will be called terminator pointer.",
        "The Middle.",
        "Note that the object Ap (0-yp) (in the derivation Ap (07p) * a,.",
        "aidp_i) can have a k-terminator where k is between 2 and MCL.",
        "Therefore, from Observation 2.1 it follows that the terminator-pointer can only be used to determine the (k+1)St symbol from the top.",
        "Therefore, assuming that = 0'71 7k-1, the terminator-pointer will allow us to access (Recall from the definition, a k-terminator of A (0'71 Nl'Yp) will have the form At (0'-y).",
        "Thus the (k + 1)3t symbol from the top in A (13-yp) is the same as the symbol below the top of the stack of the terminator.)",
        "Thus, we will need to record the string in the encoding of Ap (/(3'-yi -yk-cyp) as well.",
        "This part of the entry will be called the middle.",
        "To summarize, the entry stored in P [i, dp] (where ,13/-yi ...-yk_17p is assumed to be sufficiently long that we know Ap ...-yk_i-yp) is guaranteed to have a terminator) will have a head, (Ap, -yp); and a tail comprised of a middle, yi '-yk_i; and a terminator-pointer.",
        "Note that the length of the middle must be at least one, but at most MCL - 1, since from Observation 2.1, we know 2 < k < MCL.",
        "We will call an entry of this kind a terminator-type entry.",
        "We will now discuss what we need to store in order to point to the terminator.",
        "Suppose we would like to record in P [i, d] the derivation of a, .",
        "from A (1371 ryk_l-y) as shown below.",
        "We assume that At (0-n) is the terminator in this derivation.",
        "A (0-yi .. -rk-i-y)a1.",
        ".",
        ".",
        "at_iAt (137t)at+d, ai+d-1 a,at_iat .",
        "at+dt-iat+d, al+di a. .",
        "ai+di From Observation 2.3, it follows that it would be sufficient to use ((At, -Yt) [t, di]) as the terminator-pointer.",
        "This is because any entry with the head (At, 7t) in P [t, dt] will represent in general a derivation At (0'70 >- a. at+c11-1.",
        "This not only matches the above case, but even if /3' 0, from the Observation 2.1, we have A (13'.",
        "7k-0) > Cli at -iAt (017t) at-l-dt > ai ai+dl Thus, the use of the head information (plus the two indices) in the terminator-pointer captures the essence of Observation 2.3.",
        "It is this structure-sharing that allows us to achieve polynomial bounds for space and time.",
        "Note that the string derived from the terminator, at .",
        ".",
        "atfiti, is a substring of a,.",
        "aid_i.",
        "In such a case, i.e., when < t and i + t > t + dt, we will say that (t, d) < (i, d).",
        "We define (t, d) < (i, d) if (t, d) < (i, d) and (t, d) (i, d).",
        "Since any terminator-type entry in P [i, d] can only have terminator-pointers of the form ((At, 7t) [t, di]) where (t, c11) < (i, d), the number of terminator-type entries in P [i, el] is 0(d2).",
        "Definition 3.1 Given a grammar, G, define MSL(G) (Maximum Secondary constituent's stack Length) as MSL(G) =-.",
        "max {len (as) As (as) is the secondary constituent of a production Henceforth we will use MSL rather than MSL(G).",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms We now consider the question of when a terminator-type entry is appropriate.",
        "Of course, if A (a) - > a, .",
        ".",
        "aid_i we could store such an entry in P [i, dp] only when A (a) has a terminator in this derivation.",
        "From Observation 2.4 we know that if len (a) > MTL then there exists a terminator of A (a) in this derivation.",
        "However, it is possible that for some grammar MSL > MTL.",
        "Therefore even when len (a) > MTL (i.e., the object has a terminator) A (a) can still match the secondary category of a rule if len (a) < MSL.",
        "In order to verify that an object matches the secondary category of a rule we need to consider the entire stack in the object.",
        "When A (a) '> a,.",
        "ai+d_i and length of a does not exceed MSL, it would be convenient to store A as well as the entire stack a because such an object can potentially match a secondary category of a rule.",
        "To be certain that such an object is stored in its entirety when len (a) < MSL, the terminator-type entry can only be used when len (a) > max(MSL, MTL).",
        "However, we prefer to use the terminator-type entry for representing a derivation from A (a) only when its terminator, say At (0), is such that len (0) > max(MSL, MTL) rather than when len (a) > max(MSL, MTL).",
        "Again, we point out that this choice is made only for convenience and because we feel it leads to a simpler algorithm.",
        "The alternate choice could also be made, which would lead to a slightly different algorithm.",
        "Definition 3.2 Define the constant TTC (Terminal-Type Case) as TTC max(MSL, MTL).",
        "In a derivation A (071 7k) *> w we will say that A (071 7k) has the TC-property iff it has a k-terminator, say At (07t), such that len (07t) > TTC.",
        "If A (0-Yi 7k) > a1.",
        "a,d_i, where A (0-yi 7k) does not have the TC-property then we record the object in its entirety in P [i, d].",
        "In order for such an entry to have the same format as the terminator-type entry, we say that the entry has a head (A, 7k); a tail with a middle 71 ryk_i and a nil terminator-pointer.",
        "Note that in this case the middle can be an empty string; for instance, when we encode A (7) '> at .",
        ".",
        "a,+d_i.",
        "In general, if a = )37 then we say top (a) ='y and rest (a) -= 0.",
        "If a = c then we say that top (a) = rest (a) E. To summarize, the structure of an entry in P [i, d] is described by the following rules.",
        "An entry consists of a head and a tail.",
        "A head consists of a nonterminal and a stack symbol.",
        "A tail consists of a middle and a terminator-pointer.",
        "The exact nature of the middle and the terminator-pointer are as given below.",
        "-The terminator-pointer may be of the form ((At, -Yt) [t, di]) where At E VN,-Yt E V1 and (t, d) < (i, d).",
        "In this case, the middle is a string of stack symbols of length at least one.",
        "This form of a terminator pointer is used in the encoding of a derivation from an object if its terminator has a stack length greater than or equal to TTC.",
        "Recall that we had called this type of an entry a terminator-type entry.",
        "-A terminator-pointer can be a nil.",
        "Then the middle is a (possibly empty) string of stack symbols.",
        "However, the length of the middle is less than TTC MCL I.",
        "This form of a terminator pointer is used in the encoding of a derivation from an object if it does not satisfy the TC-property; i.e., either it has no",
        "Computational LinguisticsVolume 19, Number 4 terminator or if the terminator exists then its stack length is less than TTC."
      ]
    },
    {
      "heading": "3.2 Recognition Algorithms for LIG",
      "text": [
        "Since the full algorithm involves a number of cases, we develop it in stages by restricting the forms of productions.",
        "The first algorithm that considers the most restricted form of productions introduces much of what lies at the core of our approach.",
        "Next we relax these restrictions to some degree.",
        "After giving the algorithm at this stage, we switch to discuss how this algorithm can be adapted to yield one for CCG.",
        "Later, in Section 5, we consider further relaxation of the restrictions on the form of LIG productions, which can help us produce an algorithm for TAG.",
        "Regardless of which set of restrictions we consider, in every algorithm we shall establish that the following proposition holds.",
        "Proposition 3.1 ((A, 'Yk) ell 7k-1, ((Ah -Yt) [l, di]))) E P [i , cl] if and only if for some E 17/, A (Mil7k-17k) > a. at --iA (0-Yr) ar+d, _1 ai+d 1 where At (Mit) is the k-terminator of A (i*71 7k) and /en (070 > TTC.",
        "((A, 71c) (71 7k-1 7 nil)) E P [i, di if and only if a d_i A (71 7k-17k) a, .",
        ".",
        ".",
        "* where in this derivation A (71 .",
        ".",
        ".",
        "'yk_i-yk) does not have the TC-property.",
        "3.2.1 Algorithm 1.",
        "Recall that the general form of rules that are to be considered are as follows.",
        "1.",
        "A (a)E where E e {E} U VT, and len (a) > 1.",
        "2.",
        "A (.. 7m) > Ap (.. 70 As (as)",
        "At this stage we assume that the following restrictions hold of the above rules.",
        "In the first type of production we assume that E E VT and len (cx) > 1.",
        "Thus MTL > 1. len (as) > 1 in productions of type 2 and type 3, i.e., MSL > 1.",
        "There are no productions of type 4.",
        "We will now give the following rules that specify how entries get added in the parsing array.",
        "The control structure of the algorithm (a CKY-style dynamic programming structure) will be added later.",
        "We assume that the input given is al .",
        "an, where n > 1.",
        "Here productions of type 2 and type 3 will be considered.",
        "Let us assume the presence of the following production in the grammar: A (.",
        "71 7m)Ap (.",
        "7p) As (a5).5 Suppose that while considering which entries are to be included in P [i, d] we find the following for some dp, d, such that dp + ds = d. The entry ((A, y) (Op, tpp)) E P [i, dp] .",
        "This is consistent with the rule's primary constituent.",
        "Regardless of whether tp = nil or not, for some 13 EAp (013p-yp) > a. a,+dp_i.",
        "That is, when tpp = nil we have = E. The entry ((A5, top (as)) (rest (as), nil)) E p [i dp, cid .",
        "This is consistent with the rule's secondary object.",
        "Thus if d = dp + ds we may assume (cEs) aidp ai+d-1.",
        "From the presence of the two entries specified above (and the derivations they represent) we have A (0 .",
        ".",
        ".",
        "-ym) > Ap (0 Op-yp) As (as) a1.",
        "This derivation must be recorded with an entry in P [i , d] .",
        "The content of the entry depends on several factors: the value of m; whether or not the terminator-pointer in the entry for the primary constituent (i.e., tpp) is nil; and the length of the middle in this entry (i.e., Op ) These determine whether or not the new entry will be a terminator-type entry.",
        "We have cases for m = 0, m 1 and m > 2.",
        "CASE WHEN m =0 The new object to be stored is A (i3N).",
        "The top of the stack in this object can be obtained from the stack associated with the primary constituent.",
        "How this is done depends on whether the entry encoding the primary constituent is of terminator type or not.",
        "When m = 0 and tpp -=- nil This means that the primary constituent has been represented in its entirety; i.e., the primary constituent is Ap (/3lap).",
        "Since tpp = nil the primary constituent does not satisfy the IC-property (i.e., it does not have a terminator with a stack of length greater than or equal to TTC), the new constituent too cannot be encoded using a terminator-type entry.",
        "Therefore,",
        "Computational LinguisticsVolume 19, Number 4 The following rule is the counterpart of Rule2.ps.0 that corresponds to the use of the production A (.",
        ")A, (as) Ap (' 719) Rule 2.sp.L , top (as)) (rest (as), nil)) E P [i, ds]((Ap,-yp) (Op , nil)) E P [i + ds, d - ds] (24, top (0p)) (rest (/3), nil)) c P [i, When m = 0 and tpp nil Let the entry for the primary constituent be (Op, 70 (3p, ((At, 7t) , [t, dt]))).",
        "Since the primary constituent is Ap (33p-y) we will assume that its terminator is At (137t) where len (13-yt) > TTC.",
        "Note also that len (Op-yp) > 2.",
        "The entry for the new object (A (3,3)) is determined based on whether len (13p) = 1 or len (Op) > I.",
        "In the latter case the len (3p7) terminator of the primary constituent is the len (3)-terminator of the new object.",
        "This is not so in the former case, as noted in Observation 2.5.",
        "Considering the latter case first, i.e., len (Op) > 1, we may write 3p as 71 ...N-yyk where k > 2.",
        "Since in this case the new object and the primary constituent have the same terminator and since the primary constituent has the TC-property (tpp nil), the new object must also be encoded with a terminator-type entry.",
        "Thus we have the following rule: Rule 3.ps.L (Op, 'TO.. .7ktp)) Ed,,] tpp = ((At, 7 t) , [t, di]) , k > 2((As, top (as)) (rest (as), nil)) c P [i + d,,, d - dp] ((A, 7k) (71 7k-i, tpp)) Ed] Henceforth we shall give the ps versions of the rules only and omit sp versions.",
        "Now let us consider the case when len (i3p) = I. Rewriting Op as 71, the entries represent derivation for f3 EVf (len (0-Y1) = len (0-'t) > TTC).",
        "If the primary constituent is Ap (0 Op-yp) then the new constituent is A (1313p-yy .",
        ".",
        ".",
        "-yni).",
        "In fact, in this case, we have the primary constituent being the m-terminator of A (01,71 -ym) .",
        "Of course, this does not mean that the derivation from the new object should be recorded with the use of a terminator-type entry.",
        "We use the terminator-type entry only when len (3T-y,,) > TTC.",
        "In order to determine the length of this stack we have to use the entry for the primary constituent (i.e., ((Ap, 7p) (Op, tpp)) E P[i,dp]) and consider whether this is a terminator-type entry or not (i.e., whether tpp = nil or not).",
        "In the discussions that follow, we find it convenient to refer to the entries mentioned in the above rules as either antecedent entries (or entries that appear in the antecedent) of a rule or consequent entry (or entry that appears in the consequent) of a rule.",
        "For example, ((Ap, ')/p) (/3p, nil)) in P [i, dp] and ((As, top (as)) (rest (as), nil)) in P [i + dp, d - dp] are the antecedent entries of Rule 10.ps.L and ((A, -y,) (-yi .",
        ".",
        ".",
        "-yip-1 , (Op, -yp) , [i, dp] ))) that is added to P [i, d] is the entry in the consequent of Rule 10.ps.L."
      ]
    },
    {
      "heading": "3.3 The Control Structure",
      "text": [
        "We will start by giving a simple control structure for the recognition algorithm that follows the dynamic programming style used in the CKY algorithm.",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms In this section we modify the notation for entries slightly.",
        "In the above discussion, the terminator-pointer of a terminator-type entry contains a pair of indices representing input positions.",
        "Thus, in effect, P is a four-dimensional array.",
        "As an alternative to saying that ((A, 7) 03, ((A', , [t, 4))) is in P [i, d] we will sometimes say ((A, '-y) (0, (A' , 'y'))) is in P [i, d] [t , dt] .",
        "Also as an alternative to saying ((A, a) (13, nil)) is in P [i, d] we will sometimes say ((A, a) (0, nil)) is in P [i, d] [0, 0] .",
        "Thus P can be considered to be an array of size nxnx (n + 1) x (n + 1).",
        "In the specification of the algorithm (Figure 5) we will not restate all the rules we discussed in the previous section.",
        "Instead we will only indicate where in the control structure each rule fits.",
        "As an example, when we state \"Use Rule 2.ps.L with dp d\" within the i, d, and d' loops we mean the following: for current values of i, d, and d' (and hence dp, ds) consider every production of the form A (.",
        "71 7m) > Ap 70 As (as) with m = 0.",
        "For each such production, look for entries of the form ((ilp, -yp) (Op nil)) E P [i , dp] [0,0] for some Op and ((As, top (os)) (rest (as), nil)) E P [i + dp, d dp] [0, 0] .",
        "In the event we find such entries, we add ((21, top (13p)) (rest (/3p), nil)) to P [i, [0,0] if it is not already there.",
        "Since the entries in P [i, d] have the form ((A, -y) (0, ((At, 7t) , [t, dt] ) ) ) (where (t, d) < (i, d)) or the form ((A, -y) (0, nil)), there are 0(d2) many entries in P [i, d] (where 1 < i < n and 1 < d < n d).",
        "Thus space complexity of this algorithm is 0(n4).",
        "Note that within the body within the r loop will be attempted for all possible values of i, d, d', t, dt, r, dr.",
        "Since the range of each loop is 0(n), the time complexity is 0(n7).",
        "The asymptotic complexity of the above algorithm can be improved to 0(n6) with a simple rearrangement of the control structure.",
        "The key point here is that the steps involving the use of rules 5.ps.L and 5.sp.L can be split into two parts each.",
        "Consider, for example, the use of the Rule 5.ps.L, which is repeated below.",
        "((A, y1) (0 t , ((Ar, yr) , [r, dr]))) e P This rule corresponds to the use of the production A ( ) > Ap (- -yp) A (c).",
        "The values of i, d, d', t, dt are necessary to determine the span of the substrings derived from the primary constituent and the secondary constituent, and the values of i, d, t, dt, r, dr are needed to locate the entry for the terminator, i.e., ((At, -Yr) (i3t, ((Ar, 7r) , [r, dr]))) and to place the new entry in the appropriate parsing table element.",
        "That is, the values of r and dr are not required for the first part and the value of d' need not be known for the second part.",
        "This indicates that the second part need not be done within the loop for d'.",
        "Therefore, we can modify the control structure in the following way.",
        "Within the t loop (which appears within the loops for d, d' , dt) we find the entries for the primary and secondary constituents.",
        "Having found the two relevant entries, we must record the head of the new entry A,0p) and the terminator-pointer of the primary constituent, i.e., ((At, -yt) , [t, dt]).",
        "We can do this by using a two-dimensional array called TEMP where we store (A, 71, Ar, 7r).",
        "Outside the d' loop (and hence outside the loops for t and dt as well), but within the loops for i and d, we can have the loops that vary t, dt, r, dr (note (r, dr) < (t, dt)) in order to locate the entry for the terminator by using the information recorded in TEMP.",
        "Finally, having found the entry for the",
        "for d := 2 to n do % d loop for i := 1 to n d + 1 do % i loop begin for d' := 1 to d I do % d' loop begin Use Rule 2.ps.L, 6.ps.L, 9.ps.L, 10.ps.L with dp = d'.",
        "for dt := (d' 1) to 1 do % dt loop for t := i to (i + d' dr) do % t' loop begin Use Rule 3.ps.L, 4.ps.L, 7.ps.L, 8.ps.L with dp = d' for dr := dt to 1 do for r :-= t to t + dr dr do",
        "begin Use Rule 5.ps.L with dp = end % end of dr loop % end of r loop end % end of t loop % end of dr loop for dr := (d d' 1) to 1 do % dr loop for t := (i + d') to (i + d dt) do % t' loop begin Use Rule 3.ps.L, 4.ps.L, 7.ps.L, 8.ps.L with d, = for d, := dt 1 to 1 do for r := t to (t + dt dr) do begin Use Rule 5.sp.L with ds = d' end % end of r loop % end of dr loop end % end of t loop % end of dr loop end % end of d' loop end % end of i loop % end of d loop",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms terminator we then store the resulting entry in P [i, d].",
        "These steps are captured by the following rules.",
        "For a specific value of (i, d) we have",
        "Similarly, we assume we have the pair Rule 5.i.sp.L and Rule 5.ii.sp.L corresponding to Rule 5.sp.L.",
        "This leads to the algorithm given in Figure 6.",
        "In this algorithm we drop the sp rules and specify the ps rules only for the sake of simplicity.",
        "end % end of r loop % end of dr loop % end of dr loop % end of t loop end % end of i loop % end of d loop",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms Here x, y, zi ,,z are meta-variables and I 1,.., 17, E {\\, /}.",
        "For m0 these rules correspond to function application and for m > 0 to function composition.",
        "Note that the set R contains a finite subset of these possible forward and backward rules; i.e., for a given CCG only some of the combinatory rules will be available.",
        "Definition 4.3 In the forward and backward rules given above, we say that (x/y) (resp.",
        "(x\\y)) is the primary constituent of the forward (resp.",
        "backward) rules and (ylizi12 Imz,n) is the secondary constituent of the rule.",
        "The notion of a distinguished child is defined as in the case of LIG, i.e., a category is the distinguished child of its parent if it corresponds to the primary constituent of the rule used.",
        "As before, the distinguished descendant is the reflexive, transitive closure of the distinguished child relation.",
        "In discussing CCG we use the notational conventions that the variables I and c (when used with or without primes and subscripts) range over the forward and backward slashes and categories, respectively.",
        "We use x,y,z for meta-variables; a, f3 for strings of directional categories (i.e., a string of the form I c112lc n from some n > 0); and A, B, C for atomic categories (i.e., members of VN).",
        "Derivations in a CCG, G = (VT,VN, 5,f R), involve the use of the combinatory rules in R. Let be defined as follows, where Ti and T2 are strings of categories and terminal symbols.",
        "CCG example derivation tree.",
        "Definition 4.4 A is the minimally parenthesized form of A where A E VN.",
        "If, cn are the minimally parenthesized forms of categories el,, cn' respectively, then (Alici 12 Incn) is the minimally parenthesized form of ((.. (AlicD12.",
        "A category c is in minimally parenthesized form if c is the minimally parenthesized form of itself.",
        "Definition 4.5 Let a category c = Alici 2.. Incn be in minimally parenthesized such that n > 0, A e VN, and ci, , cn are minimally parenthesized categories.",
        "The target category of c = A11c112 Incn denoted by tar (c) is A.",
        "The arity of cA11c112 Incn, denoted as arity (c), is n. The argument categories of c = Alicil2 Inc,/ denoted by args(c)= {c1 II < i < n}."
      ]
    },
    {
      "heading": "4.1 CCG and LIG",
      "text": [
        "Before showing how the general parsing scheme illustrated by the LIG recognition algorithm can be instantiated as a recognition algorithm for CCG, we show that CCG and LIG are very closely related.",
        "The details of the examination of the relationship between CCG and LIG may be found in Weir and Joshi (1988) and Weir (1988).",
        "A minimally parenthesized category (Alici12 Incn) can be viewed as the atomic category, A, associated with a stack of directional argument categories, lic112 Incn The rule",
        "has as an instance (Apricii ...rncni As) (A511c112 Imcm)(Apricii -In' imcm) as well as (Apric'i l'nen/(AslY))(Asi'clicii2 Imc,n)(AprIellinc'nlici 12 .c.)",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms as an instance.",
        "Thus x matches the category (AprIciiy matches an atomic category A, in the first example and a nonatomic category (As I 'c') in the second, and each z, matches c, for 1 < i < m. A derivation involving the second instance (viewed bottom-up) can be seen as popping the top directional argument /(As l'c') from the primary category and pushing the m directional arguments I ci 12 ...1,ncm.",
        "Thus, each instance of the combinatory rule appears to closely resemble a LIG production.",
        "For example, in case of the second instance we have Ap (--11C112... mcm) >A (.. / (Asl'c')) As (I' ci.",
        "We now show that, like the set of stack symbols of a LIG, the set of directional argument categories that we need to be concerned with is finite.",
        "If we were to express a combinatory rule (x/y)(Y I 1 zi Inizm)(xlizi itnzm) in terms of LIG production A e. 7m)Ap7p) As (as) then we have the following correspondences: -yp with /y.",
        "'Yi with = liz or 1 < < m, i.e.,-ym with 11z1Imzm.",
        "A = AP' A, (as) with ylizi 17,,,zm.",
        "Given such a direct correspondence between combinatory rules and LIG productions, we will define the following constants to be used in the the CCG algorithm with minimal explanation.",
        "MTL is the maximum arity of a lexical category.",
        "Thus, MTL = max { arity (c) I c E f(a), a E VT}.",
        "MSL should be the maximum arity of a useful category that can match the secondary category of a rule.",
        "Note that a category matching (Ylizi 12 Inizm) will have an arity that is the sum of m and the arity of the category matching y.",
        "Furthermore, note that since y is an argument of the primary category it must be bound to a member of args (G).",
        "Thus, MSL = max { m (YliZ112is the secondary category of a rule in R + max { arity (c) I c E args (G)}.",
        "Note that in the case of CCG, MCL need not be defined independently of MSL.",
        "As before, we define TTC as TTC = max {MSL, MTL }.",
        "Since directional categories play the same role that stack symbols have in LIG, we revise the notions of length top () and rest () as follows.",
        "We say that the string of directional arguments categories lici2.",
        "Inc', has a length n, i.e., len (l1c1l2 'nen) n. Note that arity12 Incn))len (11c112 Incn) = n. We define top ((l1c1l2 Incn)) = Incn and rest ((lici12 Incti)) = 142 1n_icn_i.",
        "Additionally, top (6) = rest () = .",
        "any distinguished descendent between AO/cp and A01 ici lk-ick_i lc can be expressed in the form AM1c1 la where len (a) > 1 We say that AO/cp is the /en (lici ik-i ck-i1c) terminator of A/311c1 Note that cp need not be atomic.",
        "Hence if we write the secondary category as 'mem we are not necessarily expressing it in minimal parenthesis form.",
        "al .",
        "an), we will have an entry in P [i, cl] with a head (A, licj), where A E VN, E/1, and ci E args (G).",
        "First consider the case when a terminator-type entry is used.",
        "The terminator type entry is applicable when AOlici .. lk_ick_i lc has a k-terminator, say Af3Itct where len (01tct) > TTC.",
        "As before we say that in such a case AOlici ik-ick-i lc satisfies the TC-property.",
        "Assuming the terminator derives the substring a. .",
        ".",
        "at+di -1, we can use the terminator-pointer ((let), [t, dt] ) and a middlelk_ick_i.",
        "Notice that since the target of the category A1,311 cilc as well as the target of its terminator is A and since A is already noted in the head, it is not recorded in the terminator-pointer.",
        "For entries that are not terminator-pointer, the entire category is noted in the entry.",
        "Such an entry has the form ((A, lie!)",
        "_1 , nil)) assuming that j > I.",
        "However, it is possible that j =- 0.",
        "In this case the category being represented is A, and the entry will be written as ((A, c) (e, nil)) .",
        "In general, we use the non-terminatortype entry for recording a derivation from Aa when it has no terminator or when the terminator, say A(31/ct (rewriting a as Olici lk_ick_i lc) is such that len (Oltct) < TTC; i.e., when the category Aa does not satisfy the TC-property."
      ]
    },
    {
      "heading": "5. TAG Recognition",
      "text": [
        "We begin this section by first considering how to extend our algorithm for LIG to handle unary productions.",
        "This will be needed to show we can instantiate our scheme to give a recognition algorithm for TAG."
      ]
    },
    {
      "heading": "5.1 Handling Unary Productions and Epsilon Productions",
      "text": [
        "We will now show how the LIG algorithm given earlier can be extended to consider unary productions of the form A (.717/ ) 4 Ap (** 7p) as well as c productions of",
        "((A, top (p)) (rest (0p), nil)) E P [i, In addition, with the introduction of E productions, we have to consider derivations of strings of length d = 0.",
        "We shall assume that if A (a) * E then an encoding of A (a) will be stored in P[i, 01 (for all i).",
        "We must also consider the possibility that the primary constituent or the secondary constituent derive the empty string, i.e., dp = 0 or ds = 0.",
        "Processing of such cases becomes similar to that of unary productions.",
        "To indicate the additional processing required due to the introduction of unary productions and the possibility of the derivation of the empty string, let us consider Rule 8.ps.L.",
        "\"Use Rule 8.ps.L\" can be paraphrased as follows.",
        "If there exists a production A (.",
        "7,) Ap (.",
        "-yp) A, (as) where m 2, el = ((Ap, 'YO (i3p, (A, -y))) belongs to P [i, d] [t, d] and e2 = ((As, top (as)) (rest (as) , nil)) belongs to P [i + dp, d dp] [0,0] then add e3 = ((A, 7,,) (A, 'y))) to P [i, cl] [i, dp] if e3 is not already present in this array element.",
        "If we allow E productions it is possible that ds = ddp = 0.",
        "Consider the case where we have A, (a5) E. That is, we expect the entry e2 to be present in P[i + d, 0] [0, 0] .",
        "This means that the resulting entry e3 must be added to P [i , d] [i , cl] since we now have dp = d. Note that the addition of e3 = ((A, 7,n) (Ap, 7p))) (that encodes the derivation from A (13-yi -yp) for some 13) can result in more entries being added to the same array element P [i , cl] [i, cl] (for instance, when we have the production B (-A (-.",
        "-ym)).",
        "This is similar to the prediction phase in Earley's algorithm and the state construction in LR parsing.",
        "Based on this analogy, we will define our",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms notion of closure.",
        "Closure (e, i, d, t, dt) will add entries to P[1, [t, dt] or P [i, [i, d] that result from the inclusion of the entry P [i, d] [t, dt] by considering unary productions (or binary productions when the primary or secondary constituent derives the empty string).",
        "Before we define Closure 0 we note that for each occurrence in the algorithm of \"use Rule X\" is replaced by \"use closure of Rule X.\" For example, \"Use closure of Rule 8.ps.L\" stands for If we have the production A (.Y1 7m) > Ap ( 7p) As (cis) where m > 2, = ((Ap, 70 (Op, At, 70) belongs to P [i , [t, d] and",
        "add e3 to P [i, [i, dp] and then invoke Closure (e3, d, dp).",
        "Closure is defined as follows: Closure (e,ii,d,,t,dt) begin use closure of Rule 2.ps.L, 6.ps.L, 7.ps.L, 8.ps.L, 9.ps.L, 10.ps.L with d =- dp and the entry e as the primary constituent in the antecedent.",
        "use closure of Rule 2.sp.L, 6.sp.L, 7.sp.L, 8.sp.L, 9.sp.L, 10.sp.L with ds = d and the entry e as the secondary constituent in the antecedent.",
        "use closure of Rule 2.u.L, 6.u.L, 7.u.L, 8.u.L, 9.u.L, 10.u.L with d dp and the entry e as the primary constituent in the antecedent.",
        "end.",
        "Note Rule 3 does not apply since we have to assume MCL < 2 (hence any terminator is a 2-terminator and the length of the middle in a terminator-type entry is always one).",
        "We have not included Rule 4 and Rule 5 while computing the closure.",
        "These correspond directly to the completor step in Earley's algorithm and to the popping of stack elements and hence are not considered a part of the closure.",
        "They have to be applied later in the control structure.",
        "We will now consider the effect of including unary rules on the control structure of the algorithm.",
        "Let ((i1, d1) , (ii, d2)) ( (i3, d3) , (i4, if and only if (1) (i1, d1) < (i3, d3) or (2) (i1, d1) = (i3, d3) and (i2, d2) < (i4, d4).",
        "The simplicity of the loop structure in the algorithms seen thus far stems from the fact that for any parsing rule if the entry in the consequent is to be added to P [i3, d] [i4, d4] based on the existence of an antecedent entry in P[il, d1] [i2, d2], then ((i1, d1) , (i2, d2)) ((i3, d3) , (i4, d4)).",
        "This no longer holds when we consider Rule 5.u.L or Rule 5.ps.L when the secondary constituent derives the empty string.",
        "Consider the following derivation (and the presence of the productions assumed) for a sufficiently long 0: A() 1>(13-n) 1> A2 (711'2) 1> A3 (i) * ai .",
        "Consider the addition of an entry e3 to P [i, [t, dt] (for some (t, di)) to record the derivation from A3 (07).",
        "Closure (e3, i, d, t, dt) is invoked, resulting in the addition of C2 (corresponding to A2 (Th172)) to [i, From Rule 5.u.L and the presence of entry e2 and e3 we would add el (corresponding to A1 (0-y1) to P[i, [t, di]).",
        "This could result in the need to add more entries to P [i , d] [i, d], which in turn could cause new entries being added back to P [i, [t, dt] , and so on.",
        "Thus we have a situation where",
        "Computational LinguisticsVolume 19, Number 4 initialization phase for loops for d, i,d' as before begin consider closure of Rules in Rule set I for d, := d' 1 to 1 do for t := i to i + d' d do repeat consider closure of Rules in Rule set II for d, := dt 1 to 1 do for r := t to t + dt dr do consider closure of Rules 5.ps.L and Rule 5.u.L until no new entries are added to P [i , d] [t, d] Figure 8 Control structure with unary productions.",
        "an antecedent entry in P [i, [t, ci] ((t, dt) < (i, d)) causes an entry to be added to P [i, cl] [i, ct], which, acting as an antecedent entry, causes a new entry to be added to P [i, d][t, dt] .",
        "A simple strategy to take care of this situation would be to add another loop within the t loop (as shown in the partial control structure given in Figure 8) that is repeated until no new entries are added to P [i, d] [t, dt] .",
        "It is straightforward to prove the correctness of the algorithm with this additional loop and also that the asymptotic complexity remains the same.",
        "The latter is the case because only a bounded number of entries can belong to P[i,d][t,dt] for any fixed value of i, d, t, dt, and hence the repeat loop can be iterated only a bounded number of times (as determined by the grammar).",
        "In the partially specified control structure given in Figure 8, we have not considered the sp rules.",
        "Also we only consider the changes that need to be made to Algorithm 1; the changes to Algorithm 2 can be made in a similar fashion.",
        "Finally, for purposes of abbreviation, we have grouped Rules 2.ps.L, 6.ps.L, 9.ps.L, and 10.ps.L together and called it the Rule set I, and Rules 3.ps.L, 4.ps.L, 7.ps.L, and 8.ps.L the Rule set II.",
        "The repeat loop shown in Figure 8 is not needed in some situations.",
        "Consider the derivation and the sequence of addition of entries, e3, e2, el, as discussed above.",
        "Viewing this derivation as a bottom-up recognizer would, we have a \"prediction\" from entry e3 followed by a \"completion\" that results in the entry e1.",
        "In this case the two entries both encode objects with the same stack length.",
        "We generalize this situation and call such derivations auxiliary derivations (named after auxiliary trees in TAG).",
        "A (hi)1> TiAi (172) T2 *TlUAt (131/t) WT2 *ttilt (070 wwi where At (r37t) is the 2-terminator of Ai (0-Yi '72).",
        "We will say that this auxiliary derivation spans at least one terminal if len (al uwwi) > 1.",
        "Notice that if for a particular grammar every auxiliary derivation spans at least one terminal, then the extra repeat loop added becomes unnecessary.",
        "This is because now, with this assumption, for every parsing rule if the entry in the consequent is to be added to P [i3, d3][i4, 4] based on the existence of an antecedent entry in P[ii, [i2, d2] then ((ii , (i2, d2)) ((i3, d3) , d4))",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms We end this section by noting that in the case of a lexicalized TAG, we can verify that every auxiliary derivation spans at least one terminal, and hence in the TAG algorithm we do not have to include this additional repeat loop."
      ]
    },
    {
      "heading": "5.2 Tree Adjoining Grammars",
      "text": [
        "Tree Adjoining Grammars (TAG) is a tree generating formalism introduced by Joshi, Levy, and Takahashi (1975).",
        "A TAG is defined by a finite set of trees composed by means of the operation of tree adjunction.",
        "Definition 5.1 A TAG, G, is denoted by (VN, VT, S, I, A) where VN is a finite set of nonterminals symbols, VT is a finite set of terminal symbols, S E VN is the start symbol, I is a finite set of initial trees, A is a finite set of auxiliary trees.",
        "An initial tree is a tree with root labeled by S and internal nodes and leaf nodes labeled by nonterminal and terminal symbols, respectively.",
        "An auxiliary tree is a tree that has a leaf node (the foot node) that is labeled by the same nonterminal that labels the root node.",
        "The remaining leaf nodes are labeled by terminals and all internal nodes labeled by nonterminals.",
        "The path from the root node to the foot node of an auxiliary tree is called the spine of the auxiliary tree.",
        "An elementary tree is either an initial tree or an auxiliary tree.",
        "We will use a to refer to an initial tree, and 0 to refer to an auxiliary tree.",
        "-y may be used to refer to either an elementary tree or a tree that is derived from an elementary tree.",
        "We will call a node in an elementary tree an elementary node.",
        "We can give a unique name to each elementary node by using an elementary node address.",
        "An elementary node address is a pair composed of the name of the elementary tree to which the node belongs and the address of the node within that tree.",
        "We will assume the standard addressing scheme where the root node has an address e. If a node addressed ,Lt has k children then the k children (in left to right order) have addresses 1, .",
        ".",
        ".",
        ", p, k. Thus, if Al is the set of natural numbers then p, E Al'.",
        "In this section we will use to refer to addresses and n to refer to elementary node addresses.",
        "In general, we can write 77 = (-y, ,a) where y is an elementary tree and it E Domain (7).",
        "We will use Domain (-y) for the set of addresses of the nodes in -y.",
        "Definition 5.2 Let 7 be a tree with internal node labeled by a nonterminal A.",
        "Let 0 be an auxiliary tree with root and foot node labeled by the same nonterminal A.",
        "The tree, -y', that results from the adjunction of 0 at the node in y labeled A (as shown in Figure 9) is formed by removing the subtree of y rooted at this node, inserting 0 in its place, and substituting it at the foot node of 13.",
        "Each elementary node is associated with a selective adjoining (SA) constraint that determines the set of auxiliary trees that can be adjoined at that node.",
        "In addition, when adjunction is mandatory at a node it is said to have an obligatory adjoining (OA) constraint.",
        "Figure 9 shows how constraints are associated with nodes in trees derived from adjunctions.",
        "Whether 0 can be adjoined at the node (labeled by A) in is determined by c, the SA constraint of the node.",
        "In -y' the nodes contributed by 0",
        "In general, if /2 is the address of a node in 7 then by (7, /,/,) we refer to the elementary node address of the node that contributes to its presence, and hence its label and constraints.",
        "The tree language, T(G), generated by a TAG, G, is the set of trees derived starting from an initial tree such that no node in the resulting tree has an OA constraint.",
        "The (string) language, L(G), generated by a TAG, G, is the set of strings that appear on the frontier of trees in T(G).",
        "Example 5.1 Figure 10 gives a TAG, G, which generates the language {wcw I W E {a, b}}.",
        "The constraints associated with the root and foot of 0 specify that no auxiliary trees can be adjoined at these nodes.",
        "This is indicated in Figure 10 by associating the empty set, cb, with these nodes.",
        "An example derivation of the strings aca and abcab is shown in Figure 11."
      ]
    },
    {
      "heading": "5.3 TAG and LIG",
      "text": [
        "In this section, we examine bottom-up recognition of a TAG.",
        "In doing so, we construct a LIG that simulates the derivations of the TAG.",
        "Based on this construction, we derive a recognizer for TAG from the algorithms given earlier.",
        "Consider bottom-up TAG recognition.",
        "Having recognized the substring dominated by an elementary node there are two possible actions: (1) move up the tree by combining this node with its siblings; or (2) consider adjunction at that node.",
        "In bottom-up recognition, the second action (i.e., adjunction) must be considered before the first.",
        "Therefore, there are two phases involved in the consideration of each node.",
        "On entering the bottom phase of a node, having just combined the derivations of its children, we predict an adjunction.",
        "On entering the top phase, having just finished adjunction at that node, we must now combine with any siblings in order to move up the tree.",
        "Note that in the bottom phase we may also predict that there is no adjunction at the node (if there is no OA constraint on that node) and hence move to its top phase directly.",
        "Figure 12 shows why, because of the nature of the adjoining operation, TAG can be seen to involve stacking.",
        "Suppose, during recognition, the bottom phase of a node, 77,",
        "Stacking in a TAG.",
        "has been reached.",
        "When adjunction by the auxiliary tree 13 is predicted, control shifts to the bottom phase of /3's foot node.",
        "As we move up the spine of 13 it is necessary to remember that /3 was adjoined at n. On reaching the top phase of /3's root we must return to (the top phase of) 77.",
        "Therefore, the adjunction point, 11, must be propagated up the spine of 0.",
        "In general, we may need to propagate a stack of adjunction points as we move up the spine as shown in Figure 12 where 72 is obtained by adjoining )31 at a node i on the spine of 13.",
        "From this figure, it can be seen that the information about the adjunction points (that must be propagated along the spine of an auxiliary tree) follows the stack (last-in first-out) discipline.",
        "Notice also that only the nodes on the spine participate in the propagation of adjunction points.",
        "Consider how a LIG that simulates this process can be constructed.",
        "The details of the equivalence between LIG and TAG can be found in Vijay-Shanker (1987).",
        "In the",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms LIG, we use two nonterminals, t and b to capture the differences between the top and bottom phases associated with a node.",
        "The stack holds an appropriate sequence of adjunction points in the form of elementary node addresses.",
        "The top of the stack is the elementary node address of the node that is currently being visited (thus all objects have at least one element on the stack).",
        "Nodes that are not on the spine, or belong to an initial tree, do not participate in the propagation of adjunction points.",
        "Therefore, the objects for such nodes will have stacks that contain only their elementary node address.",
        "The set of LIG productions is determined as follows.",
        "We assume that internal elementary nodes have either a single child labeled by a terminal symbol (or E), or exactly two children labeled by nonterminals.",
        "In this discussion below, we will use 77 for a node and its elementary node address interchangeably.",
        "1.",
        "If 77 is a node that is labeled E where E e VT U{} then we will include t (n) > E. 2.",
        "If rns are the children of a node n such that the left sibling 77p (and hence 7)) is on the spine then the following holds: (1) the object corresponding to 77p can have an unboundedly large stack, whereas the object for 77, will have a stack of size one; (2) the top of the stack in these objects will be 77p and m; (3) combination of these two sibling nodes is possible only after the top parts of these nodes are reached; (4) the stack in the object for 77p must be propagated to object for 77 except that the top symbol ij,, is replaced by n; (5) when the two sibling nodes are combined we reach the bottom part of 77.",
        "Hence, we include the production bt 71p) t Os).",
        "3.",
        "If 77p, m are children of 77 as in the previous case except that 77p is the right sibling and is on the spine, then we include the production b (- 77)t (77s) t ( 77p).",
        "4.",
        "If rip, ris, and n are as before except that neither sibling is on the spine of an auxiliary tree then we include the production b ( 77)t ( 77p) t 5.",
        "If 77p is the only child of?)",
        "we have b (t (-- 71p) .",
        "6.",
        "If n is a node where 0 can be adjoined and we are at the bottom of 77, then, by predicting adjunction by 13, control moves to the bottom part of 777 (the foot node of 13).",
        "This is illustrated in Figure 13.",
        "In this case we add the production b ( 77771)b ( 77).",
        "When there is no OA constraint at 77 then we can predict that no adjunction takes place.",
        "This is captured with the production t ( b (- 7.",
        "Suppose we have reached the top part of the root node, 772, of the auxiliary tree 0.",
        "The corresponding object has the nonterminal t with 772 on top of the stack and the node at which 13 was adjoined is immediately below 772.",
        "Having reached the top of the root node of 0 we must return to the top of the node where 13 was adjoined.",
        "This is accomplished with the production t ( )t ( 772) (see Figure 13).",
        "TAG/LIG relationship.",
        "used to motivate the choices we make in the form of entries in TAG parser as well as the rules in the algorithm."
      ]
    },
    {
      "heading": "5.4 Recognition of TAG",
      "text": [
        "We now give a CKY-style recognition algorithm for TAG.",
        "But first we shall consider the LIG constructed from a given TAG as described in Section 5.3.",
        "Given this LIG grammar, consider the objects derived and the form of entries that will be used by the LIG algorithm.",
        "If n is an elementary node address of a node on the spine of an auxiliary tree, say 0, then any object that has 71 as the top symbol of its stack must be of the form A Oh .. .",
        "nom) where k> 0, A E {t, b}, and ?it is the elementary node address of a node where 0 can be adjoined.",
        "Furthermore, in any derivation, the terminator of A (yontn) will be b (p)t).",
        "For this LIG, MSL = MTL -= TTC = 1 and MCL =2.",
        "Hence it follows that any terminator is a 2-terminator.",
        "From the discussion above, an object A (n) (where A E {t, b} and len (p) > 0) has a terminator if and only if 7/ is an elementary node address of a node on the spine of an auxiliary tree.",
        "Consider the forms of entries for a LIG in this form.",
        "First, the length of the middle in a terminator-type entry will be one always, since any terminator is a 2-terminator.",
        "Note that the terminator of A (contn) will be b (cono.",
        "Thus, a terminator type entry in a parsing array entry, say P [i , d] will have the form ((A, n) (Tit, ((b, 77,) , [t, dt] ))) where A E {t, b} and (t, dt) < (i, d).",
        "Note that (b, nt) in the terminator-pointer is redundant.",
        "From the discussion above, a nonterminator-type entry will be used to record derivations from A (ij) where A E { t, b} and 7/ is the elementary node address of a node that belongs to an initial tree or of a node that is",
        "K. Vijay-Shanker and David J. WeirParsing Some Constrained Grammar Formalisms not on the spine of an auxiliary tree.",
        "To record this object the entry ((A, 77) , nil) would have been used.",
        "From the above discussion it makes sense that terminator-type entries in the TAG parser have the form ((A, n) (nt, f, dt)) where A E { t, b}, n is an elementary node address of a node on the spine of an auxiliary tree, say /3, and yt is the elementary node address of a node where /3 can be adjoined in.",
        "A nonterminator-type entry has the form ((A, n) ,nil) where A E { t, b}, and 7/ is an elementary node address of a node that is not on the spine of an auxiliary tree.",
        "Finally, consider an auxiliary derivation in the LIG obtained from a TAG as described in Section 5.3.",
        "Recall that an auxiliary derivation has the form",
        "rip is left child of n Tip is on the spine of an auxiliary treenp is right child of ((t, 7/p) (nt,t,di)) E P [i, dp]((t, 77,) , nil) E P [i + dp , d dp] ((b , 77) (Th, t, di)) E P [i, c] The following covers Case 4 of LIG construction where the two siblings are not on the spine or belong to an initial tree and corresponds to Rule 6.ps.L (or Rule 6.sp.L).",
        "Rule 6.ps.T rip is left child of n 77 is not on the spine of any auxiliary treeTip is right child of n ((t,77p) , nil) E P [, dp]((t, ns) , nil) E P [i + dp, d dp] ((),n) ,nil) E P [i, di Right sibling on the spine: Corresponding to Case 3 of LIG construction and Rule 7.sp.L we have Rule 7.sp.T 71p is right child of ii is left child of n77p is on the spine of an auxiliary tree ( (t, Th) , nil) e P [i, cis]((t, 71p) (Tit, t, d)) E P [i + cis, d ds] ((b, in (Tit, t, dt)) E P [i, el] Single child case: Corresponding to Case 5 of LIG construction, Rule 7.u.L and Rule 6.u.L.",
        "Rule 7.ii.u.T((t, rip) (W, t, dr)) E P [i, di rip is only child of n 7, is on the spine of some auxiliary tree ((b, in (nt, t, dt)) E P [i, cl]",
        "This concludes our discussion of the parsing rules for TAG.",
        "With the correspondences with the LIG parsing rules given (via the numbering of rules), these rules may be placed in the control structure as suggested in Section 5.1.",
        "As noted earlier, in the case of a lexicalized TAG, since every auxiliary derivation spans at least one terminal we do not require the repeat loop discussed in Section 5.1."
      ]
    },
    {
      "heading": "6. Conclusion",
      "text": [
        "In this paper we have presented a general scheme for parsing a set of grammar formalisms whose derivation process is controlled by (explicit or implicit) stacking machinery.",
        "We have shown how this scheme can be instantiated to give polynomial time algorithms for LIG, CCG, and TAG.",
        "In the case of CCG, this provides the only polynomial parsing algorithm (apart from a slight variant of this scheme given in Vijay-Shanker and Weir (1990)) we are aware of.",
        "The main contribution of this paper is the general recognition scheme and definitions of some notions (e.g., terminators, data structures sharing of stacks) crucial to this scheme.",
        "We believe that these ideas can be suitably adapted in order to produce parsing schemes based on other CFG parsing algorithms (such as Earley's algorithm).",
        "For instance, the definition of terminator given here was tailored for pure bottom-up parsing.",
        "In the case of Earley's algorithm, a bottom-up parser with top-down prediction, an additional notion of terminator for the top-down prediction component can be obtained in a straightforward manner.",
        "We have also introduced a new method of representing derivations in a TAG, one that we believe is appropriate in capturing the stacking that occurs during a TAG derivation.",
        "The derivations themselves represented can be in another TAG that we call the derivation grammar (see Vijay-Shanker and Weir (1993)).",
        "We have not discussed the extraction of parses after the recognition is complete because of space considerations.",
        "However, an algorithm to extract the parses and build a shared forest representation of all parses for CCG was proposed in Vijay-Shanker and Weir (1990).",
        "This scheme was based on the approach we have taken in our general scheme.",
        "The method of extracting parses and representing them using a shared forest given in Vijay-Shanker and Weir (1990) can be generalized in a straightforward manner to be compatible with the generalized recognition scheme given here."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "This work has been partially supported by NSF Grants IRI-8909810 and 'RI-9016591.",
        "We would like to thank A. K. Joshi, B. Lang, Y. Schabes, S. M. Shieber, and M. J. Steedman for many discussions.",
        "We are grateful to the anonymous reviewers for their numerous suggestions."
      ]
    }
  ]
}
