{
  "info": {
    "authors": [
      "Rolf Backofen"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P93-1027",
    "title": "On the Decidability of Functional Uncertainty",
    "url": "https://aclweb.org/anthology/P93-1027",
    "year": 1993
  },
  "references": [
    "acl-C88-1060",
    "acl-P93-1026"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We show that feature logic extended by functional uncertainty is decidable, even if one admits cyclic descriptions.",
        "We present an algorithm, which solves feature descriptions containing functional uncertainty in two phases, both phases using a set of deterministic and non-deterministic rewrite rules.",
        "We then compare our algorithm with the one of Kaplan and Maxwell, that does not cover cyclic feature descriptions."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Feature logic is the main device of unification grammars, the currently predominant paradigm in computational linguistics.",
        "More recently, feature descriptions have been proposed as a constraint system for logic programming (e.g. see [11]).",
        "They provide for partial descriptions of abstract objects by means of functional attributes called features.",
        "Formalizations of feature logic have been proposed in various forms (for more details see [3] in this volume).",
        "We will follow the logical approach introduced by Smolka [9, 10], where feature descriptions are standard first order formulae interpreted in first order structures.",
        "In this formalization features are considered as functional relations.",
        "Atomic formulae (which we will call atomic constraints) are of either the form A(x) or xfy, where z, y are first order variables, A is some sort predicate and f is a feature (written in infix notation).",
        "The constraints of the form x fy can be generalized to constraints of the form xwy, where w = fn is a finite feature path.",
        "This does not affect the computational properties.",
        "In this paper we will be concerned with an extension to feature descriptions, which has been introduced as \"functional uncertainty\" by Kaplan and Zaenen [7] and Kaplan and Maxwell [5].",
        "This formal device plays an important role in the framework of LFG in modelling so-called long distance dependencies and constituent coordination.",
        "For a detailed linguistic motivation see [7], [6] and [5]; a more general use of functional uncertainty can be found in [8].",
        "Functional uncertainty consists of constraints of *This work was supported by a research grant, ITW 9002 0, from the German Bundesministerium fiir Forschung und Technologie to the DFKI project DISCO.",
        "I would like to thank Jochen Mine, Joachim Niehren and Ralf Treinen for reading draft version of this paper.",
        "For space limitations most of the proofs are omitted; they can be found in the complete paper [2] the form xLy, where L is a finite description of a regular language of feature paths.",
        "A constraint xLy holds if there is a path w E L such that zwy holds.",
        "Under this existential interpretation, a constraint xLy can be seen as the disjunction xLy = V Ixwy I w E Ll.",
        "Certainly, this disjunction may be infinite, thus functional uncertainty yields additional expressivity.",
        "Note that a constraint xwy is a special case of a functional uncertainty constraint.",
        "To see some possible application of functional uncertainty we briefly recall an example that is given in Kaplan and Maxwell [5, page 1].",
        "Consider the top-icalized sentence Mary John telephoned yesterday.",
        "Using s as a variable denoting the whole sentence, the LFG-like clause s topic x A s obj x specifies that in s Mary should be interpreted as the object of the relation telephoned.",
        "The sentence could be extended by introducing additional complement predicates, as e.g. in sentences like Mary John claimed that Bill telephoned; Mary John claimed that Bill said that ... Henry telephoned yesterday; .... For this family of sentences the clauses s topic x A s comp obj x, s topic x A s comp comp obj x and so on would be appropriate; specifying all possibilities would yield an infinite disjunction.",
        "This changes if we make use of functional uncertainty allowing to specify the above as the single clause s topic x A s comp* obj x. Kaplan and Maxwell [5] have shown that consistency of feature descriptions is decidable, provided that a certain acyclicity condition is met.",
        "More recently, Baader et al.",
        "[1] have proven, that consistency is not decidable if we add negation.",
        "But it is an open problem whether consistency of feature descriptions without negation and without additional restrictions (such as acyclicity) is decidable.",
        "In the work presented here we show that it indeed is decidable."
      ]
    },
    {
      "heading": "2 The Method",
      "text": [
        "We will first briefly describe the main part of solving the standard feature terms and then turn to their extension with functional uncertainty.",
        "Consider a clause 0 = xpiyi A xp2y2 (from now on we will refer to pure conjunctive formulae as clauses).",
        "A standard method for solving feature terms would rewrite 0 in order to achieve a solved form.",
        "This rewriting depends on the paths pi and p2.",
        "If pi equals p2, we know that yi and y2 must be equal.",
        "This implies that 0 is equivalent to xpiylAyi = y2.",
        "If",
        "P1 is a prefix of p2 and hence P2 = Pip', we can transform 0 equivalently into the formulae xpiyi A y1p'y2.",
        "The reverse case is treated in a similar fashion.",
        "If neither prefix or equality holds between the paths, there is nothing to be done.",
        "By and large, clauses where this holds for every x and every pair of different constraints xpiy and xp2z are the solved forms in Smolka [9], which are consistent.",
        "If we consider a clause of the form 0 = xLlyi A 2L2y2, then we again have to check the relation between yi and y2.",
        "But now there is in general no unique relation determined by 0, since this depends on which paths pi and p2 we choose out of Li and L2.",
        "Hence, we have to guess the relation between pi and p2 before we can calculate the relation between yi and y2.",
        "However, there is a problem with the original syntax, namely that it does not allow one to express any relation between the chosen paths (in a later section we will compare our algorithm to the one of Kaplan/Maxwell, thus showing where exactly the problem occurs in their syntax).",
        "Therefore, we extend the syntax by introducing so-called path variables (written a, fl, a', ...), which are interpreted as feature paths (we will call the other variables first order variables).",
        "Hence, if we use the modified sub-term relation xay and a restriction constraint a e L, a constraint xLy can equivalently be expressed as xay A aeL (a new).",
        "The interpretation of xay is done in two steps.",
        "Given a valuation 14 of the path variables as feature paths, a constraint xay in 0 is substituted by xVp(a)y.",
        "This constraint is then interpreted using the valuation for the first order variables in the way such constraints are usually interpreted.",
        "By using this extended (two-sorted) syntax we are now able to reason about the relations between different path variables.",
        "In doing so, we introduce additional constraints a =.",
        "13 (equality), a -\"‹ fl (prefix) and a 11 [3 (divergence).",
        "Divergence holds if neither equality nor prefix holds.",
        "Now we can describe a normal form equivalent to the solved clauses in Smolka's work, which we will call pre-solved clauses.",
        "A clause 0 is pre-solved if for each pair of different constraint xayi and xi3y2 in 0 there is a constraint a in 0.",
        "We call this clauses pre-solved, since such clauses are not necessarily consistent.",
        "It may happen, that the divergence constraints together with the restrictions of form a e L are inconsistent (e.g. think of the clause f+A,3êff+ A a it )3).",
        "But pre-solved clauses have the property, that if we find a valuation for the path variables, then the clause is consistent.",
        "Our algorithm first transforms a clause into a set of pre-solved clauses, which is (seen as a disjunction) equivalent to the initial clause.",
        "In a second phase the pre-solved clauses are checked for consistency with respect to the path variables.",
        "In this paper we will concentrate on the first phase, since it is the more difficult one.",
        "Before looking at the technical part we will illustrate the first phase.",
        "For the rest of the paper we will write clauses as sets of atomic constraints.",
        "Now consider the clause 7 = {xay, ai e Li, xflz, fle L2}.",
        "The first step is to guess the relation between the path variables a and #.",
        "Therefore, 7 can be expressed equivalently by the set of clauses",
        "The clause yj is pre-solved.",
        "For the others we have to evaluate the relation between a and )3, which is done as follows.",
        "For 72 we substitute 13 by a and z by y, which yields {y z, xay, aeLi, aeL2}.",
        "We keep only the equality constraint for the first order variables, since we are only interested in their valuation.",
        "Combining {a e Li, a e L2} to la e (Li fl L2)} then will give us the equivalent pre-solved clause -6= {y z, xay, a e (Li nL2)}• For 73 we know that the variable /3 can be split into two parts, one of them covered by a.",
        "We can use concatenation of path variables to express this, i.e. we can replace ,3 by the term a.0', where /3' is new.",
        "Thus we get the clause = {xay, aèLi, z, a.",
        ")3'eL2}, The only thing that we have to do additionally in order to achieve a pre-solved clause is to resolve the constraint a.fi'' L2.",
        "To do this we have to guess a so-called decomposition P,S of L2 with P.S C L2 such that a é P and e S. In general, there can be an infinite number of decompositions (think of the possible decompositions of the language rg).",
        "But as we use regular languages, there is a finite set of regular decompositions covering all possibilities.",
        "Finally, reducing {a e Li, ae P} to {a e (L1 n P)) will yield a pre-solved clause.",
        "Note that the evaluation of the prefix relation in 73 has the additional effect of introducing a new constraint y131z.",
        "This implies that there again may be some path variables the relation of which is unknown.",
        "Hence, after reducing the terms of form a /3 or 13 we may have to repeat the non-deterministic choice of relations between path variables.",
        "In the end, the only remaining constraints between path variables will be of the form a 11/3.",
        "We have to consider some additional point, namely that the rules we present will (naturally) loop in some cases.",
        "Roughly speaking, one can say that this always occurs if a cycle in the graph coincides with a cycle in the regular language.",
        "To see this let us vary the above example and let 7 now be the clause {xax, a e f, xflz, gerg}.",
        "Then a possible looping derivation could be",
        "1. add a :< xax, aef, xi3z, flé f*y} 2. split 13 into a-fl': {xax, aef, xifz, cr-g1 erg} 3. decompose a-fi'' f* g: {xax, ctf, xiYz, ae f*, [3' erg}"
      ]
    },
    {
      "heading": "4. join a-restrictions:",
      "text": [
        "{xax, ae f , x,31z, #1 erg} However, we will proof that the rule system is quasi-terminating, which means that the rule system may cycle, but produces only finitely many different clauses (see [4]).",
        "This means that checking for cyclic derivations will give us an effective algorithm.",
        "Quasi-termination is achieved by the following measures: first we will guarantee that the rules do not introduce additional variables; second we restrict concatenation to length 2; and third we will show that the rules system produces only finitely many regular languages.",
        "In order to show that our rewrite system is complete, we also have to show that every solution can be found in a pre-solved clause."
      ]
    },
    {
      "heading": "3 Preliminaries",
      "text": [
        "Our signature consists of a set of sorts S (A, B, .",
        "), first order variables X (x, y, .",
        "), path variables P (a, 13, .",
        ".",
        ".)",
        "and features F (f, g, .",
        "..).",
        "We will assume a finite set of features and infinite sets of variables and sorts.",
        "A path is a finite string of features.",
        "A path u is a prefix of a path v (written u -< v) if there is a non-empty path w such that v = uw.",
        "Note that -< is neither symmetric nor reflexive.",
        "Two paths u, v diverge (written u u v) if there are features f,g with I g and possibly empty paths w, w1, w2 such that u = wfwi A v = wgw2.",
        "Clearly, u is a symmetric relation.",
        "Proposition 3.1 Given two paths u and v, then exactly one of the relations u = v, u -< v, u ›- v or u u v holds.",
        "A path term (p, q, .)",
        "is either a path variable a or a concatenation of path variables a•fl.",
        "We will allow complex path terms only in divergence constraints and not in prefix or equality constraints.",
        "Hence, the set of atomic constraints is given by",
        "We exclude empty paths in subterm agreement since xey is equivalent to x y.",
        "Therefore, we require h. • • • -fn E .P4- and L C A clause is a finite set of atomic constraint denoting their conjunction.",
        "We will say that a path term a•f3 is contained (or used) in some clause 0 if 0 contains either a constraint a-f3 e L or a constraint a•fi ii g.1 Constraints of the form pe L, pU q, and a will be called path constraints.",
        "An interpretation I is a standard first order structure, where every feature f E F is interpreted as a binary, functional relation Fx and where sort symbols We will not differentiate between p ii g and q it p. are interpreted as unary, disjoint predicates (hence",
        "• fl = 0 for A 0 B).",
        "A valuation is a pair",
        "(Vi, 14), where Vx is a standard first order valuation of the variables in X and Vp is a function Vp:P – +F.",
        "We define Vp(a.",
        "(3) to be Vp (a)Vp(t3), The validity of an atomic constraint in an interpretation I under a valuation (Vx, Vp) is defined as follows:",
        "where p is the path fi• .• fr, and Fi/ are the interpretations of fi in I.",
        "For a set C X we define =c to be the following relation on first order valuation: VX =fVk iff Vx E : V(z) = q(x).",
        "Similarly, we define =„ with ir C P for path valuations.",
        "Let t9 c xur be a set of variables.",
        "For a given interpretation I we say that a valuation (Vx, Vp) is a 19-solution of a clause 0 in I if there is a valuation (Vk, 4) in 1 such that Vx =xno q, vp and (Vi, 0.",
        "The set of all 9-solutions of 0 in • is denoted by([0],i.",
        "We will call X-solutions just solutions and write NY instead of 1[0]Fx.",
        "For checking satisfiability we will use transformation rules.",
        "A rule R is 19-sound 4) qt 7 D Hi for every interpretation I. R is called t3-preserving if 0 y log c R is globally 29-preserving if [013.c U Flo/."
      ]
    },
    {
      "heading": "4 The First Phase",
      "text": []
    },
    {
      "heading": "4.1 A Set of Rules",
      "text": [
        "Recall that we have switched from the original syntax to a (two-sorted) syntax by translating constraints xLy into Ixay, a e LI, where a is new.",
        "The result of the translation constitutes a special class of clauses, namely the class of prime clauses, which will be defined below.",
        "Hence, it suffices to show decidability of consistency of prime clauses.",
        "They are the input clauses for the first phase.",
        "Let 0 be some clause and x, y be different variables.",
        "We say that 0 binds y to x if x y E 0 and y occurs only once in 0.",
        "Here it is important that we consider equations as directed, i.e. we assume that y is different from y x.",
        "We say that 0 eliminates y if 0 binds y to some variable x.",
        "A clause is called basic if",
        "1. x y appears in 0 if 0 eliminates y, 2.",
        "For every path variable a used in 0 there is at most one constraint xay E 0.",
        "A basic clause 0 is called prime if 0 does not contain an atomic constraint of the form p ñ q, fl or a [3.",
        "Every clause 0 in the original Kaplan/Maxwell syntax can be translated into a prime clause 7 such that 0 is consistent if 7 is consistent.",
        "Now let's turn to the output clauses of the first step.",
        "A basic clause is said to be pre-solved if the following holds:",
        "1.",
        "Ax E 0 and Br E 0 implies A = B.",
        "2.aeLE 4i andaeVE q impliesL= .",
        "Furthermore, a e0 is not in 0.",
        "3. ce-i3, a = [3 or a )6 are not contained in 4. ani6E0iffa0)6,xayE0 andxfizE0.",
        "Now let's turn to the rule system.",
        "As we have explained informally, the first rule adds non-deterministicly relational constraints between path variables.",
        "In one step we will add the relations between one fixed variable a and all other path variables f3 which are used under the same node x as a.",
        "Furthermore, we will consider only the constraints = f3 and a /3 and not additionally the constraint a For better readability we will use pseudo-code for describing this rule (using the usual don't care/don't know distinction for non-determinism):",
        "For each x/6z E 0 with a #16 and afi)3V0 add a Op # with <5,3 E {-=, (don't know) \"don't care non-determinism\" means that one is free to choose an arbitrary alternative at this choose point, whereas \"don't know\" means that one has to consider every alternative in parallel (i.e. for every alternative of the don't care non-determinism a clause 0 is equivalent to the set of all don't know alternatives that can be generated by applying the rule to 0).",
        "Note that the order of rule application is another example for don't care non-determinism in our rule system.",
        "Although we have restricted the relations Op to {.=, lib this rule is globally preserving since we have non-deterministically chosen ray.",
        "To see this let 0 be a clause, I be an interpretation and (Vx,14) be a valuation in I with (Vx, Vp) 0.",
        "To find an instance of (PathRel) such that (Vi, 14) x 7 where 7 is the result of applying this instance, we choose ray E 0 with Vp(a) is prefix minimal in {l/p(/6) I xfiz E 0}.",
        "Then for each x /3z E 0 with a g and a II )6 0 we add a Op [3 where Vp(a) Op Vp()6) holds.",
        "Note that Op equals ;- will not occur since we have chosen a path variable a whose interpretation is prefix minimal.",
        "Therefore, the restriction Op E is satisfied.",
        "We have defined (PathRel) in a very special way.",
        "The reason for this is that only by using this special definition we can maintain the condition that concatenation of path variables is restricted to binary concatenation.",
        "E.g. assume that we would have added both )61 a and a /62 to a clause 7.",
        "Then first splitting up the variable a into )61.a' and then )62 into a•16; will result in a substitution of 132 in 7 by /3i-a'.16;.",
        "By the definition of (PathRel) we have ensured that this does not occur.",
        "The second non-deterministic rule is used in the decomposition of regular languages.",
        "For decomposition we have the following rules:",
        "where P, S, L C F+ and A is a finite set of reg.",
        "languages with L, P,S E A. L must contain a word w with twl > 1.",
        "The clash rule is needed since we require regular languages not to contain the empty path.",
        "The remaining rules are listed in Figure 1.",
        "We use A in (LangDecA) as a global restriction, i.e. for every A we get an different rule (LangDecA) (and hence a different rule system RA).",
        "This is done because the rule system is quasi-terminating.",
        "By restricting (LangDecA) we can guarantee that only finitely many regular languages are produced.",
        "For (LangDecA) to be globally preserving we need to find a suitable pair P, S in A for every possible valuation of a and fl.",
        "Therefore, we require A to satisfy",
        "We will call A closed under decomposition if it satisfies this condition.",
        "Additionally we have to ensure that L E A for every L that is contained in some clause 0.",
        "We will call such a set A 0-closed.",
        "Surely, we will not find a finite A that is closed under decomposition and 0-closed for arbitrary 0.",
        "But the next lemma states some weaker condition that suffices.",
        "We say that 7 is a (0,R.A)-derivative if 7 is derivable from 0 by using only rules from RA.",
        "H is clear from the context, we will just say that 7 is a 0-derivative.",
        "Lemma 4.2",
        "1.",
        "If A is 0-closed and closed under intersection, then A is 7-closed for all (0,R.A)-derivatives 2.",
        "For every prime clause 0 there is a finite A such that A is 0-closed and closed under intersection and decomposition.",
        "The proof of this lemma (containing the construction of the set A) can be found in the appendix."
      ]
    },
    {
      "heading": "4.2 Completeness and Quasi-Termination",
      "text": [
        "The rule system serves for an algorithm to transform a prime clause into an equivalent set of pre-solved clauses.",
        "The rules are applied in arbitrary order until a pre-solved clause has been derived.",
        "If one of the non-deterministic rules is applied, a clause is substituted by a whole set of clauses, one for each of the don't know alternatives.",
        "Since the rule system is quasi-terminating, we may encounter cycles during the application of the rules.",
        "In this case we skip the corresponding alternative, since every pre-solved clause that can be produced via a cyclic derivation can also be produced via a derivation that does not contain a cycle.",
        "Theorem 4.3 Let 0 be a prime clause.",
        "If A is 0 closed, closed under intersection and decomposition, then NI = U1,E,b 1711 for every interpretation I, where 4) is the set of pre-solved (0,1N-derivatives.",
        "The set 4:1) is finite and effectively computable.",
        "To prove this theorem we have to show that the rule system is sound and complete.",
        "Sound means, that we do not add new solutions during the processing, whereas complete means that we find all solutions in the set of pre-solved derivatives.",
        "For the completeness it normally suffices to show that (1) every rule preserves (or globally preserves) the initial solutions and (2) the pre-solved clauses are exactly the RA-irreducible clause (i.e. if a clause is not pre-solved, then one rule applies).",
        "But in our case this is not sufficient as the rule system is quasi-terminating.",
        "A prime clause 0 may have a solution Vx which is a solution of all (0,'RA)-derivatives in some cyclic derivation, but can not be found in any pre-solved (0, RA)-derivative.",
        "We have to show that this cannot happen.",
        "Since this part of the proof is unusual, we will explain the main idea (see the appendix for a more detailed outline of the proofs).",
        "Let 0 be some (consistent) prime clause and let Vx E [01/ for some I.",
        "Then there exists a path valuation Vp such that (Vx, Vp) 0.",
        "We will find a pre-solved 0-derivative that has Vx as a solution by imposing an additional control that depends on 14.",
        "This control will guarantee (1) finiteness of derivations, (2) that each derivation ends with a pre-solved clause, (3) the initial solution is a solution of every clause that is derivable under this control.",
        "Since the (Pre) rule does not preserve the initial path valuation V-p (recall that the variable )3 is substituted by the term a.P), we have to change the path valuation Vp every time (Pre) is applied.",
        "It is important to notice that this control is only used for proof purposes and not part of the algorithm.",
        "For the algorithm it suffices to encounter all pre-solved 0-derivatives.",
        "To understand this control, we will compare derivations in our syntax to derivations in standard feature logic.",
        "Recall that we have a two-level interpretation.",
        "A constraint xay is valid under Vx and Vp if xVp(a)y is valid under Vx.",
        "Hence, for each clause 0 and each valuation Vx, V-p with 0 valid under Vx and Vp there is a clause 0v7, in standard feature logic syntax (not containing functional uncertainty) such that 0v7„ is valid under V. E.g. for the clause {xax, aéf, xi3z, 13e f*g} and a path valuation Vp with Vp (a) = f and Vp(P) g the clause (fiv, is {xfx, xgy}.",
        "The control we have mentioned requires (by and large) that only those rewrite rules will be applied, that are compatible to the clause Ovp and thus preserve V. If one of the rules (Eq) or (Pre) is applied, we also have to rewrite 0v,„.",
        "Taking the above example, we are only allowed to add n P to 0 (using (PathRel)), since 0v, is already in pre-solved form.",
        "Now let's vary the example and let Vp be a path valuation with Vp(a) = f and 14(3) = fig.",
        "Then we have to add a in the first step, since this relation holds between a and P. The next step is to apply (Pre) on a [I.",
        "Here we have to rewrite both 0 and çiv.",
        "Hence, the new clauses 0' and 01„, are {xax, aéf, xflz, a-fle f*g} and {x f x,x fg y} respectively.",
        "Note that the constraint x f fg y has been reduced to x fg y by the application of (Pre).",
        "Since infinite derivations must infinitely often use (Pre), this control guarantees that we find a pre-solved clause that has Vx as a solution."
      ]
    },
    {
      "heading": "5 The Second Phase",
      "text": [
        "In the second phase we have to check consistency of pre-solved clauses.",
        "As we have mentioned, a pre-solved clause is consistent if we find some appropriate path valuation.",
        "This means that we have to check the consistency of divergence constraints of the form al 11 a2 together with path restrictions",
        "al e Li and a2 L2.",
        "A constraint al ñ a2 is valid under some valuation Vp if there are (possibly empty) words w, w1, w2 and features' f g such that Vp(ai) = wfwi and Vp(a2) = wgw2.",
        "This definition could directly be used for a rewrite rule that solves a single divergence constraint, which gives us",
        "where 0' 0[ai a2 4 )3.a].",
        "By the application of this rule we will get constraints of the form ii.al e L1 and 13.ai2 L2.",
        "Decomposing these restriction constraints and joining the corresponding path restrictions for 13 and c4,2 will result in fi3 e (P1 fl P2), «C.",
        "e (f n Si), a S2)} with Pi C L1 and P2.S2 C L2, which completes the consistency check.",
        "Additionally, one has to consider the effects of introducing the path terms )3.a'i.",
        "The main part of this task is to resolve constraints of the form /3.aii 11 a.",
        "There are two possibilities: Either a has also )3 as an prefix, in which case we have to add )3 a; or g is not a prefix of a, which means that we have to add a ñ )3.",
        "After doing this, the introduced prefix constraints have to be evaluated using (Pre).",
        "(In the appendix we present a solution which is more appropriate for proofing termination)."
      ]
    },
    {
      "heading": "6 Kaplan and Maxwell's Method",
      "text": [
        "We are now able to compare our method with the one used by Kaplan and Maxwell.",
        "In our method, the non-deterministic addition of path relation and the evaluation of these relations are done at different times.",
        "The evaluation of the introduced constraints )3 and a 13 are done after (PathRel) in the first phase of the algorithm, whereas the evaluation of the divergence constraints is done in a separate second phase.",
        "In Kaplan and Maxwell's algorithm all these steps are combined into one single rule.",
        "Roughly, they substitute a clause {xL1y,xL2z,} U 0 non-deterministicly by one of the following clauses:2",
        "Recall that {xLig, xL2z} is expressed in our syntax by the clause 7 = {xay, e x fiz, e L2}, which is the example we have used on page 2.",
        "The first three cases correspond exactly to the result of the 'This is not the way their algorithm was originally described in [5] as they use a slightly different syntax.",
        "Furthermore, they don't use non-deterministic rules, but use a single rule that produces a disjunction.",
        "However, the way we describe their method seems to be more appropriate in comparing both approaches.",
        "derivations that have been described for 72, 73 and 74.",
        "By and large, the last case is achieved if we first add a 11 ft to 7 and then turn over to the second phase as described in the last section.",
        "The problem with Kaplan/Maxwell's algorithm is that one has to introduce a new variable u in the last case, since there is no other possibility to express divergence.",
        "If their rule system is applied to a cyclic description, it will not terminate as the last part introduces new variables.",
        "Hence it cannot be used for an algorithm in case of cyclic descriptions.",
        "The delaying of the evaluation of divergence constraint may not only be useful when applied to cyclic feature descriptions.",
        "As Kaplan and Maxwell pointed out, it is in general useful to postpone the consistency check for functional uncertainty.",
        "With the algorithm we have described it is also possible to delay single parts of the evaluation of constraints containing functional uncertainty."
      ]
    },
    {
      "heading": "Appendix",
      "text": [
        "Proof of Lemma 4.2.",
        "The first claim is easy to prove.",
        "For the second claim let { L1, ..., C P(.1+) be the set of regular languages used in 0 and let Ai = (QA,,iA,cA,FinA,) be finite, deterministic automatons such that Ai recognizes L. For each Ai we define dec(Ai) to be the set",
        "where LI = {w E I cr'A.",
        "(p, w) = gl.",
        "It is easy to show that dec(Ai) is a set of regular languages that contains Li and is closed under decomposition.",
        "Hence, the set Ao = U1 dec (Ai) contains each Li and is closed under decomposition.",
        "Let A = fi (Ao) be the least set that contains Ao and is closed under intersection.",
        "Then A is finite and 0-closed, since it contains each L. We will prove that A is also closed under decomposition.",
        "Given some L E A and a word w = w1 w2 E L, we have to find an appropriate decomposition P, S in A.",
        "Since each L in A can be written as a finite intersection L = Lik where Li, is in Ao, we know that w = w1 w2 is in Li, for 1..m. As Ao is closed under decomposition, there are languages Pi, and Sik for k = 1..m with w1 E 1k, w2 E Si„ and Pi„-Si„ C Li,.",
        "Let P = and S = n Pik k • Clearly, wi E P, w2 E S and P.S C L. Furthermore, P, S E A as A is closed under intersection.",
        "This implies that P,S is an appropriate decomposition for W1W2.",
        "A.1 Phase I: Soundness, Completeness and Quasi-Termination",
        "Next we will prove some syntactic properties of the clauses derivable by the rule system.",
        "For the rest of the paper we will call clauses that are derivable from prime clauses admissible.",
        "Note that (by this proposition) (Pre) (resp.",
        "(Eq)) can always be applied if a constraint a f/ (resp.",
        "/3) is contained in some admissible clause.",
        "The next lemma will show that different applications of (Pre) or (Eq) will not interact.",
        "This means the application of one of these rule to some prefix or path equality constraint will not change any other prefix or path equality constraint contained in the same clause.",
        "This is a direct consequence of the way (PathRel) was defined.",
        "Lemma A.3 Given two admissible clauses 7, with 7 -y' and r different from (PathRel).",
        "Then -= E (resp.",
        "a E 7') implies a E y (resp.",
        "a .k E 7).",
        "Furthermore, if a./3 is contained in y', then either a.",
        ")(3 or a k is contained in 7.",
        "Note that this lemma implies that new path equality or prefix constraints are only introduced by (PathRel).",
        "We can derive from this lemma some syntactic properties of admissible clauses which are needed for proving completeness and quasi-termination.",
        "The first property will guarantee that concatenation does not occur in prefix or equality constraints and that the length of path concatenation is restricted to 2.",
        "The second property ensures that a constraint a./3 11 fl' is always reducible.",
        "Theorem A.5 For every finite A the rule system RA is quasi-terminating.",
        "Proof.",
        "The rule system produces only finitely many different clauses since the rules introduce no additional variables or sort symbols and the set of used languages is finite.",
        "Additionally, the length of concatenation is restricted to 2.",
        "0",
        "Since the rule system is quasi-terminating, the completeness proof consists of two parts.",
        "In the first part we will proof that pre-solved clauses are just the irreducible clauses.",
        "In the second part we will show that one finds for each solution Vx of a prime clause 0 a pre-solved 0-derivative 7 such that Vx is also a solution of 7.",
        "Theorem A.7 (Completeness I) Given an admissible clause 0 1 such that 0 is not in pre-solved form.",
        "If A is 0-closed and closed under decomposition, then 0 is RA-reducible.",
        "Theorem A.8 (Completeness II) For every prime clause 0 and for every A that is 0-closed, closed under decomposition and intersection we have",
        "where pre-solved(0, RA) is the set of pre-solved (0, RA)-derivatives.",
        "Proof (Sketch) We have to show, that for each prime clause 0 and each Vx , Vp , I with (Vs ,Vp) 0 there is a pre-solved (0, RA)-derivative 7 such that Vx E 1[7])1.",
        "We will do this by controlling derivation using the valuation (Vs, Vp).",
        "The control will guarantee finiteness of derivations and will maintain the first completeness property, namely that the irreducible clauses are exactly the pre-solved clauses.",
        "We allow only those instances of the non-deterministic rules (PathRel) and (LangDecA), which preserve exactly the valuation (Vs, Vp).",
        "That means if (Vx, Vp) kl 0 and 0 7 for one of these rules, then (Vx, Vp) y must hold.",
        "Note that the control depends only on Vp.",
        "E.g. for the clause 0 = {xay, a e Li, xigz,13 L2} and arbitray Vx this means that if Vp (a) = f, Vp(f3) = g and (Vx, Vp) z 0, the rule (PathRel) can transform 0 only into {a 11 /3} U 0.",
        "If Vp satisfies Vic, (a) Vp (13) for a different from /3 with xay E 0 and zgz E we cannot add any prefix constraint using this control.",
        "Hence, (Pre) cannot be applied, which implies (by lemma A.6) that in this case there is no infinite controlled derivation.",
        "We will call such path valuations prefix-free with respect to 0.",
        "If Vp is not prefix-free, then (Pre) will be applied during the derivations.",
        "In this case we have to change the path valuation, since (Pre) is not P-preserving.",
        "If (Vx , Vp) = {a 0} U ?,/, and we apply (Pre) on a k ,3 yielding 7, then the valuation with Vp(13) = Vp(a)14:,(#) and Vp (a) = Vi',(a) for a 0 will satisfy (Vs ,V.k.)",
        "-y.",
        "We will use VI, for controlling the further derivations.",
        "If we change the path valuation in this way, there will again be only finite derivations.",
        "To see this, note that every time (Pre) is applied and the path valuation is changed, the valuation of one variable is shortened by a non-empty path.",
        "As the number of variables used in clauses does not increase, this shortening can only be done finitely many times.",
        "This implies, that (Pre) can only finitely often be applied under this control.",
        "Hence (by lemma A.6), there are again only finite controlled derivations.",
        "We will first do a minor redefinition of _divergence.",
        "We say that two paths u, v are directly diverging (written u uo v) if there are features f g such that u E f.r and v E g.r.",
        "Then u H v holds if there are a possible empty prefix w and paths u', v' such that u = wu' and v = un, and u' uo v'.",
        "We will reformulate the reduction of divergence constraints in order to avoid constraints of form a.",
        ")3 Handling such constraints would make the termination proof somewhat complicated.",
        "For the reformulation we use a special property of pre-solved clauses, namely that a U /3 is in a pre-solved clause qi if xay and xf3x is in 0.",
        "Hence, if a and i3 U is in 0, then a Li 6 is also in 0.",
        "This implies, that we can write Op as U (Ai) 1.1(An) WO, where xi (A) is a syntactic sugar for Li (A) = {aLi a' I a a' A a, E A}, A1,.",
        ", An are disjoint sets of path variables and does not contain divergence constraints.",
        "Note that for every Ai = {ai, ..., an} there are variables x, yi, yn such that {xaiyi,.",
        ".",
        ".xay} C 0.",
        "Now given such that a constraint ñ (A), we assume that a whole set of path variables A1 C A diverges with the same prefix That means we can replace Li (A1) C (A) by",
        "where is new, A'1 = , a',} is a disjoint copy of A1 .7.: {ai, , an} and A = PAC is an abbreviation for the clause {al = g•al, ..., an = }.",
        "Li o(A) is defined similar to n (A).",
        "Assuming additionally that the common prefix (3 is maximal implies that fi Li a holds for a E (A – A1).",
        "If we also consider the effects of Ai = )3.AC on the subterm agreements in 0 that involves variables of A1, then we result in the following rule: where o' [a 1 4 – Q.ai, • • • , an #.4], Ai WA2 = A, jAi I > 1 and z, /3 new.",
        "Ais a disjoint copy of Al.",
        "xAiYi is short for fxaiyi, • • • , xanynl.",
        "may not contain constraints of form 6.6L in tk.",
        "Note that we have avoided constraints of the form oz-#1i /3'.",
        "The rules",
        "together with the rules (LangDecA), (Join) and (Empty) completes the rule system RsA°I\".",
        "(Red2) is needed as path variables always denote non-empty paths.",
        "We will view (Redi) and (Red2) as one single rule (Reduce).",
        "A clause 0 is said to be solved if (1) a.p e L and e 0 is not in Op; (2) a e Li in Op and a e L2 in Op implies L1 = L2; (3) 0 does not contain constraints of form a U fi, a U0 13, a fi, or a [1; and (4) for every {ay, xi3z} C 0 with a fi there are features I g with la e e gL2} C 0.",
        "It is easy to see that every solved clause is consistent.",
        "Note that every solved clause is also prime.",
        "Finally we can combine both phases of the algorithm.",
        "Theorem A.11 Consistency of prime clauses is decidable."
      ]
    }
  ]
}
