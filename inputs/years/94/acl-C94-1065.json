{
  "info": {
    "authors": [
      "Gisela Pitsch"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-1065",
    "title": "LR(k)-Parsing of Coupled-Context-Free Grammars",
    "url": "https://aclweb.org/anthology/C94-1065",
    "year": 1994
  },
  "references": [
    "acl-P90-1035"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Coupled-Context--Free Grammars arc a generalization of context-free grammars obtained by combining nonter-urinals to parentheses which can only be substituted simultaneously.",
        "Referring to the generative capacity of the grammars we obtain an infinite hierarchy of languages that comprises the context-free languages as the first arid all the languages generated by Tree Adjoining Grammars ('l'Affs) as the second element.",
        "Here, we present a generalization of the context-free 1,140-notion, which characterizes sub classes of Coupled-Context-Free Gran/Mars -- and therefore for 'FAGS -- which can lie parsed in linear time.",
        "The parsing procedure described works incrementally so that it can be used for on-line parsing of natural language.",
        "Examples show that important Tree Adjoining Languages, e.g. those modelling cross-serial depeirdencies, can be generated by 2(A:1-Cou pled-Context- Free G ram mars."
      ]
    },
    {
      "heading": "I Introduction",
      "text": [
        "III order to process natural languages, we first have to model the syntax formally.",
        "Many investigations its, e.g., [llig8,1] show that this cannot be done by context-free grammars (CEGs).",
        "l'or context-sensitive grammars which are powerful enough, it is known that the analysis is PSPACE-complete.",
        "Thus, there is a trade-off between tire power of the formalism and its analysis complexity.",
        "'To solve this dilemma, much work has been done to characterize language classes in between context-free and context-sensitive languages being powerful enough to model the syntax of natural languages but endowed with a polynomial time analysis.",
        "Coupled-Context-Free Grammars represent such a. formalism generalizing CFCs.",
        "Their suitability to model syntactical phenomena follows from the fact that they include the languages generated by the Tree Adjoining Grammars ('I'AGs) of Pos871 as one subclass.",
        ".Among other properties, both formalisms are able to model the linguistic phenomenon of cross-serial dependencies, which is not context-free but frequently appears in natural languages (cf. [Shi86]).",
        "'lire formalism of Coupled-Context-Free Grammars has been introduced in [(111102] and [Cita92].",
        "It belongs to the family of regulated string rewriting systems investigated in (DP891.",
        "The increased generative capacity is obtained by allowing to rewrite simultaneously a certain number of elements.",
        "Other regulated string rewriting systems :is, e.g., the Scattered Context Grammars of [G111;9] generalize CFCs by allowing simultaneous rewriting of arbitrary combinations of elements.",
        "In [DP89], it is shown that this results in languages which are not sernilinear.",
        "But semilin-earity is important since it formalizes the \"const ant-growth property\" of natural_ languages (cf. Postitil).",
        "In contrast to these, all languages defined by our formalism are semilinear *This research lugs been supported by a Gradniertenkolleg-fellowship of the Deutsche Forsciuungsgenleinschall.",
        "because of two restrictions.",
        "First, only those elements can be rewritten simultaneously which were produced by the same rewriting.",
        "Second, the Coupled-Context-Free Grammars consider elements rewritten simultaneously as components of a parenthesis.",
        "Those can only be substituted if they form a parenthesis and they can only be substituted by sequences of parentheses correctly nested.",
        "When characterizing Coupled-Context-Free Grammars by the maximal number or elements rewritten simultaneously – which we call the rank of the grammar we get all infinite hierarchy.",
        "The generative capacity grows with the rank.",
        "The smallest element of the hierarchy the one of rank I -• are GEGs.",
        "The next element, namely Coupled-Context-Free C smears of rank 2, generates the Same class of languages as the Tree Adjoining Grammars of [.11:1'75] and [Jos87].",
        "Hence, all notions and algorithms designed for Coupled-Context-Free Grammars of rank 2 can easily be translated onto TAtis (cf. Kina921).",
        "Because of the enlarged generative capacity, it is not surprising that the complexity of analysing languages generated by Coupled-Context-Eree Grammars is larger than it is in the context.",
        "free case.",
        "It event increases with growing rank (cf. [II l'9,1]).",
        "Therefore, we aim to characterize subclasses of the set of all languages generated by Coupled-Context-Free Grammars which are powerful enough to model the important 1111(1/0/11ella of naturid languages, but which are of a lower complexity.",
        "The deterministic context-free parsing with 1140--grammars leads to a linear time analysis (cf. [1(mi65D, the best possible.",
        "Therefore, its generalization is very attractive.",
        "A first, attempt in this direction was done in [tiV90].",
        "lint there, only TACs are investigated.",
        "Here, we investigate thin whole hierarchy of Coupled-Context-Free C1ramin ars.",
        "Although their enlarged generative capacity seems to be contradictory 1.0 a linear time complexity of the parsing algorithm, we can present an 1140-notion for Coupled-Cortex(.–\"rein Grammars describing a class of languages, which can actually be analysed in linear time.",
        "This increase in power as to the linear-time analysis is paid by an expensive preprocessing.",
        "It is taking into account the complex relations between parentheses that involves thin increase in complexity.",
        "However, these costs are to be paid only once for each grammar.",
        "The subclass described by our L/40-notion for a fixed 1 grows with the rank.",
        "The algorithm of [SV90] for /, /(k)-TACis does not fulfill the important Valid Prefix Property.",
        "'Chris means that for any prefix of the input already accepted, there exists a suffix suck that the whole word is in the language analysed.",
        "It allows to detect illegal inputs as soon as possible, which is necessary for efficient parsing.",
        "Our algorithm fulfills this property.",
        "Additionally, the algorithm as well as the notion defined here represent generalizations of their context-free counterparts which are natural in the sense that they strictly contain the context-free situation as the special case of Coupled-Context-Fred Grammars of rank 1.",
        "An example of an important LR(k)-Coupled-ContextFree Grammar is the one generating the language {w$7v w E {a, b}*} which reflects the syntactical construction of cross-serial dependencies.",
        "The paper starts by defining the Coupled-Context-Free Grammars.",
        "Then, we shortly recall the context-free L11-parsing procedure.",
        "Subsequently, the deterministic finite automaton used there to guide the analysis is modified such that it can handle Coupled-Context-Free Grammars.",
        "Based on it, the parsing algorithm for LR(0)-CoupledContext-Free Grammars is derived.",
        "This results in the generalized definition of the L.R(0)-notion.",
        "As for CFCs, the L.R(k)-Coupled-Context-Free Grammars result from the LR(0)-ones by resolving decision conflicts using a lookahead of at most k symbols."
      ]
    },
    {
      "heading": "2 Coupled-Context-Free Grammars",
      "text": [
        "Coupled-Context-Free Grammars are defined over extended semi-Dyck sets which are a generalization of semi-Dyck sets.",
        "Elements of these sets can be regarded as sequences of parentheses that are correctly nested.",
        "Semi-Dyck sets play an important role in the theory of formal languages.",
        "To extend the family of context-free languages by using them we consider parentheses of arbitrary finite order defined as follows:",
        "where IC[O]:= {e}.",
        "(a denotes the empty word.)",
        "The set of all (first) components of parenthesis in K is denoted by",
        "Now, we define how to generate new elements in ED(K,T) starting from given ones.",
        "Definition 3 (Parenthesis Rewriting System) A Parenthesis Rewriting System over ED(K,T) is a finite, nonempty set P of productions of the form {(k1, , kr) (ai,• • • ,a'r) (km, , kr) E K, al • ... • cy,- E ED(K,7')).",
        "The left and the right side of p := (X1,.. • Xr) E P is denoted by",
        "• S(p) := , X,), the source of p, and • D(p):= (at, – the drain of p.",
        "Now, we can define our grammars.",
        "The term \"coupled\" expresses that a certain number of context-free rewritings is executed in parallel and controlled by K.",
        "At last, we give the definition of derivation in CGFG.",
        "Let G (1C,1', P, S) E CCFG and V := comp(k) U We define the relation as a subset of V` x V* consisting of all derivation steps of rank r for G with r > 1.",
        "C•9 1,/, holds for co, c V* if and only if there ex",
        "4>G• denotes the reflexive, transitive closure of =>c;.",
        "Obviously, um • 14+1 C ED(K,T) follows from S .4>a. so for p and since the result of the substitution is a sequence of parentheses correctly nested if 1.1u.1 only if the original word was.",
        "The language generated by G is defined as L(G):= e T. I S 20.",
        "A sequence rpm , , co„ with pi -=:.-c; p1+1 for all 1 < i < n and pm = p, yo„ .11) is called a derivation of from co in G. A derivation is rightmost if and only if in each derivation step, the parenthesis ending at the rightmost point is substituted.",
        "In analogy to CFCs, it is obvious that for any derivation in CC.FG there exists exactly one rightmost derivation.",
        "In order to be able to describe the generative capacity of Coupled-Context-Free Grammars of different ranks exactly, we need the following notions:"
      ]
    },
    {
      "heading": "Definition I (Rank, CC FG(1))",
      "text": [
        "For any C (IC,T, P, S) E COFG, let time rank of G be defined as rank(G) := max (r (1c1, • • • ,k,) C K) .",
        "Then, we define for all 1> 1:",
        "The following theorem proven in [Cna92] shows that CC Fe builds up an infinite hierarchy of languages and, at the same time, represents a proper extension of CFCs not exceeding the power of context-sensitive grammars: Theorem 1 (Hierarchy) Let CPI, be the family of all context-free, CSL time family of all context-sensitive languages, TA L the family of (III languages generated by TA Os and CCFL(I) the one gerler.. alert by CCFG(1).",
        "it holds:",
        "(1) CPL = CC FL(1), TAL CCP' I,(2).",
        "(2) CC\"' I,(1)CCFL(1 + 1) for all 1> 1.",
        "(3) CCFL(I)C CSI, for all I > I.",
        "Sometimes, it is useful to \"neglect\" the relations between the components of a parenthesis for a short time.",
        "Then, we investigate C' (comp(K),T, , instead of C (K,T,P,S) C CCPG for",
        "Since is certainly a CFO we denote G` (resp.",
        "by cp(6) (resp.",
        "C F(P)) in the sequel.",
        "Obviously, G' satisfies L(G) C .1,(6\")."
      ]
    },
    {
      "heading": "3 Context-Free IA-Parsing",
      "text": [
        "Now, we shortly recall the deterministic context-free LR(k)-parsing strategy of Knuth (cf. [Knun5]).",
        "For simplicity, we restrict ourselves on the case k = 0.",
        "The strategy essentially remains unchanged if lookahead is necessary.",
        "It uses a deterministic finite tittontaton (dfa) to drive a pushdown stack while scanning the input from left to right.",
        "Thus, it constructs a rightmost derivation bottom-up.",
        "The states of the dfa for a given 1,11(0)-CPG consist of subsets of the set of all context-free items for (N,T, P, S), i.e. of the set {[X .fn I X – .",
        "/I E 1').",
        "They result from determining the deterministic version of the following nondeterministic automaton for C:",
        "• Each context-free item is a state.",
        "• There arc three kinds of state transitions:",
        "In the deterministic version, all those context-free items are grouped in one state which can be reached from the initial state by the same sequence of symbols, with any possible number of c-transitions in-between.",
        "The stack symbols are the states of the dfa.",
        "At first, the state containing the item [S' .8] is pushed, (The additional production 8' serves to define exactly the start and the end of the analysis.)",
        "Then, we iterate the following actions depending on the topmost state q: (Shift) If q contains [X rv.aln and a is the next input symbol to be read, WV push the state reached front q via a.",
        "(It contains at least [X • – ■ a./I].)",
        "(Reduce) If q contains [X al, we pop the lal topmost states.",
        "Let q' be the state now on top of the stack.",
        "Then, we push the state reached via X from q'.",
        "(q' contains at least one item [Y 6] and [A' while the new topmost, state contains [Y 7X.6].)",
        "'lime pushdown is driven deterministically by the dfa if this dfa contains no state where there are two different Reduce-items (Reduce-Reduce conflict) or as well a Shift as a Reduce-item (Shift-Reduce conflict).",
        "A CFG is le(0) iff the states of its dfa show no Shift-Reduce and no Reduce-Reduce conflict.",
        "For tie(k)-gr aniniars, conflicts ill the L,11(0)-dfa are solved by a lookahead of k symbols."
      ]
    },
    {
      "heading": "4 The Finite Automaton",
      "text": [
        "One possibility to generalize dfa is to construct the usual dfa for C F(G), C C CC PG.",
        "In principle, this idea is used in [SV00].",
        "The following example shows that this produces unnecessary conflicts: Let G=",
        "and L(C) lbed\"$,abcdd\"8 I n > 1).",
        "Its rlfa is shown in Figure 1.",
        "C is not LR(o) in this way since this din obviously has a Shift-Reduce conflict (in the box doubly lined).",
        "This conflict cannot be solved by lookahead since at this point, the lookahead is always dk.",
        "Therefore, G is not 1,14k) for any k 0.",
        "But this conflict is not necessary.",
        "E.g., when analysing Gelid bottom-up, we first have to reduce A' b.",
        "This implies that before coming to the conflict state, we have to choose .X r in order to get a correct derivation.",
        "This is die case because X and resulting from applying the production .5' XX In are",
        "coupled ;Ind therefore have to be substituted by coupled productions.",
        "'Po avoid these conflicts, we extend the dfa.",
        "If we use the context-free Alt-parsing strategy, we know which production we have to choose for any Xi C corny(K)\\ compi(K) because we first encounter and reduce the corresponding Xr E emnyi(K)- Suppose that we can store the information about.",
        "X2, (-V1, , X,.)",
        "E K[r], when X1 is reduced, let us say as the \"future\".",
        "(Row to do this is shown in Section 5.)",
        "Can we use this to avoid the conflict?",
        "Now, our automaton needs 1.",
        "(blitional transitions under such pi F CF(P) where S(p) eorap,(K) holds.",
        "Thus, we split ways inside the dfa which lead to conflict states.",
        "To formalize our automaton, we need the following",
        "and K c reachable*(Y))).",
        "I-Closure formalizes the construction of the deterministic version of a notaleterntinistic finite automaton as it is done for the dfa of CPC's.",
        "Its special feature is that it uses only those X a C CF(P) fulfilling X C coray,(K).",
        "If C conly(K)\\ comp, (K), the expanding production is determined by the corresponding first component.",
        "where := 1-ClosurefflS' .811) is the initial state, :=eornp(K) U 1 U (p c CF(P) I S(p) comPt(K)} the input alphabet, lic; the transition function definer!",
        "for C cony(K) UT and J.; E CF(P), S(fi) co.nyi(K), by",
        "and Pc; : – {q C Qc I [X a.]",
        "E a, X a C GP(1))) the set of the final states,",
        "The first difference to the usual context-free auto/radon is that we allow transitions under fi E CF(P), if we have S(A) corep,(K).",
        "The second point is that we use 1-Closure instead of the usual closure.",
        "I) PA(C) for the example grammar is shown in Figure 2.",
        "The conflict is removed because we can now distinguish two cases by looking at the information additionally stored.",
        "In [SV90], only the first idea was realized obviously leading to a weaker automaton."
      ]
    },
    {
      "heading": "5 The Analysis",
      "text": [
        "To use DFA(G), the usual pushdown is extended by a data-structure consisting in a list of partial derivation trees.",
        "This list future collects all information determined by Reduce's relative to first nonterminal components and is used to drive the transitions under p E CF(P) in .DFA(G) as soon as we have to investigate nonterminal components Xi V. compi(K).",
        "The change between the two different kinds of control leads to a new characterization of conflicts.",
        "For better explanation, we use a list past parallel to future where all Reduce operations performed so far are stored.",
        "An example for the new data-structures is shown in Figure 3.",
        "We use it to explain how they are built up during the analysis.",
        "The first operations on this past were Shift(wi Shift(w2), Reduce(A w2).",
        "Front CFCs, we know that any Reduce takes place at the end of the sentential form generated so far.",
        "This remains true.",
        "Thus, we can argue completely analogous as far /is past is concerned.",
        "But we investigate coupled productions as, e.g., (Z1, Z2) (wiA, U1 U2), A, (Z1, Z2), (Ut, (12) E K. We know that coupled nonterminal components are located at.",
        "the same depth of the derivation tree and that they are substituted by components of the same coupled production.",
        "Therefore, when inserting any p, S(p) E compi(K), in past, e.g., Z1 – s wi A, we additionally insert the coupled productions, e.g., Z2 – k Ur U2 in future.",
        "ln general, Yu.",
        "4--ws •-111 -4-past fut.--10- 112 1,33",
        "there are two cases to distinguish depending on pt inserted in past.",
        "If D(pt) contains only symbols in K,[1] U T (i.e. only uncoupled ones), the coupled p2,...,p, are inserted as the first up to the (r – 1)th element in future.",
        "(E.g. for (Z1, Z2 ) (lel A, U1(12).)",
        "Otherwise, we behave as it is done for (YU., Y2) (Z/ N, Z2Q1Q2) in Figure 3.",
        "I.e. the subtrees in future for those symbols in P(p2), \"D(pr) coupled to first components in D(pc) become the sons of these elements.",
        "Thus, we maintain the property that the symbols at each fixed depth in past and future together .form an element of ED(IC,T).",
        "Thereby, in addition to Shift's which are handled as usual, we know what to do during a sequence of Reduce operations relative to dements of compi(K).",
        "Now, let us be in the situation that we have to use the information in future, e.g. a transition under 132 =: pi front the topmost state.",
        "Then, we create ;•1 pointer presence walking on future.",
        "We push bri(tpo,„pd and make presence point onto the first son of 1)(p,).",
        "Let q be the new topmost state,.",
        "We have to distinguish three cases: C T: If e is the next input symbol, we push ba(the).",
        "Otherwise, the whole Mina is rejected.",
        "presence now points out the brother of e\".",
        "ti E comp (K) \\ comp, (K): future already stores the expansion --+ 0.",
        "We push ESC.",
        ";(q, (3).",
        "presence now points Ott the first symbol in [I. comp,(1C): future does not store information about but e and its coupled components represent a complete independent analysis problem which has to be solved recursively.",
        "E.g., this is the case for I), (01,112), and (Qt, Q2).",
        "The recursive call of the procedure starts with the topmost state since it contains all items [e. Jr].",
        "Each recursion needs separate data-structures.",
        "Details are described in [Pit93].",
        "If presence encounters no brother, we have to reduce.",
        "Let Y 7 be the production at whose last symbol presence points.",
        "We pop 171 I l states.",
        "The additional pop compared to the context-free case results front the transition under 1' 'y.",
        "presence walks to the brother of Y in future and we push Y) if q' is the new topmost state.",
        "If Y is the root of the first tree in Intnre, its complete subtree is moved front future to past and presence is deleted.",
        "Wu/ output p E /2 when reducing its last component.",
        "Thus, our result is a rightmost derivation in inverse order."
      ]
    },
    {
      "heading": "G The Definition",
      "text": [
        "So far, we did not discuss the situation that there are distinct transitions fitting for the Sallie state in D1'11(0).",
        "Shift-Reduce and Reduce-Reduce conflicts are forbidden as they are for CFCs.",
        "The new conflicts result if we have to decide whether we push 60(qi,,,„ 1), C 01'(1'), or Shift reap.",
        "Reduce as usual.",
        "If a state q shows saelt a \"new\" conflict, it contains two items of the kind [Zi and [X/ (1,1.",
        "M], C 7', or [Xi (rd.",
        "This is easy to decide as far as we are walking on future, since the information necessary is stored there.",
        "Thus, we only have a real conflict if i 1 and I = 1 holds for the above items.",
        "Obviously, this cannot be decided deterministically, since we would have to know about the structure of the derivation tree not constructed so far.",
        "E.g., in the first conflict, we would have to say whether e. is a son of yi (choose /h-1(q, V(li))) or whether f is a son of X.",
        "(choose be.;(q,)).",
        "It follows that we need a modified definition of \"conflicts\" compared to CFCs."
      ]
    },
    {
      "heading": "Definition LI (Conflict)",
      "text": [
        "For any C c (\"CYO, D1A(G) shoves conflict if at least one of its states contains a subset of the following kind:",
        "Theorem 2 Let C C GC PG be 1140.",
        "Our algorithm deterministically solves the wordproblern for any w 7', n Ind, in time 0(n) by constructing a rightmost derivation relative to C if w e L(C), and, if w c L(C), by rejecting the input.",
        "In addition, the algorithm shows the Valid Prefix Property.",
        "Proof: The linear time complexity follows since we only need a constant amount of additional steps per context-free step for past and future.",
        "DFA(G) is determined only once, for each C. The V PP holds since it holds for the context-free algorithm and future additionally ensures that the coupling is correct.",
        "L11(k)--Coupled-Context-1.",
        "'ree Grammars result from the above by resolving conflicts in 0 PA(C) by adding a lookahead set to the items which ,ire involved in a conflict.",
        "For this purpose, we use the mappings PIHSTk and POLLOWk :Ls defined for LL(k)--Couplcd-ContextFM: Grammars in [Pit94].",
        "There, these mappings arc generalized such that they take the coupling between the components of each nonterminal into account instead of working simply on CP(C).",
        "Thus, we treat only complete parentheses as a context-free nonterminal and the result is much more exact as, e.g., in [SV90].",
        "This results in :fit adequate generalisation of the L1(0-notion for CCI,C.",
        "Example 2 The language {a\"b\"c\"d\" > generated by the grammar in Example I shows the L11(0)-property.",
        "DFA(G) is shown in Figure 4.",
        "Example 3 The language (w$,In 17v C {a, b}'} modelling cross-serial dependencies can be generated by the G I1(1)-grammar ({S , (X, Y)), , rt, b}, P, C GC I,' G(2) where"
      ]
    }
  ]
}
