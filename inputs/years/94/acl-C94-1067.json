{
  "info": {
    "authors": [
      "J. Joachim Quantz"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-1067",
    "title": "An HPSG Parser Based on Description Logics",
    "url": "https://aclweb.org/anthology/C94-1067",
    "year": 1994
  },
  "references": [],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "In this paper I present a parser based on Description Logics (DL) for a German IIPSG-style fragment.",
        "The specified parser relies mainly on the inferential capabilities of the underlying DL system.",
        "Given a preferential default extension for DL disambiguation is achieved by choosing the parse containing a qualitatively minimal number of exceptions."
      ]
    },
    {
      "heading": "I Introduction",
      "text": [
        "In this paper I present a parser for IIPSO based on Description Logics (Di.).",
        "The main motivation for specifying such a parser relies on considerations concerning the disambiguation of NI.",
        "expressions.",
        "In [Schmitz, Quantz 931 it is shown how different types of ambiguity can be handled with a homogeneous approach based on the notion of preference rules Vackendoff 831.",
        "A major requirement for such a unified approach is that information usually represented rather differently (e.g. syntactic, semantic, and encyclopedic information) is homogeneously represented in a uniform and declarative formalism in order to express and evaluate the complex preferences stemming from the different kinds of information.",
        "Description Logics have been developed in the field of Knowledge Representation (see, for example, [Brachman et al.",
        "911).",
        "They have already been used for the representation of semantic and encyclopedic information, e.g. 1Allgayer et al.",
        "89, Stock 91, Preuss et al.",
        "921.",
        "Due to their similarity to typed feature formalisms [Carpenter 921, syntactic information is in principle also expressible in DL, as already sketched in [Quantz 93, Quantz, Schmitz 941.",
        "Furthermore, Preferential Default Description Logics (POOL) based on weighted defaults [Quantz, Ryan 931 can be used to represent the preference rules in a declarative and formally well-founded way.",
        "In the following I will mainly show how IIPSG-Style syntactic information can be represented in DE, and how a simple parser can be build by using the inference capabilities of a DI.",
        "system.",
        "Note that when specifying the parser I will keep the presentation as simple as possible, thereby deliberately ignoring efficiency aspects.",
        "I will also refrain from modelingall aspects of relevant knowledge in DE, i.e. there arc still pieces of information which are not explicitly encoded in the DI, modeling, but are rather implicitly contained in the parser (e.g. information related to linear precedence and to traces).",
        "The main objective of this paper it thus neither to contribute to research in efficient parsing technology, nor to *The project KIT-VM11 is supporled by the German Federal Minister of Research and Technology (I3W1') under contract 01 IV 101Q8.",
        "develop a declarative formalism in which all aspects relevant for NI.P can be represented.",
        "It is rather to provide the basis for an implementation of the exception minimization approach to interpretation proposed in [Quantz 931.",
        "In Section 6 I will briefly sketch how the DI, based parser presented in Section 5 can be extended to realize this approach."
      ]
    },
    {
      "heading": "2 Basic Ideas",
      "text": [
        "An important distinction made in DE, but missing in traditional feature formalisms, is the one between objects and types.",
        "DE formulae either express that a type It is more specific than (or subsumed by) a type 12 (ti :< 12) or that an object 0 is an instance of a type or, using DI.",
        "terminology, a concept (o c).",
        "Applying this schema to the task of NH', we can say that the objects in this domain are words or phrases, and that the types are syntactic categories.",
        "Furthermore, given a phrase 01 we have additional relations between this phrase and its constituents 02, 03, ..., usually expressed as \"02 is a daughter of of\".",
        "In DI.",
        "this is modeled as ' (oi 02) :: dtrs', or equivalently as '01 :: dtrs:o2'.",
        "'dtrs' thus acts as a binary predicate or, using Di.",
        "terminology, as a tole.",
        "Note that roles can have more than one value in contrast to features, which are functional.",
        "We can thus write dtrs:o2 & dtrs:03'.",
        "Note further that the objects stand for occurrences of words or phrases, and that different occurrences of the same word will be represented by different objects.",
        "This is represented by writing '02 phonier', for example, to express that 02 is an occurrence of the form 'er'.",
        "This is all rather similar to standard IIPSG notation, and the main difference is that in addition to the feature structures used in in'SG, we add an additional level of objects, which we see as instances of the feature structures.",
        "Feature structures thus correspond to types or more precisely to Dt.",
        "concepts.",
        "In a way, the objects in DI, are used to make the In'sG feature structures persistent, i.e. to have pointers or names to refer to them.",
        "The additional level of objects allows a straightforward description of the parsing task.",
        "We start with a number of objects, namely words, whose phonological value and position is known.",
        "We want to end up with a single object containing all these words as (riot necessarily immediate) constituents.",
        "Now the immediate dominance schemata in an !MSG tell us how to construct phrases from words or other phrases.",
        "Thus the main operation for building a phrase is to create a new object being au instance of an 10 schema (note that ID schemata are feature structures and therefore concepts) and to fill in the required daughters by using the objects available as building material.",
        "This is achieved by choosing the 'functor-daughter' and filling the required arguments.",
        "Three points are important in the following sections:",
        "1.",
        "Obviously, objects cannot be combined in a random way.",
        "In IntSG the t0 schemata and the lexical entries contain information concerning combination with other phrases.",
        "I will model this information in DL and use standard in.",
        "inferences to check consistency of combinations.",
        "Thus the 01. system is used to perform the unification task underlying I [PSG and similar Unification Grammars.",
        "2.",
        "An object can only be used as building material for a phrase if it has not yet been used as builcling material for some other phrase.",
        "Furthermore, when looking for daughters of a new phrase, we have to fill those daughters for which a filler is required, but not yet specified.",
        "I will use the epistemic operator k proposed in IDonini et al.",
        "921 to formalize these intuitions and then use standard Dr. retrieval for checking these constraints.",
        "3.",
        "For syntactically ambiguous expressions there is more than one possibility to combine the words/phrases.",
        "Since the objects and especially the relations between them are viewed from different perspectives in the alternative interpretations, we need a mechanism in DI.",
        "to represent these different views.",
        "I will use situated descriptions '0 c in s' in the following to formalize this notion of different perspectives.",
        "'Chore is a rough correspondence between the situations used to capture the specific interpretations and the charts created in chart parsing."
      ]
    },
    {
      "heading": "3 The Underlying Description I dgic",
      "text": [
        "Description Logics vary wit the term-building operators they contain.",
        "In this section I will present the syntax of the Di.",
        "which is used in the examples given in the next two sections.",
        "Due to space limitations I will not specify the formal semantics for this Di.",
        "(see, for example, [Hoppe et al.",
        "93, ()mint\", Schmitz 941 for a model-theoretic semantics):",
        "c in s , extend.",
        "sit (SI ,O When specifying the fragment aid the parser in the next sections I will use a notation based on the PROLOG interface provided by the BACK system [Hoppe et al.",
        "931.",
        "In BACK a distinction is made between term introductions or definitions, and constraint-like rules.",
        "A term name can be introduced either as primitive (I„ :<.\".",
        "0, i.e. only necessary conditions are given, or as defined 0„ 0, i.e. necessary and sufficient conditions are given.",
        "A rule el r:› means that each object being an instance of el is also an instance of c2.",
        "The formula 'extend.sit(si,s2)' expresses the fact that situation s2 is an extension of situation am.",
        "Tins means that 'o c in si ' implies 'o e in Nz for all objects o and concepts c. In order to distinguish between telling and querying information I will use 'o c in s' For tells and 'o 7: in s' for queries.",
        "I furthermore assume that a tell only suceeds if it is consistent with the previously entered information; otherwise it fails.",
        "When the object used in a query is a variable, the system will retrieve all known instances of a concept, i.e. 'Object 7: in s' will return the objects known to be instances of 'c' in 's' by backtracking.",
        "Note that the epistemic operator k will only be used in queries.",
        "It can therefore be straightforwardly integrated into existing Hi, systems.",
        "Since this is also true for situated descriptions, the parser presented in Section 5 is largely based on standard inference capabilities of DI, systems."
      ]
    },
    {
      "heading": "4 A Small Fragment",
      "text": [
        "In this section I will present examples from an liPsG-style fragment for German modeled in Dl.. Due to space limitations I will not specify all the information contained in this modeling but only the one needed to illustrate the main characteristics of the formalization and the example sentence 'Die schiine Frau sieht sic' discussed in the next section.",
        "'Hie fragment is based on the presentation in IPollard, Sag /17l and its application to German in Mild 911.",
        "A main difference between my DI, modeling and standard torsG modeling is that I avoid feature patties which would introduce superfluous lit.",
        "objects.",
        "There is thus no feature 'head' in my modeling since it would yield the introduction of head objects whose ontological status seems controversial.",
        "Consequently, lily Head Feature Principle specifies equivalence not for a single feature 'head', but rather for each head feature separately.",
        "'Me fragment contains five main categories, namely noun,np,verh,det, and adj.",
        "For i I ustra t ion, the defin it ions of noun ;inch op are given below:",
        "comp t COMpAillti & feat head cltr (firs & feat functr)r_cltr: din; & :eat 'Die feature 'functorAllr' will be used by the parser to specify the sign acting as functor of a new phrase.",
        "Its value will be identical to the value of 'head...dtt:', `adj..dir', or ' l ler.",
        "du', depending on the particular Immediate Dominance (10) schema used.",
        "Note that the daughters which :ire modeled :is features tire functional, i.e. no phrase can have two fillers for 'head Air'.",
        "Corresponding to these daughter roles arid features we have argument roles and features as 'comp_arg 1 ' etc.",
        "I then distinguish the following types of phrase structures:",
        "Thus in a 'comp_structure' the 'head_dtr' acts as a functor.",
        "Note that it has to be explicitly stated whether a certain feature is empty, e.g. 'no(adj..dir)' for 'comp_structure'.",
        "H1, systems assume an open world and take all descriptions",
        "as being partial, i.e. the fact that there is currently no known filler for a role at an object does not imply that there will never be one.",
        "The fragment contains six ID schemata, namely three for noun phrases, one for verb phrases, one for adjuncts, and one for topicalization.",
        "For the lexical entries I will use three morpho-sytntactie features (nform,case,gen) to illustrate agreement between nouns, adjectives, and determiners.",
        "Agreement concerning case and gender between nouns and determiners is modeled by specifying that the value of the feature 'case' at a common noun is the same as the value of the feature 'case' at the object filling the feature 'comp_argl' (which is the determiner).",
        "Below are lexical entries for 'frau' and 'sic':",
        "lexemc:crsie noun & nform:pro phon:sie -=> lexeme:er_sie gen:f Note the hierarchical nature of the modeling – the sub-categorization information is specified for common nouns and pronouns in general, and is then inherited by each specific common noun and pronoun.",
        "Information shared by all forms of a lexeme is specified as a property of the lexeme, whereas information specific to a particular form is specified for this form only.",
        "Adjectives require non-saturated noun phrases as arguments and agree with them wrt case and gender: adj adjunct & case=rnodiug.case & gen=mod_arg.gen &",
        "Finally, the lexical entry for 'siehe: verb the(comp_argl,rip & case:norn) lexeme:sehen _> verb & exactly(2,comp_args) the(comp_arg2,np & case:acc) phon:sicht _> lexeme:sehen Note that for verbs taking more than two arguments we need additional features 'comp_arg3' and 'comp_arg4'.",
        "In addition to the information modeled so far we need a. formalization of the principles underlying the combination of signs in IIPSG.",
        "Some of these principles hold only for phrases and not for signs in general.",
        "A phrase is defined as follows: phrase some(dtrs) phrase => lex:-lex:- phrase The (lead Feature Principle is then defined as: phrase => maj=head_dir.maj & gen=head_dtr.gen case=headaltr.case The parsing process presented in the next section is essentially triggered by signs which can act as functors, namely signs with unsaturated subcat lists, signs with slashes, and pronouns:"
      ]
    },
    {
      "heading": "5 DL-Based Parsing",
      "text": [
        "In this section I will present the basic structure of a DI:-based parser for the above fragment.",
        "The parser is realized by five main predicates.",
        "I assume that the initial information given to the parser consists of descriptions of the words occurring in the expression to be parsed.",
        "Consider the ambiguous sentence",
        "(1) Die schiine Frau sieht sic.",
        "(2) The pretty woman sees her.",
        "(3) The pretty woman she sees.",
        "The initial Di.",
        "representation of this sentence is: wu phomdie & starc0 & end:( in sr w5 :: phorcsie & starl:4 & cnd:5 in st",
        "Given this information the parser builds phrases from the five words.",
        "This is done by creating new phrases until no more combinations of signs are possible.",
        "The parsing succeeds if the words have been all used up and a single phrase results:",
        "Note that the episternie concept 'no(k(inv(dirs)))' is used to determine whether a sign is still available for phrase building.",
        "An object is an instance of this concept if it is not a filler of some 'Mrs' role at any other object.",
        "The basic idea of building a new phrase is to look for a sign which can act as a functor, to choose an ID schema in which this sign is a functor, and to find the required arguments of the functor.",
        "Finally, the linear precedence rules are checked and, if necessary, traces are introduced) new_phrase(Sit,FinSit) :- Sign'?",
        ": functor & no(k(inv(dhs))) in Sit, select_id_schema(Sign,Sit,Phrase,NewSiO, complete_arguments(Sign,NewSit,NextSit), checkJps_and_continuity(Phrase,Sit,NextSit,FinSit).",
        "Selection of an ill schema is realized in a rather naive and simple way--we just take an ID schema and try to create a new phrase as an instance of this schema, where the feature 'functor_dtr' is filled by the functor.",
        "'Due to space limitations I do riot specify the predicate 'check_lps_and_continuity' in this paper.",
        "Information about existing ID schemata thus has to be encoded as facts of the form 'id_schema(idl)', etc.",
        "The predicate 'extend_sit(Sit,NewSit).",
        "is used to tell the DI, system to create a new situation which is an extension of the current situation.",
        "Note that no further knowledge about the actual modeling of ID schemata is used in the parser except for the fact that each m schema has a 'functorAtr'.",
        "Note further that the tell will fail if the information known about the functor cannot be unified with the information required by the ID schema for the filler of 'funcloriltr'.",
        "In order to complete the arguments of the functor, the parser checks for each argument feature ArgFeat whether an argument is required (some(ArgFeat)) but not yet specified (no(k(ArgFeat))).",
        "If so, 'find_arg' looks for such an argument and enters it as tiller for ArgFeat.",
        "Then the remaining arguments are completed.",
        "Again we need to introduce facts specifying the arguments used in the fragment, e.g. 'arg_feature(comp_argl)'.",
        "If an argument is required it has to be filled, therefore the Cut.",
        "Thus the recursion terminates successfully only when all required arguments are actually filled.",
        "Note that the only information about argument structure needed by the parser are facts of the form 'arg_feature(comp_argl)' for all argument features.",
        "To find an argument the parser looks for it sign which has not yet been used for phrase building and asserts it as filler for the argument feature.",
        "Again, if unification is not possible due to conflicting constraints (e.g. agreement), the DL tell will fail.",
        "The second clause is needed to create a required argument which has not yet been build up.",
        "In this case 'new_phrase' is called to create a new potential argument.",
        "For the sentence 'Die schOne Frau sieht sic' we obtain two different parses, since both 'die schoene frau' and 'sic' are.",
        "ambiguous between nominative and accusative case.",
        "The reading according to which ',die schoene frau' is subject is shown in Figure 1 as a phrase structure tree.",
        "Some of the corresponding information contained in the DI.",
        "situation representing this Evading is given below:",
        "In the second parse In and p9 swap places, i.e. p9 is the 'comp..dtrl' of p12 and t11 is the 'cornp..dtr2'.",
        "The result of the parsing process illustrates the object-centeredness of DI.",
        "representations.",
        "The constituents of the utterance are explicitly modeled and can be used for extracting or specifying further information.",
        "'Thus we can choose to introduce a feature 'subject' and add the fact 'pl., :: subject:pa', or we can retrieve all the saturated noun phrases (Phrase 1: np & no(args)).",
        "Ibis object-centeredness is useful for disambiguation, for example for anaphora resolution, as illustrated in 1Quantz, Schmitz 941."
      ]
    },
    {
      "heading": "6 Interpretation as Exception Minimization",
      "text": [
        "I will now briefly sketch how the parser presented in the previous section can be extended to perform disambiguation by exception minimization as proposed in [Quantz 93].",
        "In case of ambiguous expressions the parser will return more than one situation.",
        "The basic idea of interpretation as exception minimization is to model additional preference rules needed for disambiguation as DI.",
        "defaults, and to choose the interpretation violating a qualitatively minimal set of defaults.",
        "A Preferential Default Description Logic (I'DDI.)",
        "based on weigthed defaults has been developed in [Quantz, Ryan 931.",
        "A weigthed default 6 has the form c2, where cr is called the premise of 6 (h7,), c2 the conclusions of h (he) and n the weight of 6 (w(6))--the higher the weight, the more relevant the default.",
        "For this PDDL a formally well-behaved preferential entailment relation 0k, is presented, which is based on an ordering on DL models °Ex.",
        "The basic idea of this preferential semantics is to compute a score for each model by summing up the exceptions to the defaults.",
        "Models with lower score are then preferred because they qualitatively minimize the exceptions.",
        "It is straightforward to carry the idea of scoring and ordering over from models to situation.",
        "To do so, we compute for each situation s and each default 6 the exceptions – those objects for which 'Object ?",
        ": 61, in s' succeeds and 'Object ?",
        ": 6, in s' fails.",
        "If there are several possible interpretations for an expression we choose the interpretation given by the situation with the lowest score.",
        "(Note that there may be tritely ambiguous expressions which yield situations with identical scores.)",
        "Thus taking the above example, we might use a preference for topicalizat ion of subjects to prefer the parse shown in Figure 1.",
        "This can be achieved by simply introducing a default np & top:± --45 case:nom Obviously, this default is a rather weak one and can be overwritten by information stemming from sclectional restrictions [Schmitz, Quantz 93].",
        "In principle, it is possible to use preferences stemming from weighted defaults already in the parsing process-situations whose score is higher than a specified threshold are not processed any further.",
        "Thus instead of producing all parses in the first step and ordering them in a second step, the parser would then only produce the preferred reading."
      ]
    },
    {
      "heading": "7 Conclusion",
      "text": [
        "I have presented a DL, based parser for a small liPsc-style fragment of German.",
        "Most aspects of the grammar and the parser have been modeled in a highly declarative way.",
        "Since the main motivation for my presentation has been to show how an IIPSG parser can be implemented in principle by using the inference functionality of a DI, system, I have deliberately ignored any efficiency issues.",
        "It should be obvious, however, that the parser can be further optimized to increase its performance, for example by integrating chart parsing techniques.",
        "We arc currently testing the performance of alternative implementations of both the parser and the underlying DL system.",
        "One advantage of using DI.",
        "as underlying formalism is that in addition to the syntactic information modeled in this paper, semantic and encyclopedic information can be easily integrated into the presented framework.",
        "Furthermore, Preferential Default Description Logics can be used to model preference rules as weighted defaults, thereby obtaining interpretation as exception minimization.",
        "The parser presented in this paper thus provides the basis for an homogeneous and formally well-founded approach to disambiguation based on Preferential Default Description Logics."
      ]
    }
  ]
}
