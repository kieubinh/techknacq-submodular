{
  "info": {
    "authors": [
      "Masayuki Ishii",
      "Kazuhisa Ohta",
      "Hiroaki Saito"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-1068",
    "title": "An Efficient Parser Generator for Natural Language",
    "url": "https://aclweb.org/anthology/C94-1068",
    "year": 1994
  },
  "references": [],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We have developed a parser generator for natural language processing.",
        "The generator named \"NLyacc\" accepts grammar rules written in the Yacc format.",
        "NLyacc, unlike Yacc, can handle arbitrary context-free grammars using the generalized Lit parsing algorithm.",
        "The parser produced by NLyacc efficiently parses given sentences and executes semantic actions.",
        "NLyacc, which is a free and sharable software, runs on UNIX workstations and personal computers."
      ]
    },
    {
      "heading": "1 Parser Generator for NLP",
      "text": [
        "Yacc[4] was designed for unambiguous programming languages.",
        "Thus, Yacc can not elegantly handle a script language with a natural language flavor, i.e. Yacc forces a grammar writer to use tricks for handling ambiguities.",
        "To remedy this situation we have developed N Lyacc which can handle arbitrary context-free grammars1 and allows a grammar writer to write natural rules and semantic actions.",
        "Although there are several parsing algorithms for a general context-free language, such as ATN, CYK, and Earley, \"the generalized Lit parsing algorithm [2]\" would be the best in terms of its compatibility with Yacc and its efficiency.",
        "An ambiguous grammar causes a conflict in the parsing table, a state which has inure than one action in an entry.",
        "The generalized Lit parsing proceeds exactly the same way as the standard one except when it encounters a conflict.",
        "The standard deterministic Lit parser chooses only one action in this situation.",
        "The generalized LR parser, on the other hand, performs all the actions in the multiple entry by",
        "splitting the parse stack for each action.",
        "The parser merges the divided stack branches, only when they have the same top state.",
        "This merger operation is important for efficiency.",
        "As a result, the stack becomes a graph instead of a simple linear state sequence.",
        "There is already a generalized LR parser for natural language processing developed at Carnegie Mellon University [3].",
        "NLyacc differs from CMU's system in the following points.",
        "• NLyacc is written in C, while CMU's in Lisp.",
        "• CMU's cannot handle c rules, while NLy-ace does.",
        "c rules are handful for writing natural rules.",
        "• The way to execute semantic actions dif",
        "fers.",
        "CMU's evaluates an LEG-like semantic action attached to each rule when reduce action is performed on that rule.",
        "NLyacc executes a semantic action in two levels; one is performed during parsing for syntactic control MI d the other is performed onto each successful final parse.",
        "We will describe the details of NLyacc's approach in the next section.",
        "NLyacc is upper-compatible to Yacc.",
        "NLyacc consists of three modules; a reader, a parsing table constructor, and a drive routine for the generalized Lit parsing.",
        "The reader accepts grammar rules in the Yacc format.",
        "The table constructor produces a generalized Lit parsing table instead of the standard Mt parsing table.",
        "We describe the details of the parser in the next section."
      ]
    },
    {
      "heading": "2 Execution of Semantic Actions",
      "text": [
        "NLyacc differs from Yacc mainly in the execution process of semantic actions attached to each grammar rule.",
        "Namely, Yacc evaluates a semantic action as it parses the input.",
        "We examine if this evaluation mechanism is suitable for the generalized Lit, parsing here.",
        "If we can assume that there is only one final parse, the parser can evaluate semantic actions when only one branch exists on top of the stack.",
        "Although having only one final parse is often the case in practical applications, the constraint of being unambiguous is too strong in general."
      ]
    },
    {
      "heading": "2.1 Handling Side Effects",
      "text": [
        "Next, we examine what would happen if semantic actions are executed during parsing.",
        "When a reduce action is performed, the parser evaluates the action attached to the current rule.",
        "As described in the previous section, the parse stack grows in a graph form.",
        "Thus, when the action contains side effects like an assignment operation to a variable shared by different actions, that side effect must not propagate to the other paths in the graph.",
        "If an environment, which is a set of value of variables, is prepared to each path of the parse branches, such side effect can be encapsulated.",
        "When a stack splits, a copy of the environment should be created for each branch.",
        "When the parse branches are merged, however, each environment can not be merged.",
        "Instead, the merged state must have all the environments.",
        "Thus, the number of environments grows exponentially as parsing proceeds.",
        "Therefore this approach decreases the parsing efficiency drastically.",
        "Also this high cost operation would be vain when the parse fails in the middle.",
        "To sum it up, although this approach retains compatibility with Yacc, it sacrifices efficiency too much."
      ]
    },
    {
      "heading": "2.2 Two Kinds of Semantic Actions",
      "text": [
        "We, therefore, take another approach to handling semantic actions in NLyacc.",
        "Namely, the parser just keeps a list of actions to be executed, and performs all the actions after parsing is done.",
        "This method can avoid the problem above during parsing.",
        "After parsing is done, the semantic action evaluator performs the task as it traces all the history paths one by one.",
        "This approach retains parsing efficiency and can avoid the execution of useless semantic actions.",
        "A drawback of this approach is that semantic actions can not control the syntactic parsing, because actions are not evaluated until the parsing is done.",
        "To compensate the cons above, we have introduced a new semantic action enclosed with [ ] to enable a user to discard semantically incorrect parses in the middle of parsing.",
        "Namely, there are two types of semantic actions:",
        "• An action enclosed with [ is executed during parsing just as done in Yacc.",
        "If `return 0;' is executed in the action, the partial parse having invoked this action fails and is discarded.",
        "• An action enclosed with { } is executed after the syntactic parsing.",
        "In the example below, the bracketed action checks if the subtraction result is negative, and, if true, discards its partial parse."
      ]
    },
    {
      "heading": "2.3 Keeping Parse History",
      "text": [
        "Our generalized LIt parsing algorithm is different from the original one [2] in that our algorithm keeps a history of parse actions to execute semantic actions after the syntactic parsing.",
        "The original algorithm uses a packed forest representation for the stack, whereas our algorithm uses a list representation.",
        "The algorithm of keeping the parse history is shown as follows.",
        "I) If the next action is \"shift s\", then make < s > as the history, where < s > is a list of only one element s. 2) If the next action is \"reduce r : ABS B2 then make append(111,112,...,14,[-r]) as the history, where Hi is a history of r is the rule number of production \"A 4 B032 ••• B„\", and the function 'append' concatenates multiple lists and returns the result.",
        "Now we describe how to execute semantic actions using the parse history.",
        "First, before starting to parse, the parser calls \"yyinit\" function to initialize variables in the semantic actions.",
        "Our system requires the user to define \"yyinit\" to set initial values to the variables.",
        "Next, the parser starts parsing and performs a shift action or a reduce action according to the parse history and evaluates the appropriate semantic actions."
      ]
    },
    {
      "heading": "2.4 Efficient Memory Management",
      "text": [
        "We use a list structure to implement the parse stack, because the stack becomes a complex graph structure as described previously.",
        "Because the parser discards failed branches of the stack, the system reclaims the memory allocated for the discarded parses using the \"mark and sweep garbage collection algorithm [1]\" to use memory efficiently.",
        "This garbage collection is triggered only when the memory is exhausted in our current implementation."
      ]
    },
    {
      "heading": "3 Distribution",
      "text": []
    },
    {
      "heading": "Portability",
      "text": [
        "Currently, NLyacc runs on UNIX workstations and DOS personal computers."
      ]
    },
    {
      "heading": "Debugging Grammars",
      "text": [
        "For grammar debugging, Ntyacc provides parse trace information such as a history of shift/reduce actions, execution information of I actions.' When NLyacc encounters an error state, \"yyerror\" function is called just as in Yacc.",
        "Distribution NLyacc is distributed through email (please contact nlyacca)nak.math.keio ac jp).",
        "Distribution package includes all the source codes, a manual, and some sample grammars."
      ]
    },
    {
      "heading": "References",
      "text": []
    },
    {
      "heading": "Appendix – Sample Runs – ",
      "text": [
        "A sample grammar below covers a small set of English sentences.",
        "The parser produces syntactic trees of a given sentence.",
        "Agreement check is done by the semantic actions."
      ]
    }
  ]
}
