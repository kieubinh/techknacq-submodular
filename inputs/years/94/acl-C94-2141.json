{
  "info": {
    "authors": [
      "Arturo Trujillo"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-2141",
    "title": "Computing First and Follow Functions for Feature-Theoretic Grammars",
    "url": "https://aclweb.org/anthology/C94-2141",
    "year": 1994
  },
  "references": [
    "acl-C92-2092",
    "acl-E91-1013",
    "acl-E93-1036",
    "acl-J92-4005",
    "acl-J93-1002",
    "acl-P85-1018"
  ],
  "sections": [
    {
      "text": [
        "Tins paper describes an algorithm for the computation of FIRST awl FOLLOW sets for use with feature-theoretic grammars, in which the value of the sets consists of pairs of feature-theoretic categories.",
        "The algorithm preserves as much information from the grammars as possible, using negative restriction to define equivalence classes.",
        "Addition of a simple data structure leads to an order of magnitude improvement in execution time over a naive implementation."
      ]
    },
    {
      "heading": "1 INTRODUCTION",
      "text": [
        "The need for efficient parsing is a constant one in Natural Language Processing.",
        "With the advent of feature-theoretic grammars, many of the optimization techniques that were applicable to Context Free (CF) grammars have required modification.",
        "-1 .,'or instance, a number of algorithms used to extract parsing tables from CF grammars have involved discarding information which otherwise would have constrained the parsing process, (Briscoe and Carroll, 1993).",
        "This paper describes an extension to an algorithm that operates over CF grammar to make it applicable to feature-theoretic ones.",
        "One advantage of the extended algorithm is that it preserves as much of the information in the grammar as possible.",
        "In order to make more efficient parsers, it is sometimes necessary to preprocess (compile) a grammar to extract from it top-down inhumation to guide the search during analysis.",
        "The first step in the preprocessing stage of several compilation algorithms requires the solution of two functions normally called FIRST and FOLLOW.",
        "Intuitively, .1% 1?ST (X) gives us the terminal symbols that may appear in initial position in substrings derived from category X.",
        ".1,' LOW (X) gives us the terminals which may immediately follow a substring of category X.",
        "For example, in the grammar S",
        "- NP VP; NP ---> det noun; VP vtra NP, we get:",
        "L LOW (S) LOW (V {$} ($ marks end of immt) These two functions are important in a large range of algorithms used for constructing efficient parsers.",
        "For example the IR-parser construction algorithm given in (Alto ct of., 1986):232 uses FIRST to compute item closure values.",
        "Another example is the computation of the /* relation which is used in the construction of generalized left-corner parsers, (Nederhof, 1993); this relation is effectively an extension of the function FIRST."
      ]
    },
    {
      "heading": "2 COMPUTING FIRST AND FOLLOW",
      "text": [
        "We propose an algorithm for the computation of FIRST values which handles feature-theoretic grammars without having to extract a CF backbone from them; the approach is easily adapted to compute FOLLOW values too.",
        "An improvement to the algorithm is presented towards the end of the paper.",
        "Before describing the algorithm, we give a well known procedure for computing FIRST for CF grammars (taken from (Aho et al., 1986):189, where e is the empty string): \"To compute FIRST(X) for all grammar symbols X, apply the following rules until no more terminals or e can be added to any FIRST set.",
        "1.",
        "If X is terminal, then FIRST(X) is X.",
        "2.",
        "If X c is a production, then add e to FIRST(X).",
        "3.",
        "If X is nonterminal and X 171Y2...Yk is a production, then place a in FIRST(X) if for some i, a is in FIRST(Yi), and c is in all of FIRST (Y0 FIRST(Yi_.1); that is,",
        "c. If c is in FIRST(Yj) for all = 1, 2,..., k, then add c to FIRST(X).",
        "Now, we can compute FIRST for any string X1 X2...X7, as follows.",
        "Add to FIRST(XIX2.-Xn) all of the non-c symbols of FIRST (X1).",
        "Also add the none symbols of FIRST(X2) if' c is in FIRST(X1), the non-c symbols of FIRST(X3) if c is in both FIRST (X1) and .FIRS7'(X2), and so on.",
        "Finally, add c to IP IRST(XiX2...Xâ€ž) if, for all FIRST (Xi) contains c.\" This algorithm will form the basis of our proposal."
      ]
    },
    {
      "heading": "3 COMPILING FEATURE-THEORETIC GRAMMARS 3.1 EQUIVALENCE CLASSES",
      "text": [
        "The main reason why the above algorithm cannot be used with feature-theoretic grammars is that in general the number of possible limiter-annals allowed by the grammar is infinite.",
        "One of the simplest ways of showing this is where a grammar accumulates the orthographic representation of its terminals as one of its feature values.",
        "It is not difficult to see how one can have an infinite number of NPs in such a grammar: NP[orth: the dog] NP[orth: the fat dog] NP[orth: the big fat dog], etc.",
        "This means that FI/?ST(NP[orth: the dog]) would have a different value to F/RST(NP[ orth: the fat dog]) even though they share the same leftmost terminal.",
        "That is, the feature structure for the substring \"det adj noun\" will be different to that for \"det noun\" even.",
        "though they have the same starting symbol.",
        "This point is important since similar situations arise with the subcategorization frame of verbs and the semantic value of categories in contemporary theories of grammar, (Pollard and Sag, 1992).",
        "Without modification, the algorithm above would riot terminate..",
        "The solution to this problem is to define a finite number of equivalence classes into which the infinite number of nonterminals may be sorted.",
        "These classes may be established in a number of ways; the one we have adopted is that presented by (Harrison and Ellison, 1992) which builds on the work of (Shieber, 1985): it introduces the notion of a negative restrictor to define equivalence classes.",
        "In this solution a predefined portion of a category (a specific set of paths) is discarded when determining whether a category belongs to an equivalence class or not.",
        "For instance, in the above example we could define the negative restrictor to be {orth}.",
        "Applying this negative restrictor to each of the three NPs above would discard the information in the `orth' feature to give us three equivalent nonterminals.",
        "It is clear that the restrictor must be such that it discards features which in one way or another give rise to an infinite number of nonterminals.",
        "Unfortunately, termination is not guaranteed for all restrictors, and furthermore, the best restrictor cannot he chosen automatically since it depends On the amount of grammatical information that is to be preserved.",
        "Thus, selection",
        "Of an appropriate restrictor will depend on the particular grammar or system used."
      ]
    },
    {
      "heading": "3.2 VALUE SHARING",
      "text": [
        "Another problem with the algorithm above is that reentrancies between a category mid its FIRST and FOLLOW values are not preserved in the solution to these functions; this is because the algorithm assumes atonuc symbols and these cannot encode explicitly shared information between categories.",
        "For example, consider the following naive grammar:",
        "We would like the solution of FOLLOW (N) to include the binding of the `agr) feature such that the value of FOLLOW resembled: FOLLOW (N[ctyr : X]) = iTtt[H,g1: : the algorithm above, even with a, restrictor, would not preserve such.",
        "a 1)inch-rig since the addition of a new category to L'OL LOW (N) is done independently of the bindings between the new category and N."
      ]
    },
    {
      "heading": "4 THE BASIC ALGORITHM",
      "text": [
        "We propose an algorithm which, rather than construct a set of categories as the value of FIRST and FOLLOW, constructs a set of pairs each of winch represents a category and its FIRST or FOLLOW category, with all the correct bindings explicitly encoded.",
        "For instance, for the above example, the pair IVI'[agr: X], Vinttagr: Xl) would he in the set representing the value of the function FIRST.",
        "In the next section the algorithm for computing Flii.ST is described; computation of 1.4)1,LOW proceeds in a similar fashion."
      ]
    },
    {
      "heading": "4.1 SoLvING FIRST",
      "text": [
        "When modifying the algorithm of Section 2 we note that each occurrence of a category in the grammar is potentially distinct front every other category.",
        "In addition, for each category we need to remember all the reentrancies between it and the daughters within the rule in winch it occurs.",
        "Finally, we assume that, any category in a, rule which can unify with a lexical category is marked in some way, say by using the feature-value pair 'ter: -L.', and that non-terminal categories must unify with the mother of S01110 rule in the grammar; the latter condition is necessary because the algorithm only computes the solution of t'IRST for lexical categories or for categories that occur as mothers.",
        "111 computing Fl.B51.' we iterate over all the plies in the gramtnar, treating the mother of each rule rrs the category for which we are trying to find a FIRST value.",
        "Throughout each iteration, unification of a daughter with the of an element, of FIRST results in a modified rule and a modified pair in which bindings between the mother category and the rhs of the pair are established.",
        "The modified mother and this are then used to construct the pair which is added to FIRST.",
        "For instance, given rule V and pair (1,, R), we unify V and L to give X' --* Y' and (L',./?,`); from these the pair (X', le) is constructed and added to FIRST.",
        "The algorithm assumes an operation -1-< which constructs a set 3' = 3 in the following way: pair p subsumes an element a of S then 3' = a + p; if p is subsumed by au element of S then 3' 3; else 3' = p. It should be noted that the pairs constituting the value of FIRS`.1' can themselves be compared using the subsumption relation in which reentrant values are subsumed by non-reentrant, ones, and combined using the unification operation.",
        "Thus in the principal step of the algorithm, a new pair is constructed as described above, a restrictor is applied to it, and the resulting, restricted pair is -1â€¹-added to FIRST.",
        "The algorithm is as follows:",
        "1. initialise First; {}.",
        "2.",
        "Run through all the daughters in the",
        "grammar.",
        "If X is pre-terminal, then First, -= -i-< (X, X)!",
        "(h (where ,N)!q> ineans apply the negative restrictor ci?",
        "to the pair (X, X)).",
        "3.",
        "For each rule in the grammar with mother",
        "X, apply steps 4 and 5 until no more changes are made to First.",
        "4.",
        "If the rule is X c, then First = First +< (X, c)!",
        "(D. 5.",
        "If the rule is X then First = First +< (X', a)!",
        "(I) if (r, a) has successfully unified with an element of First, and (V, cl)...(n ci_i) have all successfully and simultaneously unified with members of First.",
        "Also, First = Fir st+< (X', ORD if (V, ci fk) have all successfully and simultaneously unified with elements of First.",
        "6.",
        "Now, for any string of categories X1 .. Xâ€ž, First -= First + < (X; a) !",
        "(D if (Xi, a) has successfully unified with an element of First, and a e. Also, for",
        "if a) has successfully unified with an element of First, a c, and (X; , ci_i) have all successfully and simultaneously unified with members of First.",
        "Finally, First = First -}-â€¹ (X; ... c..)!",
        "(I) if (Xi, )... (_71 , cn) have all successfully and simultaneously unified with members of First.",
        "(This step may be computed on demand).",
        "One observation on this algorithm is in order.",
        "The last action of steps 5 and 6 adds e as a possible value of FIRST for a mother category or a string of categories; such a value results when all daughters or categories have c as their FIRST value.",
        "Since most grammatical descriptions assign a category to e (e.g. to bind onto it information necessary for correct gap threading), the pairs (X', e) or (X; e) should have bindings between their two elements; this creates the problem of deciding which of the cs in the FIRST pairs to use, since it is possible in principle that each of these will have a different value for E. In our implementation, the pair added to First in these situations consists of the mother category or the string of categories and the most general category for c as defined by the grammar, thus effectively ignoring any bindings that c may have within the constructed pair.",
        "A more accurate solution would have been to compute multiple pairs with c, construct their least upper bound, and then add this to First.",
        "However, in our implementation this solution has not proven necessary."
      ]
    },
    {
      "heading": "4.2 EXAMPLE",
      "text": [
        "Assuming the grammar in Fig.",
        "I. and the negative restrictor = {slash}, the following is a simplified run through the algorithm:",
        "â€¢ First = {} â€¢ After processing all pre-terminal categories First = {(Dct, Del), (N, N), (V tra,Vtra){ (obvious bindings not shown).",
        "â€¢ After the first iteration First = {(Det, Del), (N, N),(V tra, V tra),(V P[agr : X].",
        "V tra[agr : X]), (NP, Det), (N P, e)} â€¢ Since 'slash' is in (D, any of the NPs in the grammar will unify with the lhs of (NP, 6) and hence S will have Vtra as part of its FIRST value.",
        "First = {..,(VP[agr : V tra[agr : X]) , (NP, .Det),(N P, c), (8, Det), (S, Vtra)} â€¢ The next iteration adds nothing and the first stage of the algorithm terminates.",
        "The second stage (step 6) is done on demand, for example to compute state transitions for a parsing table, in order to avoid the expense of computing FIRST for all possible substrings of categories.",
        "For instance, to compute FIRST for the string [NP NP VP] the algorithm works as follows:",
        "â€¢ First = Pla,gr : Xl,Vtâ€¢a[afpâ€¢ : (NP, Oct), (N â€¢ After considering the first NP: Piâ€¢st {.., GNP NP VPI,Det)}.",
        "â€¢ Consideration of the second NP in the input string results in no changes to Mst, given the semantics of 1 , since the pair that it would have added, ([NI' NP VP],c), is already in First.",
        "â€¢ Since NPs can rewrite as (i.e. (N 1),() is in pi7.81), First S ([NI' NP VI'], Ikt), ([NP NP VP], Vtra)}.",
        "â€¢ Finally, ([NP NP VP], e) may not be added since (V P, r) does not unify with any element of First."
      ]
    },
    {
      "heading": "5 IMPROVING THE SEARCH THROUGH First",
      "text": [
        "If the algori Hun is run as presented, each it-oration through the grammar rules becomes slower and slower.",
        "The reason is that, in step 5, when searching First to create a new pair (X', a), every pair in Firs1 is considered and unification of its llts with the relevant (laughter of X attempted.",
        "Since each iteration normally adds pairs to First each iteration involves a search through a larger and larger set; furthermore, this search involves unification, and in the case of a successful match, the subsequent construction and addition to ./,'first also requires subsumption checks.",
        "All of these Operations combine to make each additional element in First have a strong effect on the per-lOrmance of the alg,oritinn.",
        "We therefore need to minimize the number of pairs searched.",
        "Considering the dependencies that exist between pairs in First one notices that once a. pair has been considered in relation with all the rules in the grammar, the effect of that pair has been completely determined.",
        "'mac is, after a pair is added to First it need only be considered up to and including the rule front which it was derived, after which tune it may be excluded from further searches.",
        "For example, take the previous grammar, and in particular the value of First after the first iteration through the algorithm.",
        "The pair (N P,1)(1), added because of the rule NP lagr: X, slash: MAN =-; Det[ter: H-] N[agr: X, ter: +], has to He considered only once by every rule in the grammar; after that, this pair cannot be involved in the construction of new values.",
        "A simple data structure which keeps track of those pairs that need to be searched at any one time was added to the algorithm; the data structure took the ham of a list of pointers to active pairs in First, where an active pair is one which has not been considered by the rule from which it was constructed.",
        "For example, the pair (ATP, I)(]t) would be active for a complete iteration from the moment that the corresponding rule introduced it until that rule is visited again during the second iteration.",
        "The effect of this policy is to allow each pair in First to be tested against each rule exactly once and then be exchaled from subsequent searches; this greatly reduces the number of pairs considered for each iteration.",
        "Using the 'Typed feature, Structure system (the LKB) of (Briscoe rt al., 1993), we wrote two grammars and tested the algorithm on them.",
        "'fable 1 shows the average number of pairs considered for each iteration compared to the average !number of pairs in First.",
        "As we can see, after the first iteration the number of pairs that needs to be considered is less (rmyth less for the final iteration) than the total number of pairs in First.",
        "Similar improvements in performance were obtained for the computation of RYI,LOW."
      ]
    },
    {
      "heading": "6 RELATED RESEARCH",
      "text": [
        "The extension to the RR algorithm presented by (Nakazawa, 1991) uses a. similar approach to that described here; the functions involved however are those necessary for the construction of an LB.",
        "parsing table (i.e. the Ci()TO and ACTION functions).",
        "One technical (lir",
        "ference between the two approaches is that he uses positive restrictors, (Shieber, 1985), instead of negative ones.",
        "In addition, both of his algorithms also differ in another way from the algorithm described here.",
        "The difference is that they add items to a set using simple set addition whereas in the algorithm of Section 4.1 we add elements using the operator +<.",
        "Furthermore, when computing the closure of a set of items, both of the algorithms there ignore the effect that unification has on the categories in the rules.",
        "For example, the states of an LR, parser are computed using the closure operation on a set I of dotted rules or items.",
        "In Nakazawa's algorithms computation of this closure proceeds as follows: if dotted rule < A w./33; > is in I, then add a dotted rule < C .y > to the closure of I, where C and B unify.",
        "This ignores the fact that both dotted rules may he modified after unification, and therefore, his algorithm leads to less restricted I values than those implicit in the grammar.",
        "To adapt our algorithm to the computation of the closure of I for a feature-theoretic grammar would involve using a set of pairs of dotted rules as the value of I."
      ]
    },
    {
      "heading": "7 CONCLUSION",
      "text": [
        "We have extended an algorithm that manipulates CF grammars to allow it to handle feature-theoretic ones.",
        "It was shown how most of the information contained in the grammar rules may be preserved by using a set of pairs as the value of a function and by using the notion of subsumption to update this set.",
        "Although the algorithm has in fact been used to adapt the constraint propagation algorithm of (Brew, 1992) to phrase structure grammars, the basic idea should be applicable to the rest of the functions needed for constructing LR tables.",
        "However, such adaptations are left as a topic for future research.",
        "Finally, improvements in speed obtained with the active pairs mechanism of Section 5 are of an order of magnitude in an implementation using Common Lisp."
      ]
    },
    {
      "heading": "ACKNOWLEDGEMENTS",
      "text": [
        "This work was funded by the UK SERC.",
        "I am very grateful to Ted Briscoe, John Carroll, Mark-Jan Nederhof, Ann Copestake and two anonymous reviewers.",
        "All remaining errors are mine."
      ]
    }
  ]
}
