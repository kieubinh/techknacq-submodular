{
  "info": {
    "authors": [
      "Kiyoshi Kogure"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-2143",
    "title": "Structure Sharing Problem and Its Solution in Graph Unification",
    "url": "https://aclweb.org/anthology/C94-2143",
    "year": 1994
  },
  "references": [
    "acl-C90-2039",
    "acl-C92-2068",
    "acl-P85-1016",
    "acl-P85-1017",
    "acl-P90-1023",
    "acl-P91-1041",
    "acl-P91-1042"
  ],
  "sections": [
    {
      "heading": "STRUCTURE SHARING PROBLEM AND ITS SOLUTION IN GRAPH UNIFICATION Kiyoshi KOGURE NTT Basic Research Laboratories",
      "text": []
    },
    {
      "heading": "ADSTRACT",
      "text": [
        "The revised graph unification algorithms presented here are more efficient because they reduce the amount of copying that was necessary because of the assumption that data-structure sharing in inputs occurs only when feature-structure sharing occurs."
      ]
    },
    {
      "heading": "1 INTRODUCTION",
      "text": [
        "Constraint-based linguistic frameworks use logical systems called feature logics (Kasper & Rounds, 1986; Shieber, 1989; Smolka, 1988), which describe linguistic objects by using logical formulas called feature descriptions that have as their models feature structures or typed feature structures.",
        "Shieber (1989) argued that if the canonical models of finite formulas of a feature logic were themselves finite, we could use them to compute over instead of theorem-proving over the formulas themselves.",
        "This would be advantageous if we had efficient algorithms for manipulating the canonical models.",
        "The most important operation on modelsfeature structures or typed feature structuresis combining the information two models contain.",
        "This operation is traditionally called unification, although recently it has come to be more suitably called informational union.",
        "This unification operation is significant not only theoretically but also practically because the efficiency of systems based on constraint based formalisms depends on the (typed) feature structure unification and/or feature description unification algorithms they use.1 This dependency is especially crucial for monostratal formalismsthat is, formalisms which use only (typed) feature structures such as IIPSG (Pollard & Sag, 1987) and MSG (Gunji, 1987).2 The efficiency of (typed) feature structure unification has been improved by developing algorithms that take as their inputs two directed graphs representing (typed) feature structures, copy all or part of them, and give a directed graph representing the unification result.",
        "These algorithms are thus called graph unification.",
        "Previous research has identified graph copying as a significant overhead and has attempted to reduce this overhead by lazy copying and structure sharing.",
        "Unification algorithms developed so far, however, including those allowing structure sharing seem to 'For example, the TASLINK natural language system uses 80% of the processing time for feature structure unification and other computations required by unification, i.e., feature structure pre-copying (Clodden, 1990).",
        "'For example, a spoken-style Japanese sentence analysis system based on HPSG (Kogure, 1989) uses 90%-98% of the processing time for feature structure unification.",
        "agree: X : agrrium sg synper: 3rd subj: syn[ag Te: X ]",
        "contradict structure sharing because they assume the two input graphs never share their parts with each other.",
        "This \"structure sharing\" assumption prevents the initial data structures from sharing structures for representing linguistic principles and lexical information even though many lexical items share common information and such initial data structure sharing could significantly reduce the amount of data structures required, thus making natural language systems much more efficient.",
        "Furthermore, even if the structure sharing assumption holds initially, unification algorithms allowing structure sharing can yield situations that violate the assumption.",
        "The ways in which such unification algoritluns are used are therefore restricted and this restriction reduces their efficiency.",
        "This paper proposes a solution to this \"structure sharing problem\" and provides three algorithms.",
        "Section 2 briefly explains typed feature structures, Section 3 defines the structure sharing problem, and Section 4 presents key ideas used in solving this problem and provides three graph unification algorithms that increase the efficiency of feature structure unification in constraint-based natural language processing."
      ]
    },
    {
      "heading": "2 TYPED FEATURE STRUCTURES",
      "text": [
        "The concept of typed feature structures augments the concept of feature structures.",
        "A typed feature structure consists of a set of feature-value pairs in which each value is a typed feature structure.",
        "The set of type symbols is partially ordered by subsumption ordering <7- and constitutes a lattice in which the greatest element T corresponds to 'no information' and the least element J.. corresponds to 'over-defined' or 'inconsistency.'",
        "For any two type symbols a, b in this lattice, their least upper bound and greatest lower bound are respectively denoted a VT b and a AT b. Typed feature structures are represented in matrix notation as shown in Fig. 1, where syn, agr, sg, and 3rd are type symbols; agree, num, per, and s/tbj are feature symbols; and X is a tag symbol.",
        "A featureaddressthat is, a finite (possibly empty) string of feature symbolsis used to specify a feature value of an embedded structure.",
        "In Fig. 1, for example, the structure at the feature-address agree 7/11M, where `' is the concatenation operator, is said to have sg as its type symbol.",
        "The root feature-address is de886 node structure tsymbol(a type symbol) arcs(a set of arc structures) generation(an integer) forwardNIL I (a node structure) lcopyNIL I (a node structure) VCOpyNIL I (a node structure) fig. 5: The node structure for the revised nondestructive unification.",
        "and output.",
        "In Fig. 4(b), for example, ti's node at feature-address h is shared as 13'5 node at the same feature-address, and the same node as 12'5 node at t4 is shared as t3's node at the same feature-address.",
        "This problem can be solved easily by keeping information on data-structure sharing status; that is, by adding to the node structure a new field for this purpose and using it thus: when a unification algorithm makes a node shared (for example, between the left input and output), it records this information on the node; later when the algorithm attempts to make the node shared, it does this only if this data-structure sharing is between the left input and output."
      ]
    },
    {
      "heading": "4.2 Algorithms",
      "text": [
        "This section first describes a non-DSS unification algorithm that discards the structure sharing assumption and thus permits initial data-structure sharing, and then it describes two DSS unification algorithms.",
        "Revised Nondestructive Unification This algorithm uses, instead of the node structure shown in Fig. 3, the node structure in Fig. 5.",
        "That is, the algorithm uses two kinds of copy links: lcopy for the left input and rcopy for the right input.",
        "The revised nondestructive unification procedure for typed feature structures is shown in Figs.",
        "6 and 7.",
        "Given two root nodes of directed graphs, the top-level procedure Unify assigns a new unification process identifier, generation, and invokes Unify_Aux.",
        "This procedure first dereferences both input nodes.",
        "This dereference process differs from the original one in that it follows up forward and lcopy links for the left input node and forward and rcopy links for the right input node.",
        "This revised dereference process eliminates the first source of the structure-sharing problem.",
        "Then Unify _Aux calculates the rneet of the type symbol.",
        "If the meet is I, which means inconsistency, it finishes by returning I.",
        "Otherwise Unify_Aux obtains the output node and sets the rneet as its is ymbol value.",
        "The output node is created only when neither input node is current; otherwise the output node is a current input node.",
        "Then Unify_Aux treats arcs.",
        "This procedure assumes the existence of two procedures: Shared_Arc_Pairs and Complement_Arcs, The former gives two lists of arcs each of which contains arcs whose labels exist in both input nodes with the same arc label order; the latter gives one list of arcs whose labels are unique to the first input node.",
        "For each arc pair obtained by Shared_Arc_P airs, Unify_AUX applies itself recursively to the value pair.",
        "And for each arc obtained by Complemenl_Arcs, it copies its value.",
        "Let us compare the newly introduced cost and the",
        "effect of this revision.",
        "This revised version differs from the original in that it uses two dereference procedures that are the same as the original dereference procedure except that they use different fields.",
        "Thus, on the one hand, the overhead introduced to this revision is only the use of one additional field of the node structure.",
        "On the other hand, although this revised version does not introduce new data-structure sharing, it can safely treat data-structure sharing in ii890 algorithm for typed feature structures uses the data structures shown in Fig. 3.3 The algorithm connects an input node and its copy node with a copy link that is, it sets the copy node as the input's copy field value.",
        "The link is meaningful during only one unification process and thus enables nondestructive modification.4 Using an idea similar to Karttunen's, 'romabechi (1991) proposed a quasi-destructive unification that uses node structures with fields for keeping update information that survives only during the unification process.5 Unification algorithms allowing data-structure sharing (DSS unification algorithms) are based on two approaches: the Boyer and Moore approach, which was originally developed for term unification in theorem-proving (Boyer & Moore, 1972) and was adopted by Pereira (1985); and the lazy copying suggested by Karttunen and Kay (1985).",
        "Recent lazy copying unification algorithms are based on Wroblewski's or Tomabechi's schema: Godden (1990) proposed a unification algorithm that uses active data structures, Kogure (1990) proposed a lazy incremental copy graph (LING) unification that uses dependency-directed copying, and Emele (1991) proposed a lazy-incremental copying (LIC) unification that uses chronological dereference.",
        "These algorithms are based on Wroblewski's algorithm, and Tomabechi (1992) has proposed a data-structure-sharing version of his quasi-destructive unification."
      ]
    },
    {
      "heading": "3.2 The Structure Sharing Problem",
      "text": [
        "The graph unification algorithms mentioned so far perhaps all those developed so farassume that data structure sharing between two input structures occurs only when feature-structure sharing occurs between feature-addresses they represent.",
        "This \"structure sharing\" assumption prevents data-structure sharing between initial data structures for representing linguistic principles and lexical information even though many lexical items share common information.",
        "For example, many lexical items in a traditional syntactic categories such as noun, intransitive verb, transitive verb, and so on share most of their syntactic information and differ in their semantic aspects such as semantic sortal restriction.",
        "Such initial data-structure sharing could significantly reduce the amount of data structures required and could therefore reduce page swapping and garbage-collection and make natural language processing systems much more efficient.",
        "Furthermore, even if the structure sharing assumption holds initially, applying a DSS unification algorithm in natural language processing such as parsing and generation can give rise to situations that violate the assumption.",
        "Consider, for example, JPSG3 For the nondestructive unification algorithm, the node structure takes as its copy field value either 1\\111, or a node structure only.",
        "4 In this algorithm each unification process has an integer as its process identifier and each node created in a process has the identifier as its generation field value.",
        "A copy link is meaningful only if its destination node has the current process identifier.",
        "Such a node is called 'current.'",
        "'The technique used to control the lifetime of update data is the same as that of Wroblewski's algorithm.",
        "based parsing.",
        "There are only a few phrase structure rules in this framework and the Complement-Head Construction rule of the form 'M C IF is applied very frequently.",
        "For instance, consider constructing a structure of the form [vp, NP 2 NI'l V]].",
        "When the rule is applied, the typed feature structure for the rule is unified with the structure resulting from embedding the typed feature structure for NPi at the feature-address for the complement daughter in the rule (e.g., dirs c (Ur), and the unification result is then unified with the structure resulting from embedding the typed feature structure for V at the feature-address for the head daughter.",
        "Because not every substructure of the structure for the rule always changed during such a unification process, there may be some substructures shared by the structure for the rule and the structure for VPi.",
        "Thus, when constructing VP2 there may be unexpected and undesired data-structure sharing between the structures.",
        "Let me illustrate what happens in such cases by using a simple example.",
        "Suppose that we use the nondestructive unification algorithm or one of its data structure sharing versions, the LING or LIC algorithm.",
        "The nondestructive and LING unification algorithms use the data structures shown in Fig. 3, and the I,IC algorithm uses the same data structures except that its node structure has no forward field.",
        "Consider unification of the typed feature structures ti and 12 shown in Fig. 4(a).",
        "Suppose that 11 and 12 are respectively represented by the directed graphs in Fig. 4(b) whose root nodes are labeled by tag symbols Xo and X4.",
        "That is, irs substructure at feature-address f2 and 12's substructure at fi are represented by the same data structure while feature structure sharing does not hold between them, and 11's substructure at f3 and 12's substructure at f4 are represented by the same data structure while feature structure sharing does not hold between them.",
        "Each of the algorithms simultaneously traverses a pair of input nodes with the same feature-address both of the inputs have from the root feature-address to leaf feature-addresses, makes a common copy of them to represent the unification result of that feature address, and connects the input and output nodes with copy links.",
        "For any feature-address that only one of the inputs has, the nondestructive unification algorithm copies the subgraph whose root is the node for that feature-address and adds the copied subgraph to the output structure, whereas the LING and LIC algorithms make the node shared by the input, and output structures.",
        "In the case shown in Fig. 4(b) the root nodes of the inputsnodes with the tag symbols X0 and X4--are first treated by creating a common copy of them (i.e., the output node with Yo), connecting the input and output nodes with copy links, arid setting bi-) = ao Ay a4 as the copy's isymbol value.",
        "Then the input nodes' arc structures are treated.",
        "Suppose that the pair of fi arcs is treated first.",
        "After the input nodes at feature-address fi are treated in the same manner as the root nodes, the pair of f2 arcs is treated.",
        "In this case, ti's node at f2 (labeled X2) already has a copy link because the node is also used as 12's node at fi so that the destination node of the link is used as this feature-address's output node, AS888 PROCEDURE Oct_Out _Node(nodel , node2, tsymbot) IF Current_knodel) AND Current_p(node.2) THEN node2 .",
        "forwardnode];",
        "tial data structures.",
        "This can significantly reduce the amount of initial data structures required for linguistic descriptions, especially for lexical descriptions, and thus reduce garbage-collection and page-swapping.",
        "Revised LING Unification LING unification is based on nondestructive unification and uses copy-dependency information to implement data-structure sharing.",
        "For a unique label arc, instead of its value being copied, the value itself is used as the output value and copy-dependency relations are recorded to provide for later modification of shared structures.",
        "This algorithm uses a revised Copy_Node procedure that takes as its input two node structures (node] and node.2) and one arc structure, arc!",
        "where node] is the node to he copied.",
        "The structure arc] is an arc to node], and node!",
        "is an ancestor node of nodelthat is, the node from which arc] departsand the revised procedure is as follows: (i) if node] ' (the dereference result of model) is current, then Copy_Node returns node] ' to indicate that the ancestor node2 must be copied immediately; otherwise, (ii) Copy_Arcs is applied to node]' and if it returns several arc copies, Copy_Node creates a. new copy node and then adds to the new node the arc copies and arcs of node.!'",
        "that are not copied, and returns the new node to indicate the ancestor node having to be copied immediately; otherwise, (iii) Copy_Node registors the copy-dependency between the node] ' and the ancestor node node2-- - that is, it adds the pair consisting of the ancestor node node2 and the arc arc!",
        "into the copy field of mode] - and returns NIL to indicate that the ancestor must not be copied immediately!'",
        "When a new copy of a node is needed later, this algorithm will copy structures the LING unificatton algorithm, a node structure's copy field is used to keep either copy information or copy dependency information.",
        "When the field keeps copy dependency information, its value is a cop ydep structure consisting of an integer generation fieldand a set of",
        "tures by using the copy-dependency information in its copy field (in the revised Gel_Out_Node procedure for the LING unification).",
        "It substitutes arcs with newly copied nodes for existing arcs.",
        "Thus the antecedent nodes are also copied.",
        "The revised LING unification is based on the revised nondestructive unification and uses a 710de structure consisting of the fields in the node structure shown in Fig, 5 and a new field reuse for indicat-node and arc pairs -deps field (see Fig. 3), The technique used to control the lifetime of copy-dependency information is the same as that of copy information.",
        "That is, the deps field value is meaningful only when the generation value is equal to the unification process identifier.",
        "noted by `c.\"11) specify token-identity in rnatrix notation, a tag symbol is used feature-address values with the same tag symbol are token-identical, and those feature-addresses with the token-identical value are said to corefer.",
        "In Fig. 1, the feature-addresses agree and subj agree corefer.",
        "A typed feature structure is also represented by a rooted, connected, directed graph within which each node corresponds to a typed feature structure and is labeled with a type symbol (and, optionally, a tag symbol) and each arc corresponds to a feature-value pair and is labeled with a feature, symbol.",
        "Fig.",
        "2 illustrates the graph representation of the typed feature structure whose matrix notation is shown in Fig.",
        "I.",
        "In a graph representation, the values at coreferent feature-addresses--that is, token-identical values - are represented by the same node.",
        "The set of typed feature structures is also partially ordered by a subsumption ordering that is an extension of the subsurnption ordering On the set of type symbols.",
        "A typed feature structure it is less than or equal to 12 (written as ir <,t 12) if and only if it is inconsistent (that is, if it includes the type symbol 1) or (i) 11's type symbol at is less than or equal to 12 's type symbol a2 (am <7- a2); (ii) each feature f of 12 exists in ti and lots a value 12j such that its counterpart 11,f is less than Or equal to 12,f ; and (iii) each coreference relation holding in 12 also holds in This subsumption ordering serves as the basis for defining two lattice operations: generalization (the least upper bound or join) and unification (the greatest lower bound or 'Ilea).",
        "Typed feature structures have been formalized in several ways, such as by using -0-types (A)t-Kaci, 1986)."
      ]
    },
    {
      "heading": "3 THE STRUCTURE SHARING PROBLEM",
      "text": []
    },
    {
      "heading": "3.1 Graph Unification Algorithms",
      "text": [
        "The destructive unification algorithm presented by AALKaci is the starting point in increasing the efficiency of graph unification.",
        "It is a node-merging process that uses the Union-Find algorithm, which was originally developed for testing finite automata equivalence (iioperoft k Karp, 1971), in a manner very similar to that of the unification algorithm for rational terms (Iluet, 1976).",
        "Given two root nodes of graphs representing (typed) feature structures, this algorithm simultaneously traverses a pair of input nodes with the same feature-address, putting them",
        "into a new and larger coreference class, and then returns the merged graph.",
        "Since the destructive unification process modifies its input graphs, they must first be copied if then; contents are to be preserved.",
        "Nondeterminism parsing, for example, requires the preservation of graph structures not only for initial graphs representing lexical entries and phrase structure rules but also for those representing well-formed intermediate structures.",
        "Although the overhead for this copying is significant, it is impossible to represent a resultant unified graph without creating any new structures.",
        "Unnecessary copying, though, must be identified and minimized.",
        "Wroblewski (1987) defined two kinds of unnecessary copying over-copying (copying structures not needed to represent resultant graphs) and early-copying (copying structures even though unification fails)- but this account is flawed because the resultant graph is assumed to consist only of newly created structures even if parts of the inputs that are not changed during unification could be shared with the resultant graph, A more efficient unification algorithm would avoid this redundant copying (copying structures that can be shared by the input and resultant graphs) (Kogure, 1990).",
        "To distinguish structure sharing at the implementation level from that at the logical level (that is, coreference relations between feature-addresses), the former is called data-structure sharing and the latter is called feature-structure sharing (Tomabechi, 1992).",
        "The key approaches to reducing the amount of structures copied are lazy copying and data-structure sharing.",
        "For lazy copying, Karttunen (1986) proposed a reversible unification that saves the original contents of the inputs into preallocated areas immediately before destructive modification, copies the resultant graph if necessary, and then restores the original contents by undoing all the changes made during unification.",
        "Wroblewski (1987), on the other hand, proposed a nondestructive unification with incremental copying.",
        "Given two graphs, Wroblewski's algorithm simultaneously traverses each pair of input nodes with the same feature-address and creates a common copy of the input nodes.",
        "The nondestructive unification",
        "ing data-structure sharing status.",
        "When the top-level unification procedure is invoked, it sets two new symbols to the two variables lased and rased.",
        "That a node structure has as its reuse field value the lased value means that it is used as part of the left input, and that it has as its reuse value the rased value means that it is used as part of the right input.",
        "The revised LING unification uses two new revised Copy_Node procedures, Copy_Node_L (shown in Fig. 8) and the analogous preocedure Copy_Nodeit.",
        "These procedures are respectively used to treat the left and right inputs and they differ from the corresponding original procedure in two places.",
        "First, instead of step (i) above, if model' (the dereference result of node') is current, Copy_Nodei (or Copy_Node_11) returns node.'",
        "'to indicate that the ancestor, node2, must be copied immediately.",
        "But if nodel ' has as its reuse field value the rased (or lased) value, it creates a copy of the whole subgraph whose root is node] 'and returns the copied structure also to indicate that the ancestor node must be copied immediately.",
        "Second, in step (iii), they register data-structure sharing status--that is, they set the lased (or rased) value to the reuse field of node./ '- as well as register copy-dependency information.",
        "This revised LING unification ensures safety in data-structure sharing.",
        "Again let us compare the newly introduced computational costs and the effect of this revision.",
        "The newly introduced costs are the additional cost of the revised dereference procedures (which is the same as in the previous one) and the cost of checking reuse status.",
        "The former cost is small, as shown in the discussion of the previous algorithm, and the latter cost is also small.",
        "These costs are thus not significant relative to the efficiency gain obtained by this revision.",
        "Revised Quasi-Destructive Unification The structure-sharing version of quasi-destructive unification keeps update information in the field meaningful only during the unification.",
        "After a successful unification is obtained, this algorithm copies the unification result and attempts data-structure sharing.",
        "This algorithm can be revised to ensure safety in data-structure sharing by using a node structure including two sets of fields for update information and one reuse field and by checking node reuse status while copying."
      ]
    },
    {
      "heading": "5 CONCLUSION",
      "text": [
        "The graph unification algorithms described in this paper increase the efficiency of feature structure unification by discarding the assumption that data-structure sharing between two input structures occurs only When the feature-structure sharing occurs between the feature-addresses they represent.",
        "All graph unification algorithms proposed so far make this assumption and are therefore required to copy all or part of their input structures when there is a possibility of violating it.",
        "This copying reduces their efficiency.",
        "This paper analyzed this problem and points out key ideas for solving it.",
        "Revised procedures for nondestructive unification, LING unification, and quasi-destructive unification have been developed.",
        "These algorithms make the use of feature structures in constraint-based natural language processing much more efficient.",
        "The key ideas in this paper can also be used to make the incremental graph generalization algorithm (Kogure, 1993) more efficient."
      ]
    },
    {
      "heading": "ACKNOWLEDGMENTS thank Akira Shimazu, Mikio Nakano, and other colleagues in the Dialogue Understanding Group at the NTT Basic Research Laboratories for their encouragement and thought-provoking discussions. REFERENCES",
      "text": [
        "ter the common label arcs are treated, unique label arcs are treated.",
        "The nondestructive unification algorithm copies it's fo and t2's f arcs and adds them to the output root node, whereas the LING and LIC algorithms make the input and output structures share their destination nodes.",
        "Finally, the LING and LiC algorithms obtain graph to, represented in matrix notation in Fig. 4(c) just over the correct result.",
        "The nondestructive unification algorithm obtains the same typed feature structure.",
        "The reversible and the quasi-destructive unification algorithms are also tin able to obtain the correct result for this example because these algorithms cannot represent two update nodes by using a single node.",
        "Thus, none of the efficient unification algorithms developed recently obtains the correct results for such a case.",
        "Avoiding such wrong unification results requires undesirable copy ing.",
        "We can, for example, avoid getting the wrong result by interleaving the application of any non-DSS unification algorithm between applications of a DSS unification algorithm, but such bypassing requires two unification programs and reduces the efficiency gain of DSS unification.",
        "This preclusion of useful data structure sharing is referred to here as the \"structure sharing\" problem.",
        "It has been shown that all the DSS unification algorithms mentioned above are subject to this problem even if the structure sharing assumption holds initially.",
        "Non-DSS unification algorithms are also subject to the problem because their inputs are created by applying not only the unification operation but also operations such as embedding and extraction, in most implementations of which data-structure sharing occurs between their input and output structures.",
        "Even non-DSS unification algoritluns must therefore take such inputs into account, and this requires an desirable copying."
      ]
    },
    {
      "heading": "4 A SOLUTION TO THE STRUCTURE SHARING PROBLEM 4.1. Key Ideas",
      "text": [
        "The example in Section 3 suggests that the structure sharing problem has two sources, which concern not only the incremental copying approach but also other approaches.",
        "The first source is the way of recording update information.",
        "In the incremental copying approach, this corresponds to the way of copying structures.",
        "That is, while calculating tiA1 t2 the int:remelttal copying process does not distinguish between the copies created as the substructures of the left input It and the copies created as the substructures of the right input 12.",
        "As a result, a copy node of it's node at feature-address p can be used as a copy node of 12's node at a feature-address, and vice versa.",
        "In Fig. 4(b), for example, the copy of 1.2's node at f2 is wrongly used as the copy of trs node at ft.",
        "This causes unexpected and wrong data-structure sharing in the resultant graph and this in turn causes unexpected and wrong feature-structure sharing in the resultant.",
        "(typed) feature structure.",
        "In other approaches, such as the quasi-destructive approach, Lite source of the structure sharing problem is that each node structure has fields for keeping information on only two typed feature structures one for the original and one for the resultwhereas fields for keeping information on three typed feature structures are needed one for the original and one for each of the two results.",
        "One way to solve this problem is therefore to make each node keep information on three typed feature structures: in the incremental copying approach each node must have two copy fields, and in the quasi destructive approach each node must have two sets of fields for updates.",
        "The second source of the structure sharing problem is the method of data-structure sharing between input and output structures.",
        "Unexpected and wrong data-structure sharing may result if a node shared by the left and right inputs is used as part of the left input, intended to be shared between the left input and output, at the sane time it is used as part of the right input, intended to be shared between the right input"
      ]
    }
  ]
}
