{
  "info": {
    "authors": [
      "T. Mark Ellison"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-2163",
    "title": "Phonological Derivation in Optimality Theory",
    "url": "https://aclweb.org/anthology/C94-2163",
    "year": 1994
  },
  "references": [
    "acl-J94-1003"
  ],
  "sections": [
    {
      "text": [
        "Summary: Optimality Theory is a constraint-based theory of phonology which allows constraints to conflict and to he violated.",
        "Consequently, implementing the theory presents problems for declarative constraint-based processing frameworks.",
        "On the basis of two regularity assumptions, Ilia sets are regular and that constraints can be modelled by transducers, this paper presents and proves correct algorithms for computing the action of constraints, and hence deriving surface forms."
      ]
    },
    {
      "heading": "INTRODUCTION",
      "text": [
        "Recent years have seen two major trends in phonology: theories have become more oriented around constraints than transformations, while implementations have come to rely increasingly on finite state automata and transducers.",
        "This paper seeks to build a bridge between these trends, showing how one constraint-based theory of phonology, namely Optimality 'theory, might be implemented using finite-state methods.",
        "'the paper falls into three main sections.",
        "The first describes Optimality Theory and its restriction to constraints which can only make binary distinctions in harmony.",
        "The second part covers the formalisation of the evaluation of harmony, including the simplifying assumptions that the set of candidate forms must initially be regular, and that the action of each constraint in assigning harmony also be regular.",
        "The third section presents algorithms !Or (i) defining the product of automata model hng constraints, (ii) finding the optimal level of harmony of a set of candidates and (iii) culling suhoptimal candidates.",
        "The last two algorithms are proved correct, and sonic worst-case complexity results are given.",
        "The paper concludes with a discussion of the work."
      ]
    },
    {
      "heading": "OPTIMALITY THEORY",
      "text": [
        "Optimality Theory (OT) is a constraint-based theory of phonology, developed by Prince and Smolensky (1993) (hereafter, this work will be referred to as P&S) and is now being used by a growing number of phonologists (Ito and Mester 1993, McCarthy and Prince 1993, McCarthy 1993).",
        "It differs from declarative phonology (Bird 1994, Scobbie 1991, Bird and Ellison 1994) in that its constraints are violable and can conflict, with the conflicts resolved by an",
        "ordered system of defaultsl.",
        "Declarative phonology evaluates candidate forms on a binary scale: whether they are accepted by a constraint system or not.",
        "In contrast, OT assigns a ranking to all of the candidate realisations of a word, calling the scale a measure of harmony.",
        "All of the candidates which show the maximal amount of harmony are accepted by the constraint systein, and others are rejected.",
        "A derivation in OT consists of an original candidate set produced by a function called and the subsequent application of constraints to reduce the candidate set, eliminating non-optimal candidates and preserving those with the greatest harmony.",
        "At no stage can a constraint eliminate all candidates.",
        "Hach constraint assigns to each candidate a list of marks.",
        "These marks may, for instance, tag segments as regular or exceptional.",
        "The marks are values on the harmony scale, and are totally ordered: for any two marks a and either a is more harmonic than b (symbolically, a I) or the reverse.",
        "In the list assigned to a candidate, however, the same mark may occur many times, '1.0 compare the harmony of two candidates with regard to a given constraint, their respective lists of marks arc sorted into increasing order of harmony3.",
        "The lists are then compared lirst-lolast componentwise.",
        "'the more harmonic candidate has the more harmonic value at the first point where the lists differ.",
        "The empty list always has the same harmony as the most harmonic mark on the harmony scale, common to all constraints, which we will call the zero mark, and write as 04.",
        "Constraints which only use two different marks arc called binary constraints.",
        "I-or binary constraints, the evaluation 01' harmony is a simple affair.",
        "The candidate with the fewest non-zero marks is preleffed.",
        "Consider, for example, the binary constraint ONs(P&S:25).",
        "This constraint discourages nuclei without onsets when selecting between different syllabifications.",
        "Two syllabifications of the Arabic segmental sequence al-qalamu are shown in (I), with syllables demarcated by parentheses.",
        "The nuclei are always the vowels, The disbar-Ellison (1994) offeis a formal analysis of the use of defaults in Optimality Theory.",
        "2 In constraint-based theories, constraints impose limits on possible realisations of objects, such as words or sentences.",
        "A candidate is a tentative realisation which is yet to be tested against the constraints.",
        "'Early in their technical report, PSzS introduce one constraint, FINtiC, which requires sorting into the reverse order.",
        "Later in the saute work they replace this constraint with a number of binary constraints with the usual ordering.",
        "monic mark L indicates on onsetiess nucleus, the harmonic (zero) mark 0 is used for other segments.",
        "In this example, the sorted lists of marks differ in the second position with the first candidate, (a1)(qa)(1a)(mu), being the more harmonic of the two.",
        "When there is more than one constraint, we must consider not only the ordering of marks assigned by one constraint, but the ordering of marks from different constraints.",
        "In OT, constraints arc placed in a total order (C1 C2), and all non-zero marks of higher-ranked constraints (C1) are less harmonic than all non-zero marks of lower-ranked constraints (C2).",
        "In effect, this means that higher-ranked constraints have priority in eliminating candidates.",
        "For all constraints, however, the zero mark has the same, maximally harmonic, value.",
        "binarity So far we have considered a general class of constraints including non-binary constraints.",
        "As it happens, non-binary constraints can often he replaced by binary constraints.",
        "Binary constraints are those which only assign two marks: the zero mark, and one other.",
        "In the simplest case, restating a constraint in a logically equivalent form can transform a non-binary constraint into a binary constraint.",
        "The constraint family EDGEMOST is defined by P&S(p35) as (2).",
        "(2) EDGEMOST(0; E; D).",
        "The item 0 is situated at the edge E of domain D. This definition covers a family of constraints depending on the instantiations of the arguments: E is either left (L) or right (R), domain may be syllable, foot or word, and can be any phonological object, such as stress or an affix.",
        "According to P&S, constraints of this form are non-binary, returning as their marks the distance of their objects from the designated edge of domain.",
        "The greater the distance, the less harmonic the mark.",
        "Constraints of this kind can, however, be replaced by logically equivalent binary constraints (3).",
        "(3) NOINTERVENING(0; E; D).",
        "There is no material intervening between 0 and edge E of domain D. This form of constraint assigns a disharmony mark to each item intervening between 0 and edge E. The more material lying between 0 and E, the greater the number of marks and so the lower the harmony value.",
        "Other types of non-binary constraints can be converted into hierarchies (ordered sequences) of binary constraints.",
        "Suppose a constraint C produces N different kinds of marks.",
        "Applied to a candidate form c, this constraint produces a list C(e) of marks.",
        "Now define a function .1' which takes a list of marks, 1, and a mark type rn, and replaces all marks in 1 which are different from m by the zero mark 0, and then resorts the list.",
        "So with the marks 2 1 0, then f (2210, 2) is 2200 and f (2210, 1) is 1000.",
        "If the marks generated by C are 0= rni >- m2 ›-- ITIN, then C can be replaced by constraints Ci,i= N _1 such that Ci (c) = f (C(c), i) subject to the ordering Ci>.- -Cj if i > j.",
        "To see the equivalence of the single non-binary constraint with the family of binary constraints, let us look at the comparison of some candidate forms.",
        "Using the three-valued constraint of the earlier example, suppose candidates M, N and P are assigned mark lists 102, 21012 and 0122 respectively.",
        "Sorted, these lists become 210, 22110 and 2210.",
        "Comparing these lists, we arrive at the harmony ordering M P N. Now, let us apply the corresponding binary constraints.",
        "The first and dominant constraint preserves only 2s in the mark list, the second preserves only the mark I.",
        "The two lists of marks for M, N and P are 200 and 100, 22000 and 11000, and 2200 and 1000, respectively.",
        "By the ordering of the constraints, we know that 2 1 still, and so merging the two lists of marks for each candidate gives 210000, 221.1000000 and 22100000.",
        "Apart from the trailing Os, these are identical to the marks assigned by the single constraint, and so lead to the same ordering: M P N. So all constraints which use a finite alphabet of marks, and some which do not, such m EDGEmosT constraints, can he translated into binary constraints or a finite sequence of binary constraints.",
        "Consequently, formalising binary constraints and their interaction will be enough to capture the bulk of constraints in OT."
      ]
    },
    {
      "heading": "FORMALISATION",
      "text": [
        "The formalisation of OT developed here makes uses three idealising assumptions (4).",
        "(4) 1.",
        "All constraints are binary.",
        "2.",
        "The output of GEN is a regular set.",
        "3.",
        "All constraints are regular.",
        "We have already seen that most non-binary constraints can be recast as binary constraints or families of binary constraints.",
        "Unfortunately, P&S are not explicit about whether there are other unbounded non-binary constraints (like EDGEMOST) – there may be some which cannot be recast as binary constraints.",
        "Assumption I is, therefore, an idealisation imposing a slight limitation on the theory."
      ]
    },
    {
      "heading": "regular gen",
      "text": [
        "The second assumption requires that the output of GEN be regular.",
        "Recall that GEN is the function which produces the initial set of candidate forms which is reduced by the constraints.",
        "In other words, the set of candidates must he initialised to a set which can be defined by a regular expression, or, equivalently, by a finite-state automaton (ESA).",
        "As an example, (5) shows a regular expression giving a subset of the candidate syllabifications of alqalamu according to the syllabification rules of P&S(p25).",
        "The set does",
        "not include all candidates; for clarity I have omitted partial syllabi heat ions in which segments have not been assigned a syllabic role, and completely empty syllables.",
        "The set does include syllabic slots which do not correspond to segments.",
        "In such slot-segment pairs, the empty segment is written as 0.",
        "an t 0 }la 0 The brackets cover disjunctions of terms separated by vertical bark while concatenation is expressed by juxtaposition.",
        "The vertical pairs of symbols arc the complex labels used on arcs in the corresponding automaton.",
        "The three syllabic slot types are onset (0), nucleus (N) and coda (C).",
        "As a regular expression, (5) captures 64 different possible syllabifications of the sequence algalamu.",
        "For example, the syllabification (a1)(qa1)(am)(u) is accepted by the (5), while (alq)(aI)(am)(u) is not."
      ]
    },
    {
      "heading": "regular constraints",
      "text": [
        "The third assumption imposes regularity on constraints.",
        "A constraint is regular if there is a finite-state transducer!'",
        "(EST) which assigns the same list of marks to a candidate form that the constraint does.",
        "Since we arc only dealing with binary constraints, the transducer will associate with each component of the candidate one of the two harmonic values c 0.",
        "Such transducers can be expressed as regular expressions over pairs of phonological material and marks.",
        "P&S (p25) use two constraints, Flu.",
        "(6) and ONs (7), to account I'm the limits on epenthesis in Arabic.",
        "IMenthetic material arises when syllabic slots which are not.",
        "occupied by segments are realised.",
        "Here the marks are given on the right hand side of the colon in each pair.",
        "Here c is the disharmonic mark, and 0 the more harmonic zero mark.",
        "(6) I'll.L.",
        "Syllable positions are filled with segmental material.",
        "(7) ONS.",
        "Every syllable has an onset.",
        "These two constraints can be readily translated into regular expressions, using the abbreviatory notations: N for onset or coda, () for segmental material and • for anything.",
        "The transducers for Fitt and ONS arc defined by the regular expressions in (5) and (9) respectively.",
        "(5) 0 • • 0 0 'Ibis transducer marks with c every syllabic slot associated with an empty (0) segment.",
        "(9)",
        "T'A finite state transducer is an I 'SA which is labelled with pairs of values.",
        "In this case, the pairs will combine phonological information with constraint marks.",
        "This transducer is non-deterministic, producing more than one sequence of marks for a given input.",
        "All nuclei preceded by an onset are marked with 0 and with c. All other segments segments are marked as 0.",
        "The multiple evaluations of candidates is not a problem: candidates will survive so long as their best evaluation is as good as the best of any other candidate."
      ]
    },
    {
      "heading": "linearity",
      "text": [
        "The reader may he concerned that the regularity constraint imposes undue restrictions of linearity on the candidate forms, and, in doing so, vitiates the phonological advantages of non-linear representations.",
        "This is not the case.",
        "Bird and Ellison (1992,1994) have shown that it is possible to capture the semantics of autosegmental rules and representations using FSAs.",
        "The output of GEN, therefore, may correspond to a set of partially specified autosegmental representations, and still be interpreted as a regular set."
      ]
    },
    {
      "heading": "candidate comparison",
      "text": [
        "For single binary constraints, the harmony of candidates is compared as sorted lists over the alphabet containing ( and 0, where 0 has the higher harmony, the same, in fact., as the empty list.",
        "Consequently, the results of comparing lists of these marks is identical with comparing #c.11(() where Itc is the number of times c occurs in the list, and /t(c) is the constant quantity of harmony assigned to As 0 has the same harmony as the empty list, It(0) must be zero.",
        "As t 0, comparison is preserved if h(c) < 0, so we set h(c) I.",
        "If the arcs in the transducer are labelled with – 1 and 0 instead of c and 0, then the harmony of a candidate can be evaluated by just adding the numbers along the corresponding path in the constraint transducer.",
        "The greater the (always non-positive) result, the more harmonic the candidate.",
        "Just as we can measure harmony relative to a single constraint with a single integer, we can measure the harmony relative to an ordered hierarchy of constraints with an ordered list of integers.",
        "The list of integers corresponds one-to-one to the constraints in decreasing order of dominance.",
        "Each integer maintains information about the number of c. values of the corresponding constraint in the evaluation of the candidate.",
        "A candidate with the list (-2, I) violates the first constraint twice and the second once: the corresponding sorted list of harmony marks is 221.",
        "Lists of this form can be compared just like lists of harmony marks.",
        "The first integer is the most significant and the last the least.",
        "The greater of two lists is the one with the higher value at the most significant point of difference.",
        "For example (-10, – 31, – 00) is more harmonic than (>) (-10, – 34, – 12).",
        "Lists of integers can be accumulated like single integers using componentwise addition.",
        "We can generalise transducers from denoting single constraints to denoting hierarchies of constraints: from translating candidates into sequences of (0, €1 or )0, – 1) marks to transducers from candidates to sequences of lists of integers, each integer drawn from )0, – 1}.",
        "Summing the lists",
        "along a path gives a harmonic evaluation of the corresponding candidate.",
        "Let us call the length of the integer list the degree of the transducer.",
        "The output of GEN is an automaton – a transducer without marks – and so corresponds to a transducer of degree 0.",
        "The transducer for a single constraint needs only a single binary distinction for its marks, so a degree I transducer suffices.",
        "In general, the number of binary constraints that a transducer encodes will equal its degree.",
        "The next section looks at how transducers of single constraints or small hierarchies can be combined into single transducers for larger hierarchies."
      ]
    },
    {
      "heading": "ALGORITHMS product",
      "text": [
        "We have seen how a single constraint can be regarded as a transducer from candidate segments into a singleton list of integers, and further that multiple constraints can be evaluated using longer lists of integers.",
        "Combining these two notions into an extended version of the automaton product operation allows us to build up transducers capturing a hierarchy of constraints from single constraint transducers.",
        "The product operation is easier to describe when transducers are thought of in terms of automata rather than regular expressions.",
        "For brevity, then, the algorithms will be phrased in terms of the states and arcs of an automaton, while, for clarity, regular expressions will he used to present the inputs and outputs of examples.",
        "The pseudocode for the standard automaton product operation appears in (10).",
        "As the initial states of any automaton can be identified with each other without affecting the language recognised, and similarly the final states, we will assume that there is only a single initial state (I) and final state (F) in each automaton.",
        "In this pseudocode, semicolons are followed by comments."
      ]
    },
    {
      "heading": "7 labelled MnAf",
      "text": [
        "The pseudocode in (10) applies to two automata A and B, over the same alphabet, and constructs their product A x B, an automaton which accepts only those strings accepted by both A and B.",
        "Each combination of arcs, one from A and one from B, which could be traversed while reading the same input, that is, an input in the intersection ./Vf n.AT of the labels of the two arcs, defines an arc in the product automaton.",
        "To make the product mimic the combination of constraints in OT, we need to introduce an asymmetric operation on the lists of marks: concatenation.",
        "Each arc in each automata passed to this product operation is labelled not only with a set of possible phonological segments, but also a list of harmony marks.",
        "When two arcs are combined, these lists are concatenated.",
        "The pseudocode for this augmented product operation appears in (I 1).",
        "4 for each are from z to t in B labelled Al'a, if )14nN\" 0",
        "Because concatenation is not a symmetric operation, the augmented product does not commute: A x 93 does not assign the same marks to candidate forms as BxA.",
        "The difference in interpretation is that A x B regards all constraints in A as higher priority than all constraints in B, whereas BxA instantiates the reverse ordering.",
        "The augmented product operation provides a way of combining two constraints into a single transducer.",
        "As an example, (12) is the product of the transducers corresponding to the constraints ONS (9) and FILL (8) in that order.",
        "The product is the crucial operation for implementing OT.",
        "The product of the regular expression or automaton produced by GEN with all of the constraints in order produces a transducer encoding the harmony evaluations of all candidates.",
        "Let us call it the surface transducer.",
        "To evaluate the harmony of any fully specified candidate, we need only follow the corresponding paths in the surface transducer accumulating the integer lists associated with each arc.",
        "The path with the greatest total harmony is the crucial one for deciding whether the candidate is optimal or not.",
        "The surface transducer which is the product of the candidate syllabifications of algalamu with the constraints ONs and FILL, in that order, is shown in (13).",
        "implement this part (tithe derivation, we need to remove all paths from the surface transducer which do not accumulate optimal values of harmony.",
        "The algorithms in this section and the next are designed to achieve this task, and will be proven to do so.",
        "The first algorithm (14) assigns to every slate N the harmony value of the optimal path to it from the initial state, storing this value in the field harmony(N).",
        "Since there is only a single final state, 17, harmony(F) will contain the harmony evaluation of all optimal candidates.",
        "1 he algorithm sets the harmony of the in nal slate to zero, and places the initial state in an otherwise empty list.",
        "The most optimal member in the list is expanded (lines 6-1.5) and removed from the list.",
        "When a state is expanded, all of the arcs from it are examined in turn.",
        "If any o them point to states with undefined harmony values, the harmony of the state being expanded, and of the arc, are used to calculate the harmony value of the other state and it is added to the list.",
        "If the arc points to a state with a defined harmony value, the harmony value of the better path is retained by that state, and its position in the sorted list adjusted appropriately.",
        "If the list is kept sorted, inserting each new state in order of the value of its harmony field then, in the worst case, o(logislales1) comparisons of harmony values will need to be done for an insertion into the list where Hlaies is the set of states in the transducer and arcs the set of arcs.",
        "As each state is expanded only once, each arc is examined only once.",
        "So larrsI forms an upper bound on the number of insertions that need to be done.",
        "The single comparison on line 9 is insignificant in relation to the comparisons used in insertion.",
        "So an upper bound on order of the worst ease execution of this algorithm is o(lares1 log istalcsI) comparisons.",
        "It is not obvious that this algorithm will, in fact, label each state with the harmony of the optimal path to it, so a proof follows.",
        "(15) Lemma.",
        "When state M is being expanded (lines 6 15), the true harmony value of the optimal path to M, namely /t(M), and the computed value, harmony(M), are equal, if the same is true for all previously expanded states.",
        "Proof.",
        "Case <.",
        "Suppose the lemma is false, and that h(M)>harmony(M).",
        "Then there is an optimal path p.a.",
        "(' where p is a (possibly null) path, a is an arc from an already expanded state R to an unexpended state S and q is another (possibly null) path.",
        "There will always he such a path as 34 is reachable from the initial state, and the initial state is the first one expanded.",
        "Tills path is optimal, so 6(M) /t(R) I h(a) I /40 which in turn is less than or equal to h(R) 1 • It(a) as It is always non-positive.",
        "Putting this inequality together with the supposition of the lemma that harmony and It match for all expanded nodes, gives the following inequality:",
        "A lower hound for harmony(S) was set when R was expanded.",
        "As R is already expanded /i(R)=harmony(R), and consequently harmony(S)>Intrmony(M) which contradicts the minimality of the choice of M (line 6 of algorithm (14)).",
        "Thus h(M)<harmony(M).",
        "Case >.",
        "I f M is in list, then harmony(M) must be defined and set at a value < /6(M).",
        "Thus the equality of harmony(M) and 6(M), and the lemma.",
        "When M is the initial state the result follows immediately front line 3 which sets harmony(I) to zero.",
        "(16) Theorem.",
        "After the application oh LAnfii,Noms, for all states N on which harmony(N) is defined, harmony(N) is the harmony of the optimal path to N. Proof.",
        "By the lemma and induction on the sequence of expansion of states.",
        "❑ We can mimic the labelling of nodes in the transducer with harmonic evaluations by labelling disjuncts in regular expressions with harmonic values.",
        "The value of a whole disjunction is most harmonic value amongst the disjuncts.",
        "As before, the harmonic evaluations arc added during concatenation.",
        "The evaluations for the surface transducer (13) of algalamtt are shown in (17).",
        "The evaluation of the optimal path in the transducer is (0,- I )."
      ]
    },
    {
      "heading": "pruning",
      "text": [
        "Having determined the harmony value of the optimal path to the final state, and others, it only remains to remove suboptimal paths.",
        "As it happens, this can be easily done by removing all arcs which cannot occur in an optimal path (18).",
        "If the sum of the harmony of an arc, and the harmony of the optimal path to the state it comes from, is less than the harmony of the state the arc goes to, then that means that there is a more optimal path to the second state which will always be preferred.",
        "Consequently this arc can never be part of an optimal path.",
        "It is, therefore, safe and appropriate to delete it.",
        "The complexity, in the number of comparisons performed, of this algorithm is identical to the number of arcs in the transducer.",
        "This is of lower order than the worst-case complexity for LABELNODES, so the complexity of the combined algorithm is still o(lares I log Istatesp comparisons.",
        "It is not immediately obvious that the only paths which can be formed by the remaining arcs are optimal.",
        "This is, however, the case.",
        "(19) Theorem.",
        "After the application of LABELNODES and PRUNE there are no non-optimal paths from the start state to any state.",
        "Proof.",
        "By induction on the length of the path.",
        "P(n) = After the application of LABELNODES and PRUNE there is no non-minimal path of length a from the initial state to any other state.",
        "Base case.",
        "P(0) is trivially true, as there is only a unique path of length zero.",
        "Step.",
        "Assume P(k) is true.",
        "Suppose we have a non-optimal path of length k 1.",
        "By the assumption, this must consist of an optimal path of length k followed by a non-optimal arc a from M to N. a would have been deleted unless harmony(M)+harmony(a)harmony(N).",
        "But, by theorem (16), harmony(N) is the harmony or the optimal path to N. So harmony(M)+harmony(a)<harmony(N), and the path must be optimal.",
        "This contradicts our supposition, and so P (k I) is true.",
        "The theorem follows by induction.",
        "❑ Consequently, the only paths front the initial state to the final state will be optimal and define optimal candidates.",
        "The regular expression corresponding to the culled automaton describing the syllahifications of algalamo appears in (20).",
        "It includes only a single candidate syllabification of the sequence."
      ]
    },
    {
      "heading": "Discussion",
      "text": [
        "The work described in this paper was based on the Optimality Theory of Prince and Smolensky (1993), making three additional assumptions:",
        "1.",
        "All constraints are binary, or can he recast as binary constraints.",
        "This seems to be true of all constraints used by P&S. 2.",
        "That the initial set of candidates, the output or GEN, is a regular set which can be specified by a finite-state automaton.",
        "3.",
        "Each constraint can be implemented as a regular tran",
        "sducer which determines the list of marks for each candidate.",
        "On the basis of these assumptions, the following developments were made:",
        "• Transducers were defined which computed not just a single constraint, but an ordered hierarchy of constraints.",
        "• An algorithm for a product operation on these transducers was given.",
        "With this operation transducers representing constraints could be applied to sets of candidates, and also be combined into transducers representing collections of constraints.",
        "• Algorithms were presented for – finding the harmony of the optimal candidate in a transducer, and – culling all non-optimal paths from a transducer.",
        "• These algorithms were proved to fulfill their goals.",
        "• The worst-case complexity of the combined algorithm in terms of harmony comparisons was found to be less than o(laresi log Istaics I), for a given transducer.",
        "Using the assumptions and algorithms given here, there are three stages to computing a derivation in OT: .",
        "Specify the regular class of candidates as an automaton.",
        "2.",
        "Build up the product of this automaton with the transducers of each constraint in decreasing order of priority.",
        "3.",
        "Cull suboptimal paths.",
        "There arc a three more points worth noting.",
        "Firstly, the constraints in a hierarchy can be precompiled into a single transducer.",
        "Each application to a set of candidates then only requires a single product operation followed by a cull.",
        "Secondly, casting the output of GIN and all constraints as regular means that, at all stages in a derivation, the set of candidates is regular.",
        "This is because the Output of the product and culling operations are regular --- both return Finally, this specification of 01' in terms of regular sets and finite-state automata opens the way for more rigorous exploration of the differences between OT and declarative phonological theories, such as One-Level Phonology (Bird and I tHison 1994), which is a constraint-based phonology that defines inviolable constraints with automata."
      ]
    }
  ]
}
