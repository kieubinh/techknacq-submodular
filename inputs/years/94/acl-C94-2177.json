{
  "info": {
    "authors": [
      "Hagen Langer"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-2177",
    "title": "Reverse Queries in DATR",
    "url": "https://aclweb.org/anthology/C94-2177",
    "year": 1994
  },
  "references": [
    "acl-E89-1009",
    "acl-E93-1012",
    "acl-J92-3001"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "DAT11.",
        "is a declarative representation language for lox-lea!",
        "information and as such, in principle, neutral with respect to particular processing strategies.",
        "Previous DA\"1\"11, compiler/interpreter systems support only one access strategy that closely resembles the set of infer-once rules of the procedural semantics of DAT11 (Evans Gazdar 1989a).",
        "1.n this paper we present an alternative access strategy (rrocr.so query strategy) for a non-trivial subset of DATE.."
      ]
    },
    {
      "heading": "1 The Reverse Query Problem",
      "text": [
        "DATE (Evans gr, Gazdar 1989a) has become one of the most widely used formal languages for the representation of lexical information.",
        "DATE, applications have been developed for a wide variety of languages (including English, .1apanese, Kikuyu, Arabic, 1.atin, and others) and many different subdomains of lexical representation, including inflectional morphology, underspecification phonology, non-concatenative morphophonology, lexical semantics, and tone systems'.",
        "We presuppose that the reader of the present paper is familiar with the basic features of DATE, as specified in Evans K.:: Gazdar [1.989a].",
        "The adequacy of a lexicon representation forntalisnn depends basically on two major factors:",
        "• its declarative expressiveness: is the formalism, in principle, capable of representing the phenomena in",
        "*This research was partly supported by the (4erman Federal Ministry of Research and Technology (13MfT, project VERB-MOBIL) at the University of Bielefeld.",
        "I would like to thank Dafydd Gibbon for very useful continents on an earlier draft of tins paper.",
        "I See Cahill [1993], Gibbon [1992], Gazdar [1992], and Kilbury [1992] for recent DATR applications in these areas.",
        "Au informal introduction to 1)N.I'lt is given in Gazdar [1990].",
        "The standard syntax and semantics of DATIt is defined in Evans k Gazdar [1989a, 1989b].",
        "Implementation issues are discussed in Gibbon Sr Ahoua [1991], Jenkins [1990], and hi Gibbon [1993[.",
        "Moser [1992a, 1992b, 1992e, 1992d] provides interesting insights into the formal properties of I Milt (see also the DATR representations of finite state automata, different kinds of logics, register operations etc, in Evans Gazdar [1990], and Langer [1993]).",
        "Audry et, al.",
        "[1993] describe how DATIt can Is used in speech-oriented applications.",
        "question, and does it allow for an explicit treatment of generalisations, subgeneralisations, and ex-ceptions'?",
        "• its range of accessing stmtegzes: are there accessing strategies for all applications which presuppose a lexicon (e.g. parsing, generation, ...), and do they support, the development, maintenance, and evaluation of lexica in an adequate manner?",
        "Most of the previous work on DA111, has focussed on the former set of criteria, i.e. the declarative features of the language, its expressive capabilities, and its adequacy for the reformulation of pre-theoretic informal linguistic concepts.",
        "'Phis paper is mainly concerned with the latter set of criteria of adequacy.",
        "However, in the case of DATE., the limited access in only one direction has led to a somewhat procedural view of the language which, in particular cases, has also had an impact on the declarative representations themselves.",
        "DATE, has often been characterised as a functional and deterministic language.",
        "These features are, of course, not properties of the language itself, but rather of the language together with a particular procedural interpretation.",
        "Actually, the term deterministic is not applicable to a declarative language, but only makes sense if applied to a procedural language or a particular procedural interpretation of a language.",
        "The DATE, interpreter/compiler systems developed so fare have in common that they support, only one way of accessing the information represented in a DATE, theory.",
        "This access strategy, which we will refer to as the standard procedural interpretation of DATR, closely resembles the inference rules defined in Evans Kr, Gazdar [1989a].",
        "Even if one considers DA H, neither as a tool for parsing nor for generation tasks, but rather as a purely representational device, the one-way-only access to DATE, theories turns out to be one of the major drawbacks of the model.",
        "One of the claims stated fill.",
        "DATR in Evans k Gazdar [1989] is that it, is computationally tractable.",
        "But for many practical purposes, including lexicon development and evaluation, it is not, sufficient that there is any",
        "arbitrary accessing strategy at all, but there should be an appropriate way for accessing whatever information that is necessary for the purpose in question.",
        "This is a strong motivation for investigating alternative strategies for processing DATR representations.",
        "This paper is concerned with the reverse query problem, i.e. the problem how a given DATR value can be mapped onto the queries that evaluate to it.",
        "A standard query consists of a node and a path, e.g. Sheep:<orth plur>, and evaluates to a sequence of atoms (value), e.g. sheep.",
        "A reverse query, on the other hand, starts with the value, e.g. sheep, arid queries the set of node-path pairs which evaluate to it, for instance, Sheep:<orth sing> and Sheep:<orth plur>.",
        "Our solution can be be regarded as an inversion of the parsing-as-deduction approach of the logic programming tradition, since we treat reverse-query theorem proving as a parsing problem.",
        "We adopt a wellknown strategy from parsing technology: we isolate the context-free \"backbone\" of DAM.",
        "and use a modified chart-parsing algorithm for CF-PSG as a theorem prover for reverse queries.",
        "For the purposes of the present paper we will introduce a DATR notation that slightly differs from the standard notation given in Evans & Gazdar [1989] in the following respects:",
        "• the usual DATR.",
        "abbreviation conventions are spelled out • the global environment of a DATR descriptor is explicitly represented (even if it is uninstantiated) • each node-path pair N:1' is associated with the set of extensional suffixes of N:1) that are defined within the DATR theory",
        "In standard DATR notation, what one might call a non-terminal symbol, is a node-path pair (or an abbreviation for a node-path pair).",
        "In our notation a DATR nonterminal symbol is an ordered set [N, P, C, N', P'].",
        "N and N' are nodes or variables ranging over nodes.",
        "P and P' are paths or variables ranging over paths.",
        "C is the set of path suffixes of N:P. A DATR terminal symbol of a theory 0 is an atom that has at least one occurence in a sentence in 0 where it is not an attribute, i.e. where it does not occur in a path.",
        "The suffix-set w.r.t.",
        "a prefix p and a set of sequences S (written as a(p, S)) is the set of the remaining suffixes of strings in S which contain the prefix p: a(p, S) ="
      ]
    },
    {
      "heading": "Islp^s E S}.",
      "text": [
        "Let N:P be the left hand side of a DATR, sentence of some DAM theory 0.",
        "Let be 1-1 the set of paths occurring under node N in 0.",
        "The path extension constraint of P w.r.t.",
        "N and 0 (written as C(P,N,0), or simply C) is defined as: C (P, N, 0) = (P, II).",
        "Thus, the constraint of a path P is the set of path suffixes extending P of those paths that have P as a prefix.",
        "Example: Consider the DATR.",
        "theory 0:",
        "The constraint of <> (w.r.t.",
        "N and 0) is { <a>, <a b> } , the constraint of <a> is { < b > } , and the constraint of <a b> is 0.",
        "We say that a sequence S = sr .",
        "s„ (1 < n) satisfies a constraint C E Clx^ X = =0 (i.e. a sequence S satisfies a constraint C iff there is no prefix of S in C).",
        "Now having defined some basic notions, we can give the rules that map standard DATR notation onto our representation:"
      ]
    },
    {
      "heading": "Mapping rules",
      "text": [
        "How these mapping principles work can perhaps best be clarified by a larger example.",
        "Consider the small DATE theory, below, which we will use as an example case throughout this paper:",
        "The application of the mapping rules to the DATR theory above yields the following result (unstantiated variables are indicated by bold letters):",
        "The general aim of this (soniewhat redundant) notation is to put everything that is needed for drawing inferences from a sentence (especially its global environment and possibly competing clauses at the same node) into the representation of the sentence itself.",
        "Similar internal representations are used in several DATR, implementations."
      ]
    },
    {
      "heading": "2 Inference in DATR",
      "text": [
        "Both standard inference and reverse query inference can be regarded as complex substitution operations defined for sequences of DATR terminal and non-terminal symbols which apply if particular matching criteria are satisfied.",
        "In case of DATR standard procedural semantics, a step of inference is the substitution of a DATR nonterminal by a sequence of DA'.fil terminal and nonterminal symbols.",
        "The matching criterion applies to a given BATH.",
        "query and the left hand sides of the sentences of the DATR theory.",
        "If the LHS of a DATR.",
        "sentences satisfies the matching criterion, a modified version of the right hand side is substituted for the LIIS.",
        "Since the matching criterion is such that there is at most one sentence in a DA .11, theory with a matching LHS, BATH, standard inference is deterministic and functional.",
        "The starting point of BATH.",
        "standard inference is single nonterminal and the derivation process terminates if a sequence of terminals is obtained (Or if there is no LIB in the theory that satisfies the matching criterion, in which case the process of inference terminates with a failure).",
        "In terms of DAM.",
        "reverse query procedural semantics, a step of inference is the substitution of a subsequence of a given sequence of BATH.",
        "terminal and non-terminal symbols by a BATH.",
        "non-terminal.",
        "The matching criterion applies to the subsequence and the right hand sides of the sentences of the DATR theory.",
        "if the matching criterion is satisfied, a modified version of the LHS of the BATH, sentence is substituted for the matching subsequence.",
        "In contrast to DATR standard inference, the matching criterion is such that there might be several DATR, sentences in a given theory which satisfy it.",
        "DATR, reverse query inference is hence neither functional, nor deterministic.",
        "Starting point of a reverse query is a sequence of terminals (a value).",
        "A derivation terminates, if the substitutions finally yield a single nonterminal with identical local and global environment (or if there are no matching sentences in the theory, in which case the derivation fails).",
        "We 110W define the matching criteria for DATI1 terminal symbols, DATR nonterminal symbols and sequences of DATR.",
        "symbols.",
        "These matching criteria relate extensional lemmata (i.e. already derived partial analyses) to DATII, definitional sentences (i.e. \"rules\" that Inay yield a further reduction) w.r.t.",
        "a given DATR, theory 0.",
        "A terminal symbol tt matches another terminal symbol 12 HI l = t2.",
        "We also say that ti matches 12 with, art arbitrary suffix and an empty constraint in order to provide compatibility with the definitions for nonterminals, below.",
        "1.",
        "A nonterminal [N, , P'] matches another nonterminal [N, P2 , C2, N', PI with a suffix E and a constraint C2 if (a) P2 = PPE, and (b) F satisfies 2.",
        "A nonterminal [N,Pi,C1 , N' X] matches another nonterminal [N , P2, C2, .N',1''] with an empty suffix and a constraint a (P , C2) if (a) Pi = 1 1';, and (b) F satisfies C2.",
        "Example: The non-terminal symbol [Node, <a b>, {<c d N[ , P([ matches [Node, <a b c d>, 0, N/2, ./.3] with suffix S = <c d> and constraint 0.",
        "From the definitions, given above, we can derive the matching criterion for sequences:",
        "1.",
        "The empty sequence matches the empty sequence with an empty suffix and constraint 0.",
        "2.",
        "A non-empty sequence of (terminal and nonterminal) symbols SI s'„ (1 < n) matches another sequence of (terminal and non-terminal) symbols sf s„ with suffix F and constraint C if (a) for each symbol si (1 < i < matches s; with suffix F and constraint and (1)) C U C2 U Cn.",
        "To put it roughly, this definition requires that the symbols of the sequences match one another with the same (possibly empty) suffix.",
        "The resulting constraint, of the sequence is the union of the constraints of the symbols.",
        "Example: The string of nonterminal symbols [N1,<a>,CI,N'1,P'1] [1\\1.2,<x>,C2,N'2,1\"2] matches [N1,<a b>,{<c>,<d>},N1 ,P'1] [N2,<x b>, {<e>},N'2,P'2] with suffix <b> and constraint {<c>, <d>, <e>}.3 3 The matching criteria, defined above, do not cover nonterminals with evaluate paths, i.e. paths that include (an arbitrary number of possibly recursively embedded) nonterminals.",
        "The matching criterion for nonterminals has to be extended in order to account for statements with evaluable paths: I,et be eval(a,c, 0) a function that, maps a string of DATE.",
        "terminal and nonterrninal symbols a = A,, onto a string of BATH.",
        "terminals a' such that (a) each terminal symbol Ai(1 < i < n) in re is mapped onto itself in a', and (b) each nonterminal A, = [N2, 1-1 (1 < j < n) in a is mapped onto the sequence ...aT in a' such that : PPe = rah ...a;\" in 0.",
        "'^' refers to (recur"
      ]
    },
    {
      "heading": "3 The Algorithm",
      "text": [
        "Metaphorically, DATR 'can be regarded as a formalism that exhibits a context-free backbone`.",
        "In analogy to a context-free phrase structure rule, a DATR sentence has a left hand side that consists of exactly one non-terminal symbol (i.e. a node-path pair) and a right hand side that consists of an arbitrary number of non-terminal and terminal symbols (i.e. DATR.",
        "atoms).",
        "In contrast to context-free phrase structure grammar, DATR nonterminals are not atomic symbols, but highly structured complex objects.",
        "Additionally, DATR differs from CF-PSG in that there is not a unique start symbol but a possibly infinite set of them (i.e. the set of node-path pairs that, taken as the starting point of a query, yield a value).",
        "Despite these differences, the basic similarity of DATR sentences and CF-PSG rules suggests that, in principle, any parsing algorithm for CF-PSGs could be a suitable starting point for constructing a reverse query algorithm for DATR..",
        "The algorithm adopted here is a bottom-up chart parser.",
        "A chart parser is an abstract machine that performs exactly one action.",
        "This action is monotonically adding items to an abstract data-structure called chart, which might be thought of as a graph with annotated arcs (which are also often referred to as edges) or a matrix.",
        "There are basically two different kinds of items:",
        "• inactive items (which represent completed analyses of substrings of the input string) • active items (which represent incomplete analyses of substrings of the input string)",
        "If one thinks of a chart in terms of a graph structure consisting of vertices connected by arcs, then an item can be defined as a triple (START, END, LABEL), where START and END are vertices connected by an arc labeled with LABEL.",
        "Active and inactive items differ with respect to the structure of the label.",
        "Inactive items are labeled with a category representing the analysis of the substring given by the START and END position.",
        "An active item is labeled with a category representing the analysis for a substring starting at START and ending at some yet unknown position X (END < X) and a list of categories that still have to sive) DATR path extension (cf. Evans Gazdar 1989a).",
        "Notice that e has no index and thus has to lie the same for all nonterminals Ai.",
        "Let X1 = [N, C1, N', be a nonterminal symbol including an evaluable path Pi.",
        "matches [N, P2, C2, N', 11 with a suffix E and a constraint (7,, if (a) eval(PL,E, 0) = sr, and (b) [N,Ir^E, , N', P'] matches [N, C2, N', P'] with suffix E and constraint Ca.",
        "(according to the matching criteria, defined above).",
        "be proven to be proper analyses of a sequence of connected substrings starting at END and ending at X. :For the purpose of processing DATR rather than CV-PSGs, each active item is additionally associated with a path suffix.",
        "Thus an active item has the structure: (START,END,CATO, CAT1 CAT„, SUFFIX) Consider the following examples: the inactive item (0, 1, [House,<orth sing>,1<gen>l,House,P1) represents the information that the substring of the input string consisting of the first symbol is the value of the query Housc:<orth sing> (with any extensional path suffix, but not gen) in the global environment that consists of the node House and some still uninstantiated path P'.",
        "The active item (0 4, [Noun , <orth> Mousey , [Mouse,<affix>,0,Mouse,P1,e) represents the information that there is a partial analysis for a substring of the input string that starts with the first symbol and ends somewhere to the right.",
        "This substring is the value of the query Noun:<orth> within the global environment consisting of the node House and some uninstantiated global path P', if there is a substring starting from vertex 1 that turns out to be the value of the query House:< a ix> in the same global environment Housc:P'.",
        "The general aim is to get all inactive items labeled with a start symbol (i.e. a DATR nonterminal with identical local and global environment) for the whole string which a derivable from the given grain-mar.",
        "There are different strategies to achieve this.",
        "The one we have adopted here is based on a chart-parsing algorithm proposed in Kay [1980].",
        "Mere is a brief description of the procedures: • parse is the main procedure that scans the input, increments the pointer to the current chart position, and invokes the other procedures",
        "• reduce searches the DATE theory for appropriate rules in order to achieve further reductions of inactive items",
        "add-epsilon applies epsilon productions complete combines inactive and active items add-item adds items to the chart We will now give a more detailed description of the procedures in a pseudo-code notation (the input arguments of a procedure are given in parentheses after the procedure Warne).",
        "Since the only chart-modifying operation is carried out as a side effect of the procedure add-item, there are no output values, at all.",
        "The procedure Parse takes as input arguments a vertex that indicates the current chart position (in the initial state this position is 0) and the suffix of the",
        "input string starting at this position.",
        "As long as the remaining suffix of the input string is non-enipty, parse calls the procedures add-epsilon, reduce, and complete, increments the pointer to the current, chart position, and starts again with the new current vertex.",
        "procedure parsc(VERTEX, variables: VERTEX, NEXT-VERTEX (integer) Si ...5„ (string of DATE, symbols) data: A DATE theory 9",
        "The procedure add-epsilon inserts arcs for the epsilon productions into the chart: procedure add-cpsilon(vEPTExi)",
        "variables: VERTEX (integer) data: A DATE, theory 0 begin for-each rule CAT /: in 0 call-proc reduce(VERTEX, CAT, VERTEX) call-proc complete(VERTEX, CAT, VERTEX) end",
        "The procedure reduce takes an inactive item as the input, argument and searches the DNI113, theory for rules that have a matching left, cornercategory.",
        "hbr each such rule found, reduce invokes the procedure add-item.",
        "procedure reduce( V ,CAT , V2 ) data: A DATE, theory 0 begin if is-terminal(CAT,) then for-each rule [N0,11)(),Cri iP '0] CAT, .",
        ".",
        ".",
        "CAT„ in 0 call-proc add-item(V , V2 ,[1\\10 ,P0,Co N 'Vs] CAT, ...CA'f,„,X) else for-each rule tN0,1)0,CO3N'n,l'of • CAT,' CAT„ in 0 such that, CAT,' matches CAT, with suffix S and constraint, C call-proc add-item( V >V21 a(S,C0),N's 'rob CAT2.",
        "• .CATiiiS)"
      ]
    },
    {
      "heading": "end",
      "text": [
        "The procedure complete takes an inactive item as au input argument and searches the chart for active items winch can be completed with it.",
        "The procedure add-item is the chart, modifying operation.",
        "It takes an active item as an input argument.",
        "If this active item has no pending categories, it is regarded as an inactive item.",
        "In fins case add-item inserts a new chart entry for the item, provided it is not already included in the chart, and calls the procedures reduce and complete.",
        "If the item is an active item, then it is inserted into the chart, provided it is not, already inside.",
        "procedure add-item(VI ,V2[N0,1)0,CO3Nio,10],",
        "(V, ,V2,[1\\10i1'ti,Co,N'o,4],CAT2 CATiii5) end"
      ]
    },
    {
      "heading": "4 Cycles",
      "text": [
        "A hard problem for DATR, interpreters are cycles, i.e. DATR statements and sets of DATE, statements which involve recursive definitions such that standard inference or reverse-query inference does not necessarily ter-mMate after a finite number of steps of inference.",
        "Here are some examples of cycles:",
        "o simple cycles: Ni<a> •--= <a>.",
        "• path lengtheninj«:yeles: Ni<a> <a a>.",
        "• path shortentny cycles: N:<a a> == <a>.",
        "While simple cycles have to be considered as semantically ill-formed and thus typically occur as typing errors only, both path lengthening and path shortening cycles occur quite frequently in many DATR representations.",
        "Note that path lengthening cycles turn out to be path shortening cycles in the reverse query direction, and vice versa.",
        "The DATR inference engine can be prevented from going lost in path-lengthening and path-shortening cycles by a limit on path length.",
        "This finite bound on path length can be integrated into our algorithm by modifying the add-item procedure such that only items with a path shorter than the permitted maximum path length are added to the chart."
      ]
    },
    {
      "heading": "5 Complexity",
      "text": [
        "CF-PSG parsing is known to have a cubic complexity w.r.t.",
        "the length of the input string.",
        "Though it is crucial for our approach that we exploit the CF-backbone of DATR for computing reverse queries, this result is of no significance, here.",
        "DATR is Turing-equivalent (Moser 1992d), and Turing-equivalence has also been shown for a proper subset of DATR (Langer 1993).",
        "These theoretical results may a priori outrule DATR, as an implementation language for large scale real time applications, but not as a development environment for prototype lexica which can be transformed into efficient task-specific on-line lexica (Andry et al.",
        "1992).",
        "With a finite bound on path length our algorithm works, in practice'', fast enough to be regarded as a useful tool for the development of small and medium scale lexica in DATR."
      ]
    },
    {
      "heading": "6 Conclusions",
      "text": [
        "We have proposed an algorithm for the evaluation of reverse queries in DATR.",
        "This algorithm makes DATR-based representations applicable for various parsing tasks (e.g. morphological parsing, lexicalist syntactic parsing), and provides an important tool for lexicon development and evaluation in DATR."
      ]
    }
  ]
}
