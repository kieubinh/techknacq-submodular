{
  "info": {
    "authors": [
      "Paul John King"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C94-2204",
    "title": "Typed Feature Structures as Descriptions",
    "url": "https://aclweb.org/anthology/C94-2204",
    "year": 1994
  },
  "references": [
    "acl-C94-2154"
  ],
  "sections": [
    {
      "heading": "ABSTRACT",
      "text": [
        "A description is an entity that can be interpreted as true or false of an object, and using feature structures as descriptions accrues several computational benefits.",
        "In this paper, I create an explicit interpretation of a typed feature structure used as a description, define the notion of a satisfiable feature structure, and create a simple and effective algorithm to decide if a feature structure is satisfiable."
      ]
    },
    {
      "heading": "INTRODUCTION",
      "text": [
        "Describing objects is one of several purposes for which linguists use feature structures.",
        "A description is an entity that can be interpreted as true or false of an object.",
        "For example, the conventional interpretation of the description `it is black' is true of a soot particle, but false of a snowflake.",
        "Therefore, any use of a feature structure to describe an object demands that the feature structure can be interpreted as true or false of the object.",
        "In this wiper, I tailor the semantics of [KING 1989] to suit the typed feature structures of [CARPENTER 1992], and so create an explicit interpretation of a typed feature structure used as a description.",
        "1 then use this interpretation to define the notion of a satisfiable feature structure.",
        "Though no feature structure algebra provides descriptions as expressive as those provided by a feature logic, using feature structures to describe objects profits from a large stock of available computational techniques to represent, test and process feature structures.",
        "In this paper, I demonstrate the computational benefits of marrying a tractable syntax and an explicit semantics by creating a simple and effective algorithm to decide the satisfiability",
        "of a feature structure.",
        "Gerdemann and Gdtz's Troll type resolution system implements both the semantics and an efficient refinement of the satisfiability algorithm I present here (see [GOTY, 1993], [GERDEmANN AND KING 1994] and [GERDEMANN (Fc)])."
      ]
    },
    {
      "heading": "2. A FEATURE STRUCTURE SEMANTICS",
      "text": [
        "A signature provides the symbols from which to construct typed feature structures, and an interpretation gives those symbols meaning.",
        "Definition 1.",
        "E is a signature iff",
        "Henceforth, I tacitly work with a signature (0,T, 0,21, I call members of states, members of T types, subsumption, members of C species, members of 21 attributes, and 3 appropriateness.",
        "A is a total function from 2( to the set of partial functions from U to U,",
        "Suppose that f is an interpretation (U, S, A).",
        "I call each member of U an object in I.",
        "Each type denotes a set of objects in The denotations of the species partition U, and S assigns each object in 1 the unique species whose denotation contains the object,: object a is in the denotation of species 0\" iff o = S(u).",
        "Silbsumption encodes a relationship between the denotations of species and types: object a is in the denotation of type riff r C S(v.).",
        "So, if T1 r2 then the denotation of type ri contains the denotation of type 7-2.",
        "Each attribute denotes a. partial finwtion from the objects in 1 to the objects in .I, and A assigns each attribute the partial function it denotes.",
        "Appropriateness encodes a relationship between the denotations of species and attributes: if 1-3.\"(a, cr) is defined then the denotation of attribute ry acts upon each object.",
        "in the denotation of species a to yield au object in the denotation of type (a, (0, but if S((r,(r) is undefined then the denotation of attribute ir acts upon no object in the denotation or species a.",
        "So, if Iv) is defined then the denotation of attribute ,t acts upon each object in the denotation of type T to yield an object.",
        "in the denotation of type a(7-, I call a finite sequence of attributes a path, and write for the set of paths.",
        "for some a E 4.3, 7r Mils to q' in V, where (o•[,...,o,„) runs to a' in V ill",
        "Each feature structure is a connected Moore machine (see [Moots'; 1956]) with finitely many states, input alphabet 21, and output alphabet T."
      ]
    },
    {
      "heading": "3. MORPHS",
      "text": [
        "The abundance of interpretations seems to preclude an effective algorithm to decide if a feature structure is satisfiable.",
        "However, I insert morphs between feature structures and objects to yield an interpretation free characterisation of a satisfiable feature structure.",
        "A is a total function from A to (3, for each 7ri E 13 and each 7r2 C",
        "Proposition 10.",
        "For each interpretation I and each object u in I, some unique morph abstracts a under I. I thus write of the abstraction of a under I.",
        "Definition 11. a is a standard object in' u is a quadruple (A, F, A, E), (A, l', A) is a morph, and E is an equivalence class under I'.",
        "write U for the set of standard objects, write S for the total function from U to 6, where for each a E 6 and each (A, r, A, E) E U, S(A, A, E) a iff for some 7 E E, A(7r) = a, and write A for the total function from 21 to the set of partial functions from U to U, where for each a. E 21, each (A, F, A, E) E U and each (A', ri, A', E')",
        "A feature structure approximates a morph iff the Moshier abstraction of the feature structure abstractly subsumes (see [CARPENTER 1992]) the morph.",
        "Proposition 17.",
        "For each interpretation I, each object a in I and each feature structure F, F is true of a under 1 iff approximates the abstraction of u under I. Theorem 18.",
        "For each feature structure F, is satisfiable F approximates some morph.",
        "Proof.",
        "From propositions 15 and 17.",
        "■"
      ]
    },
    {
      "heading": "4. RESOLVED FEATURE STRUCTURES",
      "text": [
        "Though theorem 18 gives an interpretation free characterisation of a satisfiable feature structure, the characterisation still seems to admit of no effective algorithm to decide if a feature structure is satisfiable.",
        "However, I use theorem 18 and resolved feature structures to yield a less general interpretation free characterisation of a satisfiable feature structure that admits of such an algorithm.",
        "Each resolved feature structure is a well-typed (see [CARPENTER 1992]) feature structure with output alphabet 6.",
        "Definition 22.",
        "(0,'I, 0, is rational iff for each 0\" C C-5 and each a E",
        "Proof.",
        "Suppose that R = (Q, q, 6, p) and /3 is a bijection from ordinal ( to 0.",
        "Let for some q' C 7 runs to q' iii R ' for some q' C Q, rj runs to q' in R, and 7r2 runs to q' in R. and {for some q' E Q,",
        "Ira C A„+i A,,, and is the least ordinal in ( such that (A„ (r), a) For each rr E IN, (A„, l'„, A„) is a semi-mor di.",
        "Let",
        "Theorem 24.",
        "11(0, T, -<, 21, S) is rational then for each feature structure ', is satisfiable dr I' has a resolvant.",
        "Proof.",
        "From propositions 2I and 23.",
        "■"
      ]
    },
    {
      "heading": "5. A SATISFIAI3ILITY ALGORITHM",
      "text": [
        "In this section, I use theorem 2/1 to show how -- given a rational signature that meets reasonable computational conditions - to construct an effective algorithm to decide if a feature structure is satisfiable.",
        "Definition 25.",
        "(0, T, , is computable in0, 'I and' 1 are countable, ei is finite, for sonic effective function SUB, for each ri E 'I and each 72 E T, if rf r2 then SUB(ri , T2) = 'true' otherwise SUB(ri, , 7.2) = 'false', and",
        "RES(F) = a list of the resolvants of F. Proof.",
        "Since (0,T, 2t,S) is computable, for some effective function GEN, for each finite Q C GEN(Q) = a list of the total functions from Q to for some effective function TESTI, for each finite set Q, each finite partial function 6 from the Cartesian product of Q and 21 Lo Q, and each total function 0 from Q to 'I, if for each (q,ry) in the domain of 6,",
        "otherwise TEST1(6, 0) --= 'false', and for sortie effective function TEST2, for each finite set Q, each total function Oi from Q to T and each total function 02 from Q to T, if for each q E Q, 01(q) 02(q) then TEST2(01, 02) 'true' otherwise TEST2(01, 02) = 'false'.",
        "Construct, RES as follows: for each feature structure (Q, q, 6, 0), set, = GEN(Q) and 2-%out = 0 while (p, pi, , pi) is not empty do set )_.;,„ = ..., pi) if TESTI (6, p) = 'true',",
        "then output ((Q, q,6, (Q,q,6, RES is an effective algorithm, and",
        "Theorem 27.",
        "If (0, ,Q1, a) is rational and computable then for some effective function SAT,",
        "then SAT(F) 'true otherwise SAT(F) Proof.",
        "From theorem 24 and proposition 26.",
        "■ Gerdemann and Giitz's Troll system (see [GOT2 1993], [GERDEMANN AND KING 1994] and [GERDEMANN (FC)]) employs an efficient refinement of RES to test the satisfiability of feature structures.",
        "In fact, Troll represents each feature structure as a disjunction of the resolvants of the feature structure.",
        "Loosely speaking, the resolvants of a feature structure have the same underlying finite state automaton as the feature structure, and differ only in their output function.",
        "Troll exploits this property to represent each feature structure as a finite state automaton and a set of output functions.",
        "The Troll unifier is closed on these representations.",
        "Thus, though RES is computationally expensive, Troll uses RES only during compilation, never during run time."
      ]
    }
  ]
}
