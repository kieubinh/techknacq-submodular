{
  "info": {
    "authors": [
      "Giorgio Satta"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J94-2002",
    "title": "Tree-Adjoining Grammar Parsing and Boolean Matrix Multiplication",
    "url": "https://aclweb.org/anthology/J94-2002",
    "year": 1994
  },
  "references": [
    "acl-E91-1006",
    "acl-E93-1045",
    "acl-P85-1011",
    "acl-P88-1032"
  ],
  "sections": [
    {
      "text": [
        "The computational problem of parsing a sentence in a tree-adjoining language is investigated.",
        "An interesting relation is studied between this problem and the well-known computational problem of Boolean matrix multiplication: it is shown that any algorithm for the solution of the former problem can easily be converted into an algorithm for the solution of the latter problem.",
        "This result bears on at least two important computational issues.",
        "First, we realize that a straightforward method that improves the known upper bound for tree-adjoining grammar parsing is hard to find.",
        "Second, we understand which features of the tree-adjoining grammar parsing problem are responsible for the claimed difficulty."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Among formalisms for the computation of syntactic description of natural language sentences, Tree-Adjoining Grammars (TAG) play a major role.",
        "The class of TAG's was first introduced in Joshi, Levy, and Takahashi (1975) and Joshi (1985); since then, formal and computational properties of this class have been extensively investigated, and the linguistic relevance of TAGs has been discussed in the literature as well.",
        "The reader who is interested in these topics is referred to some of the most recent works, for example Schabes (1990) and Frank (1992), and to the references therein.",
        "Both in a theoretical vein and in view of possible natural language processing applications, the recognition and parsing problems for TAGs have been extensively studied and many algorithms have been proposed for their solution.",
        "On the basis of tabular techniques, the least time upper bound that has been attested is 0(1 G11 w16) for the random-access model of computation, 1G1 being the size of the input grammar and 1w1 the length of the input string.",
        "In recent years, improvement of such a worst-case running time has been a common goal for many researchers, but up to the present time the TAG parsing problem has strongly resisted all such attempts.",
        "Because of the record of all these efforts, the task of improving the above upper bound is actually regarded as a difficult one by many researchers.",
        "In support of such a common feeling, in this paper we restate the TAG parsing problem as a search problem and relate it to the well-known computational problem of Boolean matrix multiplication.",
        "This is done in such a way that time upper bounds for TAG parsing can be transferred to time upper bounds for the latter problem.",
        "More precisely, we show that any algorithm for TAG parsing that improves the 0(1 G11w16) time upper bound can be converted into an algorithm for Boolean matrix multiplication running in less than 0(m3) time, m being the order of the input",
        "matrices.",
        "Crucially, Boolean matrix multiplication has been the object of investigation for many years: methods that are asymptotically faster than 0(m3) are known, but the more considerable the improvement turned out to be, the more complex the involved computation was found to be.",
        "At the present time, the asymptotically fastest algorithms for Boolean matrix multiplication are considered to be only of theoretical interest, because the huge constants involved in the running time of these methods render prohibitive any practical application, given current computer hardware.",
        "As a matter of fact, the design of practical algorithms for Boolean matrix multiplication that considerably improve the cubic time upper bound is regarded as a very difficult enterprise.",
        "A consequence of the results presented in this paper is that TAG parsing should also be considered as having the status of a problem that is \"hard to improve,\" and there is enough evidence to think that methods for TAG parsing that are asymptotically faster than 0(1 G11w16) are unlikely to be of any practical interest, i.e., will involve very complex computations.",
        "The remaining part of this paper is organized as follows.",
        "The next section presents the definition of tree-adjoining grammar and introduces the two computational problems that are to be related.",
        "Section 3 establishes the main result.",
        "Section 4 draws on the computational consequences of such a result and reports some discussion.",
        "Finally, Section 5 concludes by indicating how similar results can be found for variants of the TAG parsing problem that have been recently discussed in the literature."
      ]
    },
    {
      "heading": "2. Preliminaries",
      "text": [
        "This section introduces the Boolean matrix multiplication problem and the tree-adjoining grammar parsing problem, along with the definition of tree-adjoining grammar.",
        "The notation presented here will be used throughout the paper."
      ]
    },
    {
      "heading": "2.1 Boolean Matrix Multiplication",
      "text": [
        "Let B = {0, 1} be the set of truth values.",
        "The logical symbols V, A are defined as usual.",
        "The set of Boolean square matrices Bm, m > 1, is defined as the set of all m x m square matrices whose elements belong to B.",
        "Given a matrix A E Bm, we say that A has order m; the element in the ith row and jth column of A is denoted by a,1.",
        "In B„,, the product of A and B, written A x B, is a Boolean matrix C such that: cij = V aik A bki, 1 < j < m. (1) An instance of the Boolean matrix multiplication problem is therefore a pair (A, B) and the solution to such an instance consists of the matrix C such that C = A x B.",
        "In what follows BMM will denote the set of all possible instances of the Boolean matrix multiplication problem."
      ]
    },
    {
      "heading": "2.2 Tree-Adjoining Grammars",
      "text": [
        "The definition of TAG and the associated notion of derivation are briefly introduced in the following; the reader is also referred to the standard literature (see, for instance, Vijay-Shanker and Joshi [1985] or Joshi, Vijay-Shanker, and Weir [1991]).",
        "A tree-adjoining grammar is a tree rewriting system denoted by a tuple G = (VN, VT, S, I, A), where VN and VT are finite, disjoint sets of nonterminal and terminal symbols respectively, S E VN is a distinguished symbol, and I and A are finite sets of elementary trees.",
        "Trees in I and A are called initial and auxiliary trees respectively and meet the following specifications.",
        "Internal (nonleaf) nodes in an elementary tree",
        "Definitions of (a) initial and auxiliary trees and (b) adjunction operation.",
        "are labeled by symbols in VN.",
        "An initial tree has a root labeled by S and leaf nodes labeled by symbols in VT U{E}.",
        "An auxiliary tree has leaf nodes labeled by symbols in VT U {e} with the addition of one node, called the foot node, having the same nonterminal label as the root node (see Figure la).",
        "We define the size of G, written I G I, to be the total number of nodes in all the trees in the set I U A.",
        "In what follows we will also denote by TAG the class of all tree-adjoining grammars.",
        "In TAG, the notion of derivation is based on a composition operation called adjunction, defined in the following way.",
        "Let y be an auxiliary tree having its root (and foot node) labeled by A e VN.",
        "Let also y' be any tree containing a node 71 labeled by A, and let 7 be the subtree of -y' rooted in i.",
        "The adjunction of y into 7' at node n results in a tree specified as follows (see Figure lb):",
        "(i) the subtree 7 is excised from -y'; (ii) the auxiliary tree y replaces 7 in -y', with the root of y replacing the excised node 71; (iii) the subtree 7 is attached to the resulting tree, with the foot node of y replacing n in T.",
        "In TAG a derivation is the process of recursive composition of elementary trees using the adjunction operation; the resulting trees are called derived trees.",
        "Since adjunctions at different nodes can be performed in any order, we can adjoin derived trees into derived trees without affecting our arguments.",
        "Parse tree ay' is included in a parse tree of string w zixz2yz3 in L(G).",
        "We say that the derivation of string pair (x, y) is a subderivation of a sentential derivation of w."
      ]
    },
    {
      "heading": "2.3 Tree-Adjoining Grammar Parsing",
      "text": [
        "In order to introduce the definition of the TAG parsing problem on which our results are based, we define in the following the string language derived from a TAG and discuss the notion of parse forest along with the important issue of its representation.",
        "Given an alphabet V, we denote by V* the set of all finite strings over V (null string E included).",
        "Although TAG is a class of tree rewriting systems, a derivation relation can be defined on strings in the following way.",
        "Let y be an elementary tree and let y' be a tree obtained from 7 by means of zero or more adjunction operations.",
        "If the yield of 7' is a string x E 17.;, that is y E I, we say that 'y derives x in G. If the yield of -y' is a string xAy E V.I.VN VT*, that is 7 E A, we say that 7 derives the pair (x, y) in G. In particular, the set of all strings in VT that can be derived in G is denoted by L(G).",
        "In this perspective then, an elementary or a derived tree is seen as a structural description of a string (a pair of strings) derived by the grammar; such a description is called a parse tree.",
        "The space of all parse trees associated with a given string by the grammar is called a parse forest.",
        "We introduce now the notion of subderivation.",
        "Let w be a sentence in L(G) and let y E A derive the pair (x, y) in G, x,y E with an associated parse tree y'.",
        "If -y' is included in a parse tree of w, we have that w = zixz2yz3 for some z1, z2, z3 E VT (see Figure 2).",
        "Parse tree 7' represents the contribution of auxiliary tree y to a derivation of w; we say therefore that the derivation of (x, y) from y is a subderivation of a sentential derivation of w. As a consequence of the definition of parse forest, we have that all subderivations of the sentential derivations of w can be read off from the parse forest of w. Part of this information will be used to establish our result, as precisely stated in the next definition.",
        "We need some additional notation.",
        "Let w d1d2 • • dn, n > 0, be a string over some alphabet; symbol pwq denotes the substring dpdp±i • • • dq for 1 < p < q < n and is undefined otherwise."
      ]
    },
    {
      "heading": "Definition 1",
      "text": [
        "Let G = (VN,VT, S, I, A) be a tree-adjoining grammar and w e V. be an input string, wi n, n > 0.",
        "A parse relation Rp C A x {1..n}4 associated with the pair (G,w) is specified as follows.",
        "For every auxiliary tree y in G and for natural numbers p, q, r and",
        "(ii) the derivation in (i) is a subderivation of a sentential derivation of w in G. The goal of a parsing algorithm for TAG is one of constructing a \"suitable\" representation for the parse forest of a given string, with respect to a given grammar.",
        "However, there is no common agreement in the literature on the requirements that such a representation should meet; therefore the issue of the representation of a parse forest deserves some discussion here.",
        "There seems to be a trade-off between computational time and space in choosing among different representations of a parse forest.",
        "Note that, from an extreme perspective, the input itself can be considered as a highly compressed representation of the parse forest – one that needs a time-expensive process for parse tree retrieval.'",
        "More explicit representations offer the advantage of time-efficient retrieval of parse trees, at the cost of an increase in storage resources.",
        "In practice, most commonly used algorithms solve the parsing problem for TAGs by computing a superset of a parse relation (defined as above) and by representing it in such a way that its instances can be tested in constant time; such a condition is satisfied by the methods reported in Vijay-Shanker and Joshi (1985), Schabes and Joshi (1988), Palis, Schende, and Wei (1990), Schabes (1991), Lavelli and Satta (1991), Lang (1992), and Vijay-Shanker and Weir (1993).",
        "From such a representation, time-efficient computations can be used later to retrieve parse structures of the input string.",
        "On the basis of the previous observation, we assume in the following that the solution of the parsing problem involves (at least) the computation of a representation for Rp such that its instances can be tested in constant time: we base our results on such an assumption.",
        "More precisely, an input instance of the tree-adjoining grammar parsing problem is defined to be any pair (G, w), and the unique solution of such an instance is provided by an explicit representation of relation (set) Rp associated with (G, w) as in Definition 1.",
        "In what follows, TGP will represent the set of all instances of the tree-adjoining grammar parsing problem."
      ]
    },
    {
      "heading": "3. Technical Part",
      "text": [
        "In this section the Boolean matrix multiplication problem is related to the tree-adjoining grammar parsing problem, establishing the major result of this paper.",
        "A precise specification of the studied reduction is preceded by an informal discussion of the general idea underlying the construction."
      ]
    },
    {
      "heading": "3.1 The Basic Approach",
      "text": [
        "Two maps .F and g will be studied in this section.",
        "Map F establishes a correspondence between the set BMM and a proper subset of TGP containing, in some sense, its most difficult instances.",
        "Conversely, map g is defined on the set of solutions of all TGP problems in the image of .F, and gives values in the set of Boolean square matrices.",
        "Maps F and g are defined in such a way that, given any algorithm for the solution of the TGP problem, we can effectively construct an algorithm for the solution of the BMM problem using the commutative diagram shown in Figure 3.",
        "Maps F and g define a commutative diagram with respect to any algorithm for Boolean matrix multiplication and any parsing algorithm for tree-adjoining grammars.",
        "Both the BMM and the TGP problems are viewed here as search problems whose solutions are obtained by exploring a search space of elementary combinations.",
        "In the case of the BMM problem, the elementary combinations are the combinations of elements of the input matrices.",
        "If m is the order of these matrices, the solution of the problem requires the specification of 0(m2) elements of the product matrix, where each element depends upon 0(m) elementary combinations (see relation (1)).",
        "Therefore the problem involves a search in a space of 0(m3) different combinations.",
        "On the other hand, in the TGP problem the elementary combinations are taken to be single applications of the adjunction operation.",
        "In parsing a string w of length n according to a tree-adjoining grammar G, we have to construct a parse relation of size 0(1G In4) (see Definition 1), and there are 0(n2) distinguishable combinations in which each element of the relation can be obtained.",
        "In the general case then, a number 0(1G I n6) of distinguishable combinations are involved in the parsing problem, and we have to perform a search within an abstract space of this size.",
        "In order to achieve our result, we then establish a size preserving correspondence between the two search spaces above.",
        "There is no way of representing matrices A and B within string w without blowing up the search space associated with the target parsing problem.",
        "Our choice will then be to represent the input matrices by means of grammar G, which fixes I G I to a quantity 0(m2).",
        "This forces the choice of n to a quantity 0(n-t4 ), obtaining therefore the desired relation I Gln6 = 0(m3).",
        "The general idea underlying the construction is the following one.",
        "Observe that non-null elements aik and bej in the input matrices force element c,j to value 1 in the product matrix if and only if k = k'.",
        "The check of such a condition can be transferred to the computation of an adjunction operation in the target parsing problem using the following encoding method.",
        "We fix a positive integer b to a (rounded) quantity mk .",
        "Then we encode each index i of the input matrices by means of positive integers i2, and i3, such that i1 is 0(b4) and i2, i3 are 0(b).",
        "Condition k = k' above is therefore reduced to the three tests kh = kh, 1 < h < 3, which can be performed independently.",
        "The test k1 = ki is precompiled into some auxiliary tree of G; the tests k2 = k2 and k3 k3 are performed by the parser using the input string, as explained below.",
        "Map F constructs a string w of distinguishable symbols by concatenating six \"slices\" w(h), 1 < h < 6, each slice of length 0(b).",
        "Map F also encodes the input matrices A and B within the target grammar G; it does so by transforming each non-null element in the input matrices into an auxiliary tree of G in the following way.",
        "Non-null element a,k is mapped into an auxiliary tree 1l having its root (and foot node)",
        "String w is composed of six slices, and auxiliary trees corresponding to non-null elements a,k and be, derive string pairs (xi, yl) and (x2, y2) matching the slices of w as shown above; integers are used to indicate the position within a single slice of the boundary symbols in strings x2, and y2.",
        "The figure depicts the case k = k', resulting in the exact nesting of the two derived trees.",
        "labeled by a symbol including integers i1 and Moreover, ryl will eventually derive a string pair (xi, yl) with the following property.",
        "String x1 is the smallest substring of w including the symbol in the i3th position within slice w(1) and the symbol in the kith position within slice 02).",
        "Furthermore, string yi is the smallest substring of w including the symbol in the (k2 + 1)-th position within slice 05) and the symbol in the i2th position within slice 06).",
        "This is schematically shown in Figure 4.",
        "At the same time maps non-null element bk'J into an auxiliary tree 72 having its root labeled by a symbol including integers ki and Crucial to our construction, -y2 will derive a pair of strings (x2, y2) with the following property.",
        "String x2 is the smallest substring of w including the symbol in the (1e3 + 1)-th position within slice w(2) and the symbol in the j3th position within slice w(3).",
        "Furthermore, string y2 is the smallest substring of w including the symbol in the j2th position within slice w(4) and the symbol in the kith position within slice w(5).",
        "Let us call and yz the derived trees obtained from and -y2 as above.",
        "Observe that k2 = kZ and k3 = k3 if and only if the yields of and are exactly nested within w; see again Figure 4.",
        "To complete the construction of G, map .F provides an auxiliary tree 73 with the following property.",
        "Tree 73 can contribute to a sentential derivation of w in G if and only if ryi and y2 can be adjoined to it.",
        "This is in turn possible just in case integer k1 in the root of y1 and integer kl in the root of 72 coincide, as specified by the adjunction sites in 73, and the yields of and ryz are exactly nested within w. It follows that, by deciding whether -y3 contributes to a sentential derivation of w, the parser is able to perform the required test k = k'.",
        "Finally, index k in its coded form is discarded in the derivation process above, while indices i and j are preserved in such a way that map g can eventually recover non-null element by reading off the parse relation.",
        "i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 f(b)(1) 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 .f.b)(i) 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 .fib)(i) 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 The next section presents a detailed specification of maps .F and g and proves the above claimed properties.",
        "As we will see, the search space defined by the resulting instance of the TAG parsing problem includes the solution of the source matrix multiplication problem."
      ]
    },
    {
      "heading": "3.2 The Two Maps",
      "text": [
        "The goal of this subsection is to establish a mapping between comparisons of matrix indices in Boolean matrix multiplication and instances of the adjunction operation in tree-adjoining grammar parsing.",
        "As already mentioned in the previous subsection, this result is achieved by encoding natural numbers using three positive integers.",
        "The encoding is then used to chop off matrix indices into smaller numbers that will be processed independently.",
        "This is explained in detail in the following.",
        "For pairs of integers i and b, let qn(i, b) and rm(i, b) be the quotient and the remainder respectively of the integer division of i by b.",
        "We define qn+ (i, b) = qn(i, b) +1 whenever rm(i, b) 0 and qn+ (i, b) = qn(i, b) otherwise; we also define rin+ (i, b) = rm(i, b) whenever rm(i, b) 0, and rm+ (i, b) = b otherwise.",
        "Note that, for i > 1, qn+(i, b) > 1 and 1 < rm±(i, b) < b.",
        "Definition 2 Let b > 1 be an integer.",
        "We associate with b a function f (b) defined on the set of positive natural numbers, specified as follows:",
        "where qn+ (i, b2), qn+ (rm+ (i, b2), b), rm+ (i, b).",
        "Table 1 shows some values of f (b) for the case b = 3.",
        "Observe that, for i > 1, _Kb) and .e) give values in the range {1..b}, while fi(b) can give any positive integer.",
        "It is not difficult to see that function f (b) establishes a one-to-one correspondence between the set N of positive natural numbers and the set N x {1..b} x {1..b}.",
        "In an informal way, we will often refer to value 4b) (i) as the most significant digit corresponding to i, and to values .Kb) (i) and .e) (i) as the least significant digits corresponding to i.",
        "In the following, the superscript in f (b) will be omitted whenever b can be understood from the context.",
        "We are now in a position to define in detail the maps F and g involved in the diagram of Figure 3 discussed in Section 3.1.",
        "As a first step, we study map F that takes as input an instance of BMM and returns an instance of TGP.",
        "Definition of families of auxiliary trees ri(in) , n > 1 and 1 < h < 6.",
        "Each tree in some class is specified by the values of the integer parameters corresponding to that class.",
        "Let n > 1 be an integer.",
        "In the following we will refer to sets of terminal symbols",
        "and to sets of nonterminal symbols",
        "Based on these sets, Figure 5 defines families of auxiliary trees FIY) 1 < h < 6.",
        "For ( b example, an auxiliary tree -y(p, q, r, s, u, v) E rin) be specified by providing actual values for the integer parameters p, q, r, s, u, and v, consistently with the definitions of sets Vrn) and 14,7).",
        "In the following we will also use the initial tree -y, depicted in Figure 6.",
        "The next definition introduces map F, which is the core component of the proposed reduction.",
        "The definition is rather technical: it will be followed by a more intuitive example.",
        "Definition 3 Let (A, B) be an instance of BMM, m the order of matrices A and B.",
        "Let also n = Lm 'e _I +1 and a = n + 1.",
        "A map ,F is specified in such a way that F((A, B)) = (G, w), where",
        "Definition of initial tree 'ye.",
        "(ii) for every bq = 1 in B, the auxiliary tree -y(p, q,r, s, u, v) E belongs to A(n), where",
        "belong to A(n).",
        "In order to have a better understanding of map ,T and of the idea underlying grammar G and string w, we discuss in the following a simple example, adding more details to the informal discussion presented in Section 3.1.",
        "Let us define a Boolean matrix by specifying only its non-null elements.",
        "Assume then that an input instance (A, B) of the BMM problem consists of two matrices of",
        "Part (a) shows how non-null elements a2,15 and b15,7 in matrices A and B combine together, forcing element c2,7 in matrix C to value 1; each array element is represented as an arc in a directed graph.",
        "Correspondingly, trees -r2, -y3 and 74 in (b) are introduced in G by map F. These trees can be composed, using adjunction, with trees in II) and IT), in such a way that a derived tree is obtained that matches string w and encodes the indices of c2,7.",
        "The multiplication of matrices A and B results in matrix C consisting of the only non-null element c2,7.",
        "As already mentioned in Section 3.1, the multiplication process can be seen as a test for equality performed on the second index of a2,15 and the first index of b15,7; in the following these indices will be called \"intermediate\" indices.",
        "Element c2,7 in the product matrix is forced to value 1 if this test succeeds, and the intermediate indices are discarded in the process.",
        "See Figure 7a for a schematic representation of such an operation.",
        "In performing an adjunction operation, two requirements must be satisfied.",
        "First, the nonterminal label at the adjunction site must match the nonterminal label at the root (and foot node) of the adjoined tree; and second, adjunction must compose trees in such a way that the derived string is compatible with w. In the proposed reduction, each test for equality performed on some pair of intermediate indices by matrix multiplication is transferred to an adjunction operation by map .F, using as targets the two requirements just described.",
        "This is exemplified in the following.",
        "According to Definition 3, we find n = 3 and a = 4.",
        "Map F then constructs a string w = cl1c12 • • • d24, which can be thought of as composed of six slices W(h) -= 4(h-1)+1W4hr 1 < h < 6.",
        "Each element in a single slice will be used as a placeholder to record information about matrix indices.",
        "Furthermore, map F exploits function f(3) (see Table 1) in order to map each non-null element of the input matrices to an auxiliary tree in Pia) F3) (steps (i) and (ii) in Definition 3).",
        "More specifically, each index of a non-null element is converted into three digits: the most significative one is encoded as part of the nonterminal symbols, and the two least significative digits are encoded by the terminal symbols in the target tree.",
        "Trees 71 and 72 obtained in this way from non-null elements a2,15 and b15,7 respectively have been depicted in Figure 7b.",
        "Two additional trees 73 E F3) and 74 E IT) have been reported in the figure, that are also added to G by (step (iii) in Definition 3).",
        "Crucial to our construction, the test on the intermediate indices of elements a2,15 and b15,7 has been reduced to three independent tests involving smaller integers.",
        "More precisely, the equality test on the most significative digits obtained from the intermediate indices has been transferred to the requirement on the matching of the nonterminal labels of the nodes involved in the adjunction.",
        "In fact, 71 and 72 can be adjoined into 73 just in case such a test is satisfied.",
        "At the same time, the equality test on the least significative digits obtained from the intermediate indices has been transferred to the requirement on the matching of the derived string with w. In fact, after the adjunction of 71 and 72 into 73 takes place, no terminal symbol can intervene between the internal boundaries of the yield of 71 and the external boundaries of the yield of 72 in slices w(2) and w(5) (see again Figure 7b).",
        "Then 73 can participate in a sentential derivation of w just in case all three equality tests above are simultaneously satisfied.",
        "The choice of the order of I w I has been dictated by general considerations on the size of the search spaces associated with the two problems at hand, as already discussed in Section 3.1.",
        "As a note, we observe that slices w(2) and w(5) are used in the above construction to pair together least significative digits obtained from intermediate indices.",
        "The fact that these indices have range in {1..n} forces the choice of the length of these slices to a = n+ 1; the example in Figure 7 actually uses the (n + 1)-th symbol of w(2).",
        "For uniformity, this value has then been extended to all other slices, fixing w to 6u.",
        "In Lemma 1 below we will state in a more precise way the above arguments, and we will also show how derivations of the kind outlined above are the only derivations in G than can match string w, proving therefore the correctness of the reduction.",
        "To complete the diagram of Figure 3, we now turn to the specification of map g."
      ]
    },
    {
      "heading": "Definition 4",
      "text": [
        "Let (G, w) be an instance of TGP in the image of map and let m, n, and a be as in Definition 3.",
        "Let also Rp be the parse relation that solves instance (G, w).",
        "A map g is specified in such a way that g(Ro = C, C a Boolean matrix of order m, and element c1 is non-null if and only if Rp(-y, p, q, r, s) holds for an auxiliary tree -y(u, v) E inn), where",
        "In the above definition, function f (n) is used to retrieve the indices of non-null elements",
        "Non-null elements a,k and bkj are mapped into auxiliary trees and -y2 in G, and trees -y1 and rye can successively be obtained compatibly with string w. As a convention, symbols öft, 6 E fi,k,j1 and 1 < h < 3, denote integers fh(6), which indicate either positions within each single slice or components of nonterminal symbols labeling tree nodes.",
        "of matrix C. In this case also, the most significative digits associated with the retrieved indices are encoded within the nonterminal symbols of the auxiliary tree -y(u,v), while the two least significative digits are encoded by the position of the yield boundaries of the string derived from -y(u,v) consistently with the input string w. To conclude our previous example, we see that if we apply the relations in Definition 4 to the derived tree at the bottom of Figure 7b, we get indices 2 and 7 of the only non-null element in C. The following result shows that any algorithm for the solution of a generic instance of TGP can be converted into an algorithm for the solution of the BMM problem, via the computation of maps .T and g. This concludes the present section."
      ]
    },
    {
      "heading": "Lemma 1",
      "text": [
        "Let (A,13) be an instance of BMM and let (G,w) = .F((A,B)).",
        "Let also Rp be the parse relation that solves (G, w).",
        "Then we have A x B = C(Rp)."
      ]
    },
    {
      "heading": "Proof",
      "text": [
        "Assume that in is the order of the matrices A and B, n is the natural number associated with m as in Definition 3, and a = n + 1.",
        "Let C = A x B and C' = g(Ro.",
        "To prove Cu = 1 implies 4 = 1, we go through a sentential derivation of win G and then apply the definition of G. If cij = 1, then there exists k, 1 < k < m, such that a,k = bki = 1.",
        "Let yl and -y2 be the unique auxiliary trees in G associated by map .F",
        "with a,k and bkj respectively (steps (i) and (ii) in Definition 3).",
        "Tree y1 has root (and foot node) labeled by nonterminal (A,fi(i),fi(k)); furthermore, the terminal symbols in the yield of yl are (from left to right) df,(,), da+f3(k), d4,±h(k)+1 and d5,+f2(,).",
        "The only pair of substrings of w that yl can derive, by means of zero or more adjunctions of trees in Fyn) and F (6n) , is (i3(i)W u -Ff3(k) 4a -f-f2(k)+1W50- H12 (i)) • Call 4 a parse tree associated with such a derivation (see Figure 8).",
        "In a similar way, auxiliary tree 72 has root labeled by nonterminal (B,fi(k),fi(j)) and derives pair",
        "of substrings of w. Call ')4 a parse tree associated with the derivation (see again Figure 8).",
        "According to step (iii) in Definition 3, grammar G also includes auxiliary trees 1/3 = '41 (i),f1 (k),f1 (i) and y4 = -y(fi (j)) E Pin).",
        "Note that the yields of trees ryi and 14 are exactly nested within w; moreover, the root (and the foot) nodes of and 72 have been preserved in the derivation.",
        "Therefore 71 and 14 can be adjoined into n and the resulting tree rya can in turn be adjoined into -N. In this way, y4 derives the pair of substrings of w (f3(i)W2o-±f3(j)130H-f2(i)W5a-P/2(i))' Call -y!, the resulting derived tree (see Figure 9).",
        "Since derived tree 4 can be adjoined into -y, in G and a tree can be eventually derived for the input string w, we have Rp (74 , h (i), 2a + f3(j),30- +f2(/), 5cr +f2(i)), and from the definition of g we get = 1.",
        "Assuming c;j = 1, we now prove cji = 1; this is done by arguing that the only sentential derivations for w that are allowed by G are those of the kind outlined above.",
        "From the definition of g we have that",
        "holds for the auxiliary tree 74 = (i), (j)) E F. Equivalently, there exists at least one derivation from 74 of strings",
        "We first observe that, in order to derive any terminal symbol from 74, auxiliary trees in 117), Fen) and Fan) must be used.",
        "Any tree in Fin) can only derive symbols in slices Oh), h E {1,2,5,6}, and any tree in 1-'n) can only derive symbols in slices w(h) , h E {2,3,4,5}.",
        "Therefore at least one tree in Fin) and at least one tree in 1-'71) must be used in the derivation of (x, y), since (x, y) includes terminal symbols from every slice of w. Furthermore, if more than one tree in Fl(n) is used in a derivation in G, the resulting string cannot match w. The same argument applies to trees in We must then conclude that exactly one tree in Fin), one tree in 1-'n), and one tree in Fan) have been used in the derivation of (x, y) from 74.",
        "Call the above trees 71 =",
        "As a second step, we observe that 73 can be adjoined into 74 only if u' = n(i) and v' = fi (j) and 73 can host -y1 and '72 just in case u' u, v' = v, and k1 = t. We also observe that, after these adjunctions take place, the leftmost terminal symbol in the yield of 74 will be the leftmost terminal symbol in the yield of 71, that is dp.",
        "From relation (2) we then conclude that p =f3(t).",
        "Similarly, we can argue that q = 2o- + f3 (j), r = 3o- + f2(j) and s = 50- + f2(i).",
        "Finally, adjunction of 71 and 112 into -y3 can match w just in case k3 = k3 and k2 = k12.",
        "From the relations inferred above, we conclude that we can rewrite 71 as /7 (f3 (i), k3, k2 + 1,50- + f2 (i) , ki) E Fin) and72 as 7(k3 +1, 20\" +f3U)) 3°- + f2(i), k2, (j)) E Since f is one-to-one and k2, k3 E {1..n}, there exists k such that f (k) = (k1, k2, k3) .",
        "From steps (i) and (ii) in Definition 3, we then have that aik and bkj are non-null and then"
      ]
    },
    {
      "heading": "4. Computational Consequences",
      "text": [
        "The results presented in the previous section are developed here under a computational perspective.",
        "Some interesting computational consequences will then be drawn for the tree-adjoining grammar parsing problem.",
        "The following analysis assumes the random-access machine as the model of computation."
      ]
    },
    {
      "heading": "4.1 Transferring of Time Upper Bounds",
      "text": [
        "We show in the following how time upper bounds for the TGP problem can be transferred to time upper bounds for the BMM problem using the commutative diagram studied in the previous section.",
        "Let (A, B) be an instance of BMM and let (G, w) = ((A, B)); m and n are specified as in Definition 3.",
        "Observe that, since n6 > m, function f (n) maps set {1..m} into product set {1..n4} x {1..n} x {1..n}, in other words we have 1 <fl(i) < n4 and 1 < f2(i), f3(i) < n",
        " for 1 < i < m. From the definition of we see that G contains 0(m2) auxiliary trees from each of the classes Pin), 1-'n) and 1-nn).",
        "This determines the size of G and we have I (G, w) I = 0(m2), since 1 w i = 0(n).",
        "Each auxiliary tree introduced in G at steps (i) and (ii) of Definition 3 requires the computation of a constant number of instances of function f (n) on some integer i, 1 < i < m. Such a computation can be carried out in an amount of time 0(log2(m)) using standard algorithms for integer division.",
        "Summing up, the entire computation of F on an instance (A, B) takes time 0(m2 log2(m)).",
        "Let Rp be the parse relation that solves (G, w) = ,F ((A, B)).",
        "From Definition 1 and the above observations we have that 1Rpl = 0(m2n4), that is 1 Rp 1 = 0(m2+ ).",
        "We can compute C = g(Rp) in the following way.",
        "For every element ctiwe compute PO (i) and PO (j) and then check Rp according to Definition 4.",
        "(Recall also our assumption that an instance of Rp can be tested in constant time.)",
        "Again we find that the entire computation takes an amount of time 0(m2 log2 (m)).",
        "We observe that the computation of F and g takes an amount of time (asymptotically) very close to the one needed to store (A, B) or C. As a consequence of the above discussion and of Lemma 1, we have that any time upper bound for the TGP problem can be transferred to an upper bound for the BMM problem, down to the time needed for the computation of transformations and G. The following statement gives an example."
      ]
    },
    {
      "heading": "Theorem 1",
      "text": [
        "Let Ap be an algorithm for the solution of the TGP problem having running time 0(1G 1111 W I q ).",
        "Then any instance of BMM can be solved in time 0(max{m2P+ 4, m2 log2(m)}), where m is the order of the input matrices."
      ]
    },
    {
      "heading": "Proof",
      "text": [
        "From Lemma 1 and from the previous discussion we have that two Boolean matrices of order m can be multiplied in time 0(1G 1P1 w lq + m2 log2(m)), where 1 G I = 0(m2) and 1 w 1 = 0(ml).",
        "0 Observe that, according to our definition, the TGP problem has a trivial time lower bound O(1 RpI), since this is the amount of time needed in the worst case to store a representation for Rp that can be accessed in constant time.",
        "In practice this means that the upper bound transfer stated by the above result is effective down to 0(m2+i )."
      ]
    },
    {
      "heading": "4.2 Time Upper Bounds for TGP",
      "text": [
        "In previous sections we have related the complexity of tree-adjoining grammar parsing to the complexity of Boolean matrix multiplication.",
        "Here we speculate on the consequences of the presented result.",
        "As a computational problem, Boolean matrix multiplication has been an object of investigation for many years.",
        "Researchers have tried to improve the well-known 0(m3) time upper bound, m the order of the input matrices, and methods were found that work asymptotically faster than the standard cubic time algorithm.",
        "Strassen's divide and conquer algorithm that runs in time 0(m2.81) (see for instance Cormen, Leiserson, and Rivest [1990]) has been the first one in the series, and the best time upper bound known to date is approximately 0(m2.376), as reported in Coppersmith and Winograd (1990).",
        "It is worth noting here that the closer researchers have come to the 0(m2) trivial time lower bound, the more complex the computation involved in these methods has become.",
        "In fact, if Strassen's algorithm outperforms the 0(m3) standard algorithm only",
        "for input matrices of order greater than 45 or so (see again Cormen, Leiserson, and Rivest [1990]), recently discovered methods that are asymptotically faster are definitely prohibitive, given current computer hardware.",
        "At present, no straightforward method is known for Boolean matrix multiplication that considerably improves the cubic upper bound and that can be used in practical cases.",
        "Also, there is enough evidence that, if such a method exists, its discovery should be a very difficult enterprise.",
        "Let us now turn to the TAG parsing problem.",
        "Many algorithms have been proposed for its solution and an 0(1G11/ U A11w16) time upper bound has been given in the literature; see for instance Schabes (1990).",
        "We remark here that the dependency on the grammar size can be further improved using techniques similar to the one proposed in Graham, Harrison, and Ruzzo (1980) for the context-free grammar recognition/parsing problem: this results in an 0(1 G11w16) time upper bound for the general case.",
        "Theorem 1 can be used to transfer this upper bound to an upper bound for Boolean matrix multiplication, finding the already mentioned 0(m3) result.",
        "More interestingly, Theorem 1 implies that any method for the solution of the tree-adjoining grammar parsing problem having running time 0(1G11w15) will give us a method for Boolean matrix multiplication having running time 0(m2.83).",
        "Likewise, any 0(1 G 11 w 14) time method for the former problem will result in an 0(m2.6) time method for Boolean matrix multiplication.",
        "Even if the involved constants hidden in the studied construction are large, the resulting methods will still be competitive with known methods for Boolean matrix multiplication that improve the cubic time upper bound.",
        "We conclude then that the TAG parsing problem should also be considered as having the status of a problem that is \"difficult\" to improve, and we have enough evidence to think that methods for TAG parsing that are asymptotically faster than 0(1G11 w 16) are unlikely to be practical, i.e., will involve rather complex computations."
      ]
    },
    {
      "heading": "5. Remarks and Conclusion",
      "text": [
        "Polynomial time reductions between decision/search problems are commonly used in providing hardness results for complexity classes not known to be included in P (P is the class of all languages decidable in deterministic polynomial time).",
        "We have studied here a polynomial time reduction between Boolean matrix multiplication and TAG parsing, two problems already known to be in P. However, the choice of the mapping allows one to transfer upper bounds from the first problem to the other.",
        "In this way TAG parsing inherits from Boolean matrix multiplication the reputation of being a problem tough to improve.",
        "We comment in the following on the significance of this result.",
        "As already discussed, the notion of the parse forest is an informal one, and there is no common agreement on which specifications such a structure should meet.",
        "The obtained results are based on the assumption that a parsing algorithm for TAG should be able to provide a representation for a parse forest such that instances of the parse relation Rp in Definition 1 can be retrieved in constant time.",
        "Whatever the specifications of the output parse forest structure will be, it seems quite reasonable to require that an explicit representation of relation Rp can be extracted from the output in linear time with respect to the size of the output itself, therefore without affecting the overall running time of the method.",
        "This requirement is satisfied by all TAG parsers that have been presented to date in the literature.",
        "As a second point, the studied construction provides an interesting insight into the structure of the TAG parsing problem.",
        "We see for instance that the major source of",
        "complexity derives from cases of properly nested adjunction operations.",
        "Such cases are responsible for a bounded amount of nondeterminism in the computation: to detect how a string divides into subparts according to the adjunction of a derived tree into another, we have to consider many possibilities in general, as much as we do to detect a non-null element within a product Boolean matrix.",
        "A closer look at the studied construction reveals also that the parsing problem for linear TAG does not seem easier than the general case, since .F maps instances of BMM to instances of TGP restricted to such a class (a linear TAG is a TAG whose elementary trees allow adjunction only into nodes along a single spine).",
        "This contrasts with the related case of context-free grammar parsing, where the restriction of the problem to linear grammars can be solved in time 0(1G11w12) but no method is known for the general case working with this bound.",
        "As expected from our result, the techniques that are used for linear context-free grammar parsing cannot be easily generalized to improve the parsing problem for linear TAGs with respect to the general case.",
        "Finally, we want to discuss here an interesting extension of the studied result.",
        "The TAG parsing problem can be generalized to cases in which the input is a lattice representation of a string of terminal symbols along with a partially specified parse relation associated with it.",
        "This has many applications for ill-formed input and error-correcting parsing.",
        "The TAG lattice parsing problem can still be solved in 0(1G11w16) time: the general parsing method provided in Lang (1992) can be used to this purpose, and already known tabular methods for TAG parsing can be easily adapted as well.",
        "Without giving the technical details of the argument, we sketch here how Boolean matrix multiplication can be related to TAG lattice parsing.",
        "For order m matrices, one can use an encoding function f1(\"), where n Lmi/2] + 1, mapping set {1..m} into product set {1..n} x {1..n}.",
        "This allows a direct encoding of any instance (A, B) of the BMM problem into a word lattice w1 consisting of 6(n + 1) nodes and 0(m2) arcs, where some arcs involve four nodes and represent a derived tree corresponding to a non-null element in either A or B.",
        "Then we can use a grammar G in the target instance of the TAG lattice problem that is defined independently of (A, B) and therefore has constant size.",
        "(Such a grammar can be obtained from families F and lin) defined in Section 3 by deleting the integer components in each nonterminal symbol.)",
        "The construction obtained in this way relates therefore the BMM problem to the fixed grammar parsing problem, and provides a result even stronger than the one presented in Theorem 1.",
        "We have in fact that any algorithm for TAG lattice parsing having running time 0(1 G IpI wlq) can be converted into an algorithm for Boolean matrix multiplication running in time 0(max{m z , m2 log2 (m) }), independently of p. As an example, 0 (I G II I w14) for TAG lattice parsing becomes 0(m2log2(m)) for matrix multiplication, for any p. Since many tabular methods for TAG parsing can be easily extended to TAG lattice parsing, this means that the chances of getting an 0(1 G IP1w14) time upper bound for the TAG parsing problem itself by means of these techniques are really small."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "I am indebted to Yves Schabes who suggested to me the original idea of relating a standard computational problem to the tree-adjoining grammar parsing problem.",
        "I want to thank Bernard Lang, Owen Rambow, and Yves Schabes, who have provided, directly or indirectly, important suggestions for the development of the ideas in this paper.",
        "Comments from two anonymous referees have also been very helpful in improving the exposition of the results reported in this paper.",
        "Finally, I am grateful to Aravind Joshi for his support in this research.",
        "None of these people is responsible for any error in this work.",
        "This research was partially funded by the following grants: ARO grant DAAL"
      ]
    }
  ]
}
