{
  "info": {
    "authors": [
      "Mark-Jan Nederhof"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P94-1017",
    "title": "An Optimal Tabular Parsing Algorithm",
    "url": "https://aclweb.org/anthology/P94-1017",
    "year": 1994
  },
  "references": [
    "acl-E93-1036",
    "acl-P89-1017",
    "acl-P89-1018",
    "acl-P91-1014",
    "acl-P94-1029"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "In this paper we relate a number of parsing algorithms which have been developed in very different areas of parsing theory, and which include deterministic algorithms, tabular algorithms, and a parallel algorithm.",
        "We show that these algorithms are based on the same underlying ideas.",
        "By relating existing ideas, we hope to provide an opportunity to improve some algorithms based on features of others.",
        "A second purpose of this paper is to answer a question which has come up in the area of tabular parsing, namely how to obtain a parsing algorithm with the property that the table will contain as little entries as possible, but without the possibility that two entries represent the same subderivation."
      ]
    },
    {
      "heading": "Introduction",
      "text": [
        "Left-corner (LC) parsing is a parsing strategy which has been used in different guises in various areas of computer science.",
        "Deterministic LC parsing with k symbols of lookahead can handle the class of LC(k) grammars.",
        "Since LC parsing is a very simple parsing technique and at the same time is able to deal with left recursion, it is often used as an alternative to top-down (TD) parsing, which cannot handle left recursion and is generally less efficient.",
        "Nondeterministic LC parsing is the foundation of a very efficient parsing algorithm [7], related to Tomita's algorithm and Earley's algorithm.",
        "It has one disadvantage however, which becomes noticeable when the grammar contains many rules whose right-hand sides begin with the same few grammars symbols, e.g. A a/31 Iath ... where a is not the empty string.",
        "After an LC parser has recognized the first symbol X of such an a, it will as next step predict all aforementioned rules.",
        "This amounts to much nondeterminism, which is detrimental both to the time-complexity and the space-complexity.",
        "A first attempt to solve this problem is to use predictive LB.",
        "(PLR) parsing.",
        "PLR parsing allows simultaneous processing of a common prefix a, provided that the left-hand sides of the rules are the same.",
        "However, in case we have e.g. the rules A a01 and B – 4 al32, where again a is not the empty string but now A B, then PLR parsing will not improve the efficiency.",
        "We therefore go one step further and discuss extended LR (ELR) and common-prefix (CP) parsing, which are algorithms capable of simultaneous processing of all common prefixes.",
        "ELR and CP parsing are the foundation of tabular parsing algorithms and a parallel parsing algorithm from the existing literature, but they have not been described in their own right.",
        "To the best of the author's knowledge, the various parsing algorithms mentioned above have not been discussed together in the existing literature.",
        "The main purpose of this paper is to make explicit the connections between these algorithms.",
        "A second purpose of this paper is to show that CF and ELR parsing are obvious solutions to a problem of tabular parsing which can be described as follows.",
        "For each parsing algorithm working on a stack there is a realisation using a parse table, where the parse table allows sharing of computation between different search paths.",
        "For example, Tomita's algorithm [18] can be seen as a tabular realisation of nondeterministic LR parsing.",
        "At this point we use the term state to indicate the symbols occurring on the stack of the original algorithm, which also occur as entries in the parse table of its tabular realisation.",
        "In general, powerful algorithms working on a stack lead to efficient tabular parsing algorithms, provided the grammar can be handled almost deterministically.",
        "In case the stack algorithm is very nondeterministic for a certain grammar however, sophistication which increases the number of states may lead to an increasing number of entries in the parse table of the tabular realization.",
        "This can be informally explained by the fact that each state represents the computation of a number of subderivations.",
        "If the number of states is increased then it is inevitable that at some point some states represent an overlapping collection of subderivations,",
        "which may lead to work being repeated during parsing.",
        "Furthermore, the parse forest (a compact representation of all parse trees) which is output by a tabular algorithm may in this case not be optimally dense.",
        "We conclude that we have a tradeoff between the case that the grammar allows almost deterministic parsing and the case that the stack algorithm is very nondeterministic for a certain grammar.",
        "In the former case, sophistication leads to less entries in the table, and in the latter case, sophistication leads to more entries, provided this sophistication is realised by an increase in the number of states.",
        "This is corroborated by empirical data from [1, 4], which deal with tabular LR parsing.",
        "As we will explain, CP and ELR parsing are more deterministic than most other parsing algorithms for many grammars, but their tabular realizations can never compute the same subderivation twice.",
        "This represents an optimum in a range of possible parsing algorithms.",
        "This paper is organized as follows.",
        "First we discuss nondeterministic left-corner parsing, and demonstrate how common prefixes in a grammar may be a source of bad performance for this technique.",
        "Then, a multitude of parsing techniques which exhibit better treatment of common prefixes is discussed.",
        "These techniques, including nondeterministic PLR, ELR, and CP parsing, have their origins in theory of deterministic, parallel, and tabular parsing.",
        "Subsequently, the application to parallel and tabular parsing is investigated more closely.",
        "Further, we briefly describe how rules with empty right-hand sides complicate the parsing process.",
        "The ideas described in this paper can be generalized to head-driven parsing, as argued in [9].",
        "We will take some liberty in describing algorithms from the existing literature, since using the original descriptions would blur the similarities of the algorithms to one another.",
        "In particular, we will not treat the use of lookahead, and we will consider all algorithms working on a stack to be nondeterministic.",
        "We will only describe recognition algorithms.",
        "Each of the algorithms can however be easily extended to yield parse trees as a side-effect of recognition.",
        "The notation used in the sequel is for the most part standard and is summarised below.",
        "A context-free grammar G = (T, N, P, S) consists of two finite disjoint sets N and T of nonterminals and terminals, respectively, a start symbol S E N, and a finite set of rules P. Every rule has the form A – > a, where the left-hand side (lhs) A is an element from N and the right-hand side (rhs) a is an element from V, where V denotes (N U T).",
        "P can also be seen as a relation on N x V. We use symbols A, B, C,... to range over N, symbols a, b, c, ... to range over T, symbols X, Y, Z to range over V, symbols a, 0, to range over V*, and v, w, x, to range over T*.",
        "We let c denote the empty string.",
        "The notation of rules A – > al, A – > a2, ... with the same lhs is often simplified to A '011a2 A rule of the form A --> e is called an epsilon rule.",
        "1... We assume grammars do not have epsilon rules unless stated otherwise.",
        "The relation P is extended to a relation – * on V* x V* as usual.",
        "The reflexive and transitive closure of is denoted by -4*.",
        "We define: B L. A if and only if A – > Ba for some a.",
        "The reflexive and transitive closure of is denoted by L*, and is called the left-corner relation.",
        "We say two rules A – > al and B a2 have a common prefix 0 if al = 0-yi and a2 = 13'y2, for some and 1,2, where 0 e. A recognition algorithm can be specified by means of a push-down automaton A = (T, Alph, Init,H, Fin), which manipulates configurations of the form (F, v), where r E Alph* is the stack, constructed from left to right, and v E T* is the remaining input.",
        "The initial configuration is (Init,w), where Init E Alph is a distinguished stack symbol, and w is the input.",
        "The steps of an automaton are specified by means of the relation H. Thus, (r,v) H (F', v') denotes that (r', is obtainable from (r, v) by one step of the automaton.",
        "The reflexive and transitive closure of H is denoted by H*.",
        "The input w is accepted if (Init, w) H* (Fin, c), where Fin E Alph is a distinguished stack symbol."
      ]
    },
    {
      "heading": "LC parsing",
      "text": [
        "For the definition of left-corner (LC) recognition [7] we need stack symbols (items) of the form [A – > a • 0], where A a0 is a rule, and a E. (Remember that we do not allow epsilon rules.)",
        "The informal meaning of an item is \"The part before the dot has just been recognized, the first symbol after the dot is to be recognized next\".",
        "For technical reasons we also need the",
        "where Pt represents the augmented set of rules, consisting of the rules in P plus the extra rule S' --+ S. Algorithm 1 (Left-corner)",
        "where there is A – > aa E Pt such that A L* C",
        "2.",
        "(F[A – > a • a0], av) H (r[A aa • 0], v) 3.",
        "(F[B – > 0 • C'y][A – > a •], v) H",
        "where there is D – * Ab ePt such that D I* C",
        "4.",
        "(r[B – > 0 • A-y][A – * a •], v) H (r[B 0A • -y], v)",
        "The conditions using the left-corner relation 7* in the first and third clauses together form a feature which is",
        "called top-down (TD) filtering.",
        "TD filtering makes sure that subderivations that are being computed bottom-up may eventually grow into subderivations with the required root.",
        "TD filtering is not necessary for a correct algorithm, but it reduces nondeterminism, and guarantees the correct-prefix property, which means that in case of incorrect input the parser does not read past the first incorrect character.",
        "Example 1 Consider the grammar with the following rules:",
        "It is easy to see that EL E,T L E,T LT, FL T. The relation L* contains L but from the reflexive closure it also contains F L* F and from the transitive closure it also contains F L* E. The recognition of a * a is realised by:",
        "[E' o • E] a * a 1 E' -+ • E [F o a.]",
        "* a 2 E' o • E [T 0 F 41] * a 3 E' 4 • E [T o T • * F] * a 4 E' o • E [T o T * • F] a 5 E' o • E [T o T * 41 F [F --* a .]",
        "6 E' o • E [T 0 T * F .]",
        "7 E' o • E [E -+ T .]",
        "8 E' o E •",
        "Note that since the automaton does not use any lookahead, Step 3 may also have replaced [T o F e] by any other item besides [T o T • * F] whose rhs starts with T and whose lhs satisfies the condition of top-down filtering with regard to E, i.e. by [T o T • ** F], [E o T • E], or [E T .].",
        "LC parsing with k symbols of lookahead can handle deterministically the so called LC(k) grammars.",
        "This class of grammars is formalized in [13].1 How LC parsing can be improved to handle common suffixes efficiently is discussed in [6]; in this paper we restrict our attention to common prefixes.",
        "PLR, ELR, and CP parsing In this section we investigate a number of algorithms which exhibit a better treatment of common prefixes."
      ]
    },
    {
      "heading": "Predictive LR parsing",
      "text": [
        "Predictive LR (PLR) parsing with k symbols of lookahead was introduced in [17] as an algorithm which yields efficient parsers for a subset of the LR(k) grammars [16] and a superset of the LC(k) grammars.",
        "How deterministic PLR parsing succeeds in handling a larger class of grammars (the PLR(k) grammars) than the LC(k) grammars can be explained by identifying PLR parsing 1 In [171 a different definition of the LC(k) grammars may be found, which is not completely equivalent.",
        "for some grammar G with LC parsing for some grammar G' which results after applying a transformation called left-factoring.",
        "Left-factoring consists of replacing two or more rules A 011021... with a common prefix a by the rules A aA' and A' 0 011021 – , where A' is a fresh nonterminal.",
        "The effect on LC parsing is that a choice between rules is postponed until after all symbols of a are completely recognized.",
        "Investigation of the next k symbols of the remaining input may then allow a choice between the rules to be made deterministically.",
        "The PLR algorithm is formalised in [17] by transforming a PLR(k) grammar into an LL(k) grammar and then assuming the standard realisation of LL(k) parsing.",
        "When we consider nondeterministic top-down parsing instead of LL(k) parsing, then we obtain the new formulation of nondeterministic PLR(0) parsing below.",
        "We first need to define another kind of item, viz, of the form [A --+ a] such that there is at least one rule of the form A ad3 for some /3.",
        "Formally:",
        "Informally, an item [A a] E IPLR represents one or more items [A 4 a • 0] E /LC.",
        "where there are A 4 aa,B OCry E Pt such that A L* C",
        "2.",
        "(r[A 0 a], av) (r[A aa], v)",
        "where there is A ---■ aall E Pt",
        "3.",
        "(r[B 0][A o a], v) F (r[B 13][D o A], v)",
        "where A a E Pt and where there are D Afi, B o pc7 E Pt such that D 1* C 4.",
        "(r[B 0 13][A a], t)) F (r[B OA], v) where A 4 a E Pt and where there is B 0117 E Pt Example 2 Consider the grammar from Example 1.",
        "Using Predictive LR, recognition of a *a is realised by:",
        "[E' o ] a * a 1 [E' ][F a] * a 2 [E' ][T o F] *a 3 [E' o ][T -0T] * a 4 [E' ][T T *] a 8 [E' o E.]",
        "Comparing these configurations with those reached by the LC recognizer, we see that here after Step 3 the stack element [T --■ T] represents both [T 0 T • * F] and [T T • **F], so that nondeterminism is reduced.",
        "Still some nondeterminism remains, since Step 3 could also have replaced [T o F] by [E o T], which represents both [E o T • I E] and [E o T •].",
        "0"
      ]
    },
    {
      "heading": "Extended LR parsing",
      "text": [
        "An extended context-free grammar has right-hand sides consisting of arbitrary regular expressions over V. This requires an LR parser for an extended grammar (an EL R parser) to behave differently from normal LR parsers.",
        "The behaviour of a normal LR parser upon a reduction with some rule A 4 a is very simple: it pops la!",
        "states from the stack, revealing, say, state Q; it then pushes state goto(Q, A).",
        "(We identify a state with its corresponding set of items.)",
        "For extended grammars the behaviour upon a reduction cannot be realised in this way since the regular expression of which the rhs is composed may describe strings of various lengths, so that it is unknown how many states need to be popped.",
        "In [11] this problem is solved by forcing the parser to decide at each call goto(Q, X) whether",
        "In the second case, a state which is a variant of goto(Q, X) is pushed on top of state Q as usual.",
        "In the first case, however, state Q on top of the stack is replaced by a variant of goto(Q, X).",
        "This is safe since we will never need to return to Q if after some more steps we succeed in recognizing some rule corresponding with one of the items in Q.",
        "A consequence of the action in the first case is that upon reduction we need to pop only one state off the stack.",
        "Further work in this area is reported in [5], which treats nondeterministic ELR parsing and therefore does not regard it as an obstacle if a choice between cases a) and b) cannot be uniquely made.",
        "We are not concerned with extended context-free grammars in this paper.",
        "However, a very interesting algorithm results from ELR parsing if we restrict its application to ordinary context-free grammars.",
        "(We will maintain the name \"extended LR\" to stress the origin of the algorithm.)",
        "This results in the new nondeterministic ELR(0) algorithm that we describe below, derived from the formulation of ELR parsing in [5].",
        "First, we define a set of items as",
        "For ELR parsing however, we need two goto functions, gotoi and goto2, one for kernel items (i.e. those in /Lc) and one for nonkernel items (the others).",
        "These are defined by",
        "At each shift (where X is some terminal) and each reduce with some rule A -> a (where X is A) we may nondeterministically apply gotoi, which corresponds with case a), or goto2, which corresponds with case b).",
        "Of course, one or both may not be defined on Q and X, because gotoi(Q, X) may be 0, for i E {1, 2}.",
        "Now remark that when using gotoi and goto2, each reachable set of items contains only items of the form A -> a • 0, for some fixed string a, plus some nonkernel items.",
        "We will ignore the nonkernel items since they can be derived from the kernel items by means of the closure function.",
        "This suggests representing each set of items by a new kind of item of the form [{A1, A2, , An} --+ a], which represents all items A -> a • 0 for some 0 and A E {Ai, A2, An}.",
        "Formally:",
        "where we use the symbol A to range over sets of nonterminals.",
        "[{S'} S], and F defined by: 1.",
        "(F[A 0], av) F (r[6. o][A' a], v) where A' = {A I 3A ---> acy, B i3C7 E A A A 7* CD is non-empty 2.",
        "(r[6, a], av) H (F[A' aa], v)",
        "where A' = {A EAI A 4 aa0 E Pt} is non-empty 3.",
        "(r[A #][A' -* a], v) (r[A /3][A\" 4 A], v) where there is A 4 a E Pt with A E A', and A\" = {D I 3D -> A6, B 0C-y E Pt[B E AAD L* Cif is non-empty",
        "4.",
        "(r[6.",
        "-+ a], v) H (F[A\" -> 0A], v)",
        "where there is A -> a E Pt with A E A', and A\" E A I /3 -> 0A-y E Pt} is non-empty Note that Clauses 1 and 3 correspond with goto2 and that Clauses 2 and 4 correspond with goto1.",
        "Example 3 Consider again the grammar from Example 1.",
        "Using the ELR algorithm, recognition of a * a is realised by:",
        "Comparing these configurations with those reached by the PLR recognizer, we see that here after Step 3 the stack element [{T, E} T] represents both [T T •",
        "A simplified ELR algorithm, which we call the pseudo ELR algorithm, results from avoiding reference to A in Clauses 1 and 3.",
        "In Clause 1 we then have a simplified definition of A', viz. A' = {A I 3A -> aa, B -> /3C7 E Pt [A L* C]}, and in the same way we have in Clause 3 the new definition A\" = {D 3D Ab, B -> 3C-y E Pt[D L* C]l. Pseudo ELR parsing can be more easily realised than full ELR parsing, but the correct-prefix property can no longer be guaranteed.",
        "Pseudo ELR parsing is the foundation of a tabular algorithm in [20]."
      ]
    },
    {
      "heading": "Common-prefix parsing",
      "text": [
        "One of the more complicated aspects of the ELR algorithm is the treatment of the sets of nonterminals in the left-hand sides of items.",
        "A drastically simplified algorithm is the basis of a tabular algorithm in [21].",
        "Since in [21] the algorithm itself is not described but only its tabular realisation,2 we take the liberty of giving this algorithm our own name: common-prefix (CP) parsing, since it treats all rules with a common prefix simultaneously.",
        "The simplification consists of omitting the sets of nonterminals in the left-hand sides of items:",
        "where there are A -> aa, B --> i3C-y E Pt such that A L* C",
        "2.",
        "(r[.",
        "a], av) F (r[ – , aa], v) where there is A aaf3 E pt 3.",
        "(r[-.",
        "o][, – a], v) F (F[-> 0]-> A], v)",
        "where there are A a, D 4 AS, B OC7 E Pt such that D L* C",
        "4.",
        "(r[--+ o][, a], v) F (r[.-4 v)",
        "where there are A a, B -> 3A7 E Pt The simplification which leads to the CP algorithm inevitably causes the correct-prefix property to be lost.",
        "Example 4 Consider again the grammar from Example 1.",
        "It is clear that a+a j a is not a correct string according to this grammar.",
        "The CF algorithm may go through the following sequence of configurations:",
        "We see that in Step 9 the first incorrect symbol I is read, but recognition then continues.",
        "Eventually, the recognition process is blocked in some unsuccessful configuration, which is guaranteed to happen for any incorrect input4.",
        "In general however, after reading the first incorrect symbol, the algorithm may perform an unbounded number of steps before it halts.",
        "(Imagine what happens for input of the form a+a a+ a+a+ + a.)",
        "13"
      ]
    },
    {
      "heading": "Tabular parsing",
      "text": [
        "Nondeterministic push-down automata can be realised efficiently using parse tables [1].",
        "A parse table consists of sets Ti,j of items, for 0 < i < j < n, where al .",
        "• • an represents the input.",
        "The idea is that an item is only stored in a set Tid if the item represents recognition of the part of the input ai+i ai.",
        "We will first discuss a tabular form of CP parsing, since this is the most simple parsing technique discussed above.",
        "We will then move on to the more difficult ELR technique.",
        "Tabular PLR parsing is fairly straightforward and will not be discussed in this paper."
      ]
    },
    {
      "heading": "Tabular CP parsing",
      "text": [
        "CP parsing has the following tabular realization:"
      ]
    },
    {
      "heading": "Algorithm 5 (Tabular common-prefix)",
      "text": [
        "Sets Ti,j of the table are to be subsets of /cP.",
        "Start with an empty table.",
        "Add [---+] to T0,0.",
        "Perform one of the following steps until no more items can be added.",
        "1.",
        "Add [-> a] to for a = ai and [-> 0] E",
        "where there are A ---> aa, B )3C7 E Pt such that A L* C",
        "2.",
        "Add aa] to Tj,i for a = ai and [-> a] E T1,i-1",
        "where there is A •-■ aaf3 E Pt",
        "3.",
        "Add [-+ A] to for a] E 7:;,, and [---4 0] E Thj",
        "where there are A -+ a, D 4 AS, B -> /3C 'y Pt such that D L* C",
        "4.",
        "Add [-+ OA] to Th,,i for [-> a] E Tj, and [--4 0] E Th,3",
        "where there are A a, B 3 A-y E Pt Report recognition of the input if S] E To,n.",
        "For an example, see Figure 1.",
        "Tabular CP parsing is related to a variant of CYK parsing with TD filtering in [5].",
        "A form of tabular 'unless the grammar is cyclic, in which case the parser may not terminate, both on correct and on incorrect input",
        "Consider again the grammar from Example 1 and the (incorrect) input a + a a.",
        "After execution of the tabular common-prefix algorithm, the table is as given here.",
        "The sets Ti,j are given at the j-throw and i-th column.",
        "The items which correspond with those from Example 4 are labelled with (0), (1), ...",
        "These labels also indicate the order in which these items are added to the table.",
        "CF parsing without top-down filtering (i.e. without the checks concerning the left-corner relation 7*) is the main algorithm in [21].",
        "Without the use of top-down filtering, the references to 0] in Clauses 1 and 3 are clearly not of much use any more.",
        "When we also remove the use of these items, then these clauses become:",
        "1.",
        "Add [ – + a] to for a =",
        "where there is A – > aa E PI",
        "3.",
        "Add [ – + A] to for a] E",
        "where there are A – 4 a, D – >A5 E Pt In the resulting algorithm, no set depends on any set Tg,h with g < i.",
        "In [15] this fact is used to construct a parallel parser with n processors Po, , Pfl_1, with each P, processing the sets Tz,i for all j > i.",
        "The flow of data is strictly from right to left, i.e. items computed by P. are only passed on to P0,.",
        "• • ,"
      ]
    },
    {
      "heading": "Tabular ELR parsing",
      "text": [
        "The tabular form of ELR parsing allows an optimization which constitutes an interesting example of how a tabular algorithm can have a property not shared by its nondeterministic origin.5 First note that we can compute the columns of a parse table strictly from left to right, that is, for fixed i we can compute all sets Ti.",
        "before we compute the sets If we formulate a tabular ELR algorithm in a naive way analogously to Algorithm 5, as is done in [5], then for example the first clause is given by:",
        "1.",
        "Add [A' – > a] to for a = ai and",
        "where A' = {A I 3A aa, B – > OC-y E Pt[B E A A A 7* C]} is non-empty 5 This is reminiscent of the admissibility tests [3], which are applicable to tabular realisations of logical push-down automata, but not to these automata themselves.",
        "However, for certain i there may be many [A – > 0] E Tj,i_i, for some j, and each may give rise to a different A' which is non-empty.",
        "In this way, Clause 1 may add several items [A' a] to some possibly with overlapping sets A'.",
        "Since items represent computation of subderivations, the algorithm may therefore compute the same subderivation several times.",
        "We propose an optimization which makes use of the fact that all possible items [A – > 0] E T3,i_1 are already present when we compute items in we compute one single item [A' a], where A' is a large set computed using all [A – ÷ 0] E for any j.",
        "A similar optimization can be made for the third clause."
      ]
    },
    {
      "heading": "Algorithm 6 (Tabular extended LR)",
      "text": [
        "Sets Ti,j of the table are to be subsets of IELR• Start with an empty table.",
        "Add [{S'} – > ] to T0,0.",
        "For i = 1, , n, in this order, perform one of the following steps until no more items can be added.",
        "1.",
        "Add [A' – 4 a] to for a = ai",
        "where A' = {A I 3j3[A – > 13] E T3,2_13A -> aa, B Pay E Pt[B E AAA 7* C]} is non-empty",
        "2.",
        "Add [A' aa] to Tj, for a = ai and"
      ]
    },
    {
      "heading": "[A a] E Tj,z_i",
      "text": [
        "where A' = {A E A A ---> aa0 E Pt} is non-empty",
        "3.",
        "Add [A\" – > A] to Tj, for [A' – + a] E T3,,",
        "where there is A a E Pt with A E A', and A\" = {D I 31/3[A --> 0] E Th,j3D -■ A6, B -> OC-y E PI[B EAAD 7* C]} is non-empty",
        "4.",
        "Add [A\" – > OA] to Tki for [A' --> a] E Ti and [A ---> 0] E Th,3",
        "where there is A – > a E Pt with A E A', and A\" = {B EAIB – > 0A7 E Pt} is non-empty Report recognition of the input if [{S'} --> S] E To,.",
        "Informally, the top-down filtering in the first and third clauses is realised by investigating all left corners D of nonterminals C (i.e. D 7* C) which are expected",
        "from a certain input position.",
        "For input position i these nonterminals D are given by",
        "Provided each set Si is computed just after completion of the i-th column of the table, the first and third clauses can be simplified to:",
        "1.",
        "Add [A' a] to for a = ai",
        "where A' ,--{A I A aa E Pt} n Si_1 is non-empty"
      ]
    },
    {
      "heading": "3. Add [A\" Al to for [A' a] E",
      "text": [
        "where there is A a E pt with A E A', and A\" =- ID I D – 4 Ab E Pt} n s; is non-empty which may lead to more practical implementations.",
        "Note that we may have that the tabular ELR algorithm manipulates items of the form [A a] which would not occur in any search path of the nondeterministic ELR algorithm, because in general such a A is the union of many sets A' of items [A' a] which would be manipulated at the same input position by the nondeterministic algorithm in different search paths.",
        "With minor differences, the above tabular ELR algorithm is described in [21].",
        "A tabular version of pseudo ELR parsing is presented in [20].",
        "Some useful data structures for practical implementation of tabular and non-tabular PLR, ELR and CF parsing are described in [8]."
      ]
    },
    {
      "heading": "Finding an optimal tabular algorithm",
      "text": [
        "In [14] Schabes derives the LC algorithm from LR parsing similar to the way that ELR parsing can be derived from LR parsing.",
        "The LC algorithm is obtained by not only splitting up the goto function into gotoi and goto2 but also splitting up goto2 even further, so that it nondeterministically yields the closure of one single kernel item.",
        "(This idea was described earlier in [5], and more recently in [10].)",
        "Schabes then argues that the LC algorithm can be determinized (i.e. made more deterministic) by manipulating the goto functions.",
        "One application of this idea is to take a fixed grammar and choose different goto functions for different parts of the grammar, in order to tune the parser to the grammar.",
        "In this section we discuss a different application of this idea: we consider various goto functions which are global, i.e. which are the same for all parts of a grammar.",
        "One example is ELR parsing, as its goto2 function can be seen as a determinized version of the goto2 function of LC parsing.",
        "In a similar way we obtain PLR parsing.",
        "Traditional LR parsing is obtained by taking the full determinization, i.e. by taking the normal goto function which is not split up.6",
        "We conclude that we have a family consisting of LC, PLR, ELR, and LR parsing, which are increasingly deterministic.",
        "In general, the more deterministic an algorithm is, the more parser states it requires.",
        "For example, the LC algorithm requires a number of states (the items in /Lc) which is linear in the size of the grammar.",
        "By contrast, the LR algorithm requires a number of states (the sets of items) which is exponential in the size of the grammar [2].",
        "The differences in the number of states complicates the choice of a tabular algorithm as the one giving optimal behaviour for all grammars.",
        "If a grammar is very simple, then a sophisticated algorithm such as LR may allow completely deterministic parsing, which requires a linear number of entries to be added to the parse table, measured in the size of the grammar.",
        "If, on the other hand, the grammar is very ambiguous such that even LR parsing is very nondeterministic, then the tabular realisation may at worst add each state to each set Ti,j, so that the more states there are, the more work the parser needs to do.",
        "This favours simple algorithms such as LC over more sophisticated ones such as LR.",
        "Furthermore, if more than one state represents the same subderivation, then computation of that subderivation may be done more than once, which leads to parse forests (compact representations of collections of parse trees) which are not optimally dense [1, 12, 7].",
        "Schabes proposes to tune a parser to a grammar, or in other words, to use a combination of parsing techniques in order to find an optimal parser for a certain grammar.7 This idea has until now not been realised.",
        "However, when we try to find a single parsing algorithm which performs well for all grammars, then the tabular ELR algorithm we have presented may be a serious candidate, for the following reasons: • For all i, j, and a at most one item of the form [A a] is added to Ti,j.",
        "Therefore, identical subderivations are not computed more than once.",
        "(This is a consequence of our optimization in Algorithm 6.)",
        "Note that this also holds for the tabular CF algorithm.",
        "• ELR parsing guarantees the correct-prefix property, contrary to the CP algorithm.",
        "This prevents computation of all subderivations which are useless with regard to the already processed input.",
        "• ELR parsing is more deterministic than LC and PLR parsing, because it allows shared processing of all",
        "common prefixes.",
        "It is hard to imagine a practical parsing technique more deterministic than ELR parsing which also satisfies the previous two properties.",
        "In particular, we argue in [8] that refinement of the LR technique in such a way that the first property above holds whould require an impractically large number of LR states.",
        "'This is reminiscent of the idea of \"optimal cover\" [5]."
      ]
    },
    {
      "heading": "Epsilon rules",
      "text": [
        "Epsilon rules cause two problems for bottom-up parsing.",
        "The first is non-termination for simple realisations of nondeterminism (such as backtrack parsing) caused by hidden left recursion [7].",
        "The second problem occurs when we optimize TD filtering e.g. using the sets Si: it is no longer possible to completely construct a set Si before it is used, because the computation of a derivation deriving the empty string requires Si for TD filtering but at the same time its result causes new elements to be added to Si.",
        "Both problems can be overcome [8]."
      ]
    },
    {
      "heading": "Conclusions",
      "text": [
        "We have discussed a range of different parsing algorithms, which have their roots in compiler construction, expression parsing, and natural language processing.",
        "We have shown that these algorithms can be described in a common framework.",
        "We further discussed tabular realisations of these algorithms, and concluded that we have found an optimal algorithm, which in most cases leads to parse tables containing fewer entries than for other algorithms, but which avoids computing identical subderivations more than once."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "The author acknowledges valuable correspondence with Klaas Sikkel, Rene Leermakers, Francois Barthelemy, Giorgio Satta, Yves Schabes, and Frederic Voisin."
      ]
    }
  ]
}
