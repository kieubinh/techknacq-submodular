{
  "info": {
    "authors": [
      "Gerald Penn",
      "Richmond H. Thomason"
    ],
    "book": "Workshop on Computational Phonology",
    "id": "acl-W94-0204",
    "title": "Default Finite State Machines and Finite State Phonology",
    "url": "https://aclweb.org/anthology/W94-0204",
    "year": 1994
  },
  "references": [],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We propose DFSM's as an extension of finite state machines, explore some of their properties, and indicate how they can be used to formalize naturally occurring linguistic systems.",
        "We feel that this implementation of two-level rules may be more linguistically natural and easier to work with computationally.",
        "We provide complexity results that shed light on the computational situation."
      ]
    },
    {
      "heading": "INTRODUCTION",
      "text": [
        "Two-level phonology combines the computational advantages of finite state technology with a formalism that permits phenomena to be described with familiar-looking rules.",
        "The problem with such a scheme is that, in practice, the finite state machines (FSM's) can grow too large to be manageable; one wants to describe them and to run them without having to deal with them directly.",
        "The Kimmo approachiseeks to achieve this by",
        "(1) decomposing the computational process into a battery of parallel finite state machines and (2) compiling rules (which notationally resemble familiar phonological rules, but which are inter",
        "preted declaratively) into these parallel finite state implementations.",
        "But the Kimmo formalism unfortunately gains no tractability in the process of compilation.",
        "Moreover, the compiler is complex enough to create software engineering problems, and this has led to practical difficulties, which in turn have made the Kimmo technology less generally available than one might wish.",
        "here, we describe a different finite-state foundation for two-level rules, involving generalizations of FSM's which we call Default Finite State Machines (DFSM's).",
        "Whether or not this approach remains intractable after compilation is an open question; but even without compilation, we believe that it has some conceptual advantages as well.",
        "DFSM's extend FSM's (specifically, finite-state transducers) so that transitions can be context-sensitive, and enforce a preference for the maximally specific transitions.",
        "The first change allows phonological rules to appear as labels of transition arcs in transducers; the second change incorporates the elsewhere condition into the computational mode1.2 DFSM's can be implemented directly, although there may be a method to compile them into a more efficient machine.",
        "We believe that either approach will be feasible for realistic linguistic applications (though, of course, not in the theoretically worst case).",
        "In particu-lax, the direct implementation of DFSM's is very straightforward; no rule compiler is needed, since rules are labels on the arcs of the machines themselves.",
        "This implementation may not provide an optimal allocation of space and time usage at run time, but we believe that it will be adequate for testing and research purposes.",
        "This presentation of DFSM's is confined to defining the basic ideas, presenting some examples of linguistic description, and providing a partial complexity analysis.",
        "In later work, we hope to explore descriptive and implementational issues further."
      ]
    },
    {
      "heading": "NOTATIONAL PRELIMINARIES",
      "text": [
        "We assume an alphabet C, with a reserved symbol 0 .0 for insertions and deletions.",
        "A replacement over C is a pair of the form 1 = (1,1') where (1) 1 E C and (2) 1' E C or l' = 0; Replacementsz is the set of replacements over E. US-strings is the set of strings over the set .C2 U x {0}] of replacements.",
        "We use roman letters to denote themselves: for instance, '1' denotes the letter 1.",
        "Boldface letters denote constant replacements: for instance, 1 is the pair (1,1).",
        "Moreover, c is the empty string over C, and e is the empty string over the ,C replacements.",
        "When the name of a subset of (e.g. C) is written in boldface, (e.g. C), the set of identity pairings is intended (e.g., C = {1 : 1/1 E C}).",
        "We use ordinary italics as variables over let-tiers, and boldface italics as variables over replacements and strings of replacements.",
        "Ordinarily, we will use I for replacements and z, y for strings of replacements.",
        "Finally, we use /:/\" for the pair (1,1').",
        "Where a E US-strings, U-String(x) is the underlying projection of z, and S-String(z) is its surface projection.",
        "That is, if a = (x, x'), then U-String(x) = x and S-String(x)= xi."
      ]
    },
    {
      "heading": "RULE NOTATION AND EXAMPLES",
      "text": [
        "The rules with which we are concerned are like the rewrite rules of generative phonology; they are general, context-conditioned replacements.",
        "That is, a rule allows a replacement if (1) the replacement belongs to a certain type, and (2) the surrounding context meets certain constraints.",
        "If we represent the contextual constraints extensionally, as sets of strings, a rule will consist of three things: a replacement type, and two sets of US-Strings.",
        "Thus, we can think of a rule as a triple (X, Y, F), where X and Y are sets of US-strings.",
        "Imagine that we are given a replacement instance I in a context (z, y), where z and y are US-strings.",
        "This contextualized replacement (z, 1, y) satisfies the rule if a E I, y E Y, and 1 E F. For linguistic and computational purposes, the sets that figure in rules must somehow be finitely represented.",
        "The Kimmo tradition uses regular sets, which can of course be represented by regular expressions, for this purpose.",
        "We have not been able to convince ourselves that regular sets are needed in phonological applications.' In-'The issue here is whether there are any linguistically plausible or well-motivated applications of the Kleene star in stating phonological rules.",
        "For instance, take the English rule that replaces \"e by 0 after a morpheme boundary preceded by one or more consonants preceded by a vowel.\" You could represent the context in question with the regular expression VCC; but you could equally well use VC I VCC I VCCC IVCCCC.The only way to distinguish the two rule formulations is by considering strings that violate the phonotactic constraints of English; but as far as we can see, there are no intuitions about the results of applying English rules to underlying strings like typppppei-ed.",
        "We do not question the usefulness stead, we make the stronger assumption that contexts can be encoded by finite sets of strings.",
        "A string satisfies such a context when its left (or its right) matches one of the strings in this set.",
        "(Note that satisfaction is not the same as membership; infinitely many strings can satisfy a finite set of strings.)",
        "Assuming a finite alphabet, all replacement types will be finite sets.",
        "With these assumptions, a rule can be finitely encoded as a pair ((X, Y), F), where the sets ./ and Y are finite, and F is a replacement type.",
        "Rule encodings, rule applicability and satisfaction are illustrated by the rule examples given below.",
        "The ideas are further formalized in the next section."
      ]
    },
    {
      "heading": "Language:",
      "text": [
        "Let .0 = {a, b, ', } Declare the following subsets of C:",
        "Rule description: Replace y by i before a morpheme boundary and after a constant US-consonant, i.e. after (1,1), where 1 E C."
      ]
    },
    {
      "heading": "Example rule applications:",
      "text": [
        "1.",
        "The rule encoded in Example 1 is satisfied by (+, 0) in the context (cat, s) because (1) for some z, cat = z-e, (2) for some y, s = and (3) (+, 0) E {(+, 0)}.",
        "of regular expressions in many computational applications, but are not convinced that they are needed in a linguistic setting.",
        "We would be interested to see a well motivated case in which the Kleene star is linguistically indispensable in formulating a two-level phonological rule.",
        "Such a case would create problems for the approach that we adopt here.",
        "2.",
        "The rule encoded in Example 2 is not satisfied by (y, i) in the context (spot :t , +:0ness) because there is no a such that spot +:t = a where 1E C.",
        "3.",
        "The rule encoded in Example 3 is not satisfied by (+, 0) in the context (ash, s #:0).",
        "In fact, the context is satisfied: (1) sh = a -sh for some a and (2) s #:0 e Csib for some y.",
        "(3.1) Moreover, the underlying symbol of the replacement (namely, +) matches the argument of the rule's replacement function.",
        "Under these circumstances, we will say that the rule is applicable.",
        "But the rule is not satisfied, because (3.2) the surface symbol of the replacement (namely, 0) does not match the value of the rule's replacement function (namely, e): thus, (+, 0) e)}."
      ]
    },
    {
      "heading": "INDEXED STRINGS AND RULES",
      "text": [
        "We now restate the above ideas in the form of formal definitions.",
        "An indexed US-String over C is a triple (a, I, y), where e, y E US-strings and I E Replacements.",
        "An indexed US-string is a presentation of a nonempty US-string that divides the string into three components: (1) a replacement occurring in the string, (2) the material to the left of that replacement, and (3) the material to the right of it.",
        "Where (a, 1, y) is an indexed string, we call a the left context of the string, y the right context of the string, and I the designated replacement of the string.",
        "A rule licenses certain sorts of replacements in designated sorts of environments, or context types.",
        "For instance, we may be interested in the environment after a consonant and before a morpheme boundary.",
        "Here, the phrase \"after a con-sonant\" amounts to saying that the string before the replacement must end in a consonant, and the phrase \"before a morpheme boundary\" says that the string after the replacement must begin in a morpheme boundary.",
        "Thus, we can think of a context type as a pair of constraints, one on the US-string to the left of the replacement, and the other on the US-string to its right.",
        "If we identify such constraints with the set of strings that satisfy them, a context type is then a pair of sets of US-strings; and an indexed string satisfies a context type in case its left and right context belong to the corresponding types.",
        "Definition 3.",
        "Replacement types.",
        "A replacement type over ,C is a partial function F from U {0} to CUM.",
        "(Thus, a replacement type is a certain set of replacements.)",
        "Dom(F) is the domain of F.",
        "The above definitions do not assume that the contexts are finitely encodable.",
        "But, as we said, we are assuming as a working hypotheses that phonological contexts are finitely encodable; this idea was incorporated in the method of rule encoding that we presented above.",
        "We now make this idea explicit by defining the notion of a finitely encodable rule.",
        "A subset X of US-strings is left-encoded by a set U in case X = LeftExp(U), and is right-encoded by V in case X = RightExp( V).",
        "(It is easy to get confused about the usage of \"left\" and \"right\" here; in left encoding, the left of the encoded string is arbitrary, and the right must match the encoding set.",
        "We have chosen our terminology so that a left context type will be left-encoded and a right context type will be right-encoded.)",
        "A context type C = (X, Y) is encoded by a pair (U, V) of sets in case U left-encodes X and V right-encodes Y.",
        "A rule R. = (C, F) is finitely encoded by a rule encoding structure ((U, V), g) in case (U, V) encodes C, g = F, and U and V are finite.",
        "In the following material, we will not only confine our attention to finitely encodable rules, but will refer to rules by their encodings; when the notation ((X, Y), F) appears below, it should be read as a rule encoding, not as a rule.",
        "Thus, for instance, the indexed string (cat, +:0 , s) satisfies the rule (encoded by) (({e}, {e}), {(+, 0)}), even though cat ft {e}."
      ]
    },
    {
      "heading": "SPECIFICITY OF CONTEXT TYPES AND RULES",
      "text": [
        "We have a good intuitive grasp of when one context type is more specific than another.",
        "For instance, the context type preceded by a back vowel is more specific than the type preceded by a vowel; the context type followed by an obstruent is neither more nor less specific than the type followed by a voiced consonant; the context type preceded by a vowel is neither more nor less specific than the type followed by a vowel.",
        "Since we have identified context types with pairs of sets of strings, we have a very natural way of defining specificity relations such as \"more specific than\", \"equivalent\", and \"more specific than or equivalent\": we simply use the subset relation.",
        "It is not in general true that if LeftExp(X) C LeftExp(r, then X C Y; for instance, LeftExp({aa,ba}) c LeftExp({a}), but {aa, ba} {a}.",
        "However, we can easily determine the specificity relations of two contexts from their finite encodings: Lemma 1.",
        "LeftExp(X) C LeftErp(Y) if for all z El there is a yE Y such that for some z, z = z-y.",
        "Similarly, RightExp(I) C RightExp( Y) if for all x E X there is a yE Y such that for some z, z = y Proof of the lemma is immediate from the definitions.",
        "It follows from the lemma that there is a tractable algorithm for testing specificity relations on finitely encodable contexts: Lemma 2.",
        "Let C be finitely encoded by (Xi, 12) and C' be finitely encoded by ( Y1, 1'2).",
        "Then there is an algorithm for testing whether C < C' that is no more complex than 0(m x n x k), where m = maxa Xii, I X2I), n = max(' Yii, I Y21), and k is the length of the longest string in Y1 U Y2.",
        "Proof.",
        "Test whether for each zi E Xi there is a yi E Yi that matches the end of xi.",
        "Then perform a similar test on 12 and Y2.",
        "DFSM'S A DFSM's transitions are labelled with finitely encodable rules rather than with pairs of symbols.",
        "Moreover, nondeterminism is restricted so that in case of conflicting transitions, a maximally specific transition must be selected.",
        "The critical definition is that of minimal satisfaction of an arc by an indexed path, where an indexed path represents a DFSM derivation, by recording the state transitions and replacements that are traversed in processing a US-String.",
        "A path w or w(so, sn) over M from state so to state sn is a string 80118111 ...1nsn, where for all m, 0 < m < n, sn, is a state of M and",
        "path has the form s, where s is a state.",
        "Remark 2: we use the notations w and r(s, s') alternatively for the same path; the second notation provides a way of referring to the beginning and end states of the path.",
        "Definition 15.",
        "Recovery of strings from paths.",
        "Let w = 80118111 ...1n8n.",
        "Then String(r) = 11.",
        "• • ln • Definition 16.",
        "Indexed paths.",
        "An indexed path over M is a triple (z-,1,7e) where w, w' are paths, and 1m E US-strings.",
        "(r,1, Tr') is an indexing of path a if and only if a =",
        "As we said, the above definition is the crucial component of the definition of DFSM's. According to this definition, to see whether a DFSM derivation is correct, you must check that each state transition represents a maximally specific rule application.",
        "This means that at each stage the DFSM does not provide another arc with a competing replacement and a more specific context.",
        "(\"Competing\" means that the underlying symbols of the replacement match; a replacement competes even if the surface symbols does not match the letter in the US-String being tested.",
        ")4"
      ]
    },
    {
      "heading": "EXAMPLE: SPELLING RULES FOR ENGLISH STEM-FSUFFIX COMBINATIONS",
      "text": [
        "The following is an adaptation of the treatment in Antworth (1990) of English spelling rules, which 'This use of competition builds some directional bias into the definition of DFSM's, i.e., some preference for their use in generation.",
        "Even if we are using DFSM's for recognition, we will need to verify that the recognized string is generated from an underlying form by a derivation that does not allow more specific corn peting derivations.",
        "in turn is taken from Karttunen and Wittenburg (1983).",
        "• M = (S , i ,T , A) , where S {i, s, t}.",
        "{t} – Task of i: Begin and process left word boundary.",
        " – Task of s: Process stem and suffixes.",
        " – Task oft: Quit, having processed right word boundary.",
        "• Remark: the small number of states is deceptive, since contexts are allowed on the arcs.",
        "An equivalent finite-state transducer would have many hundreds of states at least.",
        "• Remark: the relatively small number of arcs enumerated below is also deceptive, since two of these \"arcs,\" arc 3 and arc 13, are actually schemes.",
        "In the following discussion we will speak loosely and refer to these schemes as arcs; this will simplify the discussion and should create no confusion.",
        "• Declare the following subsets of E:",
        "• Where 8, E S, let A,,,,, = {A/A E A and for some 1,A = (s, s', R)}.",
        "We present arcs by listing the rules associated with the arcs, for each appropriate pair (s, s') of states.",
        "We will give each arc a numerical label, and give a brief explanation of the purpose of the arc.",
        "I.",
        "The derivation that relates #kiss+s# to Okisses0 proceeds as follows.",
        "1.",
        "Begin in state i looking at #:0.",
        "2.",
        "Follow arc 2 to s, recognizing k:k. (This is the only applicable arc.)",
        "3.",
        "Follow arc 3 to s, recognizing i:i.",
        "(This is the only applicable arc.)",
        "4.",
        "Follow arc 3 to 8, recognizing s:s. (This is the only applicable arc.)",
        "5.",
        "Follow arc 3 to s, recognizing s:s. (This is the only applicable arc.)",
        "6.",
        "Follow arc 6 to 8, recognizing +:e. (Arc 2 is also applicable here; but see the next illustration.)",
        "7.",
        "Follow arc 3 to 8, recognizing s:s. (This is the only applicable arc.)",
        "8.",
        "Follow arc 14 to f, recognizing #:0.",
        "(This is the only applicable arc.)",
        "II.",
        "No derivation relates #kiss-Fs# to Okiss0s0.",
        "Any such derivation would have to proceed like the above derivation through Step 5.",
        "At the next step, the conditions for two arcs are met: arc 2 (replacing + with 0) and arc 6 (replacing + with e).",
        "Since the context of the latter 'Here, C+ can be any string of no more than four consonants.",
        "arc is more specific, it must apply; there is no derivation from this point using arc 2.",
        "III.",
        "The derivation that relates #try+ing# to Otry0ing0 proceeds as follows.",
        "1.",
        "Begin in state i looking at #:0.",
        "2.",
        "Follow arc 2 to s, recognizing t:t. (This is the only applicable arc.)",
        "3.",
        "Follow arc 3 to s, recognizing r:r. (This is the only applicable arc.)",
        "4.",
        "Follow arc 8 to a, recognizing y:y.",
        "(There are three applicable arcs at this point: arc 3, arc 7, and arc 8.",
        "However, arcs 3 and 7 are illegal here, since their contexts are both less specific than arc 8's.) 5.",
        "Follow arc 2 to 8, recognizing +:0.",
        "(This is the only applicable arc.)",
        "6.",
        "Follow arc 3 to s, recognizing i:i.",
        "(This is the only applicable arc.)",
        "7.",
        "Follow arc 3 to 8, recognizing n:n. (This is the only applicable arc.)",
        "8.",
        "Follow arc 3 to 8, recognizing g:g. (This is the only applicable arc.)",
        "9.",
        "Follow arc 14 to f, recognizing #:0.",
        "(This is the only applicable arc.)",
        "IV.",
        "No derivation relates #try+ing# to OtriOing0.",
        "Any such derivation would have to proceed like the above derivation through Step 3.",
        "At the next step, arc 7 cannot be traversed, since arc 8 is also applicable and its context is more specific.",
        "Therefore, no arc is minimally satisfied and the derivation halts at this point."
      ]
    },
    {
      "heading": "COMPUTATIONAL COMPLEXITY",
      "text": [
        "We now consider the complexity of using DFSM's to create one side of a US-string, given the other side as input.",
        "There are basically two tasks to be analyzed:",
        "• DFSM GENERATION: Given a DFSM, D, over an alphabet, C, and an underlying form, u, does D generate a surface form, s, from u?",
        "• DFSM RECOGNITION: Given a DFSM, D, over an alphabet, and a surface form, s, does D generate an underlying form, u, from s?",
        "These two tasks are related to the tasks of KIMMO GENERATION and KIMMO RECOGNITION, the various versions of which Barton et al.",
        "(1987) proved to be NP-complete or worse."
      ]
    },
    {
      "heading": "Relationship to Kimmo",
      "text": [
        "The DFSM is not a generalization of Kitvimo; it is an alternative architecture for two-level rules.",
        "Kimmo takes a programming approach; it provides a declarative rule formalism, which can be related to a very large FS automaton or to a system of parallel FS automata.",
        "The automata are in general too unwieldy to be pictured or managed directly; they are manipulated using the rules.",
        "By integrating rules into the automata, the DFSM approach provides a procedural formalism that is compact enough to be diagrammed and manipulated directly.",
        "DFSM rules are procedural; their meaning depends on the role that they play in an algorithm.",
        "In a DFSM with many states, the effect achieved by a rule (where a rule is a context-dependent replacement type) will in general depend on how the rule is attached to states.",
        "In practice, however, the proceduralism of the DFSM approach can be limited by allowing only a few states, which have a natural morphonemic interpretation.",
        "The English spelling example that we presented in the previous section illustrates the idea.",
        "There are only four states.",
        "Of these, two of them delimit word processing; one of them begins processing by traversing a left word boundary, the other terminates processing after traversing a final word boundary.",
        "Of the remaining two states, one processes the word; all of the rules concerning possible replacements are attached to arcs that loop from this state to itself.",
        "The other is a nonterminal state with no arcs leading from it.",
        "In the example, the only purpose of this state is to render certain insertions or deletions obligatory, by \"trapping\" all US-strings in which the operation is not performed in the required context.",
        "In cases of this kind, where the ways in which rules can be attached to arcs are very restricted, the proceduralism of the DFSM formalism is limited.",
        "The uses of rules in such cases correspond roughly to two traditional types of phonological constructs: rules that allow certain replacements to occur, and constraints that make certain replacements obligatory.",
        "Although DFSM's are less declarative than Kimmo, we believe that it may be possible to interpret at least some DFSM's (those in which the roles that can be played by states are limited) using a nonmonotonic formalism that provides for prioritization of defaults, such as prioritized default logic; see (Brewka, 1993).",
        "In this way, DFSM's could be equated to declarative, axiomatic theories with a nonmonotonic consequence relation.",
        "But we have not carried out the details of this idea.",
        "Though it is desirable to constrain the number of states in a DFSM, there may be applications in which we may want more states than in the English example.",
        "For instance, one natural way to process vowel harmony would multiply states by creating a word-processing state for each vowel quality.",
        "Multiple modes of word-processing could also be used to handle cases (as in many Athabaskan languages) where different morphophonemic processes occur in different parts of the word.",
        "If they are desired, local translations of the four varieties of Kimmo rules6 into DFSM's are available, by using only one state plus a sink state.",
        "The following correspondences provide translations, in polynomial time, to one or more DFSM arcs:",
        "• Exclusion, u : sl .# LC – RC: an arc u s 1 LC – RC from the state to a sink state.",
        "• Context Restriction, u : s LC_RC: a loop u s / LC_RC, and an arc u 0 s / to a sink state.",
        "• Surface Coercion, u : s LC_RC: a loop u a 1 LC_RC, and for each surface character s' E C, an arc u – + s' 1 LC_RC to a sink state.",
        "• Composite, u : s <=> LC_RC: all of the arcs mentioned in Context Restriction or Surface Coercion."
      ]
    },
    {
      "heading": "Extended DFSM's",
      "text": [
        "The differences between Kimmo and DFSM's prohibit the complexity analysis for the corresponding two Kimmo problems from naturally extending to an analysis of DFSM generation and recognition.",
        "In fact, we can define an extended DFSM (EDFSM), which drops the finite encodability requirement that Kimmo lacks, for which we have the following result: Theorem 1.",
        "EDFSM GENERATION is PSPACE-hard Proof by reduction of REGULAR EXPRESSION NON-UNIVERSALITY (see Figure 1).",
        "Given an alphabet E, and a regular expression, a 0 (A, over E, we define an EDFSM over the alphabet, E U {$}, where $ E. We choose one non-empty string aEL(a) of length n. The EDFSM first recognizes each character in a, completing the task at state so: --■ al / (C:,C)*_(C:Z)* 7 an a.",
        "/ ( )* C:e )\"",
        "where the latter rule traverses to some state si, with a being the expression which replaces each atom, b, in a by its constant replacement, b:b , and likewise for E. From si, the EDFSM then recognizes a again, terminating at the only final state.",
        "We provide •this EDFSM, along with the input a$a to EDFSM GENERATION.",
        "This EDFSM can accept Ace if and only if, at state so, the context (E*, E*) is not more specific than the context ((a + $), (a + $)).",
        "So, we have:"
      ]
    },
    {
      "heading": "The Complexity of DFSM GENERATION",
      "text": [
        "Finite encodability foils the above proof technique, since one can no longer express arbitrary regular expressions over pairs in the contexts of rules.",
        "In fact, as we demonstrated above, there is a polynomial-time algorithm for comparing the specificities of finitely-encodable contexts.",
        "Finite encodability does not, however, restrict the complexity of DFSM's enough to make DFSM GENERATION polynomial time: Theorem 2.",
        "DESM GENERATION is NP-complete.",
        "Proof DFSM GENERATION is obviously in NP.",
        "The proof of NP-hardness is a reduction of 3-SAT.",
        "Given an input formula, w, we construct a DFSM consisting of one state over an alphabet consisting of 0, 1, #, one symbol, ui, for each variable in w, and one symbol, cj, for each conjunct in w. Let m be the number of variables in w, and n, the number of conjuncts.",
        "For each variable, ui, we add four loops:",
        "The first two choose an assignment for a variable, and the second two enforce that assignment's consistency.",
        "For each conjunct, Iji V lj3 V lis, where the l's are literals, we also add three loops, one for each literal.",
        "The loops enforce a value of 1 on the symbol uj, if /j, is a positive literal, or 0, if it is negative.",
        "For example, for the conjunct V --1u3 V u4, we add the following three rules: cj --+ cj / ui:1 u2:.0 urn:C – + cj / u3:0 u4LC urn:e cj / u4:1 u5:C um:e Thus, the input to DFSM GENERATION is the above DFSM plus an input string created by iterating the substring u1... time' for each conjunct.",
        "The input string corresponding to the formula, ( – mi V u2 V u4) A ( – ,u2 V u3 V -,u4) A (u1 V u2 V u3), would be #121 u2u3u4ci u u2u3u4c2ui u2 u3u4c3.",
        "The DFSM accepts this input string if and only if the input formula is satisfiable; and this translation is linear in m n. 0"
      ]
    },
    {
      "heading": "Compilation",
      "text": [
        "Of course, we should consider whether the complexity of DFSM GENERATION can be compiled out, leaving a polynomial-time machine which accepts input strings.",
        "This can be formalized as the separate problem:",
        "• FIXED-DFSM-GENERATION: For some DFSM, D, over alphabet, given an underlying form, u, does .D generate a surface form, s, from u?",
        "Whether or not FIXED DFSM GENERATION belongs to P remains an open problem.",
        "It is, of course, no more difficult than the general DFSM GENERATION problem, and thus no more difficult than NP-complete.",
        "The method used in the proof given above, however, does not naturally extend to the case of FIXED DFSM GENERATION, since we cannot, with a fixed DFSM, know in advance",
        "how many variables to expect in a given input formula, without which we cannot use the same trick with the left context to preserve the consistency of variable assignment.",
        "Even more interestingly, the technique used in the proof of PSPACE-hardness of EDFSM GENERATION does not naturally extend to fixed EDFSM's either; thus, whether or not FIXED DFSM GENERATION belongs to P is an open question as wells.",
        "Dropping finite encodability, of course, affects the compilation time of the problem immensely."
      ]
    },
    {
      "heading": "Nulls",
      "text": [
        "The two proofs we have given remain valid if we switch all of the underlying forms with their surface counterparts.",
        "Thus, without nulls, EDFSM RECOGNITION is PSPACE-hard, DFSM RECOGNT1ON is NP-complete, and, if FIXED DFSM GENERATION is in P, then we can presumably use the same compilation trick with the roles of underlying and surface strings reversed to show that FIXED DFSM RECOGNITION is in P as well.",
        "If nulls are permitted in surface realizations, however, DFSM RECOGNTION becomes much more difficult, even with finite encodability enforced: Theorem 3.",
        "DFSM RECOGNTION with nulls is PSPACE-hard.",
        "Proof by reduction of CONTEXT-SENSITIVE LANGUAGE MEMBERSHIP (see Figure 2).",
        "Given a context-sensitive grammar and an input string of length m, we let the input surface form to the DFSM RECOGNTION problem be the same as the input string.",
        "We then design a DFSM with an alphabet equal to E U {$, !",
        "}, where E is the the set of non-terminals plus the set of terminals.",
        "The DFSM first copies each surface input symbol to the corresponding position in the underlying form, and then adds the pair 8:0, completing the task in a state so.",
        "Having copied the string onto the underlying side of the pair, the remainder of the recognized underlying form will consist of rewritings of the string for each rule application, and will be paired with surface nulls at the end of the input string.",
        "Each rewriting will be separated by a $ symbol, and, as the string length changes, it will be padded by !",
        "symbols.",
        "For each rule a -4, #, we add a cycle to the DFSM, emanating from state so, which first 'It is quite unlikely, however, since the reduction can probably be made with a different PSPACE-complete problem, from which the NP-completeness of FIXED EDFSM GENERATION would follow as a corollary.",
        "writes j copies of the !",
        "symbol to the underlying form, where j =6 - a, b = pi, and a = laj:",
        "The cycle then copies part of the most recent $-bounded string of symbols with a family of loops of the form: -+ 0 cr:C(C:C ...,,,+j (r1) for each a E E. It then recognizes /I, and : writes a, with:",
        "It then copies the rest of the most recent $- bounded string, using copy of the family of loops in (r1), and then adds a new $ with a rule that also ensures that this second loop has iterated the appropriate number of times by checking that the length has been preserved: $ •-■• 0 / ...,„ (r2) The DFSM also has a loop emanating from so which adds more !",
        "symbols: !",
        "-+ 0 / !",
        ":.0 ( E:L .C:.0 All of the rule-cycles will use this to copy previously-added !",
        "symbols, as the string shrinks in size.",
        "The proper application of this loop is also ensured by the length-checking of (r2).",
        "Finally, we add one arc to the DFSM from so to the only final state which checks that the final copy of the string contains only the distinguished"
      ]
    },
    {
      "heading": "symbol, S:",
      "text": [
        "Thus, the DFSM recognises the surface form if and only if there is a series of rewritings from the input string to S using the rules of the grammar, and the translation is linear in the size of the input string times the number of rules.",
        "0 Since there exist fixed context-sensitive grammars for which the acceptance problem is NP-hard9, the NP-hardness of FIXED DFSM RECOGNITION with nulls follows as a corollary."
      ]
    },
    {
      "heading": "CONCLUSION",
      "text": [
        "We claimed that DFSM's provide an approach to rules that is likely to seem more natural and intuitive to phonologists.",
        "Bridging the gap between linguistically adequate formalisms and computationally useful formalisms is a long-term, community effort, and we feel that it would be premature to make claims about the linguistic adequacy of the approach; this depends on whether two-level approaches can be developed and deployed in a way that will satisfy the theoretical and explanatory needs of linguists.",
        "A specific claim on which our formalism depends is that all natural two-level phonologies can be reproduced using DFSM's with finitely encodable rules.",
        "We feel that this claim is plausible, but it needs to be tested in practice.",
        "Computationally, our complexity work so far on DFSM's does not preclude the possibility that compilers for generation and recognition (without nulls) exist which will allow for polynomial-time behavior at runtime.",
        "Although this question must eventually be resolved, we feel that any implementation is likely to be simpler than that required for Kimmo, and that even a direct implementation of DFSM's can prove adequate in many circumstances.",
        "We have not constructed an implementation as yet.",
        "Like other two-level approaches, we have a problem with surface nulls.",
        "It is possible in most realistic recognition applications to bound the number of nulls by some function on the length of the overt input; and it remains to be seen whether a reasonable bound could sufficiently improve complexity in these cases.",
        "We have dealt with the problem of underlying nulls by simply ruling them out.",
        "This simplifies the formal situation considerably, but we do not believe that it is acceptable as a general solution; for instance, we can't expect all cases of epentheses to occur at morpheme boundaries.",
        "If underlying nulls are allowed, though, we will somehow need to limit the places where underlying nulls can occur; this is another good reason to pay attention to a phonotactic level of analysis."
      ]
    },
    {
      "heading": "ACKNOWLEDGEMENTS",
      "text": [
        "This material is based upon work supported under a National Science Foundation Graduate Research Fellowship.",
        "This work was funded by National Science Foundation grant IRI-9003165.",
        "We thank the anonymous referees for helpful comments."
      ]
    },
    {
      "heading": "REFERENCES",
      "text": []
    }
  ]
}
