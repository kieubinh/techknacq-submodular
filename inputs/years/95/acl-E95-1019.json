{
  "info": {
    "authors": [
      "Glyn Morrill"
    ],
    "book": "Conference of the European Association for Computational Linguistics",
    "id": "acl-E95-1019",
    "title": "Higher-Order Linear Logic Programming of Categorial Deduction",
    "url": "https://aclweb.org/anthology/E95-1019",
    "year": 1995
  },
  "references": [
    "acl-P89-1033"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We show how categorial deduction can be implemented in higher-order (linear) logic programming, thereby realising parsing as deduction for the associative and non-associative Lambek calculi.",
        "This provides a method of solution to the parsing problem of Lambek categorial grammar applicable to a variety of its extensions.",
        "The present work deals with the parsing problem for Lambek calculus and its extensions as developed in, for example, Moortgat (1988), van Benthem (1991), Moortgat and Morrill (1991), Moortgat and Oehrle (1993), Morrill (199413) and Hepple (1995).",
        "Some previous approaches to parsing Lambek grammar such as KOnig (1989), Hepple (1990) and Hendriks (1993) have concentrated on the possibilities of sequent proof normalisation.",
        "In Roorda (1991), Moortgat (1992), Hen-driks (1993) and Oehrle (1994) a strategy of unfolding and labelling for proof net construction is considered.",
        "We aim to show here how such unfolding allows compilation into programs executable by a version of SLD resolution, implementing categorial deduction in dynamic linear clauses.",
        "The linearity resides in the use exactly once per word token of each of the clauses compiled from lexical categorisations.",
        "By dynamic, it is meant that clauses may be higher-order (they are hereditary Harrop Horn clauses) so that clausal resolution involves insertion in, as well as retraction from, the resolution database; see Miller et al.",
        "(1991), and Hodas and Miller (1994).",
        "It is shown how a range of calculi can be treated by dealing with the highest common factor of connectives as linear logical validity.",
        "The prosodic (i.e. sublinear) aspects of word order and hierarchical structure are encoded in labels, in effect the term structure of quantified linear logic.",
        "Compiling labels according to interpretations in groupoids provides a general method for calculi with various structural properties and also for multimodal hybrid formulations.",
        "Unification must be carried out according to the structural axioms but is limited to one-way matching, i.e. one term is always ground.",
        "Furthermore, for the particular case of associative Lambek calculus an additional perspective of binary relational interpretation allows an especially efficient coding in which the span of expressions is represented in such a way as to avoid the computation of unifiers under associativity, and this can also be exploited for non-associative calculus.",
        "Higher-order linear logic programming has already been applied to natural language processing in, for example, Hodas (1992) and Hodas and Miller (1994), in work deriving from Pareschi (1989) and Pareschi and Miller (1990).",
        "What we show here is that such implementation can be realised systematically, indeed by a mechanical compilation, while grammars themselves are written in higher level categorial grammar formalism.",
        "Automated deduction for Lambek calculi is of interest in its own right but solution of the parsing problem for categorial logic allowing significant linguistic coverage demands automated deduction for more than just individual calculi.",
        "There is a need for methods applying to whole classes of systems in ways which are principled and powerful enough to support the further generalisations that grammar development will demand.",
        "We aim to indicate here how higher-order logic programming can provide for such a need.",
        "After reviewing the \"standard\" approach, via sequent proof normalisation, we outline the relevant features of (linear) logic programming and explain compilation and execution for associative and non-associative calculi in terms of groupoid and binary relational interpretations of categorial connectives.",
        "We go on to briefly mention multimodal calculi for the binary connectives.",
        "The parsing problem is usually construed as the recovery of structural descriptions assigned to strings by a grammar.",
        "In practice the interest is in computing semantic forms implicit in the structural descriptions, which are themselves usually implicit in the history of a derivation recognising well-formedness of a string.",
        "This is true in particular of compositional categorial architec",
        "tures and we shall focus on algorithms for showing well-formedness.",
        "The further step to computing semantics is unproblematic.",
        "For the non-associative Lambek calculus NL of Lambek (1961) we assume types freely generated from a set of primitive types by binary (infix) operators \\, / and •.",
        "A sequent comprises a succedent type A and an antecedent configuration I' which is a binary bracketed list of one or more types; we write I' A.",
        "The notation r(A) here refers to a configuration I' with a distinguished subconfiguration",
        "For the associative Lambek calculus L of Lambek (1958) the types are the same.",
        "A sequent comprises a succedent type A and an antecedent configuration I' which is a list of one or more types; again we write I' A.",
        "a. AAA id F A A(A) B A(F) B b. F A A (B) C A, r B",
        "Lambek showed Cut-elimination for both calculi, i.e. every theorem has a Cut-free proof.",
        "Of the remaining rules each instance of premises has exactly one connective occurrence less than the corresponding conclusion so Cut-elimination shows decidability through finite space Cut-free sequent proof search from conclusions to premises.",
        "Lifting is derivable in NL as follows:",
        "It is also derivable in L; indeed all NL derivations are converted to L derivations by simply erasing the brackets.",
        "But L-derivable composition depends essentially on associativity and is not NL-derivable:",
        "Even amongst the Cut-free proofs however there is still semantic equivalence under the Curry-Howard rendering (van Benthem, 1983; see Morrill, 1994b) and in this respect redundancy in parsing as exhaustive proof search since distinct lines of inference converge on common subproblems.",
        "This derivational equivalence (or: \"spurious ambiguity\") betrays the permutability of certain rule applications.",
        "Thus two left rules may be permutable: N/CN, CN, N \\S S can be proved by choosing to work on either connective first, And left and right rules are permutable: N/CN, CN S/(N \\ S)) may be proved by applying a left rule first, or a right rule, (and the latter step then further admits the two options of the first example).",
        "Such non-determinism is not significant semantically: the variants have the same readings; the non-determinism in partitioning by the binary left rules in L is semantically significant, but still a source of inefficiency in its backward chaining \"generate-and-test\" incarnation.",
        "Another source of derivational equivalence is that a complex id axiom instance such as N \\S N \\S can be proved either by a direct matching against the axiom scheme, or by two rule applications.",
        "This is easily solved by restricting id to atomic formulas.",
        "More problematic are the permutability of rule applications, the non-determinism of rules requiring splitting of configurations in L, and the need in NL to hypothesise configuration structure a priori (such hierarchical structure is not given by the input to the parsing problem).",
        "It seems that only the first of these difficulties can be overcome from a Gentzen sequent perspective.",
        "The situation regarding equivalence and rule ordering is solved, at least for L – {•L}, by sequent proof normalisation (KOnig, 1989; Hepple, 1990; Hendriks, 1993):",
        "This involves firstly ordering right rules before left rules reading from ensequent to axiom leaves",
        "(so left rules only apply to sequents with atomic succedents; this effects uniform proof; see Miller et al., 1991), and secondly further demanding successive unfolding of the same configuration type (\"focusing\").",
        "In the *-ed rules the succe-dent is atomic.",
        "A necessary condition for success is that an antecedent type is only selected by P* if it yields the succedent atom as its eventual range.",
        "Let us refer to (5) as I L L I is free of spurious ambiguity, and FL I' A iff F-© 1' pi.",
        "The focusing strategy breaks down for •L: (VP/PP)/N, N•PP VP requires switching between configuration types.",
        "It happens that left occurrences of product are not motivated in grammar, but more critically sequent proof normalisation leaves the non-determinism of partitioning, and offers no general method for multimodal extensions which may have complex and interacting structural properties.",
        "To eliminate the splitting problem we need some kind of representation of configurations such that the domain of functors need not be hypothesised and then checked, but rather discovered by constraint propagation.",
        "Such is the character of our treatment, whereby partitioning is explored by unification in the term structure of higher-order linear logic programming, to which we now turn.",
        "By way of orientation we review the (propositional) features of clausal programming.",
        "The first order case, naturally, corresponds to Prolog.",
        "Let us assume a set ATOM of atomic formulas, 0-ary, 1-ary, etc., formula constructors {• A .",
        ".",
        ".",
        "A • },E{0,1,.,,} and a binary (infix) formula constructor A sequent comprises an agenda formula A and a database r which is a bag of program clauses {B1, ..., B„}„,, > 0 (subscript in for multiset); we write r A.",
        "In BNF, the set of agendas corresponding to the nonterminal Age ArDA and the set of program clauses corresponding to the nonterminal PC.CS are defined by:",
        "For first order programming the set COAC of goals is defined by:",
        "I.e. the unit agenda is a consequence of any database containing its atomic clause.",
        "I.e. we can resolve the first goal on the agenda with the head of a program clause and then continue with the program as before and a new agenda given by prefixing the program clause subagenda to the rest of the original agenda (depth-first search).",
        "For the higher-order case agendas and program clauses are defined as above, but the notion of GO AC on which they depend is generalised to include implications:",
        "And a \"deduction theorem\" rule of inference is added:",
        "I.e. we solve a higher-order goal first on the agenda by adding its precondition to the database and trying to prove its postcondition.",
        "In linear logic programming the rules become resource conscious; in this context we write 0 for the conjunction and o – for the implication: A A ax (12) I.e. an atomic agenda is a consequence of its unit database: all program clauses must be \"used up\" by the resolution rule:",
        "I.e. a program clause disappears from the database once it is resolved upon: each is used exactly once.",
        "The deduction theorem rule for higher-order clauses also becomes sensitised to the employment of antecedent contexts:",
        "We shall motivate compilation into linear clauses directly from simple algebraic models for the calculi.",
        "In the case of L we have first interpretation in semigroups (L, +) (i.e. sets L closed under associative binary operations +; intuitively: strings under concatenation).",
        "Relative to a model each type A has an interpretation as a subset D(A) of L. Given that primitive types are interpreted as some such subsets, complex types receive their denotations by residuation as follows (cf. e.g. Lambek, 1988):",
        "For the non-associative calculus we drop the condition of associativity and interpret in arbitrary",
        "groupoids (intuitively: trees under adjunction').",
        "Categorial type assignment statements comprise a term a and a type A; we write a: A.",
        "Given a set of lexical assignments, a phrasal assignment is projected if and only if in every model satisfying the lexical assignments the phrasal assignment is also satisfied.",
        "A categorial sequent has a translation given by I • I into a linear sequent of type assignments which can be safely read as predications.",
        "For L we have the following (NL preserves input antecedent configuration in output succedent term structure):",
        "• • , Bn Al = (16) k0: , • • • • kn: 13;4; ko+ +kr,: A",
        "Categorial type assignment statements are translated into linear logic according to the interpretation of types.",
        "The polar translation functions are identity functions on atomic assignments; on complex category predicates they are defined mutually as follows (for related unfolding, but for proof nets, see Roorda, 1991; Moortgat, 1992; Hendriks, 1993; and Oehrle, 1994); 1 indicates the polarity complementary to p:",
        "The unfolding transformations have the same general form for the positive (configuration/database) and negative (succedent/agenda) occurrences; the polarity is used to indicate whether new symbols introduced for quantified variables in the interpretation clauses are ►etavariables (in italics) or Skolem constants (in boldface); we shall see examples shortly.",
        "The program clauses and agenda are read directly off the unfoldings, with the only manipulation being a flattening of positive implications into uncurried form:",
        "The sharing of a Skolem constant between A and B in (20) ensures that B can and must be used to prove A so that a mechanism for the lazy splitting of contexts is effected.",
        "The termination condition is met by a unit agenda with its unit database.",
        "By way of illustration for L consider composition given the sequent translation (21).",
        "IA\\B, B\\C A\\CI= (21) k: A\\B+, 1: B\\C+ k+1: A\\C-The assignments are unfolded thus: a+k: B o a: A b+1: C o b: B(22)",
        "k: A\\B+ 1: B\\C+ m+(k+1): C o m: A k+1: A \\ C-Then the proof runs as follows.",
        "database al-k: B o a: A3, (23) b+1: C o b: B2, in: A1 agenda 1. m+(k+1): C m: A '2. m+(k+1): C 3. m+k: B 4. in: A",
        "(This means that matching against the head of a clause and assembly of subgoals does not require any recursion or restructuring at runtime.)",
        "We shall also allow unit program clauses X o to be abbreviated X.",
        "Starting from the initial database and agenda, a proof will be represented as a list of agendas, avoiding the context repetition of sequent proofs by indicating where the resolution rule retracts from the database (superscript coindexed over-line), and where the deduction theorem rule adds to it (subscript coindexation): 'Though NL with product is incomplete with respect to finite trees as opposed to groupoids in general.",
        "database agenda",
        "The simple one-way term unification is very fast but it is unnatural from the point of view of parsing that, as for the sequent approach, a hierarchical binary structure on the input string needs to be posited before inference begins, and exhaustive search would require all possibilities to be tried.",
        "Later we shall see how hierarchical structure can be discovered rather than conjectured by factoring out horizontal structure.",
        "Let us note here the relation to IL] L applies (working back from the target sequent) right rules before left rules.",
        "Here, when a higher-order goal is found on the agenda its precondition is added to the database by DT.",
        "This precedes applications of the RES rule (hence the uniformity character) which corresponds to the left sequent inferences.",
        "It applies when the agenda goal is atomic and picks out antecedent types which yields that atom (cf. the eventual range condition of L ).",
        "The focusing character is embodied by creating in one step the objective of seeking all the arguments of an uncurried functor.",
        "By way of further example consider the following in L, with terms and types as indicated.",
        "(a book from which) the references are missing (27) the references are missing (28) r: N m: ((S/(N\\S))\\S)/PP r+m: S/PP We have compilation for 'are missing' as in Figure 1 yielding (29).",
        "I> (29) b+(in+a): So (b+k: S o (c+k: S o c: N)) a: PP And the succedent unfolds as follows: The problem is that a and Q are not deterministically given by y at the \"compile time\" of unfolding.",
        "The best we could manage seems to be to try different partitionings of y at execution time; but even if this could work it would still amount to trying different partitionings for •R.",
        "as in the sequent calculus: a source of non-determinism we seek to reduce.",
        "This limitation combines with the other difficulties with groupoid labelling of worst case of (even) one-way associative unification for L, and the need for a priori hypothesis of non-associative structure for NL.",
        "The method of solution resides in looking at an alternative model: the associative calculus has relational algebraic models (van Benthem, 1991) which interpret types as relations on some set V, i.e. as sets of ordered pairs.",
        "Given denotations for primitive types, those of compound types are fixed as subsets of V x V by:",
        "Points in V intuitively corresponds to string positions (as in definite clause grammars, and charts) and ordered pairs to the vertices of substrings pertaining to the categories to which they are assigned.",
        "This induces unfolding as follows:",
        "Derivation is as in figure 2.",
        "The unification at line 2 relies on associativity and as always atomic goals on the agenda are ground.",
        "But in general we have to try subproofs for different unifiers, that is, we effectively still have to guess partitioning for left rules.",
        "We shall see that this is not necessary, and that associative unification can he avoided.",
        "There is a further problem which will be solved in the same move.",
        "Unfolding of left products would create two positive subformulas and thus fall outside the scope of Horn clause programming.",
        "However, the term-labelled implementation as it has been given also fails for right products:",
        "database r: N5,",
        "b+(m+a): S o (b+k: S o (c+k: S o c: N)) a: PP 2, c+k: S o c: N34, agenda 1.",
        "(r+m)+1: S o 1: PP 2.",
        "(r+m)+1: S 3.",
        "S o (c+k: S o c: N))01: PP 4. r+k: S 01: PP 5. r: N®1: PP 6.",
        "1: PP",
        "1.",
        "3 - 2: C o 3 - 0: A DT 2.",
        "3 - 2: C RES j = 3 3.",
        "3 - 1: B RES i = 3 4.",
        "3 - 0: A RES",
        "In this way associative unification is avoided; indeed the only matching is trivial unification between constants and variables.",
        "So for L the relational compilation allows partitioning by the binary rules to be discovered by simple constraint propagation rather than by the generate-and-test strategy of normalised sequent proof.",
        "Although the (one-way) term unification for groupoid compilation of the non-associative calculus is very fast we want to get round the fact that a hierarchical binary structure on the input string needs to be posited before inference begins.",
        "We can do this through observation of the following:",
        "• All non-associative theorems are associative theorems (ignore brackets) • Interpret non-associative operators in the product algebra of NL groupoid algebra and L relational algebra, and perform labelled compilation accordingly • Use the (efficient) relational labelling to check associative validity • Use the groupoid labelling to check non-associative validity and compute the prosodic form induced",
        "I.e. the endsequent succedent groupoid term can be left as a variable and the groupoid unification performed on the return trip from axiom leaves after associative validity has been assured, as will be seen in our final example.",
        "The groupoid unification will now be one-way in the opposite direction.",
        "The simultaneous compilation separates horizontal structure (word order) represented by interval segments, and horizontal-and-vertical structure (linear and hierarchical organisation) represented by groupoid terms, and uses the efficient segment labelling to compute L-validity, and then the term labelling both to check the stricter NL-validity, and to calculate the hierarchical structure.",
        "In this way we use the fact that models for NL are given by intersection in the product of relational and groupoid models.",
        "Each type A has an interpretation D(A) as a subset of L x V x V:",
        "a, i new variables/ constants as p +1- k new variables/ constants as p +I-j new variables",
        "database i:1:F17F14, S o– (b+k-1-4: S o– S o– c-/-1: N)) (2) : PP', c+k-1-4: S o– c-/-1: N23, f-2-3: PP5 agenda",
        "1. d-0-3: S RES d = b+(m+a) 2.",
        "(b+k-0-4: S o– (c+k-/-4: So– c-I-1: N))®a-2-3: PP DT 3. b+k-0-4: S 0a-2-3: PP RES b = c 4. c-0-1: N 0a-2-3: PP RES c = r 5. a-2-3: PP RES a = f",
        "f-2-3: PP d-0-3: S The unfolding compilation yielding (41) for 'are missing' is given in Figure 3.",
        "(41) : So(b-+-k-i-4: S o– (c+k-/-4: So– c-1-1: N)) ®a-2-k,: PP The derivation is given in Figure 4.",
        "Note how the term unification computing the hierarchical structure can be carried out one-way in the reverse order to the forward segment matchings: d = b-1-(m+a) = c-F(m-Fa) r-I-(m-Fa) = (42) rd-(ind-f) In the case of NL-invalidity the term unification would fail.",
        "We mention finally multimodal generalisations.",
        "In multimodal calculi families of connectives {ii, \\i,•i}ie{1,...,.}",
        "are each defined by residuation with respect to their adjunction in a \"polygroupoid\" (L, (Moortgat and Morrill, 1991):",
        "Multimodal groupoid compilation for implications is immediate: This is entirely general.",
        "Any multimodal calculus can be implemented this way provided we have a (one-way) unification algorithm specialised according to the structural communication axioms.",
        "For example Morrill (1993) deals with multimodality for discontinuity which involves varying internal structural properties (associativity vs. non-associativity) as well as \"split/wrap\" interaction between modes.",
        "This is treated computationally in the current manner in Morrill (1994a) which also considers head-oriented discontinuity and unary operators projecting bracketed string structure.",
        "In these cases also simultaneous compilation including binary relational labelling can provide additional advantages.",
        "Labelled unfolding of categorial formulas has been invoked in the references cited as a way of checking well-formedness of proof nets for categorial calculi by unification of labels on linked formulas.",
        "This offers improvements over sequent formulations but raises alternative problems; for example associative unification in general can have infinite solutions and is undecidable.",
        "Taking linear validity as the highest common factor of sublinear categorial calculi we have been able to show a strategy based on resolution in which the flow of information is such that one term in unification is always ground.",
        "Furthermore binary relational labelling propagates constraints in such a way that",
        "computation of unifiers may be reduced to a subset of cases or avoided altogether.",
        "Higher-order coding allows emission of hypotheticals to be postponed until they are germane.",
        "Simultaneous compilation allows a factoring out of horizontal structure from vertical structure within the sublinear space in such a way that the partial information of word order can drive computation of hierarchical structure for the categorial parsing problem in the presence of non-associativity.",
        "The treatments for the calculi above and their multimodal generalisations have been implemented in Prolog (Morrill, 1994a)."
      ]
    }
  ]
}
