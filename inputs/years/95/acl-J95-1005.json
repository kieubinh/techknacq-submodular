{
  "info": {
    "authors": [
      "Friedrich Steimanno",
      "Christoph Brzoska"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J95-1005",
    "title": "Dependency Unification Grammar for PROLOG",
    "url": "https://aclweb.org/anthology/J95-1005",
    "year": 1995
  },
  "references": [
    "acl-C86-1046",
    "acl-J81-4003",
    "acl-J90-4003"
  ],
  "sections": [
    {
      "heading": "1. Introduction",
      "text": [
        "The programming language PROLOG has proved to be an excellent tool for implementing natural language processing systems.",
        "Its built-in resolution and unification mechanisms are well suited to both accept and generate sentences of artificial and natural languages.",
        "Although supporting many different linguistic formalisms, its straightforwardness and elegance have perhaps best been demonstrated with definite clause grammars (DCGs) (Pereira and Warren 1980), an extension to PROLOG's syntax allowing direct implementation of rules of context-free grammars as Horn clauses.",
        "While context-free grammars and DCGs – strongly related to the huge linguistic field of constituency or phrase structure grammars and their descendants – have become very popular among logic programmers, dependency grammars (DGs) have long remained a widely unnoticed linguistic alternative.",
        "DG is based on the observation that each word of a sentence has individual slots to be filled by others, its so-called dependents.",
        "Which dependents a particular word takes depends not only on its function within the sentence, but also on its meaning – like other contemporary linguistic frameworks, DG integrates both syntactic and semantic aspects of natural language.",
        "DG was first formalized by Tesniere (1959) and later, among others, by Gaifman (1965) and Hays (1964).",
        "The formalization presented in this paper is based on Hellwig's Dependency Unification Grammar (DUG) (Hellwig 1986).",
        "We merely add a framework for automatic translation of DUG rules to Horn clauses that makes DUGs as easy to implement as classic DCGs."
      ]
    },
    {
      "heading": "2. Dependency Grammar as Context-Free Grammar",
      "text": [
        "Whereas context-free grammars differentiate between terminals (coding the words of a language) and non-terminals (representing the constituents that are to be expanded), the symbols of a DG uniformly serve both purposes: like terminals they must be part of the sentence to be accepted (or generated), and like non-terminals, they call for additional constituents of the sentence.",
        "Despite this significant difference, DG can be defined in terms of context-free grammar, making the twofold role of its symbols explicit:"
      ]
    },
    {
      "heading": "Definition",
      "text": [
        "A context-free grammar G = (T, N, P, S) where – terminals and non-terminals are related by a one-to-one mapping",
        "n('Peter', noun(N)) --> [n('Peter', noun(N))].",
        "n(qilark', noun(N)) --> [n(cMark', noun(N))].",
        "n(book, noun(N)) --> n(_, det), [n(book, noun(N))].",
        "n(a, det) --> [n(a, det)].",
        "The terms n(., .)",
        "provide space for feature structures commonly employed to capture syntactic and semantic properties of words (Shieber 1986; Knight 1989).",
        "They serve only as an example here; other structures, including that used by Hellwig (1986), can also be employed.",
        "Prior to parsing, each sentence must be converted to a string of terms holding the features derived through lexical analysis.",
        "This preprocessing step also resolves lexical ambiguities by representing words with alternative meanings through different symbols.",
        "Parsing the sentences \"Peter gives Mark a book\" and \"Mark sleeps\" with the"
      ]
    },
    {
      "heading": "3. Direct Transformation of DUG Rules to Horn Clauses",
      "text": [
        "Although implementing DUG as DCG works acceptably, it makes no use of the rules' regular form: note how, when parsing the sentence \"Mark sleeps,\" the parser calls several rules before it realizes that the rule for give must fail (because the sentence does not contain give), even though the head already indicates that give is required for the rule to succeed.",
        "If, however, the word partially specified as n(_, verb(_)) in the body of the start rule is accepted before the next rule is selected, an intelligent parser can exploit the fact that the sentence's verb is sleep and immediately call the appropriate rule.",
        "We therefore suggest an alternative syntax and translation scheme that produces a more efficient DUG parser.",
        "In our DUG syntax, the head of a rule is separated from its body (holding the dependents of the word in the head) by the binary infix operator :>.",
        "The start rule",
        "where the arguments appended to each predicate hold input and output sentence, respectively, and where an accept predicate is inserted before each literal of the rule body.' Accordingly, n(sleep, verb(N)) :> n(_, noun(N)).",
        "becomes n(sleep, verb(N), _G1, _G2) :- accept(n(_G3, noun(N)), _G1, _G4), n(_G3, noun(N), _G4, _G2).",
        "Note that the head literal of the sleep rule need not be repeated in the body because the respective word is removed from the input sentence before the rule is called (in this case in the start rule).",
        "The fact that a word has no dependent is coded by n(well, adverb) :> ❑ .",
        "and translated to n(well, adverb, _G1, _G1).",
        "Like other contemporary grammar formalisms, DUG comes with syntactic extensions that code optionality and references."
      ]
    },
    {
      "heading": "3.1 Optionality",
      "text": [
        "Many dependents are optional.",
        "Rather than providing an alternative rule for every possible combination of dependents, it is more convenient to declare a dependent optional, meaning that a sentence is correct independent of its presence.",
        "For example, n(sleep, verb(N)) :> n(_, noun(N)), ?",
        "n(_, adverb).",
        "where ?",
        "precedes the optional dependent, is implemented as",
        "accepting \"Mark sleeps\" as well as \"Mark sleeps well.\""
      ]
    },
    {
      "heading": "3.2 Referencing",
      "text": [
        "References account for the fact that many words are similar in terms of the dependents they take.",
        "In order not to repeat the same set of rules over and over again, a reference operator (read 'goes like') is introduced that causes branching to the rule of an analogous word, as in n(yawn, verb(N)) :> ==> n(sleep, verb(N)).",
        "In this case, the word sleep being referred to is not a dependent of yawn, the PROLOG translation n(yawn, verb(N) , _G1, _G2) :- n(sleep, verb(N) , _G1, _G2) .",
        "therefore branches to the rule for sleep without accepting the word sleep.",
        "As a side effect, references introduce quasi non-terminals to DUG.",
        "For example, by factoring out common dependency patterns, it is possible to generalize the rules for transitive verbs and allow for exceptions to the rule at the same time: Y. standard dependents of transitive verbs in active voice transverb(N, active) :> word(_, noun(N)), % subject word(_, noun(_)).",
        "% object % standard dependents of transitive verbs in passive voice transverb(N, passive) :> word(_, noun(N)), 'h subject ?",
        "word(by, preposition).",
        "% optional agent % standard transitive verb word(like, verb(N, Voice)) :> ==> transverb(N, Voice).",
        "Friedrich Steimann and Christoph Brzoska Dependency Unification Grammar for PROLOG % transitive verb with additional indirect object word(give, verb(N, Voice)) :> ==> transverb(N, Voice), word(_, noun(_))."
      ]
    },
    {
      "heading": "4. A Word about Word Order",
      "text": [
        "Following Hellwig's DUG formalism, our PROLOG implementation does not code word order directly in the rules.",
        "Other DG formalisms, such as the one proposed by Gaifman (1965) and Hays (1964), mark the position of the head among its dependents by a special symbol in the body.",
        "The DUG parser can be adapted to follow this convention by accepting the symbol self in the rule body as in n(sleep, noun(N)) :> n(_, noun(N)), self.",
        "and by modifying both the preprocessor and the accept predicate so that the input sentence is split at the position of the dependent accepted and left and right remainders are passed to the next rules separately.",
        "However, many natural languages leave word order rather unconstrained, and its adequate handling is not a problem specific to DGs (see, for example, Pereira 1981, and Covington 1990)."
      ]
    },
    {
      "heading": "5. Notes on Performance",
      "text": [
        "The presented DUG formalism with free word order has successfully been employed to parse Latin sentences.",
        "Tracing showed that backtracking was considerably reduced as compared with an equivalent phrase structure grammar, although no good upper bound for complexity could be found (Steimann 1991).",
        "Although the pure DG formalism proved to be particularly practical for integration of idioms and exceptions, its lack of constituent symbols, i.e., non-terminals, would have lead to a grammar of enormous size and made it difficult to integrate special Latin constructs such as accusative cum infinitive or ablative absolute.",
        "However, as shown above, DUG is a hybrid grammar: although dependency rules are the backbone of the formalism, it allows the introduction of quasi non-terminals that are integrated into the grammar via references.",
        "If desired, phrase structure rules can thus easily be combined with ordinary dependency rules.",
        "The size of a grammar can be further reduced by introduction of order-sorted feature types (Alt-Kaci and Nasr 1986) supporting variable numbers of labeled arguments and subtyping.",
        "Using feature types instead of constructor terms for representing the words of a language increases readability and enables abstraction of rules as well as implementation of semantic type hierarchies supporting selectional restrictions (Steimann 1991)."
      ]
    },
    {
      "heading": "References",
      "text": [
        "Aft-Kaci, H., and Nasr, R. (1986).",
        "\"LOGIN: A logic programming language with built-in inheritance.\" The Journal of Logic Programming 3:185-215.",
        "Covington, M. A.",
        "(1990).",
        "\"Parsing discontinuous constituents in dependency grammar.\" Computational Linguistics 16(4):234-236.",
        "Gaifman, H. (1965).",
        "\"Dependency systems and phrase-structure systems.\" Information and Control 8:304-337.",
        "Hays, D. G. (1964).",
        "\"Dependency theory: A formalism and some observations.\" Language 40(4):511-525."
      ]
    },
    {
      "heading": "Appendix A",
      "text": []
    },
    {
      "heading": "The DUG Preprocessor",
      "text": [
        "The following PROLOG source code implements a simple preprocessor that converts source files containing DUG rules into target files consisting of Horn clauses only.",
        "Automatic creation of the parse tree has also been implemented.",
        "However, it is omitted here for clarity.",
        "Note that every call to a start rule must be extended by two list arguments: the input and the output sentence (the latter usually being the empty list [D. % operator directives (priorities must be adapted) op(1200, xfx, ':>')."
      ]
    }
  ]
}
