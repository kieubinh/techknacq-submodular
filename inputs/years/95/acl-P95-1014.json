{
  "info": {
    "authors": [
      "Mark Johnson",
      "Jochen Dorre"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P95-1014",
    "title": "Memoization of Coroutined Constraints",
    "url": "https://aclweb.org/anthology/P95-1014",
    "year": 1995
  },
  "references": [
    "acl-P83-1021",
    "acl-P85-1018",
    "acl-P94-1021"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Some linguistic constraints cannot be effectively resolved during parsing at the location in which they are most naturally introduced.",
        "This paper shows how constraints can be propagated in a memoizing parser (such as a chart parser) in much the same way that variable bindings are, providing a general treatment of constraint coroutining in memoization.",
        "Prolog code for a simple application of our technique to Bouma and van Noord's (1994) categorial grammar analysis of Dutch is provided."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "As the examples discussed below show, some linguistic constraints cannot be effectively resolved during parsing at the location in which they are most naturally introduced.",
        "In a backtracking parser, a natural way of dealing with such constraints is to coroutine them with the other parsing processes, reducing them only when the parse tree is sufficiently instantiated so that they can be deterministically resolved.",
        "Such parsers are particularly easy to implement in extended versions of Prolog (such as Pro-logII, SICStus Prolog and Eclipse) which have such coroutining facilities built-in.",
        "Like all backtracking parsers, they can exhibit non-termination and exponential parse times in situations where memoizing parsers (such as chart parsers) can terminate in polynomial time.",
        "Unfortunately, the coroutining approach, which requires that constraints share variables in order to communicate, seems to be incompatible with standard memoization techniques, which 'This research was largely conducted at the Institut fiir maschinelle Sprachverarbeitung in Stuttgart.",
        "We would like to thank Andreas Eisele, Pascal van Hen-tenryck, Martin Kay, Fernando Pereira, Edward Stabler and our colleagues at the Institut fiir maschinelle Sprachverarbeitung for helpful comments and suggestions.",
        "All remaining errors are our own.",
        "The Prolog code presented in this paper is available via anonymous ftp from lx.cog.brown.edu as ipubilemma.tar.Z require systematic variable-renaming (i.e., copying) in order to avoid spurious variable binding.",
        "For generality, conciseness and precision, we formalize our approach to memoization and constraints within Hafeld and Smolka's (1988) general theory of Constraint Logic Programming (CLP), but we discuss how our method can be applied to more standard chart parsing as well.",
        "This paper extends our previous work reported in DOrre (1993) and Johnson (1993) by generalizing those methods to arbitrary constraint systems (including feature-structure constraints), even though for reasons of space such systems are not discussed here."
      ]
    },
    {
      "heading": "2 Lexical rules in Categorial Grammar",
      "text": [
        "This section reviews Bouma and van Noord's (1994) (BN henceforth) constraint-based categorial grammar analysis of modification in Dutch, which we use as our primary example in this paper.",
        "However, the memoizing CLP interpreter presented below has also been applied to GB and HPSG parsing, both of which benefit from constraint coroutining in parsing.",
        "BN can explain a number of puzzling scope phenomena by proposing that heads (specifically, verbs) subcategorize for adjuncts as well as arguments (rather than allowing adjuncts to subcategorize for the arguments they modify, as is standard in Categorial Grammar).",
        "For example, the first reading of the Dutch sentence",
        "(1) Frits opzettelijk Marie lijkt te ontwijken",
        "deliberately seems avoid 'Fritz deliberately seems to avoid Marie' 'Fritz seems to deliberately avoid Marie' is obtained by the analysis depicted in Figure 1.",
        "The other reading of this sentence is produced by a derivation in which the adjunct addition rule 'A' adds an adjunct to lijki te, and applies vacuously to oni-wijken.",
        "It is easy to formalize this kind of grammar in pure Prolog.",
        "In order to simplify the presentation of the proof procedure interpreter below, we write clauses",
        "as 'H : B' where H is an atom (the head) and B is a list of atoms (the negative literals).",
        "The atom x(Cat, Left, Right) is true if the substring between the two string positions Left and Right can be analyzed as belonging to category Cat.",
        "(As is standard, we use suffixes of the input string for string positions).",
        "The modal operator 13' is used to diacritically mark untensed verbs (e.g., ontwijken), and prevent them from combining with their arguments.",
        "Thus untensed verbs must combine with other verbs which subcategorize for them (e.g., lijkt te), forcing all verbs to appear in a 'verb cluster' at the end of a clause.",
        "For simplicity we have not provided a semantics here, but it is easy to add a 'semantic interpretation' as a fourth argument in the usual manner.",
        "The forward and backward application rules are specified as clauses of x/3.",
        "Note that the application rules are left-recursive, so a top-down parser will in general fail to terminate with such a grammar.",
        "Lexical entries are formalized using a two place relation lex( Word, Cat), which is true if Cat is a category that the lexicon assigns to Word.",
        "The add_adjuncts/2 and division/2 predicates formalize the lexical rules 'A' (which adds adjuncts to verbs) and `.13' (the division rule).",
        "Note that the definitions of add_adjuncts/2 and division/2 are recursive, and have an infinite number of solutions when only their first arguments are instantiated.",
        "This is necessary because the number of adjuncts that can be associated with any given verb is unbounded.",
        "Thus it is infeasible to enumerate all of the categories that could be associated with a verb when it is retrieved from the lexicon, so following BN, we treat the predicates add_adjuncts/2 and division/2 as coroutined constraints which are only resolved when their second arguments become sufficiently instantiated.",
        "As noted above, this kind of constraint coroutining is built-in to a number of Prolog implementations.",
        "Unfortunately, the left recursion inherent in the combinatory rules mentioned earlier dooms any standard backtracking top-down parser to nontermination, no matter how coroutining is applied to",
        "the lexical constraints.",
        "As is well-known, memoizing parsers do not suffer from this deficiency, and we present a memoizing interpreter below which does terminate."
      ]
    },
    {
      "heading": "3 The Lemma Table proof procedure",
      "text": [
        "This section presents a coroutining, memoizing CLP proof procedure.",
        "The basic intuition behind our approach is quite natural in a CLP setting like the one of Hafeld and Smolka, which we sketch now.",
        "where the Xi are vectors of variables, p(X) and qi(Xi) are relational atoms and 0 is a basic constraint coming from a basic constraint language C. will typically refer to some (or all) of the variables mentioned.",
        "The language of basic constraints is closed under conjunction and comes with (computable) notions of consistency (of a constraint) and entailment (411 c 462) which have to be invariant under variable renaming.'",
        "Given a program P and a goal G, which is a conjunction of relational atoms and constraints, a P-answer of G is defined as a consistent basic constraint 4, such that G is valid in every model of P. SLD-resolution is generalized in this setting by performing resolution only on relational atoms and simplifying (conjunctions of) basic constraints thus collected in the goal list.",
        "When finally only a consistent basic constraint remains, this is an answer constraint 0.",
        "Observe that this use of basic constraints generalizes the use of substitutions in ordinary logic programming and the (simplification of a) conjunction of constraints generalizes unification.",
        "Actually, pure Prolog can be viewed as a syntactically sugared variant of such a CLP language with equality constraints as basic constraints, where a standard Prolog clause",
        "is seen as an abbreviation for a clause in which the equality constraints have been made explicit by means of new variables and new equalities",
        "Here the Xi are vectors of variables and the Ti are vectors of terms.",
        "Now consider a standard memoizing proof procedure such as Earley Deduction (Pereira and Warren 1983) or the memoizing procedures described by Tamaki and Sato (1986), Vieille (1989) or Warren (1992) from this perspective.",
        "Each memoized goal is associated with a set of bindings for its arguments; so in CLP terms each memoized goal is a 'This essentially means that basic constraints can be recast as first-order predicates.",
        "conjunction of a single relational atom and zero or more equality constraints.",
        "A completed (i.e., atomic) clause p(T) with an instantiated argument T abbreviates the non-atomic clause p(X) 4 X = T, where the equality constraint makes the instantiation specific.",
        "Such equality constraints are 'inherited' via resolution by any clause that resolves with the completed clause.",
        "In the CLP perspective, variable-binding or equality constraints have no special status; informally, all constraints can be treated in the same way that pure Prolog treats equality constraints.",
        "This is the central insight behind the Lemma Table proof procedure: general constraints are permitted to propagate into and out of subcomputations in the same way that Earley Deduction propagates variable bindings.",
        "Thus the Lemma Table proof procedure generalizes Earley Deduction in the following ways: 1.",
        "Memoized goals are in general conjunctions of relational atoms and constraints.",
        "This allows constraints to be passed into a memoized subcomputation.",
        "We do not use this capability in the categorial grammar example (except to pass in variable bindings), but it is important in GB and HPSG parsing applications.",
        "For example, memoized goals in our GB parser consist of conjunctions of X' and ECP constraints.",
        "Because the X' phrase-structure rules freely permit empty categories every string has infinitely many well-formed analyses that satisfy the X' constraints, but the conjoined ECP constraint rules out all but a very few of these empty nodes.",
        "2.",
        "Completed clauses can contain arbitrary negative literals (rather than just equality constraints, as in Earley Deduction).",
        "This allows constraints to be passed out of a memoized subcomputation.",
        "In the categorial grammar example, the add_adjunct s/ 2 and division/2 associated with a lexical entry cannot be finitely resolved, as noted above, so e.g., a clause",
        "In the categorial grammar example, a category becomes more instantiated when it combines with arguments, allowing eventually the add_adjuncts/2 and division/2 to be deterministically resolved.",
        "Thus we use the flexibility",
        "in the selection of goals to run constraints whenever their arguments are sufficiently instantiated, and delay them otherwise.",
        "4.",
        "Memoization can be selectively applied (Earley Deduction memoizes every computational step).",
        "This can significantly improve overall efficiency.",
        "In the categorial grammar example only x/3 goals are memoized (and thus only these goals incur the cost of table management).",
        "The 'abstraction' step, which is used in most memoizing systems (including complex feature grammar chart parsers where it is somewhat confusingly called 'restriction', as in Shieber 1985), receives an elegant treatment in a CLP approach; an 'abstracted' goal is merely one in which not all of the equality constraints associated with the variables appearing in the goal are selected with that goal.2 For example, because of the backward application rule and the left-to-right evaluation our parser uses, eventually it will search at every left string position for an uninstantiated category (the variable Y in the clause), we might as well abstract all memoized goals of the form x(C, L, R) to x(_, L,_), i.e., goals in which the category and right string position are uninstantiated.",
        "Making the equality constraints explicit, we see that the abstracted goal is obtained by merely selecting the underlined subset of these below: x(Xi, X2, Xz), Xi 7 C, X2 L, X3 = R. While our formal presentation does not discuss abstraction (since it can be implemented in terms of constraint selection as just described), because our implementation uses the underlying Prolog's unification mechanism to solve equality constraints over terms, it provides an explicit abstraction operation.",
        "Now we turn to the specification of the algorithm itself, beginning with the basic computational entities it uses.",
        "Definition 1 A (generalized) goal is a multiset of relational atoms and constraints.",
        "A (generalized) clause Ho BO is an ordered pair of generalized goals, where Ho contains at least one relational atom.",
        "A relational interpretation A (see Haffeld and Smolka 1988 for definition) satisfies a goal G if A satisfies each element of G, and it satisfies a clause Ho 4 Bo if either A fails to satisfy some element of Boor A satisfies each element of Ho.",
        "2After this paper was accepted, we discovered that a more general formulation of abstraction is required for systems using a hierarchy of types, such as typed feature structure constraints (Carpenter 1992).",
        "In applications of the Lemma Table Proof Procedure to such systems it may be desirable to abstract from a 'strong' type constraint in the body of a clause to a logically 'weaker' type constraint in the memoized goal.",
        "Such a form of abstraction cannot be implemented using the selection rule alone.",
        "This generalizes the standard notion of clause by allowing the head Ho to consist of more than one atom.",
        "The head Ho is interpreted conjunctively; i.e., if each element of Bois true, then so is each element of Ho.",
        "The standard definition of resolution extends unproblematically to such clauses.",
        "Definition 2 We say that a clause co = Ho Bo resolves with a clause c1 = H1 B1 on a non-empty set of literals C C Bo if there is a variant c1' of c1 of the form C Bl' such that V(co)n v(B11) c V(C) (i.e., the variables common to co and Bl' also appear in C, so there is no accidental variable sharing).",
        "If co resolves with ci on C, then the clause Ho 4 – (Bo – C) U Bl' is called a resolvent of c0 with ci on C. Now we define items, which are the basic computational units that appear on the agenda and in the lemma tables, which record memoized subcomputations.",
        "Definition 3 An item is a pair (I, c) where c is a clause and t is a tag, i.e., one of program, solution or table(B) for some goal B.",
        "A lemma table for a goal G is a pair (G, LG) where L0 is a finite list of items.",
        "The algorithm manipulates a set T of lemma tables which has the property that the first components of any two distinct members of T are distinct.",
        "This justifies speaking of the (unique) lemma table in T for a goal G. Tags are associated with clauses by a user-specified control rule, as described below.",
        "The tag associated with a clause in an item identifies the operation that should be performed on that clause.",
        "The solution tag labels 'completed' clauses, the program tag directs the proof procedure to perform a non-memoizing resolution of one of the clause's negative literals with program clauses (the particular negative literal is chosen by a user-specified selection rule, as in standard SLD resolution), and the table(B) tag indicates that a subcomputation with root goal B (which is always a subset of the clause's negative literals) should be started.",
        "Definition 4 A control rule is a function from clauses G B to one of program, solution or table(C) for some goal C C B.",
        "A selection rule is a function from clauses G B where B contains at least one relational atom to relational atoms a, where a appears in B.",
        "Because program steps do not require memoization and given the constraints on the control rule just mentioned, the list L0 associated with a lemma table (G, LG) will only contain items of the form (t,G B) where t is either solution or table(C) for some goal C C B.",
        "Definition 5 To add an item an item e = (t, H B) to its table means to replace the table (H, L) in T with (H,[elL]).",
        "Input A non-empty goal G, a program P, a selection rule S, and a control rule R. Output A set of goals G' for which R(G') = solution and P G 4 – G'.",
        "Global Data Structures A set T of lemma tables and a set A of items called the agenda.",
        "Algorithm Set T := {(G, 0)} and A := {(program,G G)}.",
        "Until A is empty, do: Remove an item e = (t, c) from A.",
        "Case t of program For each clause p E P such that c resolves with p on S(c), choose a corresponding resolvent c' and add (R(c'), c') to A. table(B) Add e to its table.3 If T contains a table (B', L) where B' is a variant of B then for each item (solution, ci) E L such that c resolves with c' on B choose a corresponding resolvent c\" and add (R(c\"), c\") to A.",
        "Otherwise, add a new table (B, 0) to T, and add (program, B B) to the agenda.",
        "solution Add e to its table.",
        "Let c = H B.",
        "Then for each item of the form (table(H'), ci) in any table in T where H' is a variant of H and c' resolves with c on H', choose a corresponding resolvent c\" and add (R(c\"), c\")",
        "The formal description of the Lemma Table proof procedure is given in Figure 2.",
        "We prove the soundness and completeness of the proof procedure in Dane and Johnson (in preparation).",
        "In fact, soundness is easy to show, since all of the operations are resolution steps.",
        "Completeness follows from the fact that Lemma Table proofs can be `unfolded' into standard SLD search trees (this unfolding is well-founded because the first step of every table-initiated subcomputation is required to be a program resolution), so completeness follows from Hafeld and Smolka's completeness theorem for SLD resolution in CLP."
      ]
    },
    {
      "heading": "4 A worked example",
      "text": [
        "Returning to the categorial grammar example above, the control rule and selection rule are specified by the Prolog code below, which can be informally described as follows.",
        "All x/3 literals are classified as `memo' literals, and add_adjuncts/2 and division/2 whose second arguments are not sufficiently instantiated are classified as 'delay' literals.",
        "If the clause contains a memo literal G, then the control rule returns table([G]).",
        "Otherwise, if the clause contains any non-delay literals, then the control rule 'In order to handle the more general form of abstraction discussed in footnote 2 which may be useful with typed feature structure constraints, replace B with a(B) in this step, where a(B) is the result of applying the abstraction operation to B.",
        "The abstraction operation should have the property that a(B) is exactly the same as B, except that zero or more constraints in B are replaced with logically weaker constraints.",
        "returns program and the selection rule chooses the leftmost such literal.",
        "If none of the above apply, the control rule returns solution.",
        "To simplify the interpreter code, the Prolog code for the selection rule and table(G) output of the control rule also return the remaining literals along with chosen goal.",
        "Because we do not represent variable binding as explicit constraints, we cannot implement 'abstraction' by means of the control rule and require an explicit abstraction operation.",
        "The abstraction operation here unbinds the first and third arguments of x/3 goals, as discussed above.",
        "abstraction( a (_ sLeft,_)] , ,Lett ,_)3 ) .",
        "x(A/#B, [Lt, [o]) 4 add(s \\ npAs \\ np), C), div(C, A/B).",
        "x(A, [Lt, B) add(s \\ np/(s \\ np), C), div(C, A/D), x(#D, [o], B).",
        "x(A, [o], B) 4 – x(A, [o], B).",
        "x(A, [o], B) 4 x(A/C, [o], D), x(C, D, B).",
        "x(A, [o], 13) 4 x(C, [o], D), x(A C, D, B).",
        "Figure 3 depicts the proof of a parse of the verb cluster in (1).",
        "Item 1 is generated by the initial goal; its sole negative literal is selected for program resolution, producing items 2-4 corresponding to three program clauses for x/3.",
        "Because items 2 and 3 contain 'memo' literals, the control rule tags them table; there already is a table for a variant of these goals (after abstraction).",
        "Item 4 is tagged program because it contains a negative literal that is not 'memo' or 'delay'; the resolution of this literal with the program clauses for lex/3 produces item 5 containing the constraint literals associated with lijkt te.",
        "Both of these are classified as 'delay' literals, so item 5 is tagged solution, and both are 'inherited' when item 5 resolves with the table-tagged items 2 and 3, producing items 6 (corresponding to a right application analysis with Izjkt le as functor) and item 19 (corresponding to a left application analysis with ontwijken as functor) respectively.",
        "Item 6 is tagged table, since it contains a x/3 literal; because this goal's second argument (i.e., the left string position) differs from that of the goal associated with table 0, a new table (table 1) is constructed, with item 7 as its first item.",
        "The three program clauses for x/3 are used to resolve the selected literal in item 7, just as in item 1, yielding items 8-10.",
        "The lex/3 literal in item 10 is resolved with the appropriate program clause, producing item 11.",
        "Just as in item 5, the second argument of the single literal in item 11 is not sufficiently instantiated, so item 11 is tagged solution, and the unresolved literal is 'inherited' by item 12.",
        "Item 12 contains the partially resolved analysis of the verb complex.",
        "Items 13-16 analyze the empty string; notice that there are no solution items for table 2.",
        "Items 17-19 represent partial alternative analyses of the verb cluster where the two verbs combine using other rules than forward application; again, these yield no solution items, so item 12 is the sole analysis of the verb cluster."
      ]
    },
    {
      "heading": "5 A simple interpreter",
      "text": [
        "This section describes an implementation of the Lemma Table proof procedure in Prolog, designed for simplicity rather than efficiency.",
        "Tables are stored in the Prolog database, and no explicit agenda is used.",
        "The dynamic predicate goal_table(G, I) records the initial goals G for each table subcomputation and that table's identifying index I (a number assigned to each table when it is created).",
        "The dynamic predicate table-solution(i, S) records all of the solution items generated for table I so far, and table_parent(I, T) records the table items T, called 'parent items' below, which are 'waiting' for additional solution items from table I.",
        "The 'top level' goal is prove(G, Cs), where G is",
        "a single atom (the goal to be proven), and Cs is a list of (unresolved) solution constraints (different solutions are enumerated through backtracking).",
        "prove/2 starts by retracting the tables associated with previous computations, asserting the table entry associated with the initial goal, and then calls take_action/ 2 to perform a program resolution on the initial goal.",
        "After all succeeding steps are complete, prove/2 returns the solutions associated with table 0.",
        "The predicate take_action(L, C, I) processes items.",
        "L is the item's label, C its clause and I is the index of the table it belongs to.",
        "The first clause calls complete/2 to resolve the solution clause with any parent items the table may have, and the third clause constructs a parent item term (which encodes both the clause, the tabled goal, and the index of the table the item belongs to) and calls insert_into_table/2 to insert it into the appropriate table."
      ]
    },
    {
      "heading": "6 Conclusion",
      "text": [
        "This paper has presented a general framework which allows both constraint coroutining and memoization.",
        "To achieve maximum generality we stated the Lemma Table proof procedure in 1143hfeld and Smolka's (1988) CLP framework, but the basic idea – that arbitrary constraints can be allowed to propagate in essentially the same way that variable bindings do – can be applied in most approaches to complex feature based parsing.",
        "For example, the technique can be used in chart parsing: in such a system an edge consists not only of a dotted rule and associated variable bindings (i.e., instantiated feature terms), but also contains zero or more as yet unresolved constraints that are propagated (and simplified if sufficiently instantiated) during application of the fundamental rule.",
        "At a more abstract level, the identical propagation of both variable bindings and more general constraints leads us to question whether there is any principled difference between them.",
        "While still preliminary, our research suggests that it is often possible",
        "to reexpress complex feature based grammars more succinctly by using more general constraints."
      ]
    }
  ]
}
