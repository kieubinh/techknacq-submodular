{
  "info": {
    "authors": [
      "Sanguthevar Rajasekaran",
      "Shibu Yooseph"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P95-1023",
    "title": "TAL Recognition in O(M(n2)) Time",
    "url": "https://aclweb.org/anthology/P95-1023",
    "year": 1995
  },
  "references": [
    "acl-H86-1020",
    "acl-J94-2002",
    "acl-P88-1032"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We propose an 0(M(n2)) time algorithm for the recognition of Tree Adjoining Languages (TALs), where n is the size of the input string and M(k) is the time needed to multiply two k x k boolean matrices.",
        "Tree Adjoining Grammars (TAGs) are formalisms suitable for natural language processing and have received enormous attention in the past among not only natural language processing researchers but also algorithms designers.",
        "The first polynomial time algorithm for TAL parsing was proposed in 1986 and had a run time of 0(n6).",
        "Quite recently, an 0(n3 M(n)) algorithm has been proposed.",
        "The algorithm presented in this paper improves the run time of the recent result using an entirely different approach."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The Tree Adjoining Grammar (TAG) formalism was introduced by Joshi, Levy and Takahashi (1975).",
        "TAGs are tree generating systems, and are strictly more powerful than context-free grammars.",
        "They belong to the class of mildly context sensitive grammars (Joshi, et al., 1991).",
        "They have been found to be good grammatical systems for natural languages (Kroch, Joshi, 1985).",
        "The first polynomial time parsing algorithm for TALs was given by Vi-jayashanker and Joshi (1986), which had a run time of 0(n6), for an input of size n. Their algorithm had a flavor similar to the Cocke-Younger-Kasami (CYK) algorithm for context-free grammars.",
        "An Earley-type parsing algorithm has been given by Schabes and Joshi (1988).",
        "An optimal linear time parallel parsing algorithm for TALs was given by Palis, Shende and Wei (1990).",
        "In a recent paper, Rajasekaran (1995) shows how TALs can be parsed in time 0 (n3 M(n)).",
        "In this paper, we propose an 0(M(n2)) time recognition algorithm for TALs, where M(k) is the time needed to multiply two k x k boolean matrices.",
        "The best known value for M(k) is 0(n2.376) (Coppersmith, Winograd, 1990).",
        "Though our algorithm is similar in flavor to those of Graham, Harrison, & Ruzzo (1976), and Valiant (1975) (which were algorithms proposed for recognition of Context Free Languages (CFLs)), there are crucial differences.",
        "As such, the techniques of (Graham, et al., 1976) and (Valiant, 1975) do not seem to extend to TALs (Satta, 1993)."
      ]
    },
    {
      "heading": "2 Tree Adjoining Grammars",
      "text": [
        "A Tree Adjoining Grammar (TAG) consists of a quintuple (N, E U {E}, /, A, S), where N is a finite set of nonterminal symbols, E is a finite set of terminal symbols disjoint from N, c is the empty terminal string not in E, I is a finite set of labelled initial trees, A is a finite set of auxiliary trees, S E Nis the distinguished start symbol The trees in / U A are called elementary trees.",
        "All internal nodes of elementary trees are labelled with nonterminal symbols.",
        "Also, every initial tree is labelled at the root by the start symbol S and has leaf nodes labelled with symbols from E U {e}.",
        "An auxiliary tree has both its root and exactly one leaf (called the foot node ) labelled with the same nonterminal symbol.",
        "All other leaf nodes are labelled with symbols in E U fel, at least one of which has a label strictly in E. An example of a TAG is given in figure 1.",
        "A tree built from an operation involving two other trees is called a derived tree.",
        "The operation involved is called adjunction.",
        "Formally, adjunction is an operation which builds a new tree -y, from an auxiliary tree /3 and another tree a (a is any tree - initial, auxiliary or derived).",
        "Let a contain an internal node m labelled X and let )3 be the auxiliary tree with root node also labelled X.",
        "The resulting tree 7, obtained by adjoining onto a at node m is built as follows (figure 2):",
        "1.",
        "The subtree of a rooted at m, call it t, is excised, leaving a copy of m behind.",
        "2.",
        "The auxiliary tree is attached at the copy of m and its root node is identified with the copy of m. 3.",
        "The subtree t is attached to the foot node of 16 and the root node of I (i.e. m) is identified with the foot node of P.",
        "This definition can be extended to include adjunction constraints at nodes in a tree.",
        "The constraints include Selective, Null and Obligatory adjunction constraints.",
        "The algorithm we present here can be modified to include constraints.",
        "For our purpose, we will assume that every internal node in an elementary tree has exactly 2 children.",
        "Each node in a tree is represented by a tuple < tree, node index, label >.",
        "(For brevity, we will refer to a node with a single variable m whereever there is no confusion) A good introduction to TAGs can be found in (Partee, et al., 1990)."
      ]
    },
    {
      "heading": "3 Context Free recognition in 0(M(n)) Time",
      "text": [
        "The CFG G = (N,E,P,A1), where Nis a set of Nonterminals {Ai, A2, ••) AO) E is a finite set of terminals, P is a finite set of productions, A1 is the start symbol is assumed to be in the Chomsky Normal Form.",
        "Valiant (1975) shows how the recognition problem can be reduced to the problem of finding Transitive Closure and how Transitive Closure can be reduced to Matrix Multiplication.",
        "Given an input string ala2....an E E*, the recursive algorithm makes use of an (71+1)x (n+1) upper triangular matrix b defined by",
        "= 0, for j i +1 and proceeds to find the transitive closure 6+ of this",
        "Instead of finding the transitive closure by the customary method based on recursively splitting into disjoint parts, a more complex procedure based on 'splitting with overlaps' is used.",
        "The extra cost involved in such a strategy can be made almost negligible.",
        "The algorithm is based on the following lemma",
        "1. performing a single matrix multiplication, and 2. finding the closure of a 2(n – r) x 2(n – r) upper triangular matrix of which the closure of the partitions [1 < i,j < n – r] and [n – r < i,j < 2(n – r)] are known.",
        "The idea behind (Valiant, 1975) is based on visualizing Ak E btj as spanning a tree rooted at the node Ak with leaves ai through aj_i and internal nodes as nonterminals generated from Ak according to the productions in P. Having done this, the following observation is made Given an input string a1 ...a and 2 distinct symbol positions, i and j, and a nonterminal Ak such that Ak E b., where < > j, then 3 a nonterminal Aki which is a descendent of Akin the tree rooted at Ak, such that Aki E bt where z < i,3 > j and Akt has two children Ak, and Ak2 such that Ak, E Nt,, and Ak2 E b.+1,.",
        "with i < s < j. Aki can be thought of as a minimal node in this sense.",
        "(The descendent relation is both reflexive and transitive) Thus, given a string al...an of length it, (say r = 2/3), the following steps are done :",
        "1.",
        "Find the closure of the first 2/3 ,i.e. all nodes spanning trees which are within the first 2/3 .",
        "2.",
        "Find the closure of the last 2/3 , i.e. all nodes spanning trees which are within the last 2/3.",
        "3.",
        "Do a composition operation (i.e. matrix multiplication) on the nodes got as a result of Step 1 with nodes got as a result of Step 2.",
        "4.",
        "Reduce problem size to al ...anpa and find closure of this input.",
        "1+2,/3...a.",
        "The point to note is that in step 3, we can get rid of the mid 1/3 and focus on the remaining problem size.",
        "This approach does not work for TALs because of the presence of the adjunction operation.",
        "Firstly, the data structure used, i.e. the 2 dimensional matrix with the given representation, is not sufficient as adjunction does not operate on contiguous strings.",
        "Suppose a node in a tree dominates a frontier which has the substring as ai to the left of the foot node and 401 to the right of the footnode.",
        "These substrings need not be a contiguous part of the input; in fact, when this tree is used for adjunction then a string is inserted between these two substrings.",
        "Thus in order to represent a node, we need to use a matrix of higher dimension, namely dimension 4, to characterize the substring that appears to the left of the footnode and the substring that appears to the right of the footnode.",
        "Secondly, the observation we made about an entry E b+ is no longer quite true because of the presence of adjunction.",
        "Thirdly, the technique of getting rid of the mid 1/3 and focusing on the reduced problem size alone, does not work as shown in figure 3: Suppose 7 is a derived tree in which 3 a node m on which adjunction was done by an auxiliary tree /3.",
        "Even if we are able to identify the derived tree 71 rooted at m, we have to first identify before we can check for adjunction.",
        "i3 need not be realised as a result of the composition operation involving the nodes from the first and last 2/3's ,(say r =2/3).",
        "Thus, if we discard the mid 1/3, we will not be able to infer that the adjunction had indeed taken place at node m."
      ]
    },
    {
      "heading": "4 Notations",
      "text": [
        "Before we introduce the algorithm, we state the notations that will be used.",
        "We will be making use of a 4-dimensional matrix A of size (n + 1) x (n + 1) x (n + 1) x (n + 1), where n is the size of the input string.",
        "(Vijayashanker, Joshi, 1986) Given a TAG G and an input string aia2..an, n > 1, the entries in A will be nodes of the trees of G. We say, that a node m < 71, node index , label >) E A(i,j, k, 1) if m is a node in a derived tree 7 and the subtree of 7 rooted at m has a yield given by either ai+1...aiXak+1...ai (where X is the footnode of n, j < k) or ai+1....a/ (when j = k).",
        "If a node m E A(i,j,k,1), we will refer to m as spanning a tree (i,j,k,1).",
        "When we refer to a node m being realised as a result of composition of two nodes ml and m2, we mean that 3 an elementary tree in which m is the parent of ml and m2.",
        "A Grown Auxiliary Tree is defined to be either a tree resulting from an adjunction involving two auxiliary trees or a tree resulting from an adjunction involving an auxiliary tree and a grown auxiliary tree.",
        "Given a node m spanning a tree (i,j,k,/), we define the last operation to create this tree as follows if the tree (i,j,k,l) was created in a series of operations, which also involved an adjunction by an auxiliary tree (or a grown auxiliary tree) (i, ji, kl, 1) onto the node m, then we say that the last operation to create this tree is an adjunction operation; else the last operation to create the tree (i,j,k,/) is a composition.",
        "The concept of last operation is useful in modelling the steps required, in a bottom-up fashion, to create"
      ]
    },
    {
      "heading": "5 Algorithm",
      "text": [
        "Given that the set of initial and auxiliary trees can have leaf nodes labelled with E, we do some preprocessing on the TAG G to obtain an Association List (ASSOC LIST) for each node.",
        "ASSOC LIST (m), where m is a node, will be useful in obtaining chains of nodes in elementary trees which have children labelled e. Initialize ASSOC LIST (m) = V m, and then call procedure MAKELIST on each elementary tree, in a top down fashion starting with the root node.",
        "Procedure MAKELIST (m) Begin",
        "1.",
        "If m is a leaf then quit 2.",
        "If m has children ml and m2 both yielding the empty string at their frontiers (i.e. m spans a subtree yielding E) then",
        "3.",
        "If m has children ml and m2, with only m2 yielding the empty string at its frontier, then",
        "We initially fill A(i,i+1,i+1,i+1) with all nodes from Sin', Vml, where Smi -= U ASSOC LIST (m1), ml being a node with the same label as the input ai+1, for 0 < i < n-1.",
        "We also fill A < j, with nodes from Sm2,Vm2, where ImP4 U ASSOC LIST (m2), m2 being a foot node.",
        "All entries 0 < i < n, are filled with nodes from Sm3,Vrn3, where S m3 = {m3} U ASSOC LIST (m3), m3 having label E. Following is the main procedure, Compute Nodes, which takes as input a sequence r1r2 rp of symbol positions (not necessarily contiguous).",
        "The procedure outputs all nodes spanning trees (i,j,k,/), with {i,/} E {ri,r2 rp} and {j,k} E {ri,ri + 1, •-•,rp}• The procedure is initially called with the sequence 012..n corresponding to the input string al an.",
        "The matrix A is updated with every call to this procedure and it is updated with the nodes just realised and also with the nodes in the ASSOC LISTs of the nodes just realised.",
        "Procedure Compute Nodes ( r1r2 r) Begin 1.",
        "If p = 2, then a. Compose all nodes E A(ri, j, k, r2) with all nodes E A(r2, r2, r2, r2), r1 < j < k < r2.",
        "Update A .",
        "b. Compose all nodes E A(ri , ri , ri, ri) with all nodes E A(ri,i, k, r2), r1 <j < k < r2.",
        "Update A. c. Check for adjunctions involving nodes realised from steps a and b. Update A .",
        "d. Return 2.",
        "Compute Nodes ( rir2 r2p/3 ).",
        "3.",
        "Compute Nodes ( ri+pis rp )- 4. a. Compose nodes realised from step 2 with nodes realised from step 3. b. Update A.",
        "5. a.",
        "Check for all possible adjunctions involving the nodes realised as a result of step 4. b. Update A.",
        "6.",
        "Compute Nodes ( rir2...rpi3ri+2p/3...rp )"
      ]
    },
    {
      "heading": "End",
      "text": [
        "Steps la,lb and 4a can be carried out in the following manner : Consider the composition of node ml with node m2.",
        "For step 4a, there are two cases to take care of.",
        "Case 1 If node ml in a derived tree is the ancestor of the foot node, and node m2 is its right sibling, such that ml E A(i, j, k ,1) and m2 E A(1,r,r, s), then their parent, say node m should belong to A(i, j,k, s).",
        "This composition of m/ with m2 can be reduced to a boolean matrix multiplication in the following way: (We use a technique similar to the one used in (Rajasekaran, 1995)) Construct two boolean matrices B1, of size ((n + 1)2p/3) x (p/3) and B2, of size",
        "and i E fri, ••, rp/3) and 1 E {ri÷p/3, ..r2p13} = 0 otherwise",
        "and 1 E {ri+p13, ..r2p13} and s E {r1+2p/3, rp} = 0 otherwise Clearly the dot product of the ijkth row of BI with the sth column of B2 is a 1 if m E A(i, j,k,․).",
        "Thus, update A(i, j,k, s) with {m} U ASSOC LIST (m).",
        "Case 2 If node m2 in a derived tree is the ancestor of the foot node, and node ml is its left sibling, such that ml E A(i, j, j, 1) and m2 E A(1, p, q, r), then their parent, say node m should belong to A(i,p,q, s).",
        "This can also be handled similar to the manner described for case 1.",
        "Update A(i, p, q, s) with {m} U"
      ]
    },
    {
      "heading": "ASSOC LIST (m).",
      "text": [
        "Notice that Case 1 also covers step la and Case 2 also covers step lb.",
        "Step 5a and Step lc can be carried out in the following manner We know that if a node m E A(i, j, k,1), and the root ml of an auxiliary tree E A(r, i,1, s), then adjoining the tree n, rooted at ml, onto the node m, results in the node m spanning a tree (r,j,k,․), i.e. m E A(r, j, k, s).",
        "We can essentially use the previous technique of reducing to boolean matrix multiplication.",
        "Construct two matrices Cl and C2 of sizes (p2/9) x (n+ 1)2 and (n + 1)2 x (n + 1)2, respectively, as follows",
        "= 0 otherwise Note that in C2 0<q<r<s<t<n. Clearly the dot product of the 11th row of Cl with the rith column of C2 is a 1 if m E A(i, r, s, I).",
        "Thus, update A(i, r, s,1) with {m} U ASSOC LIST (m).",
        "The input string aia2...an is in the language generated by the TAG G if 3 a node labelled S in some A(0, j, j,n), 0 <j < n."
      ]
    },
    {
      "heading": "6 Complexity",
      "text": [
        "Steps la, lb and 4a can be computed in",
        "Steps 5a and lc can be computed in 002/p2)2m(p2)).",
        "If T(p) is the time taken by the procedure Compute Nodes, for an input of size p, then",
        "where n is the initial size of the input string.",
        "Solving the recurrence relation, we get T(n) = 0(M(n2))."
      ]
    },
    {
      "heading": "7 Proof of Correctness",
      "text": [
        "We will show the proof of correctness of the algorithm by induction on the length of the sequence of symbol positions.",
        "But first, we make an observation, given any two symbol positions (r,, re), rt > r, +1 , and a node m spanning a tree (i, j, k ,1) such that i < r, and / > rt with j and k in any of the possible combinations as shown in figure 4.",
        "3 a node m which is a descendent of the node m in the tree (i,j,k,l) and which either E ASSOC LIST(ml) or is the same as m1, with ml having one of the two properties mentioned below : 1. ml spans a tree (i1, k1,11) such that the last operation to create this tree was a composition operation involving two nodes m2 and m3 with m2 spanning (ii, j2, k2, /2) and m3 spanning (12, is, k3,11).",
        "(with (r3 < 12 < re), < ), (r < li) and either (j2 = k2, j3 = j1, k3 = k1) Or (j2 = 11,k2 k1 ,j3 = k3) ) 2. ml spans a tree k1,11) such that the last operation to create this tree was an adjunction by an auxiliary tree (or a grown auxiliary tree) (i1,i2, k2,11), rooted at node m2, onto the node m1 spanning the tree (j2, j1, ki, k2) such that node m2 has either the property mentioned in (1) or belongs to the ASSOC LIST of a node",
        "which has the property mentioned in (1).",
        "(The labels of ml and m2 being the same) Any node satisfying the above observation will be called a minimal node w.r.t.",
        "the symbol positions (7-3, re).",
        "The minimal nodes can be identified in the following manner.",
        "If the node m spans (i, j, k, 1) such that the last operation to create this tree is a composition of the form in figure 5a, then m U ASSOC LIST(m) is minimal.",
        "Else, if it is as shown in figure 5b, we can concentrate on the tree spanned by node ml and repeat the process.",
        "But, if the last operation to create (i, j, k , 1) was an adjunction as shown in figure 5c, we can concentrate on the tree (ii, j, k, /1) initially spanned by node m. If the only adjunction was by an auxiliary tree, on node m spanning tree k,11) as shown in figure 5d, then the set of minimal nodes will include both m and the root ml of the auxiliary_ tree and the nodes in their respective ASSOC LISTs.",
        "But if the adjunction was by a grown auxiliary tree as shown in figure 5e, then the minimal nodes include the roots of 131, .., and the node m. Given a sequence < ri, r2, rp >, we call (rq, rq+i) a gap, if rq.“ rq + 1.",
        "Identifying minimal nodes w.r.t.",
        "every new gap created, will serve our purpose in determining all the nodes spanning trees (i, j, k, 1), with {i, E rz, • •, rp} • Theorem : Given an increasing sequence < r1, r2, rp > of symbol positions and given a. V gaps (rq,rq+1.",
        "), all nodes spanning trees (i,j,k,l) withrq<i<j<k<1<rq+i b. V gaps (rq,rq+1), all nodes spanning trees (i,j,k,l) such that either rq < i < rq+1 or rq < 1 < rq.4.1 c. V gaps (rq, rq+1), all the minimal nodes for the gap such that these nodes span trees (i,j,k,l) with {i,1} E { ri, r2, rp } and i < 1 in addition to the initialization information, the algorithm computes all the nodes spanning trees"
      ]
    },
    {
      "heading": "Base Cases",
      "text": [
        "For length = 1, it is trivial as this information is already known as a result of initialization.",
        "For length = 2, there are two cases to consider",
        "volving nodes from A(ri, r1, r1, ri) with nodes from A(ri, r2, r2, r2) and a composition involving nodes from A(ri, r2, r2, r2) with nodes from A(r2, r2, r2, r2), followed by a check for adjunction involving nodes realised from the previous two compositions, will be sufficient.",
        "Note that since there is only one symbol from the input (namely, ar,), and because an auxiliary tree has at least one label from E, thus, checking for one adjunction is sufficient as there can be at most one adjunction.",
        "2. r2 r1 + 1, implies that (ri, r2) is a gap.",
        "Thus, in addition to the information given as per the theorem, a composition involving nodes from A(ri, j,k,r2) with nodes from A(r2, r2, r2, r2) and a composition involving nodes from A(ri, ri, ri, ri) with nodes from A(ri, j, k, r2), (ri <j < k < r2), followed by an adjunction involving nodes realised as a result of the previous two compositions will be sufficient as the only adjunction to take care of involves the adjunction of some auxiliary tree onto a node m which yields e, and m E A(ri,r1,ri,r1) or m E A(r2 , r2 , r2, r2).",
        "Induction hypothesis : V increasing sequence < r1, r2, rq > of symbol positions of length < p, (i.e q < p), the algorithm, given the information as",
        "required by the theorem, computes all nodes spanning trees (i,j,k,l) such that {1, E { ri, r2, rq } and i <j < k <1.",
        "Induction : Given an increasing sequence < ri, r2, rp, rp+i > of symbol positions together with the information required as per parts a,b,c of the theorem, the algorithm proceeds as follows: 1.",
        "By the induction hypothesis, the algorithm correctly computes all nodes spanning trees (i,j,k,l) within the first 2/3, i.e, {i, /} E { r1, r2, r2(p+i)/3 } and i <1 .",
        "By the hypothesis, it also computes all nodes (i',F,k',19 within the last 2/3, i.e, { i', 1' } E frii-(p+i)/3, and i' < 1'.",
        "2.",
        "The composition step involving the nodes from the first and last 2/3 of the sequence < ri, r2, rp, rp+i >, followed by the adjunction step captures all nodes m such that either a. m spans a tree (i,j,k,/) such that the last operation to create this tree was a composition operation on two nodes ml and m2 with ml spanning (i,f,k',19 and m2 spanning (1',j\",k\",1).",
        "(with i E { r1, r2, r(p+i)/3 },",
        ")• b. m spans a tree (i,j,k,Osuch that the last operation to create this tree was an adjunction by an auxiliary or grown auxiliary tree 0, rooted at node ml, onto the node m spanning the tree (f,j,k,k9 such that node ml has either the property mentioned in (I) or it belongs to the ASSOC LIST of a node which has the property mentioned in (1).",
        "(The labels of m and ml being the same) Note that, in addition to the nodes m captured from a or b, we will also be realising nodes E"
      ]
    },
    {
      "heading": "ASSOC LIST (m).",
      "text": [
        "The nodes captured as a result of 2 are the minimal nodes with respect to the gap (r(p+i)/3, rii.2(p+i)/ 3) with the additional property that the trees (i,j,k,/) they span are such that i E { r1, r2, r(p+i)/3 } and 1E { ri+2(p+i)/3, 7))+1 }.",
        "Before we can apply the hypothesis on the sequence < ri , r2, r(p+i)/3, ri4-2(p+i),a, ••rp+i >, we have to make sure that the conditions in parts a,b,c of the theorem are met for the new gap (r(p+i)/3, ri+2(p+i)/3).",
        "It is easy to see that conditions for parts a and b are met for this gap.",
        "We have also seen that as a result of step 2, all the minimal nodes w.r.t the gap (r(p+i)/3, ri+2(p4.1)/3), with",
        "the desired property as required in part c have been computed.",
        "Thus applying the hypothesis on the sequence < r1, r2, .•, r(p+1)13, ri-1-2(p+i)/3, -rp+i >, the algorithm in the end correctly computes all the nodes spanning trees (i,j,k,l) with {i,1} E {ri,r2,..,ri}andi<j<k<l.D"
      ]
    },
    {
      "heading": "8 Implementation",
      "text": [
        "The TAL recognizer given in this paper was implemented in Scheme on a SPARC station-10/30.",
        "Theoretical results in this paper and those in (Rajasekaran, 1995) clearly demonstrate that asymptotically fast algorithms can be obtained for TAL parsing with the help of matrix multiplication algorithms.",
        "The main objective of the implementation was to check if matrix multiplication techniques help in practice also to obtain efficient parsing algorithms.",
        "The recognizer implemented two different algorithms for matrix multiplication, namely the trivial cubic time algorithm and an algorithm that exploits the sparsity of the matrices.",
        "The TAL recognizer that uses the cubic time algorithm has a run time comparable to that of Vijayashanker-Joshi's algorithm.",
        "Below is given a sample of a grammar tested and also the speed up using the sparse version over the ordinary version.",
        "The grammar used, generated the TAL bn en .",
        "This grammar is shown in figure 1.",
        "Interestingly, the sparse version is an order of magnitude faster than the ordinary version for strings of length greater than 7.",
        "The above implementation results suggest that even in practice better parsing algorithms can be obtained through the use of matrix multiplication techniques."
      ]
    },
    {
      "heading": "9 Conclusions",
      "text": [
        "In this paper we have presented an 0(M(n2)) time algorithm for parsing TALs, n being the length of the input string.",
        "We have also demonstrated with our implementation work that matrix multiplication techniques can help us obtain efficient parsing algorithms."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "This research was supported in part by an NSF Research Initiation Award CCR-92-09260 and an ARO grant DAAL03-89-C-0031."
      ]
    }
  ]
}
