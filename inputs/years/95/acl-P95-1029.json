{
  "info": {
    "authors": [
      "Seth Kulick"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P95-1029",
    "title": "Using Higher-Order Logic Programming for Semantic Interpretation of Coordinate Constructs",
    "url": "https://aclweb.org/anthology/P95-1029",
    "year": 1995
  },
  "references": [
    "acl-J87-1005",
    "acl-P86-1037",
    "acl-P89-1005",
    "acl-P92-1027"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Many theories of semantic interpretation use A-term manipulation to compositionally compute the meaning of a sentence.",
        "These theories are usually implemented in a language such as Prolog that can simulate A-term operations with first-order unification.",
        "However, for some interesting cases, such as a Combinatory Categorial Grammar account of coordination constructs, this can only be done by obscuring the underlying linguistic theory with the \"tricks\" needed for implementation.",
        "This paper shows how the use of abstract syntax permitted by higher-order logic programming allows an elegant implementation of the se-.",
        "mantics of Combinatory Categorial Grammar, including its handling of coordination constructs."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Many theories of semantic interpretation use A-term manipulation to compositionally compute the meaning of a sentence.",
        "These theories are usually implemented in a language such as Prolog that can simulate A-term operations with first-order unification.",
        "However, there are cases in which this can only be done by obscuring the underlying linguistic theory with the \"tricks\" needed for implementation.",
        "For example, Combinatory Categorial Grammar (CCG) (Steedman, 1990) is a theory of syntax and semantic interpretation that has the attractive characteristic of handling many coordination constructs that other theories cannot.",
        "While many aspects of CCG semantics can be reasonably simulated in first-order unification, the simulation breaks down on some of the most interesting cases that CCG can theoretically handle.",
        "The problem in general, and for CCG in particular, is that the implementation language does not have sufficient expressive power to allow a more direct encoding.",
        "The solution given in this paper is to show how advances in logic programming allow the implementation of semantic theories in a very direct and natural way, using CCG as a case study.",
        "We begin by briefly illustrating why first-order unification is inadequate for some coordination constructs, and then review two proposed solutions.",
        "The sentence in (la) usually has the logical form (LF) in (lb).",
        "(la) John and Bill run.",
        "(lb) (and (run John) (run Bill)) CCG is one of several theories in which (lb) gets derived by raising John to be the LF AP.",
        "(P john), where P is a predicate that takes a NP as an argument to return a sentence.",
        "Likewise, Bill gets the LF AP.",
        "(P bill), and coordination results in the following LF for John and Bill: (2) AP.",
        "(and (P john) (P bill)) When (2) is applied to the predicate, (lb) will result after /3-reduction.",
        "However, under first-order unification, this needs to simulated by having the variable x in Ax.run(x) unify both with Bill and John, and this is not possible.",
        "See (Jowsey, 1990) and (Moore, 1989) for a thorough discussion.",
        "(Moore, 1989) suggests that the way to overcome this problem is to use explicit A-terms and encode /3-reduction to perform the needed reduction.",
        "For example, the logical form in (3) would be produced, where X \\run(I) is the representation of Ax.run (x).",
        "(3) and(apply(nrunaLjohn), apply(nrun(X),hill))",
        "This would then be reduced by the clauses for apply to result in (lb).",
        "For this small example, writing such an apply predicate is not difficult.",
        "However, as the semantic terms become more complex, it is no trivial matter to write /3-reduction that will correctly handle variable capture.",
        "Also, if at some point it was desired to determine if the semantic forms of two different sentences were the same, a predicate would be needed to compare two lambda forms for a-equivalence, which again is not a simple task.",
        "Essentially, the logic variable X is meant to be interpreted as a bound variable, which requires an additional layer of programming.",
        "(Park, 1992) proposes a solution within first-order unification that can handle not only sentence (la), but also more complex examples with determiners.",
        "The method used is to introduce spurious bindings that subsequently get removed.",
        "For example, the semantics of (4a) would be (4b), which would then get simplified to (4c).",
        "(4a) A farmer and every senator talk",
        "While this pushes first-order unification beyond what it had been previously shown capable of, there are two disadvantages to this technique: (1) For every possible category that can be conjoined, a separate lexical entry for and is required, and (2) As the conjoinable categories become more complex, the and entries become correspondingly more complex and greatly obscure the theoretical background of the grammar formalism.",
        "The fundamental problem in both cases is that the concept of free and bound occurrences of variables is not supported by Prolog, but instead needs to be implemented by additional programming.",
        "While theoretically possible, it becomes quite problematic to actually implement.",
        "The solution given in this paper is to use a higher-order logic programming language, AProlog, that already implements these concepts, called \"abstract syntax\" in (Miller, 1991) and \"higher-order abstract syntax\" in (Pfenning and Elliot, 1988).",
        "This allows a natural and elegant implementation of the grammatical theory, with only one lexical entry for and.",
        "This paper is meant to be viewed as furthering the exploration of the utility of higher-order logic programming for computational linguistics - see, for example, (Miller Nadathur, 1986), (Pareschi, 1989), and (Pereira, 1990)."
      ]
    },
    {
      "heading": "2 CCG",
      "text": [
        "CCG is a grammatical formalism in which there is a one-to-one correspondence between the rules of composition' at the level of syntax and logical form.",
        "Each word is (perhaps ambiguously) assigned a category and LF, and when the syntactical operations assign a new category to a constituent, the corresponding semantic operations produce a new LF for that constituent as well.",
        "The CCG rules shown in Figure 1 are implemented in the system described 'In the general sense, not specifically the CCG rule for function composition.",
        "in this paper.2 3 Each of the three operations have both a forward and backward variant.",
        "As an illustration of how the semantic rules can be simulated in first-order unification, consider the derivation of the constituent harry found, where harry has the category up with LF harry' and found is a transitive verb of category (s \\np)/np with LF",
        "(5) Aobject.Asubject.",
        "(found' subject object)",
        "In the CCG formalism, the derivation is as follows: harry gets raised with the > T rule, and then forward composed by the > B rule with found, and the result is a category of type sinp with LF Az.",
        "(i ounce harry' x).",
        "In section 3 it will be seen how the use of abstract syntax allows this to be expressed directly.",
        "In first-order unification, it is simulated as shown in Figure 2.4 The final CCG rule to be considered is the coordination rule that specifies that only like categories can coordinate: 'The type-raising rules shown are actually a simplification of what has been implemented.",
        "In order to handle determiners, a system similar to NP-complement categories as discussed in (Dowty, 1988) is used.",
        "Although a worthwhile further demonstration of the use of abstract syntax, it has been left out of this paper for space reasons.",
        "'The \\ for a backward-looking category should not be confused with the \\ for A-abstraction.",
        "This is actually a schema for a family of rules, collectively called \"generalized coordination\", since the semantic rule is different for each case.5 For example, if X is a unary function, then the semantic rule is (7a), and if the functions have two arguments, then the rule is (7b).6",
        "For example, when processing (la), rule (7a) would be used with:",
        "• F = Ax•Ay (and' x • G = AP.",
        "(P john') • H = AP.",
        "(P",
        "with the result OFGH = Ax.",
        "(ance (x john') bi.1.1!))",
        "which is a-equivalent to (2)."
      ]
    },
    {
      "heading": "3 APROLOG and Abstract Syntax",
      "text": [
        "AProlog is a logic programming language based on higher-order hereditary Harrop formulae (Miller et al., 1991).",
        "It differs from Prolog in that first-order terms and unification are replaced with simply-typed A-terms and higher-order unificationr, respectively.",
        "It also permits universal quantification and implication in the goals of clauses.",
        "The crucial aspect for this paper is that together these features permits the usage of abstract syntax to express the logical forms terms computed by CCG.",
        "The built-in A-term manipulation is used as a \"meta-language\" in which the \"object-language\" of CCG logical forms is expressed, and variables in the object-language are mapped to variables in the metalanguage.",
        "The AProlog code fragment shown in Figure 3 declares how the CCG logical forms are represented.",
        "Each CCG LF is represented as an untyped A-term, namely type tm.",
        "abs represents object-level abstraction Ax.M by the meta-level expression (abs X),",
        "where N is a meta-level function of type ta tat.",
        "A meta-level A-abstraction Ay.P is written y \\P.5 Thus, if walked' has type tat tia, then y\\(walkedi y) is a AProlog (meta-level) function with type tat -+ tm, and (abs y\\(walked' y)) is the object-level representation, with type tm.",
        "The LF for found shown in (5) would be represented as (abs obj\\(abs sub\\(found' sub obj))).",
        "app encodes application, and so in the derivation of harry found, the type-raised harry has the AProlog value (abs p\\(app p harry')).9 The second part of Figure 3 shows declares how quantifiers are represented, which are required since the sentences to be processed may have determiners.",
        "torah l and exists are encoded similarly to abstraction, in that they take a functional argument and so object-level binding of variables by quantifiers is handled by meta-level A-abstraction.",
        ">> and kk are simple constructors for implication and conjunction, to be used with forall and exists respectively, in the typical manner (Pereira and Shieber, 1987).",
        "For example, the sentence every man found a bone has as a possible LF (8a), with the AProlog representation (8b)15: 'This is the same syntax for A-abstraction as in (3).",
        "(Moore, 1989) in fact borrows the notation for A-abstraction from AProlog.",
        "The difference, of course, is that here the abstraction is a meta-level, built-in construct, while in (3) the interpretation is dependent on an extra layer of programming.",
        "Bound variables in AProlog can be either upper or lower case, since they are not logic variables, and will be written in lower case in this paper.",
        "6It is possible to represent the logical forms at the object-level without using abs and app, so that harry could be simply p\\ (p harry').",
        "The original implementation of this system was in fact done in this manner.",
        "Space prohibits a full explanation, but essentially the fact that AProlog is a typed language leads to a good deal of formal clutter if this method is used.",
        "16 The LF for the determiner has the form of a Mon-tagovian generalized quantifier, giving rise to one fully scoped logical form for the sentence.",
        "It should be stressed that this particular kind of LF is assumed here purely for the sake of illustration, to make the point that composition at the level of derivation and LF are one-to-one.",
        "Section 4 contains an example for which such a",
        "Figure 4 illustrates how directly the CCG operations can be encodedll.",
        "o is the type of a meta-level proposition, and so the intended usage of apply is to take three arguments of type tm, where the first should be an object-level A-abstraction, and set the third equal to the application of the first to the second.",
        "Thus, for the query ?- apply (abs sub\\(walked' sub)) harry' X. R unifies with the tm tie function sub\\(walked' sub), S with harry' and M with (R S), the meta-level application of R to S, which by the built-in /3-reduction is (walked' harry').",
        "In other words, object-level function application is handled simply by the meta-level function application.",
        "Function composition is similar.",
        "Consider again the derivation of harry found by type-raising and forward composition.",
        "harry would get type-raised by the raise clause to produce (abs pVapp p harry')), and then composed with found, with the result shown in the following query:",
        "At this point a further )6-reduction is needed.",
        "Note however this is not at all the same problem of writing a /3-reducer in Prolog.",
        "Instead it is a simple matter of using the meta-level /3-reduction to eliminate /3-redexes to produce the final result (abs xViound' harry x)).",
        "We won't show the complete declaration of the /3-reducer, but the key clause is simply: red (app (abs X) 11) CM N).",
        "Thus, using the abstract syntax capabilities of AProlog, we can have a direct implementation of the underlying linguistic formalism, in stark contrast to the first-order simulation shown in Figure 2."
      ]
    },
    {
      "heading": "4 Implementation of Coordination",
      "text": [
        "A primary goal of abstract-syntax is to support recursion through abstractions with bound variables.",
        "This leads to the interpretation of a bound variable as a \"scoped constant\" - it acts like a constant that is not visible from the top of the term, but which becomes visible during the descent through the abstraction.",
        "See (Miller, 1991) for a discussion of how this may be used for evaluation of functional programs by \"pushing\" the evaluation through abstractions to reduce redexes that are not at the top-level.",
        "This technique is also used in the /3-reducer briefly mentioned at the end of the previous section, and a similar technique will be used here to implement coordination by recursively descending through the two arguments to be coordinated.",
        "Before describing the implementation of coordination, it is first necessary to mention how CCG categories are represented in the AProlog code.",
        "As shown in Figure 5, cat is declared to be a primitive type, and up, e, conj, noun are the categories used in this implementation.",
        "is and bs are declared",
        "to be constructors for forward and backward slash.",
        "For example, the CCG category for a transitive verb (s \\up)/np would be represented as (is up (be up s)).",
        "Also, the predicate atomic-type is declared to be true for the four atomic categories.",
        "This will be used in the implementation of coordination as a test for termination of the recursion.",
        "The implementation of coordination crucially uses the capability of AProlog for universal quantification in the goal of a clause.",
        "pi is the meta-level operator for V, and Vx.M is written as pi x\\M.",
        "The operational semantics for AProlog state that pi x \\ G is provable if and only if [c/x]G is provable, where c is a new variable of the same type as x that does not otherwise occur in the current signature.",
        "In other words, c is a scoped constant and the current signature gets expanded with c for the proof of [c/x]G. Since c is meant to be treated as a generic placeholder for any arbitrary x of the proper type, c must not appear in any terms instantiated for logic variables during the proof of [c/x]G. The significance of this restriction will be illustrated shortly.",
        "The code for coordination is shown in Figure 6.",
        "The four arguments to coord are a category and three terms that are the object-level LF representations of constituents of that category.",
        "The last argument will result from the coordination of the second and third arguments.",
        "Consider again the earlier problematic example (la) of coordination.",
        "Recall that after john is type-raised, its LF will be (abs p\\ (app p john')) and similarly for bill.",
        "They will both have the category (is (be up s) s).",
        "Thus, to obtain the LF for John and Bill, the following query would be made: coord (is (be up s) s) (abs p\\(app p john')) (abs p\\(app p bill')) N. This will match with the first clause for coord, with",
        "• A instantiated to (be up s) • B to s • R to (p\\ (app p john')) • S to (p\\ (app p bill')) • and T a logic variable waiting instantiation.",
        "Then, after the meta-level /3-reduction using the new scoped constant c, the following goal is called: coord s (app c john' ) (app c bill' ) N. where I = (T c).",
        "Since a is an atomic type, the third coord clause matches with",
        "• B instantiated to s • R to (app c john' ) • S to (app c bill') • Ito (and' (app c john' ) (app c bill' ))",
        "Since I (T c), higher-order unification is used by AProlog to instantiate T by extracting c from I with the result T = x \\ (and' (app x john') (app x and so 11 from the original query is (abs x \\ (and' (app x john') (app x bill'))) Note that since c is a scoped constant arising from the proof of an universal quantification, the instantiation",
        "is prohibited, along with the other extractions that do not remove c from the body of the abstraction.",
        "This use of universal quantification to extract out c from a term containing c in this case gives the same result as a direct implementation of the rule for coo-ordination of unary functions (7a) would.",
        "However, this same process of recursive descent via scoped constants will work for any member of the conj rule family.",
        "For example, the following query coord (is up (bs up a)) (abs obj\\(abs sub\\(like' sub obj))) (abs obj\\(abs sub\\(hate' sub obj))) K. = (abs x\\ (abs xl\\ (and' (like' xi x) (hate' xl x)))).",
        "corresponds to rule (7b).",
        "Note also that the use of the same bound variable names obj and sub causes no difficulty since the use of scoped-constants, meta-level /3-reduction, and higher-order unification is used to access and manipulate the inner terms.",
        "Also, whereas (Park, 1992) requires careful consideration of handling of determiners with coordination, here such sentences are handled just like any others.",
        "For example, the sentence Mary gave every dog a bone and some policeman a flower results in the LF 12.",
        "\"This is a case in which the particular LF assumed here fails to yield another available scoping.",
        "See footnote 10.",
        "Thus, \"generalized coordination\", instead of being a family of separate rules, can be expressed as a single rule on recursive descent through logical forms.",
        "(Steedman, 1990) also discusses \"generalized com-position\", and it may well be that a similar implementation is possible for that family of rules as well."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We have shown how higher-order logic programming can be used to elegantly implement the semantic theory of CCG, including the previously difficult case of its handling of coordination constructs.",
        "The techniques used here should allow similar advantages for a variety of such theories.",
        "An argument can be made that the approach taken here relies on a formalism that entails implementation issues that are more difficult than for the other solutions and inherently not as efficient.",
        "However, the implementation issues, although more complex, are also well-understood and it can be expected that future work will bring further improvements.",
        "For example, it is a straightforward matter to transform the AProlog code into a logic called LA (Miller, 1990) which requires only a restricted form of unification that is decidable in linear time and space.",
        "Also, the declarative nature of AProlog programs opens up the possibility for applications of program transformations such as partial evaluation."
      ]
    },
    {
      "heading": "6 Acknowledgments",
      "text": [
        "This work is supported by ARO grant DAAL03-890031, DARPA grant N00014-904-1863, and ARO grant DAAH04-94-G-0426.",
        "I would like to thank Aravind Joshi, Dale Miller, Jong Park, and Mark Steedman for valuable discussions and comments on earlier drafts."
      ]
    }
  ]
}
