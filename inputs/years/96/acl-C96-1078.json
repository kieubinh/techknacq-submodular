{
  "info": {
    "authors": [
      "Adam Meyers",
      "Roman Yangarber",
      "Ralph Grishman"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C96-1078",
    "title": "Alignment of Shared Forests for Bilingual Corpora",
    "url": "https://aclweb.org/anthology/C96-1078",
    "year": 1996
  },
  "references": [
    "acl-C90-3031",
    "acl-C90-3044",
    "acl-C92-2101",
    "acl-C94-1015",
    "acl-J93-2003",
    "acl-P85-1016",
    "acl-P85-1017",
    "acl-P93-1002",
    "acl-P93-1004"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Research in example-based machine translation (Enivr.r) has been hampered by the lack of efficient tree alignment algorithms for bilingual corpora.",
        "This paper describes an alignment algorithm for Ell3MT whose running time is quadratic in the size of the input parse trees.",
        "The algorithm uses dynamic programming to score all possible matching nodes between structure-sharing trees or forests.",
        "We describe the algorithm, various optimizations, and our implementation."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The development of a machine translation (MT) system requires the lengthy manual preparation of bilingual lexicons and transfer rules.",
        "Research over the past few years using parallel sentence-aligned bilingual corpora suggests ways in which this manual effort can be partly replaced by corpus-based training.",
        "Some of this research has treated the sentences as unstructured word sequences to be aligned; this work has primarily involved the acquisition of bilingual lexical correspondences (Chen, 1993), although there has also been an attempt to create a full MT system based on such treatment (Brown et al., 1993).",
        "Recently, several groups have been exploring the possibility of aligning parallel syntactically analyzed sentences from the source and target languages (cf. (Sato and Nagao, 1990), (Klavans and Tzoukermann, 1990), (Grishman and Kosaka, 1992), (Kaji et al., 1992), (Matsumoto et al., 1993) and (Grishman, :1994)).",
        "This offers the potential for acquiring not just lexical but also structural correspondences between the two languages.",
        "The specific goal in aligning syntax trees is to identify the corresponding tree fragments in the source and target trees.",
        "13y processing a substantial corpus, a large set of such corresponding fragments can be collected.",
        "These can then serve as the example base for a form of example-based MT (cf. (Nagao, 1984), (Sato and Nagao, 1990), (Kaji et al., 1992), (-Matsumoto et al., 1993) and (Furuse and Lida, 1994)).",
        "This approach requires a fast tree alignment technique; research has been hampered by the lack of efficient algorithms.",
        "This paper describes an efficient algorithm for bilingual tree alignment."
      ]
    },
    {
      "heading": "2 Our Approach",
      "text": [
        "For each input sentence our parser produces a set of trees, corresponding to each possible syntactic analysis.",
        "Our parse trees are transformed into a \"regularized\" format, to represent the Predicate-Argument structure.",
        "For each sentence, the output of the parser is a structure-sharing forest.",
        "An example of structure sharing between two parse trees of the same input sentence is shown in Figure 1.",
        "We apply the parser to the source and target sentences, using a Spanish and an English grammar, respectively.",
        "'the resulting sets of structure-sharing parse trees form the input to the alignment procedure.",
        "Our alignment program employs dynamic programming' algorithms, which are described in detail in later sections.",
        "The program begins at the roots of the source and target trees, and proceeds top-down recursively, filling a matrix of scores.",
        "Given N nodes in the source tree Ts '.I'(V, , Ps) and M nodes in the target tree T( VI, tit), the score matrix is an N x Al matrix.",
        "For each pair of nodes ...N V, and yi, E , the corresponding entry in the score matrix is a measure of how well xi matches lb.",
        "The score for each pair of nodes depends only on the closeness of the lexical entries associated with the nodes and",
        "on the scores of the best matching pairs of their descendants.",
        "Dynamic programming assures that each entry in the matrix, (i.e. the score for the corresponding pair of nodes) is computed only once.",
        "We have implemented this approach.",
        "for 185 sett.",
        "tenees from two sources: LI Camino Real (a Spanish textbook from which we used 73 sentences with their knglisli translations), and Curious Gcorj«: or Jorge rl Curioso (the English and Spanish versions011.1.",
        "N. lay's popular children's book, from which we used all I I I English sentences and 1.12 Spanish Sentences).",
        "Of the total 185 sentences, 57 from Li Camino Bent and 55 from Cur-ions Gcmgc produced at least one parse tree in both languages.",
        "The alignment procedure was applied only to these pairs of senten•es.'"
      ]
    },
    {
      "heading": "3 Data Structures",
      "text": [
        "Regularized parses are similar to the I° structure of Lexical Functional Grammar (110(0, except that a dependency type structure is assunied.4 Ilere a relation liole(l'ItP.I), A R(') is represented by an arc, the P.l?,1‘;.1) of 1,10G at the tail of the arc, and the AUX,' (or the role recipient) at the head",
        "of the arc.",
        "For example, el tenis is the subject of' the predicate ser in Figure I.",
        "In a regular.",
        "ized parse, certain closed syntactic classes, such as prepositions and subordinate conjunctions, are represented as arc labels denoting roles, (e.g., the preposition de in Figure I) rather than as nodes in 10-st ruchure.",
        "Structure sharing among the trees in the parse forest allows us to reduce the number of computed scores.",
        "We compute the score for a given pair of subtrees only once, regardless of the ntanber of trees which share these subtrees because the score of a pair of nodes depends only on the scores of their descendants (and not 01 their ancestors).",
        "Currently 0111' parser records structure sharing only between NI's.",
        "Experiments in which all coni-mon structure is shared, as in Figure I, suggest that extending structure sharing to other types of nodes would further improve performance.",
        "This structure-sharing approach is based on previous work in optimizing reature Structure-based parsing.",
        "(See for example, (lart.limen, 1985) and (Pereira, 1985))."
      ]
    },
    {
      "heading": "4 Tile LCA-Preserving Algorithms",
      "text": [
        "We first discuss the formal aspects 01 the alignment problem and introduce terminology."
      ]
    },
    {
      "heading": "4.1 'flie Maximal Tree Alignment Problem",
      "text": [
        "The objective is to find a. maximum-score correspondence between nodes in a pair of trees.",
        "The statement of the problem of aligning two trees\" '/', and corresponds closely to that found in (Matsumoto et al., 1993).",
        "Our algorithms are based on those presented iu (Steel and Warnow, 1993), (Farach et al., I 995b) and ( I995a).",
        "We say that a node x is a common ancestor of nodes a and bin a tree T a there exist paths of length > 0 front a' to a and from a' to b.",
        "The least common ancestor (Ica) of two nodes a mid 1) is the node :r ca(o , b), such that",
        "1. are is a. common ancestor of' a and b, and 2. for any other common ancestor a' of a. and b, :v() is a descendant of a:.",
        "An alignment between two trees 7' (V, 10 (V', 0) is a. correspondence (a one-to-one mapping) f : where C V and H C V', which maintains the following relationship: 'For ;:iinplicity 01 presctitettion we state the problem in terms of alignment.",
        "of trees.",
        "In practice we are using an optimized variant.",
        "of the algorithm, which aligns pairs of structure-sharing forests.",
        "SOURCE TARGET the matrix is undefined, it is recursively computed e d' by the following formula:",
        "If nodes a E V and b E V map into nodes a' = f (a) E V' and b' = f (b) E V', then f(lca(a,b)) = lca(f (a), f(b)) = lca(a' ,6') To illustrate, in Figure 2 there is no Ica-preserving alignment of the two trees which maps all three of the leaf nodes a, b and c into the nodes a', b' and c'.",
        "Lca-preserving alignments are possible which map any two of the leaves.",
        "The algorithm assumes that least common ancestors are preserved in the alignment.",
        "We assign a score to each alignment based on the labels of the corresponding nodes and the arcs from these nodes, as described below.",
        "The algorithm seeks an alignment with maximal score."
      ]
    },
    {
      "heading": "4.2 The Algorithm",
      "text": [
        "Let T3 and Tt be the source and the target trees.",
        "The algorithm uses dynamic programming to build up, in a bottom-up fashion, the scores for matching each node in T, against each node of T t. There are 0(n2) such scores, where n max( I I, I Tt I) is the number of nodes in the trees.",
        "Let d(v) be the degree of a node v. We denote children of v by vi, i = 1, ..., d(v), and the arc (v, vi) by Procedure SCORELcA: The dynamic programming builds up a score function S(v, v') for all v E T, and v' E Tt, which is stored in a Ts I x I Tt I matrix S. The value S(v, v') is the score assigned to the best match between the two subtrees rooted at v in T, and at v' in Tt.",
        "Initially, S is filled with undefined values.",
        "When a value for S(v, v') is required, and the corresponding entry in",
        "• Lexriode (v, v') > 0 is a measure of how closely the label on source node v corresponds to the label on target node v' in the bilingual dictionary.",
        "Lex„„ V') is the corresponding measure for arcs.",
        "• P(v, v') is the set of all possible pairings of the children of v against the children of v'.",
        "There are 0(d!)",
        "such pairings, where d is the smaller of the degrees of v and v'.",
        "• P(f/i) > 0 is the penalty for collapsing the edge which may depend on the label of that edge.",
        "The summation in (2) ranges over all pairs, denoted by (i, j), which appear in a given pairing p E P(v, v').",
        "The summation is evaluated for all 0(d!)",
        "possible pairings.",
        "The pairing with the maximum score is then selected.",
        "The total running time for computing the scores of all of the 0(n2) node pairs v and v', is 0(d!n2), where d is the lesser of the degrees of the source and target trees.",
        "Computing the max term in (2) can be mapped into the Maximum-Weight Clique problem (which is NP-complete), cf. (Farach et al., 1995b).",
        "However, in the NLP domain, the running time is contained because d < 6 for most trees encountered in practice.",
        "Next we describe a heuristic which achieves a time bound quadratic in the size of the tree."
      ]
    },
    {
      "heading": "5 A Greedy Heuristic",
      "text": [
        "We can reduce the computation time of the max term in (2), if we do not consider all of the 0(d!)",
        "pairings of the children of v and v'.",
        "Instead we",
        "use a greedy approach and choose the d highest-scoring, mutually disjoint pairs from among the d2 possible pairs of children of v and v'.",
        "The justification for this heuristic is that we expect that the high-scoring pairs will dominate, and will be a priori mutually disjoint.",
        "The following is an alternative, greedy procedure for computing S(v, v'): Procedure GREEDY Lcn:",
        "1.",
        "Vi, j s.t.",
        "1 < i < d(v), < j deo') compute the corresponding entry in a d(v) x d(v') matrix M: = Lex(ffi , ) S(vi",
        "The entry Mij of M M v') is the score of matching the ith child of v with jth child of v'.6",
        "2.",
        "Let TOP {} be the set of highest scoring pairs.",
        "3.",
        "Find the largest entry Micic in the matrix, such that neither its row nor its column is already occupied by some pair in TOP:",
        "TOP +– TOP U {(io,io)} where the coordinates (io, jo) are such that",
        "4.",
        "Repeat the above step d times, where d inin(d(v), d(v')).",
        "5.",
        "Compute the result:",
        "With sorting, this can be done in 0(d log d+ d2) time.",
        "The validity of this heuristic can be tested by comparing the performance of the procedures using the computation in (2) and in (4).",
        "6Note: if we disregard the arc labels for simplicity, and set Lexarc•, •) 0, then we do not need to build M, and may simply use Md = S(v;, v;)."
      ]
    },
    {
      "heading": "6 Strict Lexical Matching Heuristic",
      "text": [
        "(Grishman, 1.994) employed an optimization heuristic which favored lexical matches.",
        "For each source node v with label gv), the procedure using this heuristic would first attempt to find a target node v' with label .L(e) such that L(v) translated as 1#') in the bilingual dictionary (a perfect lexical match).",
        "If such a lexical match was found, the procedure did not attempt to match v with any other target node.",
        "A similar heuristic (Lex-Match) was incorporated into our program as the following preprocessing steps: 1 For each source node v, all possible lexical matches are identified in the target tree.7 If, v has at least one possible lexical match, all of those positions in the score matrix S which do not correspond to a lexical match of v are set to zero.",
        "2 For each target node v' which has at least one lexical match, all of those positions in the score matrix which do not correspond to a lexical match of v' are set to zero.",
        "113y setting to zero those positions in the score matrix which represent unlikely matches, this heuristic prevents these scores from ever being calculated, substantially reducing the running time.",
        "Lex-Match, unlike the (Grishtnan, 1994) heuristic, allows one source node to match lexically with more than one node in the target tree."
      ]
    },
    {
      "heading": "7 Implementation",
      "text": [
        "We have implemented the greedy LCA.-preserving algorithm with the following features: Penalties: The penalties for collapsing edges were set to 0.8 Scores: A Lext,„d„ score of 100 and a Lex a,.„ score of 21 was awarded for each match using our bilingual dictionary.",
        "These functions have the value 0 if there is no lexical match.",
        "7 A match M (v, v') is also a lexical 'natal if either M(v, w') or M(D, v') is a lexical match, where w and w' are children of v and v', respectively.",
        "8 When penalties are set to zero and an empty bilingual dictionary is used, the alignment algorithm fills the scoring matrix with zeros.",
        "When we introduce non-zero penalties, the alignment procedure prefers matches between nodes dominating similar structures, since nodes dominating dissimilar structures receive negative scores.",
        "We expect that non-zero penalties will improve precision with a nonempty bilingual dictionary, because they will favor similar structures.",
        "In preliminary testing, penalty values of 20 and 30 yielded improvements in precision.",
        "Optimization Variables: We experimented with variants of the procedures which included Structure Sharing (Struc-Share) and the Lexical Match Optimization (Lex-Match), as well as with those that did not.",
        "Table 1 shows the time consumed by our pro-grain to align sentences under different conditions.",
        "The baseline refers to our program without any optimizations (which is at least 6 times faster than before using this algorithm.)",
        "The optimization variables have different effects on the different texts.",
        "We believe that structure sharing has a much stronger effect on Curious George than on El Camino Real because the former has longer sentences which produced more parses.",
        "The Lex-Match optimization has a greater effect on El Camino Real than on Curious George because all of the words contained in El Camino Real are included in our bilingual dictionary, but only a small portion of the words in Curious George are included.",
        "We expect that as the size of our dictionary increases, the Lex-Match optimization will have a greater effect.",
        "The precision for each aligned pair of sentences is computed according to the formula:",
        "where ResultSei is the set of source parses to which the alignment procedure assigned the highest score, and Answer key is the set of best source parses as judged by one of the experimenters.",
        "'\" This precision measure was previously used in (Matsumoto et al., 1993) and (Grishman, 1994).",
        "Table 2 compares the precision of the alignment procedure with and without the Lex-Match heuristic (structure sharing had no effect on the scores.)",
        "The slight increase in precision observed with the g if there was no correct parse, the parses with the fewest errors were used for purposes of alignment.",
        "Lex-Match optimization, may be an indication that we should raise the score for lexical matches of node labels."
      ]
    },
    {
      "heading": "8 Results and Future Directions",
      "text": [
        "The current implementation aligns trees 63 times faster than our previous program (Grishmatt, 1994), with a 2.3% improvement in precision.\" We expect line-tuning of the parameters in our procedures to improve our performance.",
        "We expect to gain greater efficiency if all common nodes between forests are shared, rather than just the NPs.",
        "Another efficiency improvement will be achieved by factoring all ambiguity into the parse tree, as in (Matsumoto et a]., 1993).",
        "ln our current approach, disjunctions are represented only at the root level.",
        "In order to improve the precision of alignment, we plan to experiment with varying the values of the Lex functions and penalties in our scoring algorithm and expanding our bilingual dictionary.",
        "We will also expern tient with the non-greedy algorithm discussed above and a dominance-preserving algorithm (a less constrained version of the algorithm which we have omitted due to space limitations).",
        "In the dominance-preserving algorithm we relax the requirement of lea-preservation, and require the preservation of the dominance relationship between nodes: lf, for two nodes a C and b C T, a dominates b (denoted as a -; b), then for f (a) C T' and f (b) f (a) .1(b).",
        "The idea which makes it possible to align sentences quickly is that we place restrictions on the ways in which we align the parse trees.",
        "We '''I\"he dynamic programming algorithm accounts for an approximately 600% increase in speed of alignment - a rough estimate since much of the program has been reimplemented.",
        "disallow alignments which violate the 1,CA constraint or the dominance requirement, and per-nut one-to-one alignments between nodes.",
        "Some cases where one might posit a correspondence between a single node a: and a group of nodes GI {m, y„}, can be interpreted as an alignment between x and xi, for sonic j, 1 < j < u, where yj dominates the remaining nodes in C. We do not consider other types of one-to-many align-inents."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": []
    }
  ]
}
