{
  "info": {
    "authors": [
      "Andre Kempe",
      "Lauri Karttunen"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C96-2105",
    "title": "Parallel Replacement in Finite State Calculus",
    "url": "https://aclweb.org/anthology/C96-2105",
    "year": 1996
  },
  "references": [
    "acl-A92-1021",
    "acl-C90-2040",
    "acl-C92-1027",
    "acl-J94-3001",
    "acl-J95-2004",
    "acl-P95-1003"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper extends the calculus of regular expressions with new types of replacement expressions that enhance the expressiveness of the simple replace operator defined in Karttunen (1995).",
        "Parallel replacement allows multiple replacements to apply simultaneously to the same input without interfering with each other.",
        "We also allow a replacement to be constrained by any number of alternative contexts.",
        "With these enhancements, the general replacement expressions are more versatile than two-level rules for the description of complex morphological alternations."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "A replacement expression specifies that a given symbol or a sequence of symbols should be replaced by another one in a certain context or contexts.",
        "Phonological rewrite-rules (Kaplan and Kay, 1994), two-level rules (Koskenniemi 1983), syntactic disambiguation rules (Karlsson et al. 1994, Koskenniemi, Tapanainen, and Voutilainen 1992), and part-of-speech assignment rules (Brill 1992, Roche and Schabes 1995) are examples of replacement in context of finite-state grammars.",
        "Kaplan and Kay (1994) describe a general method representing a replacement procedure as finite-state transduction.",
        "Karttunen (1995) takes a somewhat simpler approach by introducing to the calculus of regular expression a replacement operator that is defined just in terms of the other regular expression operators.",
        "We follow here the latter approach.",
        "In the regular expression calculus, the replacement operator, ->, is similar to crossproduct, in that a replacement expression describes a relation between two simple regular languages.",
        "Consequently, regular expressions can be conveniently combined with other kinds of coperations, such as composition and union to form complex expressions.",
        "A replacement relation consists of pairs of strings that are related to one another in the manner sketched below:",
        "We use ui and uk to represent instances of Ui (with i E [1, n]) and 1.1 and Vic to represent instances of Li.",
        "The upper string contains zero or more instances of Ui possibly interspersed with other material (denoted here by x, y, and z).",
        "In the corresponding lower string the sections corresponding to Ui are instances of Li, and the intervening material remains the same (Karttunen, 1995).",
        "The -> operator makes the replacement obligatory, (->) makes it optional.",
        "For the sake of completeness, we also define the inverse operators, <and (<-), and the bidirectional variants, <-> and (<-> ) .",
        "We have incorporated the new replacement expressions into our implementation of the finite-state calculus (Kempe and Karttunen, 1995).",
        "Thus, we can construct transducers directly from replacement expressions as part of the general calculus, without invoking any special rule compiler.",
        "1.1 Simple regular expressions The table below describes the types of regular expressions and special symbols that are used to define the replacement operators.",
        ".#.",
        "string beginning or end (sec.",
        "2.1) Note that expressions that contain the crossproduct ( .",
        "x .)",
        "or the composition ( .",
        "o .)",
        "operator, describe regular relations rather than regular languages.",
        "A regular relation is a mapping from one regular language to another one.",
        "Regular languages correspond to simple finite-state automata; regular relations are modelled by finite-state transducers.",
        "In the relation A .",
        "x .",
        "B, we call the first member, A, the upper language and the second member, B, the lower language.",
        "This choice of words is motivated by the linguistic tradition of writing the result of a rule application underneath the original form.",
        "In a cascade of compositions, R1 .",
        "o .",
        "R2 .o .",
        "Rn, which models a linguistic derivation by rewrite-rules, the upper side of the first relation, R1, contains the \"underlying lexical [2]",
        "form\", while the lower side of the last relation, Rn, contains the resulting \"surface form\".",
        "We recognize two kinds of symbols: simple symbols (a, b, c, etc.)",
        "and fst pairs (a:b, y:z, etc.).",
        "An fst pair a:b can be thought of as the crossproduct of a and b, the minimal relation consisting of a (the upper symbol) and b (the lower symbol)."
      ]
    },
    {
      "heading": "2 Parallel Replacement",
      "text": [
        "Conditional parallel replacement denotes a relation which maps a set of n expressions Ui (i E [1, n]) in the upper language into a set of corresponding n expressions Li in the lower language if, and only if, they occur between a left and a right context (li,",
        "Unconditional parallel replacement denotes a similar relation where the replacement is not constraint by contexts.",
        "Conditional parallel replacement corresponds to what Kaplan and Kay (1994) call \"batch rules\" where a set of rules (replacements) is collected together in a batch and.",
        "performed in parallel, at the same time, in a way that all of them work on the same input, i.e. not one applies to the output of another replacement."
      ]
    },
    {
      "heading": "2.1 Examples",
      "text": [
        "Regular expressions based on [3] can be abbreviated if some of the UPPER-LOWER pairs, and/or some of the LEET-RIGia pairs, are equivalent.",
        "he complex expression: {a->b ,b->c II x_y ; [4] which contains multiple replacement in one left and right context, can be written in a more elementary way as two parallel replacements:",
        "Figure 1 shows the state diagram of a tram-ducer resulting from [4] or [5].",
        "The transducer maps the string xaxayby to xaxbyby following the path 0-1-2-1-3-0-0-0 and the string xbybyxa to xcybyxa following the path 0-1-3-0-0-0-1-2.",
        "where a is replaced by b only when occuring between x and y, or after v, or before w. An unspecified context is equivalent to ?",
        "*, the universal (sigma-star) language.",
        "Similarly, a specified context, such as x _ y, is actually interpreted as ?",
        "* x _ y ?",
        "*, that is, implicitly extending the context to infinity on both sides of the replacement.",
        "This is.",
        "a useful convention, but we also need to be able to refer explicitly to the beginning or the end of a string.",
        "For this purpose, we introduce a special symbol, .#.",
        "(Kaplan and Kay, 1994, p. 349).",
        "In the example",
        "{ a -> b II , v .#.}",
        "; [9] a is replaced by b only when it is at the beginning of a string or between v and the two final symbols of a string'."
      ]
    },
    {
      "heading": "2.2 Replacement of the Empty String",
      "text": [
        "'1.",
        ":he language described by the UPPER part of a replacement expression",
        "can contain the empty string F. In this case, every string that is in the upper-side language of the relation, is mapped to an infinite set of strings in the lower-side language as the upper-side string can be considered as a concatenation of empty and non-empty substrings, with e at any position and in any number.",
        "E.g.",
        "maps the string bb to the infinite set of strings bb, xbb, xbxb, xbxbx, xxbb, etc., since the language described by a* contains e, and the string bb can be considered as a result of any one of the concatenations b – b, c – b – c – b, c – c – b – b, etc.",
        "For many practical purposes it is convenient to construct a version of empty-string replacement that allows only one application between any two adjacent symbols (Karttunen, 1995).",
        "In order not to confuse the notation by a non-standard interpretation of the notion of empty string, we introduce a special pair of brackets, C. .1, placed around the 1 Note that .# .",
        "denotes the beginning or the end of a string depending on whether it occurs in the left or the right context.",
        "upper side of a replacement expression that presupposes a strict alternation of empty substrings and non-empty substrings of exactly one symbol: [12] In applying this to the above example, we obtain E. a* .1 -> x _ ; [13] that maps the string bb only to xbxbx since bb is here considered exclusively as a result of the concatenation c – b – c – b – c.",
        "If contexts are specified (in opposition to the above example) then they are taken into account."
      ]
    },
    {
      "heading": "2.3 The Algorithm 2.3.1 Auxiliary Brackets",
      "text": [
        "The replacement of one substring by another one inside a context, requires the introduction of auxiliary symbols (e.g. brackets).",
        "Kaplan and Kay (1994) motivate this step.",
        "If we would use an expression like 1, CUB .x.",
        "U 7.7 [14] to map a particular Ui (i E [1, n]) to Li when occuring between a left and.",
        "a right context, li and ri, then every li and ri would map substring adjacent to However, this approach is impossible for the following reason (Kaplan and Kay, 1994): In an example like {a->b Ilx_x} ; [15] where we expect xaxax to be replaced by xbxbx, the middle x serves as a context for both a's.",
        "A relation described by [14] could not accomplish this.",
        "The middle x would be mapped either by an ri or by an li but not by both at the same time.",
        "That is why only one a could be replaced and we would get two alternative lower strings, xbxax and xaxbx.",
        "Therefore, we have to use the contexts, li and ri, without mapping them.",
        "For this purpose we introduce auxiliary brackets <i after every left context di and >i before every right context ri.",
        "The replacement maps those brackets without looking at the actual contexts.",
        "We need separate brackets for empty and non-empty UPPER.",
        "If we used the same bracket for both this would mean an overlap of the substrings to replace in an example like x>i <ia>i.",
        "Here we might have to replace >1<1 and <1a>1 where <1 is part of both substrings.",
        "Because of this overlap, we could not replace both substrings in parallel, i.e. at the same time.",
        "To make the two replacements sequentially is also impossible in either order, for reasons in detail explained in (Kempe and Karttunen, 1995).",
        "A regular relation describing replacement in context (and a transducer that represents it), is defined by the composition of a set of \"simpler\" auxiliary relations.",
        "Context brackets occur only in intermediate relations and are not present in the final result.",
        "Before the replacement we make the following three transformations:",
        "(1) Complex regular expressions like [4] are transformed into elementary ones like [5], where every single replacement consists of only one UPPER, one LOWER, one LEFT and one RIGHT expression.",
        "E.g. 1 C. (a) .1 ->b I I x_y} , ->c ,e->f II ; [16] would be expanded to { [.",
        "(a).]",
        "->bIlx_y} , -> c II v_w} [17] {e->f II v_w}; (2) Since we have to use different types of brackets for the replacement of empty and non-empty UPPER (cf. 2.3.1), we split the set of parallel replacements into two groups, one containing only replacements with empty UPPER and the other one only with non-empty UPPER.",
        "If an UPPER contains the empty string but is not identical with it, the replacement will be added to both groups but with a different UPPER.",
        "E.g.[1:7] would be split into { a -> I ] x_ y1 le->f II v_wl; [i s] the group of non-empty UPPER and {[.",
        ".]",
        "-> b x_y} , { [] ->c II v_w } ; [19] the group of empty UPPER.",
        "(3) All empty UPPER of type ] are transformed into type [ . ]",
        "and the corresponding LOWER are replaced by their Kleene star function.",
        "E .g [19] wouldbe transformed",
        "The following algorithm of conditional parallel replacement will consider all empty UPPER as being of type C. .1, i.e. as not being adjacent to another empty string.",
        "Apart from the previously explained symbols, we will make use of the following symbols in the next regular expressions:",
        "[ ::EE ], union of all left brackets ], union of all right brackets [or empty UPPER.",
        "<1 1...1<n union of all left brackets for non-empty UPPER.",
        ">MINE >1 >7,1, union of all right brackets for non-empty UPPER.",
        "We compose the conditional parallel replacement of the six auxiliary relations described by Kaplan and Kay (1994) and Karttunen (1995) which are:",
        "(1) InsertBrackets [22] (2) ConstrainBrackets (3) LeftContext (4) RightContext (5) Replace (6) RemoveBrackets",
        "The composition of these relations in the above order, defines the upward-oriented replacement.",
        "The resulting transducer maps UPPER inside an input string to LOWER, when UPPER is between LEFT and RIGHT in the input context, leaving everything else unchanged.",
        "Other variants of the replacement operator will be defined later.",
        "For every single replacement { -> Li I I ri } we introduce a separate pair of brackets <i and >i with i E [IE...rriE] if UPPER is identical with the empty string and i E [1 /1.1 if UPPER does not contain the empty string.",
        "A eft bracket <i indicates the end of a complete left context.",
        "A right bracket >i marks the beginning of a complete right context.",
        "We define the component relations in the following way.",
        "Note that UPPER, LOWER, LEFT and RIGHT (Ui, and ri) stand for regular expressions of any complexity but restricted to denote regular languages.",
        "Consequently, they are represented by networks that contain no Est pairs.",
        "The relation inserts instances of all brackets on the lower side (everywhere and in any number and order).",
        "(2) Constrainifrackets",
        "The language does not apply to single brackets but to their types and allows them to be only in the following order:",
        "this constraint, which is necessary for the following The composition of the steps (1) and (2) invokes reasons: If we allowed sequences like <3 U3 <1>3 Ur we would have an overlap of the two substrings <3 U3 >3 and <1 U1 >1 which have to be replaced.",
        "Here, either U1 or U3 could be replaced but not both at the same time.",
        "If we permitted sequences like >1E<2<lE U2 >2 we would also have an overlap of the two replacements which means we could either replace <2 U2 >2 or >Le<iE but not both."
      ]
    },
    {
      "heading": "Ai An",
      "text": [
        "for all i E [1E...mE,1...n] , Ai \"$C Eli •1><aul (><all - <0* <i ] & SE [di .1><au] (><ati - <i)* bracket <i to be immediately preceded by the cor-The constraint forces every instance of a left responding left context i and every instance of di to be immediately followed by ignoring all brackets that are different from <i inbetween, and all brackets (<i included) inside li (.1).",
        "We separately make the constraints Ai for every <i and li and then intersect them in order to get the constraint for all left brackets and contexts.",
        "(4) Right Context",
        "The constraint relates instances of right brackets >i and of right contexts ri, and is the mirror image of step (3).",
        "We derive it from the left context constraint by reversing every right context before making the single constraints Ai (not pi) and reversing again the result after having intersected all Ai.",
        "(5) Replace Ai ]* .Af [28]",
        "The relation maps every bracketed UPPER, >i for non-empty UPPER and >i<i for empty UPPER, to the corresponding bracketed LOWER, <i Li leaving everything else unchanged.",
        "The term IV in [28] means a string that does not contain any bracketed UPPER:",
        "A particular bracketed empty UPPER >i <i is excluded from the corresponding E [1E, rn11) by",
        "and a bracketed non-empty UPPER <i Ui >i is excluded from the corresponding Ni (i E [1, n]) by = [<alINE <i]* [31] U1 •><all C>alINE - >il* lation that maps any bracketed UPPER to the cor-The term R. in expression [28] abbreviates a re-responding bracketed LOWER.",
        "It is the union of all single Ri relations mapping all occurrences of one Ui (empty and non-empty) to the corresponding [32] = RiE I • • • I nmE I R.4 I • .",
        "• I The replacement Ri of non-empty UPPER, Ui (i E [1, n]) is performed by: .x.",
        "[Lii>‹.11] > [33] To illustrate this: Suppose we have a set of replacements containing among others a -> b II x_y ; [34] This particular replacement is done by mapping inside an input string every substring that looks like (underlined part)",
        "using the brackets <1 and >1 to a substring (underlined part)",
        "In the following example we replace the empty U2E by L2E.",
        "Suppose we have in total one replacement of non-empty UPPER and two of empty UPPER, one of which is [.",
        ".]",
        "-> b II x _ y ; [38] This replacement is done by mapping inside a string every substring that looks like (underlined part)",
        "using the brackets >2E<2E into a substring (underlined part)",
        "The occurrence of exactly one bracket pair >iE and <iE between a left and a right context, actually corresponds to the definition of a (single) empty string expressed by C.",
        ".]",
        "(cf. sec. 2.2).",
        "The brackets C>2E 1 >1E I <1E I <1] and [>1 I >1E I <1E I <2E] in [40] are inserted on the lower side any number of times (including zero), i.e. they exist optionally, which makes them present if checking for the left or right context requires them, and absent if they are not allowed in this place.",
        "This set of brackets does not contain those ones used for the replacement, >i <i, because if we later check for them we do not want this check to be always satisfied but only when the specified contexts are present, in order to be able to confirm or to cancel the replacement a posteriori.",
        "This set of optionally inserted brackets equally does not contain those which potentially could be used for the replacement of adjacent non-empty strings, i.e. anNE on the left and <aiiNE on the right side of the expression.",
        "Otherwise, checking later for the legitimacy of the adjacent replacements would no longer be possible."
      ]
    },
    {
      "heading": "(6) RemoveBrackets",
      "text": [
        "><ati -> [41] The relation eliminates from the lower-side language all brackets that appear on the upper side."
      ]
    },
    {
      "heading": "3 Variants of Replacement",
      "text": []
    },
    {
      "heading": "3.1 Application of context constraints",
      "text": [
        "We distinguish four ways how context can constrain the replacement.",
        "The difference between them is where the left and the right contexts are expected, on the upper or on the lower side of the relation, i.e. LEFT and RIGHT contexts can be checked before or after the replacement.",
        "We obtain these four different applications of context constraints (denoted by II, /1, \\\\ and \\/) by varying the order of the auxiliary relations (steps (3) to (5)) described in section 2.3.3 (cf. [22]) :",
        "(c) Left-oriented { Ul -> Lt \\\\ 11 - rt [44] ...LeftContext .o.",
        "Replace .o.",
        "RightContext... (d) Downward-oriented { U1 -> Li \\/ ll - rl } , • • • [45]",
        "...Replace .o.",
        "LeftContext .o.",
        "RightContext... the three alternative interpretations of phonological rewrite rules discussed in Kaplan and Kay The versions (a) to (c) roughly correspond to (1994).",
        "The upward-oriented version corresponds to the simultaneous rule application; the right and left-oriented versions can model rightward or leftward iterating processes, such as vowel harmony and assimilation.",
        "In the downward-oriented replacement the operation is constrained by the lower (left and right) context.",
        "Here the (Ji get mapped to the corresponding Li just in case they end up between I, and ri in the output string."
      ]
    },
    {
      "heading": "3.2 Inverse, bidirectional and optional replacement",
      "text": [
        "Replacement as described above, ->, maps every Ui on the upper side unambiguously to the corresponding Li on the lower side but not vice versa.",
        "A Li on the lower side gets mapped to Li or Ui on the upper side.",
        "The inverse replacement, <-, maps unambiguously from the lower to the upper side only.",
        "The bidirectional replacement, <->, is unambiguous in both directions.",
        "Replacements of all of these three types (directions) can be optional, (->) (<-) (<->), i.e. they are either made or not.",
        "We define such a relation by changing Al (the part not containing any bracketed UPPER) in expression [28] into ?",
        "* that accepts every substring: ?",
        "* R]* 1* [46] Here an IA is either mapped by the corresponding Ri contained in R. (cf. [32]) and therefore replaced by Li, or it is mapped by ?",
        "* and not replaced."
      ]
    },
    {
      "heading": "4 A Practical Application",
      "text": [
        "In this section we illustrate the usefulness of the replace operator using a practical example.",
        "We show how a lexicon of French verbs ending in -ir, inflected in the present tense subjunctive mood, can be derived from a lexicon containing the corresponding present indicative forms.",
        "We assume here that irregular verbs are encoded separately.",
        "It is often proposed that the present subjunctive of -ir verbs be derived, for the most basic case, from",
        "a stem in -iss- (e.g.: finirjfinis.․) rather than from a more general root (e.g.: fin(i)) because once this stern is assumed, the subjunctive ending itself becomes completely regular: (that I finish) (that I run) que je finiss-e que je cour-e que to finiss-es que to tour-es que ils finiss-ent que its tour-ent The algorithm we propose here, is straightforward: We first derive the present subjunctive stem from the third person plural present indicative (e.g.: finiss, cour), then append the suffix corresponding to the given person and number.",
        "The first .step can be described as follows:",
        "The first transducer in [49] inserts the tags of the third person plural present indicative between the word and the tags of the actually required subjunctive form.",
        "The second transducer in [49] which is an indicative lexicon of -ir verbs, concatenated with a sequence of at least one tag, provides the indicative form arid keeps the initial subjunctive tags.",
        "The last transducer in [49] replaces the suffix -ent by the symbol SUFF.",
        "E.g.:",
        "To append the appropriate suffix to the subjunctive stem, we use the following transducer which maps the symbol SUFF to a suffix and deletes all tags:",
        "The complete generation of subjunctive forms can be described by the composition: define LexSubjP : [51] StemRegular .o.",
        "Suffix ; The resulting (single) transducer LexSubjP represents a lexicon of present subjunctive forms of French verbs ending in tin It maps the infinitive of those verbs followed by a sequence of subjunctive tags, to the corresponding inflected surface form and vice versa.",
        "All intermediate transducers mentioned in this section will contribute to this final transducer but will themselves disappear.",
        "The regular expressions in this section could also be written in the two-level formalism (Koskenniemi, 1983).",
        "However, some of them can be expressed more conveniently in the above way, especially when the replace operator is used.",
        "E.g., the first line of [49], written above as: [.",
        ".]",
        "<-> IndP PL P3 Verb 11 LETTER _ TAG [52] would have to be expressed in the two-level forrnal-ism by four rules:",
        "Here, the difficulty comes not only from the large number of rules we would have to write in the above example, but also from the fact that writing one of these rules requires to have in mind all time others, to avoid inconsistencies between them."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "This work builds on the research by Ronald Kaplan and Martin Kay on the finite-state calculus and the implementation of phonological rewrite rules (1994).",
        "Many thanks to our collegues at PARC and RXRC Grenoble who helped us in whatever respect, particularly to Annie Zaenen, Jean-Pierre Chanod, Marc Dymetman, Kenneth Beesley and Anne Schiller for helpful discussion on different topics, and to Irene Maxwell for correcting the paper."
      ]
    }
  ]
}
