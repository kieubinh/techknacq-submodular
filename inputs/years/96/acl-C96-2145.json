{
  "info": {
    "authors": [
      "Kemal Oflazer"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C96-2145",
    "title": "Error-Tolerant Tree Matching",
    "url": "https://aclweb.org/anthology/C96-2145",
    "year": 1996
  },
  "references": [
    "acl-C90-3044",
    "acl-J96-1003"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "This paper presents an efficient algorithm for retrieving from a database of trees, all trees that match a given query tree approximately, that is, within a certain error tolerance.",
        "It has natural language processing applications in searching for matches in example-based translation systems, and retrieval from lexical databases containing entries of complex feature structures.",
        "The algorithm has been implemented on SparcStations, and for large randomly generated synthetic tree databases (some having tens of thousands of trees) it can associatively search for trees with a small error, in a matter of tenths of a second to few seconds."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "..Recent approaches in machine translation known as example-based translation rely on searching a database of previous translations of sentences or fragments of sentences, and composing a translation from the translations of any matching examples (Sato and Nagao, 1990; Nirenburg, Beale and Domasnhev, 1994).",
        "The example database may consist of paired text fragments, or trees as in Sato and Nagao (1990).",
        "Most often, exact matches for new sentences or fragments will not be in the database, and one has to consider examples that are \"similar\" to the sentence or fragment in question.",
        "This involves associatively searching through the database, for trees that are \"close\" to the query tree.",
        "This paper addresses the computational problem of retrieving trees that are close to a given query tree in terms of a certain distance metric.",
        "The paper first presents the approximate tree matching problem in an abstract setting and presents an algorithm for approximate associative tree matching.",
        "The algorithm relies on linearizing the trees and then representing the complete database of trees as a trie structure which can be efficiently searched.",
        "The problem then reduces to sequence correction problem akin to standard spelling correction problem.",
        "The trie is then used with an approximate finite state recognition algorithm close to a query tree.",
        "Following some experimental results from a number of synthetic tree databases, the paper ends with conclusions."
      ]
    },
    {
      "heading": "2 Approximate Tree Matching",
      "text": [
        "In this paper we consider the problem of searching in a database of trees, all trees that are \"close\" to a given query tree, where closeness is defined in terms of an error metric.",
        "The trees that we consider have labeled terminal and non-terminal nodes.",
        "We assume that all immediate children of a given node have unique labels, and that a total ordering on these labels is defined.",
        "We consider two trees close if we can",
        "• add/delete a small number of leaves to/from one of the trees, and/or • change the label of a small number of leaves in one of the trees to get the second tree.",
        "A pair of such \"close\" trees is depicted in Figure 1."
      ]
    },
    {
      "heading": "2.1 Linearization of trees",
      "text": [
        "Before proceeding any further we would like to define the terminology we will be using in the following sections: We identify each leaf node in a tree with an ordered vertex list (vo, vi, v2, • • • , vd) where each vi is the label of a vertex from the root vo to the leaf vd at depth d, and for i > 0, vi is the parent of vi+i .",
        "A tree with n leaves is represented by a vertex list sequence V LS = V , V2, • • • , where each Vi = • • , vidi corresponds to a vertex list for a leaf at level di .",
        "This sequence is constructed by taking into account the total order on the labels at every level, that is, V is lexicographically less than •V i+1, based on the total ordering of the vertex labels.",
        "For instance, the first tree in Figure 1 would be represented by the vertex list sequence:",
        "((S,NP,Det,a), (S,NP,NP,Adj,black), (S,NP,NP,N,cat), (S,VP,NP,Det,the), (S,VP,NP,NP,Adj,little), (S,VP,NP,NP,N, mouse), (S,VP,V,chased)) assuming the normal lexicographic ordering on riode names."
      ]
    },
    {
      "heading": "2.2 Distance between two trees",
      "text": [
        "We define the distance between two trees according to the structural differences or differences in leaf labels.",
        "We consider an extra or a missing leaf as a structural change.",
        "if, however, both trees have a leaves whose vertex lists match in all but the last (leaf vertex) label, we consider tins as a difference in leaf labels.",
        "For instance, in Figure 2, there is extra leaf in tree (h) in comparison to the tree in (a), while tree (c) has a leaf' label differ-once.",
        "We associate the following costs associated with these differences:",
        "• if both trees have a leaf whose vertex list matches in all but the last (leaf vertex) label, we assign a label difference error of C. • ii a certain leaf is missing In one of the trees but exists in the other one, then we assign a cost S for this a structural difference.",
        "We currently treat all structural or leaf label differences as incurring a cost that, is independent of the tree level at which the difference takes place.",
        "lf, however, differences that are closer to the root of the tree are considered to be more serious than differences further away from the root, it is possible to modify the fortmdation to take this into account."
      ]
    },
    {
      "heading": "2.3 Converting a set of trees into a trie",
      "text": [
        "A tree database I) consists of a set of trees 7'1,7'2, • • • , it ti each Ti being a vertex list sequence for a tree.",
        "Once we convert all the trees to a linear form, we have a set of vertex list sequences.",
        "We can convert this set into a trie data structure.",
        "'l'lris trie will compress any possible redundancies in the prefixes of the vertex list sequences to achieve a certain compaction which helps during searching.' For instance, the three trees in Figure 2 can be represented as a trie as shown in Figure 3.",
        "The edge labels along the path to a leaf when concatenated in order gives the vertex list sequence for a tree, e.g., ((a,b,a,x), (a,b,c), (a , b,k) , (a, e)) represents the tree (a) in Figure 2. x 1 Note that it is possible to obtain more space reduction by also sharing any common postfixes of tire vertex label sequences using a directed acyclic graph representation and not a trie, but this does not improve the execution time."
      ]
    },
    {
      "heading": "2.4 Error-tolerant. matching in the trio",
      "text": [
        "Our concern in this work is not the exact match of trees but rather approximate match.",
        "Given the vertex list sequence for a query tree, exact match over the trie can be performed using the standard techniques by following the edge labeled with next vertex list until a leaf in the trie is reached, and the query vertex label sequence is exhausted.",
        "For approximate tree matching, we use the error-tolerant approximate finite-state recognition algorithm ((Mazer, 1996), which finds all strings within a given error threshold of some string in the regular set accepted by the underlying finite-state acceptor.",
        "An adaptation of this algorithm will be briefly summarized here.",
        "Error-tolerant matching of vertex list sequences requires an error metric for measuring how much two such sequences deviate from each other.",
        "The distance between two sequences measures the minimum number of insertions, deletions and leaf label changes that are necessary to convert one tree into another.",
        "It should be noted that this is different from the error metric defined by (Wang et al., 1994).",
        "Let Z = Z2, ..., Zp, denote a generic vertex list sequence of p vertex lists.",
        "Z[j] denotes the initial subsequence of Z up to and including the jni leaf label.",
        "We will use X (of length In) to denote the query vertex list sequence, and Y (of length n) to denote the sequence that is a (possibly partial) candidate vertex list sequence (from the database of trees).",
        "Given two vertex list sequences X and Y, the distance, ilist(X[rn], Y[n]), computed according to the recurrence below, gives the minimum",
        "For a tree database D and a distance threshold t > 0, we consider a query tree represented by a vertex list sequence X[rn] (not in the database) to match the database with an error of -I, if the set"
      ]
    },
    {
      "heading": "2.5 An algorithm for approximate tree matching",
      "text": [
        "Standard searching with a trie corresponds to traversing a path starting from the start node (of the trie), to one of the leaf nodes (of the trie), so that the concatenation of the labels on the arcs along this path matches the input vertex list sequence.",
        "For error-tolerant matching, one needs to find all paths front the ,start node to one of the final nodes, so that when the labels on the edges along a path are concatenated, the resulting vertex list sequence is within a given distance threshold t, of the query vertex list sequence.",
        "This search has to be very fast if approximate matching is to be of any practical use.",
        "'this means that paths in the trie that can lead to no solutions have to be pruned so that the search can be limited to a very small percentage of the search space.",
        "We need to make sure that any candidate (prefix) vertex list sequence that is generated as the search is being performed, does not deviate from certain initial subsequences of the query sequence by more than the allowed threshold.",
        "To detect such cases, we use the notion of a cut-off distance.",
        "The cut-off distance measures the minimum distance between an initial subsequence of the query",
        "sequence sequence, and the (possibly partial) candidate sequence.",
        "Let Y he a partial candidate sequence whose length is n, and let X be the query sequence of length Tn.",
        "Let 1= min(1, 71 – [I'M]) and n inax(rn, T1 1-1/M1) where M is the cost of insertions and deletions.",
        "The cut-off distance el thlist(X[m],-17[n]) is defined as culdist(X[7rd, min dist(X[i], Y[n]).",
        "Note that except at the boundaries, the initial subsequences of the query sequence X considered are of length [1111.1.1 to length 11+ [II 1111.",
        "Any initial subsequence of X shorter than 1 needs more than 11,111] leaf node insertions, and any initial substrittg of X longer than u requires more than +1.111111 leaf node deletions, to al least equal Y length, violating the distance constraint.",
        "Given a vertex list sequence X (corresponding to a query tree), a partial candidate sequence Y is generated by successively concatenating labels along the arcs as transitions are made, starting with the start state.",
        "Whenever we extend Y going along the trio, we check if the cut-off distance of X and the partial Y is within the bound specified by the threshold 1.",
        "If the cut-off distance goes beyond the threshold, the last edge is backed off to the source node (in parallel with the shortening of Y) and some other edge is tried.",
        "Backtracking is recursively applied when the search can not be continued from that node.",
        "if, during the construction of Y, a terminal node (which may or may not be a leaf of the trio) is reached without violating the cutoff distance constraint, and dist(X[In],-)/H) < 1 at that point, then Y is a tree in the database that matches the input query"
      ]
    },
    {
      "heading": "SeqUencc.2",
      "text": [
        "Denoting the nodes of the trio by subscripted q's (qe being the initial node (e.g., top node in Figure 3)) and the labels of the edges by V, and denoting by 6(qi, V) the node in the trie that one can reach from node qi with edge label V (denoting a vertex list), we present, in Figure 4, the algorithm for generating Y's by a (slightly modified) depth-first probing of the trie.",
        "'Hie crucial point in this algorithm is that the cut-off distance computation can be performed very efficiently by maintaining a matrix // which is an Tn by matrix with element 11(i, = disl(X[i],Y[j]) (Du and Chang, 1992).",
        "We can Rote that the computation of the element 11(i+ I, ) recursively depends on only /1(i, J), 11(i, .1 +1), 1/(i+ I, j) from the earlier definition of the edit, distance (see Figure h.) During the depth first search of the trie, entries in column ii.",
        "of the matrix 11 have to be (re)computed, only when the candidate string is of length n. During backtracking, the entries for the last column are 'Note that we have to (10 this check since we nay come to other irrelevant terminal nodes daring the search.",
        "/*push empty candidate, and start node to start search */ push((( , go)) while stack not empty begin pop((' , qi)) /* pop partial sequence Y and the node */ for all qj and V such that (qi, V) = q) begin /* extend the candidate sequence */ Y = concat(17 , V) /* n is the current length of Y */ /* check if Y has deviated too much, if not push */",
        "discarded, but the entries in prior columns are still valid.",
        "'thus all entries required by 11(i+ I, j+ I), except 11(i, j +1), are already available in the matrix in columns – I and i.",
        "The computation of ruldist(X[In],Y[n]) involves a loop in which the minimum is computed.",
        "This loop (indexing along column j + 1) computes j + I) before it is needed for the computation of IT (i + 1, j 1)."
      ]
    },
    {
      "heading": "3 Experimental Results",
      "text": [
        "We have experimented with 3 syntheLicly generated sets of trees with the properties given in 'fable 1. hi this table, the third column (label ALP) gives the average ratio of the vertices at each level which are randontly selected as leaf vertices in a tree.",
        "The fourth colimin gives the maximum number of children that a non-leaf node may have.",
        "The last column gives the maximum depth of the trees in that database.",
        "Front these synthetic databases, we randomly extracted 100 trees and then perturbed them with random leaf deletions, insertions and label changes so that they were of sonic distance from a",
        "tree in the original tree.",
        "We used thresholds t = 2 and t = 4, allowing an error of C 1 for each leaf label change and an error of S = 2 for each insertion or deletion (see Section 2.2).",
        "We then ran our algorithm on these data sets and obtained performance information.",
        "All runs were performed on a Sun SparcStation 20/61 with 128M real memory.",
        "The results are presented in Table 2.",
        "It can be",
        "seen that the approximate search algorithm is very fast for the set of synthetic tree databases that we have experimented with.",
        "It certainly is also possible that additional space savings can be achieved if directed acyclic graphs can be used to represent the tree database taking into account both common prefixes and common suffixes of vertex list sequences."
      ]
    },
    {
      "heading": "4 Conclusions",
      "text": [
        "This paper has presented an algorithm for approximate associative tree matching that can be used in example-based machine translation applications.",
        "The algorithm efficiently searches in a database of trees, all trees that are \"close\" to a given query tree.",
        "The algorithm has been implemented on Sun Sparcstations, and experiments on rather large synthetic tree database indicate that it can perform approximate matches within tenths of a second to few seconds depending on the size of the database and the error that the search is allowed to consider."
      ]
    },
    {
      "heading": "5 Acknowledgments",
      "text": [
        "This research was in part funded by a NATO Science for Stability Phase III Project Grant – LANGUAGE."
      ]
    }
  ]
}
