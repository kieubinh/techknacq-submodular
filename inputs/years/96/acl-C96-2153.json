{
  "info": {
    "authors": [
      "Michael Schiehlen"
    ],
    "book": "International Conference on Computational Linguistics",
    "id": "acl-C96-2153",
    "title": "Semantic Construction from Parse Forests",
    "url": "https://aclweb.org/anthology/C96-2153",
    "year": 1996
  },
  "references": [
    "acl-C90-2018",
    "acl-C92-1017"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "The paper describes a system which uses packed parser output directly to build semantic representations.",
        "More specifically, the system takes as input Packed Shared Forests in the sense of Tomita (Tomita, 1985) and produces packed Underspecified Discourse Representation -Structures.",
        "The algorithm visits every node in the Parse Forest only a bounded number of times, so that a significant increase in efficiency is registered for ambiguous sentences."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "One of the most interesting problems comes about by the tendency of natural language discourse to be ambiguous and open to a wide variety of interpretations.",
        "Generating representations for all the interpretations is not feasible in view of the strict computational hounds imposed on NLP systems.",
        "Instead, two other routes have been pursued: (1) the integration of further disambiguating knowledge and heuristics into the system or (2) the generation of a single semantic representation that summarizes all the interpretations in the hope that the application task will force a distinction between the interpretations only in few cases.",
        "Such a summary representation is called underspecified if a procedure is given with it, to derive a set of real semantic representations from it.",
        "By now, several techniques are known to underspcc-ify quantifier scope ambiguities (Alshawi, 1992), (Reyle, 1993).",
        "In this paper Discourse Representation Structures (Kamp and Reyle, 1993) are employed as underlying semantic representations.",
        "For underspecification with respect.",
        "to scope ambiguities the present; approach makes use of Under-\"This work was funded by the German Federal Ministry of Education, Science, Research and Technology (BMW in the framework of the Verbmobil Project under Grant 01 IV 1.01 U.",
        "Many thanks are due to M. Dorna, J. Diirre, M. Emele, E. KOnig-Bautner, C. Rohrer, C.J.",
        "Rupp, and C. Vogel.",
        "specified Discourse Representation Theory (Reyle, 1993).",
        "Another strand of research has looked at compact representations for parse outputs (Ear-ley, 1970), (Tornita, 1985) and efficient parsing algorithms to deliver such representations.",
        "Unfortunately, advances made in this area did not have impact on semantic construction.",
        "It was still necessary to first; unpack the compact parsing representation and derive the individual parse trees from it before going about generating semantic representations.",
        "So in this area another application for semantic underspecification is lurking.",
        "Several approaches to underspecification are conceivable.",
        "(1) Operational Underspecification: Construction operations that involve arbitrary choices are delayed and carried out only on demand (Alshawi, 1992), (Pinkal, 1995).",
        "(2) Representational Underspecification: The ambiguities are represented (explicitly or implicitly) in a formalism.",
        "A resolution procedure derives the full-fledged semantic representations.",
        "This paper opts for the second approach (for motivation see chapter 7).",
        "between parser and the semantic construction component, too.",
        "• Parse forests/charts (Alshawi, 1992).",
        "• Underspecified \"trees\" with abstract dominance information (Finical, 1995).",
        "• Fully specified parse trees (Egg and Leheth, 1995).",
        "The syntactic ambiguities are obtained by re-ambiguation in the semantic component.",
        "Our choice are parse forests since there are well-known methods of construction for them and it is guaranteed that every syntactic ambiguity can be represented in this way.",
        "Furthermore a wide range of existing parsing systems, e.g. (Block and Schachtl, 1992), produce packed representations of this kind."
      ]
    },
    {
      "heading": "2 Outline of the System",
      "text": [
        "Let us begin with a rough sketch of the architecture of the system.",
        "The semantic construction module works on parse forests and presupposes",
        "a semantic grammar of a certain kind (see chapter 6).",
        "The semantic grammar must be correlated with the syntactic grammar so that there is a one-to-one mapping between lexical entries and rules.",
        "input string"
      ]
    },
    {
      "heading": "3 Packed Shared Forests",
      "text": [
        "In this section a formal description of packed shared forests in the sense of Tomita (Tomita, 1985) is given.",
        "Let a context-free grammar g be a quadruple < N, T, R, S > where N and T are finite disjoint sets of nonterminal symbols and terminal symbols, respectively, R is a set of rules of the form A 4 a (A is a nonterminal and a a possibly empty string of nonterminal or terminal symbols), S is a special nonterminal, called start symbol.",
        "An ordered directed graph marked according to grammar g is a triple < V, E, m > so that ✓ is a finite set of vertices or nodes, E a finite set of edges e of the form (v1, (v2, , vr,)) (v, E V, n > 2, e starts at v1, v1 is the predecessor of v2, .. , vn), m is the marking function which associates with each vertex a terminal or nonterminal symbol or the special symbol e. is restricted so that the vertices on each edge are marked with the symbols of a rule in Cf', the empty string being represented by the additional symbol e. A parse tree is an ordered directed acyclic graph (DAG) satisfying the following constraints.",
        "1.",
        "There is exactly one vertex without predecessors, called the top vertex or root.",
        "The root is marked with the start symbol.",
        "2.",
        "For every vertex there is at most one edge starting at the vetteX.",
        "Vertices that do not begin edges are called leaves, such that do are called inner nodes.",
        "3.",
        "Every vertex except the root has exactly one predecessor.",
        "A DAG satisfying the constraints (1-2) is called Shared Forest, a DAG only satisfying (1) is a Packed Shared Forest or parse forest (see figure 1).",
        "A packed shared forest for an input string a obeys the further constraint that there must be at most one vertex for each grammar symbol and substring of a.",
        "Thus, if a consists of n words, there will be at most k * n2 vertices in the parse forest for it (k being constant).",
        "Parse forests can be efficiently constructed using conventional parsing algorithms (Tomita, 1985), (Earley, 1970)."
      ]
    },
    {
      "heading": "4 Determining Tree Readings from",
      "text": []
    },
    {
      "heading": "a Forest",
      "text": [
        "A tree reading of forest F is a tree in F that contains the root and all leaves.",
        "Tree readings are treated as objects.",
        "An edge is used in a tree reading if it is one of the tree's edges.",
        "Let us now define a disambiguated parse forest (DPF for short).",
        "A DPF D is a quadruple < V, D, , m > such that",
        "• V and D are finite disjoint sets.",
        "V is the set of vertices and D is the set of tree readings.",
        "• E' is a finite set of edges of the form (vi , (v2, , vt,), {di, .",
        ", d,„}).",
        "The third element is a set of tree readings (C D) and encodes the tree readings in which the edge is used.",
        "• rn is a marking function from vertices to grammar symbols.",
        "To derive a DPF from a parse forest every edge must be assigned a set of tree readings.",
        "There is no simple way to determine from a parse forest the number of its tree readings.",
        "So instead of postulating a fixed set of readings the present approach uses pointers (implemented as Prolog variables) to refer to sets of tree readings.",
        "Two operations disjoint union and multiplication are defined for these set pointers.",
        "Both operations are monotonic in the sense that the pointers are not altered, their value is only specified.",
        "Let si be a set of tree readings.",
        "• si s2",
        "The operator U differs from the set-theoretic notion of disjoint union in that it is neither commutative nor associative.",
        "This is so because on the implementational level commutativity and associativity would necessitate an abstract data type, thus a costly overhead.",
        "• 51 x 52",
        "In general, si and 82 correspond to formulae involving atomic sets and U operators: Si = sn U ... U sim, and s2 = 821 U • • • U 82n•",
        "The operation x introduces rn * n new atomic sets sib and splits the former atomic sets such that Vi : 1 i m : ... and V j 1 5 j5n:s2i =s1ii U s:„.j.",
        "The sets si and s2 are now equal modulo associativity and commutativity.",
        "Consider the following example:",
        "We begin by associating a particular set pointer s1 with the root vertex.",
        ".s1 refers to the total set of tree readings of the forest since the root vertex figures in all trees derivable from the forest.",
        "We then traverse the graph in top-down fashion applying to each new vertex v the following procedure: Let ei be the set of tree readings at edge i ending in v, and hi the set of tree readings at edge j starting in v. Then the following actions must be performed.",
        "• Apply the procedure to all successors of v. This step yields for each edge j starting in v and for each vertex u at the end of j a set of tree readings b'j„.",
        "• bi x x //i„ for each edge j starting in v • (b1 Cl U b„) x (ei Li ... U c„,)",
        "If a vertex v has already been encountered the only action required is to connect the edge information on v's predecessor w with the edge information already present on vertex v. In particular, the successors of v need not be checked again.",
        "Let k be the edge over which the vertex v was reached from another vertex w in the top-down traversal.",
        "Let ck,,, be the set of tree readings determined for edge k at vertex w and ek„ the set of tree readings determined for the edge at vertex v.",
        "• C kv X Ckw"
      ]
    },
    {
      "heading": "5 Packed Underspecified Discourse Representation Structures",
      "text": [
        "In this section an extension to UDR,Ss (Reyle, 1993) to express referentially underspecified semantic representations is presented.",
        "First a definition of UDRSs is given.",
        "A UDRS is a quadruple < L,R,C7<> where L and R arc disjoint finite sets of labels and discourse referents, respectively.",
        "The order relation < forms a semilattice over L with one-element h. C is a set of conditions of the following form",
        "• l: x7 where 1 E G, 7?,.",
        "• 1 : ,s„), where 1 E ,x„ E 7?,, and p is an n-place predicate • 1: 11 => /2, where 1,11,12 E • 1 : , where 1,11 E • 1 : 11 V 12, where 1,11,12 E E • 11 5 12, where 11,12 E E",
        "In UDRSs = L and '1?, = To get packed UDR,Ss the UDRS language is extended by adding reified contexts (semantic readings) to it.",
        "The idea of using context variables to represent ambiguous structures originally stems from the literature on constraint-based formalisms (Darre and Eisele, 1990).",
        "A packed UDRS is a quintuple < L,R,D, C', 5> where L, R, < arc the same as in UDRSs, D is a finite set of contexts which is disjoint from L and R. C' is defined as in UDRSs except that (1) any condition may",
        "also be prefixed by a context set, and (2) label arguments may, not only be labels but also functions from contexts to labels (E = L U (D L)), and the same holds for discourse referents (R. =",
        "RU (D R)).",
        "If a function {A --+ xi ,B 4 x2}",
        "replaces a discourse referent in a packed UDRS, this intuitively means that the argument slot is filled by x1 in reading A and by x2 in reading B.",
        "As an example for a packed UDRS consider the following representation for I saw every man with a telescope.",
        "In the implementation contexts are represented by Prolog variables.",
        "In this way disambiguation is ensured to be monotonic': A context d can be cancelled by grounding the Prolog variable representing d to a specific atom \"no\".",
        "The formalism also allows any kind of partially disambiguated structures since the variables for the readings do not interact.",
        "In the above version of UDR,S packing, disjuncts are reified.",
        "Another way to represent referential ambiguities is to reify argument slots using additional variable names (L and X below, not to be mistaken as discourse referents).",
        "Disjunctions are then represented directly."
      ]
    },
    {
      "heading": "6 Building Semantic Representations",
      "text": [
        "UDRS construction (Frank and Reyle, 1992), (Bos, 1995) is different from conventional semantic construction in that embedding is not represented directly but by means of labels.",
        "The only semantic composition operation is concatenation.",
        "In addition labels and discourse referents are matched as specified in the semantic part of the grammar rules (the \"semantic grammar\").",
        "In the semantic grammar every nonterminal is assigned a list of arguments.",
        "For every operator (e.g. an NP) a lower label and a series of upper labels must he given.",
        "The lower label points to material which must be in the scope of the operator (e.g. the verb).",
        "The upper labels refer to the minimal scope domain the operator must occur in.",
        "This domain differs for indefinite NPs and quantifier NPs since these types of NPs are subject to different island constraints (only indefinites can be raised over clause boundaries).",
        "Furthermore, the semantic grammar specifies the UDRS conditions introduced by lexical items and rules and determines the arguments to be matched in rules and lexical items.",
        "It also gives the direction of this matching by fixing in which lexical item an argument originates (see last slot of lexical entries).",
        "If an argument originates in an item (because it is e.g. its instance discourse referent or label) then the value of this argument is un-ambigous for the item'.",
        "In adjunction structures, the modified constituent assigns arid the modifier receives the shared discourse referent.",
        "Consider the following example grammar'.",
        "2A similar train of thought lies behind the notion of \"focus\" proposed by Tomita (Tomita, 1985).",
        "A \"focus\" in a rule is the constituent which gets assigned an argument from the \"background\" constituents of the rule.",
        "In general this notion of focus must be rela-tivised to individual arguments.",
        "Constituent 1 can be focus with respect to argument i while constituent 2 is focus for argument j in a rule.",
        "Let; us turn now to the semantic construction component.",
        "The tree readings of the DPF correspond to the contexts of the packed UDRS.",
        "The motivation behind this layout is that; in most cases syntactic ambiguity has some impact on the semantic readings4.",
        "The construction algorithm traverses the DPF and assigns to each vertex the argument; list associated with its category in the semantic grammar.",
        "The arguments on this list are not; arguments proper as they would be if only parse trees were considered, but functions from contexts to arguments proper.",
        "These functions are total only for the root and the leaves, for inner nodes v they are restricted to the union D1 of the context; sets at the edges starting at v. A predicate matchl matches arguments proper as given in the lexical entries and the startsymbol declaration onto functions as used in the rules.",
        "Let D1 be a context set {(11, , du}, let LexArg be an argument as provided by a lexical item or startsymbol declaration I, let Arg be an argument as occurring attached t;o a nonterrninal on the right-hand side of a grammar rule.",
        "Then the predicate mat chl unifies LexArg with Arg if LexArg does not originate in I.",
        "If LexArg does, Arg is unified with the function {d1 –* LexArg,... ,d„ LexArg).",
        "Let us assume a bottom-up traversal of the parse forest and let e be the edge from v t;o one of its successors w. Then the arguments already presents' at w must be matched with the arguments predicted for w by the semantic rule corresponding to e (predicate match2).",
        "Let D2 be the context set assigned to e. Then only t;he argument values of the contexts in D2 are unified.",
        "In this way it is guaranteed that argument matching is done 'If several tree readings correspond to a single context (semantic reading) this is recognised in the last step (determining unambiguous arguments) where the tree readings are merged.",
        "'The bottom-up assumption makes sure that vertex w has been treated.",
        "as it; would be done in tire underlying trees: The contexts clearly separate the information flow.",
        "Let D2 be the context set {d1, , d„) at; c, let; UpperArg be an argument as provided by the semantic rule corresponding to edge c, let LowerArg be an argument; as attached to the vertex w. Then the predicate match2 unifies UpperArg with the restriction of the function Lower Arg 1,o the contexts in D2 {d1 4 v1, ... ,d„ v„} (a subset; of LowerArg).",
        "In the final step the packed UDRS is traversed and functions where all contexts point t;o a single value are replaced by this value."
      ]
    },
    {
      "heading": "7 Comparison with Other Approaches",
      "text": [
        "This section discusses two evaluation criteria for approaches to semantic underspecification.",
        "The present proposal is measured against the criteria, and so are the Minimal Recursion Semantics approach (Egg and Lebeth, 1995), the Radical Underspecification approach (Pinkal, 1995), and the Core Language Engine approach (Alshawi, 1992).",
        "The first criterion is coverage.",
        "Several types of syntactic ambiguities can be distinguished.",
        "• adjunction ambiguities (arising from attachment of PPs, adjectives, adverbial subclauses, and other modifiers) • coordination ambiguities • 0-role assignment ambiguities (arising from scrambling) • ambiguities arising from multi-part-of-speech words (A subcase of this type of ambiguity is the treatment of unknown input words.)",
        "The MRS approach is restricted t;o adjunction ambiguities, while the other approaches are applicable to all the kinds of ambiguities mentioned.",
        "A drawback of the MRS approach might be that it generates semantic readings which are not licensed by the syntactic structure.",
        "To give an example consider the sentence 1 saw a 'man in the apartment with a telescope.",
        "MRS produces a spurious reading in which the PP with a telescope adjoins to the NP a man while the PP in the apartment modifies t;he full sentence.",
        "Remember that MRS does not use a parse forest as input structure but; an arbitrary parse tree, i.e. one specific syntactic reading.",
        "MRS re-ambiguates the parse tree only afterwards within semantic construction.",
        "At this point; information about positions in the input; string is lost.. Another test is the usefulness of the representation for further processing.",
        "Such processes are",
        "• disambiguation by sort hierarchies • theorem proving",
        "• transfer and generation",
        "All these processes can successfully handle sco-pally underspecified structures (for sortal disambiguation and transfer see the Core Language Engine (Alshawi, 1992), for theorem proving see the Underspecified DRS formalism (Reyle, 1993)).",
        "In the Core Language Engine approach to syntactic underspecification the representation must be unpacked to perform disambiguation by sorts.",
        "This seems to be true for any approach relying on delay of semantic construction operations: In order to apply the sortal restrictions of, e.g., a verb to one of its argument discourse referents it must be known which discourse referents could possibly fill the argument slot.",
        "Moore and Alshawi (Alshawi, 1992) explain their reluctance to apply sort restrictions already in the packed structure with the maintenance overhead in associating semantic records with vertices of the forest.",
        "In the packed UDRS approach the problem is handled by explicitly enumerating all possible readings.",
        "Then, the maintenance effort is reduced to the effort of extrapolating the tree readings from the parse forest.",
        "None of the compared approaches makes any claims about theorem proving and transfer.",
        "In the packed UDRS approach it is conceivable to delay actual disambiguation as long as possible: Apart from the potential representation of referential ambiguities by functions packed UDRSs look exactly like UDRSs.",
        "So if only referentially unambiguous conditions must be consulted in a proof, a UDRS theorem prover may be used."
      ]
    },
    {
      "heading": "8 Efficiency",
      "text": [
        "This section reports on an experiment in which the efficiency of the proposed underspecified construction mechanism was measured against; the cost; of generating all UDRSs separately.",
        "Table 1 compares the time behaviour of constructing one underspecified structure (U-Time) with the time needed for constructing of the whole bunch of specified structures (S-Time).",
        "The experiment was conducted on a SPARCstation 20 using input sentences of the form I saw a man (with a telescope)\".",
        "Visibly the time needed per reading remains approximately constant in the construction of the underspecified representation whereas it grows sharply when the ambiguities are enumerated."
      ]
    }
  ]
}
