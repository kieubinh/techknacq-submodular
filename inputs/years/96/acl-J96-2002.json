{
  "info": {
    "authors": [
      "Roger Evans",
      "Gerald Gazdar"
    ],
    "book": "Computational Linguistics",
    "id": "acl-J96-2002",
    "title": "DATR: A Language for Lexical Knowledge Representation",
    "url": "https://aclweb.org/anthology/J96-2002",
    "year": 1996
  },
  "references": [
    "acl-A94-1045",
    "acl-C92-4202",
    "acl-C94-2177",
    "acl-E89-1009",
    "acl-E91-1023",
    "acl-E91-1024",
    "acl-E93-1012",
    "acl-E93-1026",
    "acl-E93-1065",
    "acl-J91-3003",
    "acl-J91-4003",
    "acl-J92-2004",
    "acl-J92-3001",
    "acl-J92-3003",
    "acl-J94-3001",
    "acl-J96-3001",
    "acl-P92-1034",
    "acl-P93-1019",
    "acl-P93-1028",
    "acl-P95-1008",
    "acl-P95-1011",
    "acl-W94-0204"
  ],
  "sections": [
    {
      "text": [
        "Much recent research on the design of natural language lexicons has made use of nonmonotonic inheritance networks as originally developed for general knowledge representation purposes in Artificial Intelligence.",
        "DAT R is a simple, spartan language for defining nonmonotonic inheritance networks with path/value equations, one that has been designed specifically for lexical knowledge representation.",
        "In keeping with its intendedly minimalist character, it lacks many of the constructs embodied either in general-purpose knowledge representation languages or in contemporary grammar formalisms.",
        "The present paper shows that the language is nonetheless sufficiently expressive to represent concisely the structure of lexical information at a variety of levels of linguistic analysis.",
        "The paper provides an informal example-based introduction to DAT R and to techniques for its use, including finite-state transduction, the encoding of DAGs and lexical rules, and the representation of ambiguity and alternation.",
        "Sample analyses of phenomena such as inflectional syncretism and verbal subcategorization are given that show how the language can be used to squeeze out redundancy from lexical descriptions.",
        "1.",
        "Introduction Irregular lexemes are standardly regular in some respect.",
        "Most are just like regular lexemes except that they deviate in one or two characteristics.",
        "What is needed is a natural way of saying \"this lexeme is regular except for this property.\" One obvious approach is to use nonmonotonicity and inheritance machinery to capture such lexical irregularity (and subregularity), and much recent research into the design of representation languages for natural language lexicons has thus made use of nonmonotonic inheritance networks (or \"semantic nets\") as originally developed for more general representation purposes in Artificial Intelligence.",
        "Daelemans, De Smedt, and Gazdar (1992) provide a rationale for, and an introduction to, this body of research and we will not rehearse the content of that paper here, nor review the work cited there.1 DAT R is a rather spartan nonmonotonic language for defining inheritance networks with path/value equations.",
        "In keeping with its intendedly minimalist character, it lacks many of the constructs embodied either in general-purpose knowledge representation languages or in contemporary grammar formalisms.",
        "But the present paper seeks to * Information Technology Research Institute, University of Brighton, Brighton BN2 4AT, U.K. E-mail: Roger.Evans@itri.brighton.ac.uk t Cognitive & Computing Sciences, University of Sussex, Brighton BN1 9QH, U.K. E-mail: Gerald.Gazdar@cogs.sussex.ac.uk 1 Daelemans and Gazdar (1992) and Briscoe, de Paiva, and Copestake (1993) are collections that bring together much recent work on the application of inheritance networks to lexical description.",
        "Other relevant recent work not found there includes Bouma (1993), Briscoe, Copestake, and Lascarides (1995), Calder (1994), Copestake (1992), Daelemans (1994), Daelemans and De Smedt (1994), Ide, Le Maitre, and Veronis (1994), Lascarides et al.",
        "(1996), Mellish and Reiter (1993), Mitamura and Nyberg (1992), Penn and Thomason (1994), Reiter and Mellish (1992), Young (1992), and Young and Rounds (1993)."
      ]
    },
    {
      "heading": "1996 Association for Computational Linguistics",
      "text": [
        "Computational LinguisticsVolume 22, Number 2 show that the language is nonetheless sufficiently expressive to represent concisely the structure of lexical information at a variety of levels of language description.",
        "The development of DAT R has been guided by a number of concerns, which we summarize here.",
        "Our objective has been a language that (i) has an explicit theory of inference, (ii) has an explicit declarative semantics, (iii) can be readily and efficiently implemented, (iv) has the necessary expressive power to encode the lexical entries presupposed by work in the unification grammar tradition, and (v) can express all the evident generalizations and subgeneralizations about such entries.",
        "Our first publications on DATR (Evans and Gazdar 1989a, 1989b) provided a formal theory of inference (i) and a formal semantics (ii) for DATR and we will not recapitulate that material here.2 With respect to (iii), the core inference engine for DAT R can be coded in a page of Prolog (see, e.g., Gibbon 1993, 50).",
        "At the time of writing, we know of a dozen different implementations of the language, some of which have been used with large DATR lexicons in the context of big NLP systems (e.g., Andry et al.",
        "1992; Cahill 1993a, 1994; Cahill and Evans 1990).",
        "We will comment further on implementation matters in Section 5, below.",
        "However, the main purpose of the present paper is to exhibit the use of DATR for lexical description (iv) and the way it makes it relatively easy to capture lexical generalizations and subregularities at a variety of analytic levels (v).",
        "We will pursue (iv) and (v) in the context of an informal example-based introduction to the language and to techniques for its use, and we will make frequent reference to the DATR-based lexical work that has been done since 1989.",
        "The paper is organized as follows: Section 2 uses an analysis of English verbal morphology to provide an informal introduction to DAT R. Section 3 describes the language more precisely: its syntax, inferential and default mechanisms, and the use of abbreviatory variables.",
        "Section 4 describes a wide variety of DAT R techniques, including case constructs and parameters, Boolean logic, finite-state transduction, lists and DAGs, lexical rules, and ways to encode ambiguity and alternation.",
        "Section 5 explores more technical issues relating to the language, including functionality and consistency, multiple-inheritance, modes of use, and existing implementations.",
        "Section 6 makes some closing observations.",
        "Finally, an appendix to the paper replies to the points made in the critical literature on DAT R."
      ]
    },
    {
      "heading": "2. DATR by Example",
      "text": [
        "We begin our presentation of DAT R with a partial analysis of morphology in the English verbal system.",
        "In DAT R, information is organized as a network of nodes, where a node is essentially just a collection of closely related information.",
        "In the context of lexical description, a node typically corresponds to a word, a lexeme, or a class of lexemes.",
        "For example, we might have a node describing an abstract verb, another for the subcase of a transitive verb, another for the lexeme love, and still more for the individual words that are instances of this lexeme (love, loves, loved, loving, etc.).",
        "Each node has associated with it a set of path/value pairs, where a path is a sequence of atoms (which are primitive objects), and a value is an atom or a sequence of atoms.",
        "We will sometimes refer to atoms in paths as attributes.",
        "For example, a node describing the present participle form of the verb love (and called perhaps Wordi) might contain the path/value pairs shown in Table 1.",
        "The paths",
        "Evans and GazdarLexical Knowledge Representation Table 1 Path/value pairs for present participle of love.",
        "PathValue syn catverb syn type main syn form present participle mor form love ing in this example all happen to contain two attributes, and the first attribute can be thought of as distinguishing syntactic and morphological types of information.",
        "The values indicate appropriate linguistic settings for the paths for a present participle form of love.",
        "Thus, its syntactic category is verb, its syntactic type is main (i.e., it is a main verb, not an auxiliary), its syntactic form is present participle (a two-atom sequence), its morphological form is love ing (another two-atom sequence).",
        "In DATR this can be written as:3 Wordl: <syn cat> = verb <syn type> = main <syn form> = present participle <mor form> = love ing.",
        "Here, angle brackets (< >) delimit paths.",
        "Note that values can be atomic or they can consist of sequences of atoms, as the two last lines of the example illustrate.4 As a first approximation, nodes can be thought of as denoting partial functions from paths (sequences of atoms) to values (sequences of atoms).5 In itself, this tiny fragment of DATR is not persuasive, apparently allowing only for the specification of words by simple listing of path/value statements for each one.",
        "It seems that if we wished to describe the passive form of love we would have to write: Word2: <syn cat> = verb <syn type> = main <syn form> = passive participle <mor form> = love ed.",
        "This does not seem very helpful: the whole point of a lexical description language is to capture generalizations and avoid the kind of duplication evident in the specification of Wordl and Word2.",
        "And indeed, we shall shortly introduce an inheritance mechanism that allows us to do just that.",
        "But there is one sense in which this listing approach",
        "Computational LinguisticsVolume 22, Number 2 is exactly what we want: it represents the actual information we generally wish to access from the description.",
        "So in a sense, we do want all the above statements to be present in our description; what we want to avoid is repeated specification of the common elements.",
        "This problem is overcome in DAT R in the following way: such exhaustively listed path/value statements are indeed present in a description, but typically only implicitly present.",
        "Their presence is a logical consequence of a second set of statements, which have the concise, generalization-capturing properties we expect.",
        "To make the distinction sharp, we call the first type of statement extensional and the second type definitional.",
        "Syntactically, the distinction is made with the equality operator: for extensional statements (as above), we use =, while for definitional statements we use ==.",
        "And, although our first example of DAT R consisted entirely of extensional statements, almost all the remaining examples will be definitional.",
        "The semantics of the DAT R language binds the two together in a declarative fashion, allowing us to concentrate on concise definitions of the network structure from which the extensional \"results\" can be read off.",
        "Our first step towards a more concise account of Wordl and Word2 is simply to change the extensional statements to definitional ones:",
        "<syn cat> <syn type> <syn form> <mor form>= = =love ing.",
        "Word2:=verb main passive participle <syn cat> <syn type> <syn form> <mor form>= =love ed.",
        "This is possible because DAT R respects the unsurprising condition that if at some node a value is specifically defined for a path with a definitional statement, then the corresponding extensional statement also holds.",
        "So the statements we previously made concerning Wordl and Word2 remain true, but now only implicitly true.",
        "Although this change does not itself make the description more concise, it allows us to introduce other ways of describing values in definitional statements, in addition to simply specifying them.",
        "Such value descriptors will include inheritance specifications that allow us to gather together the properties that Wordl and Word2 have solely by virtue of being verbs.",
        "We start by introducing a VERB node: VERB: <syn cat> == verb <syn type> == main.",
        "and then redefine Wordl and Word2 to inherit their verb properties from it.",
        "A direct encoding for this is as follows: Wordl: <syn cat> == VERB:<syn cat> <syn type> == VERB:<syn type> <syn form> == present participle",
        "Evans and GazdarLexical Knowledge Representation <mor form> Word2:=love ing.",
        "<syn cat> <syn type> <syn form> <mor form>== == == = =VERB:<syn cat> VERB:<syn type> passive participle love ed.",
        "In these revised definitions the right-hand side of the <syn cat> statement is not a direct value specification, but instead an inheritance descriptor.",
        "This is the simplest form of DATR inheritance: it just specifies a new node and path from which to obtain the required value.",
        "It can be glossed roughly as \"the value associated with <syn cat > at Wordl is the same as the value associated with <syn cat> at VERB.\" Thus from VERB: <syn cat> == verb it now follows that Wordl : <syn cat> == verb.6 However, this modification to our analysis seems to make it less concise, rather than more.",
        "It can be improved in two ways.",
        "The first is really just a syntactic trick: if the path on the right-hand side is the same as the path on the left-hand side, it can be omitted.",
        "So we can replace VERB: <syn type>, in the example above, with just VERB.",
        "We can also extend this abbreviation strategy to cover cases like the following, where the path on the right-hand side is different but the node is the same: Come: <mor root> == come <mor past participle> == Come:<mor root>.",
        "In this case we can simply omit the node: Come: <mor root> == come <mor past participle> == <mor root>.",
        "The other improvement introduces one of the most important features of DAT R specification by default.",
        "Recall that paths are sequences of attributes.",
        "If we understand paths to start at their left-hand end, we can construct a notion of path extension: a path P2 extends a path P1 if and only if all the attributes of P1 occur in the same order at the left-hand end of P2 (so <al a2 a3> extends <>, <al>, <al a2>, and <al a2 a3>, but not <a2>, <al a3>, etc.).",
        "If we now consider the (finite) set of paths occurring in definitional statements associated with some node, that set will not include all possible paths (of which there are infinitely many).",
        "So the question arises of what we can say about paths for which there is no specific definition.",
        "For some path P1 not defined at node N, there are two cases to consider: either P1 is the extension of some path defined at N or it is not.",
        "The latter case is easiestthere is simply no definition for P1 at N (hence N can be a partial function, as already noted above).",
        "But in the former case, where P1 extends some P2 which is defined at N, P1 assumes a definition \"by default.\" If P2 is the only path defined at N which P1 extends, then P1 takes its definition from the definition of P2.",
        "If P1 extends several paths defined at N, it takes its definition from the most specific (i.e., the longest) of the paths that it extends.",
        "In the present example, this mode of default specification can be applied as follows:"
      ]
    },
    {
      "heading": "6 And hence also the extensional version, Wordl :<syn cat> = verb.",
      "text": [
        "Computational LinguisticsVolume 22, Number 2 We have two statements at Wordl that (after applying the abbreviation introduced above) both inherit from VERB:",
        "The paths <syn type> and <syn cat> (and also many others, such as <syn cat foo>, <syn baz>) obtain their definitions from <syn> using the default mechanism just introduced, and so inherit from VERB.",
        "The path <syn form>, being explicitly defined, is exempt from this default behavior, and so retains its value definition, present participle; any extensions of <syn form> obtain their definitions from <syn form> rather than <syn> (since it is a more specific leading subpath), and so will have the value present participle also.",
        "The net effect of this definition for Wordl can be glossed as \"Word1 stipulates its morphological form to be love ing and inherits values for its syntactic features from VERB, except for <syn form>, which is present participle.\" More generally, this mechanism allows us to define nodes differentially: by inheritance from default specifications, augmented by any nondefault settings associated with the node at hand.",
        "In fact, the Wordl example can take this default inheritance one step further, by inheriting everything (not just <syn>) from VERB, except for the specifically mentioned values: Word1:"
      ]
    },
    {
      "heading": "== VERB",
      "text": [
        "<syn form> == present participle <mor form> == love ing.",
        "Here the empty path <> is a leading subpath of every path, and so acts as a \"catch all\"any path for which no more specific definition at Word1 exists will inherit from VERB.",
        "Inheritance via the empty path is ubiquitous in real DATR lexicons but it should be remembered that the empty path has no special formal status in the language.",
        "In this way, Word1 and Word2 can both inherit their general verbal properties from VERB.",
        "Of course, these two particular forms have more in common than simply being verbsthey are both instances of the same verb: love.",
        "By introducing an abstract Love",
        "Evans and GazdarLexical Knowledge Representation lexeme, we can provide a site for properties shared by all forms of love (in this simple example, just its morphological root and the fact that it is a verb).",
        "VERB:",
        "= main.",
        "love.",
        "present participle <mor root> ing.",
        "passive participle <mor root> ed.",
        "So now Word1 inherits from Love rather than VERB (but Love inherits from VERB, so the latter's definitions are still present at Word1).",
        "However, instead of explicitly including the atom love in the morphological form, the value definition includes the descriptor <mor root>.",
        "This descriptor is equivalent to Wordl : <mor root> and, since <mor root > is not defined at Wordl, the empty path definition applies, causing it to inherit from Love : <mor root>, and thereby return the expected value, love.",
        "Notice here that each element of a value can be defined entirely independently of the others; for <mor form> we now have an inheritance descriptor for the first element and a simple value for the second.",
        "Our toy fragment is beginning to look somewhat more respectable: a single node for abstract verbs, a node for each abstract verb lexeme, and then individual nodes for each morphological form of each verb; but there is still more that can be done.",
        "Our focus on a single lexeme has meant that one class of redundancy has remained hidden.",
        "The line",
        "To see how this global inheritance works, consider the query Wordl : <mor form>.",
        "Since <mor form> is not defined at Wordl, it will inherit from VERB via Love.",
        "This specifies inheritance of <mor root > from the query node, which in this case is Wordl.",
        "The path <mor root> is not defined at Wordl but inherits the value love from Love.",
        "Finally, the definition of <mor form> at VERB adds an explicit ing, resulting in a value of love ing for Wordl : <mor form>.",
        "Had we begun evaluation at, say, a daughter of the lexeme Eat, we would have been directed from VERB: <mor form> back to the original daughter of Eat to determine its <mor root>, which would be inherited from Eat itself; we would have ended up with the value eat ing.",
        "The analysis is now almost the way we would like it to be.",
        "Unfortunately, by moving <mor form> from Wordl to VERB, we have introduced a new problem: we have specified the present participle as the (default) value of <mor form> for all verbs.",
        "Clearly, if we want to specify other forms at the same level of generality, then <mor form> is currently misnamed: it should be <mor present participle>, so that we can add <mor past participle>, <mor present tense>, etc.",
        "If we make this change, then the VERB node will look like this:",
        "Evans and GazdarLexical Knowledge Representation <mor present> == \"<mor root>\" <mor present participle> == \"<mor root>\" ing <mor present tense sing three> == \"<mor root>\" s. In adding these new specifications, we have added a little extra structure as well.",
        "The passive form is asserted to be the same as the past formthe use of global inheritance here ensures that irregular or subregular past forms result in irregular or subregular passive forms, as we shall see shortly.",
        "The paths introduced for the present forms illustrate another use of default definitions.",
        "We assume that the morphology of present tense forms is specified with paths of five attributes, the fourth specifying number, the fifth, person.",
        "Here we define default present morphology to be simply the root, and this generalizes to all the longer forms, except the present participle and the third person singular.",
        "For Love, given these changes, the following extensional statements hold, inter alia: Love: <syn <syn <mor <mor <mor <mor <mor <mor <mor <mor <mor <mor <mor",
        "present tense sing one> = love present tense sing two> = love present tense sing three> = love present tense plur> = love present participle> = love ing past tense sing one> = love ed past tense sing two> = love ed past tense sing three> = love ed past tense plur> = love ed past participle> = love ed passive participle> = love ed.",
        "There remains one last problem in the definitions of Wordl and Word2.",
        "The morphological form of Wordl is now given by <mor present participle>.",
        "Similarly, Word2's morphological form is given by <mor passive participle>.",
        "There is no longer a unique path representing morphological form.",
        "This can be corrected by the addition of a single statement to VERB: VERB: <mor form> == \"<mor \"<syn form>\">\".",
        "This statement employs a DATR construct, the evaluable path, which we have not encountered before.",
        "The right-hand side consists of a (global) path specification, one of whose component attributes is itself a descriptor that must be evaluated before the outer path can be.",
        "The effect of the above statement is to say that <mor form> globally inherits from the path given by the atom nor followed by the global value of <syn form>.",
        "For Wordl, <syn form> is present participle, so <mor form> inherits from <mor present participle>.",
        "But for Word2, <mor form> inherits from <mor passive participle>.",
        "Effectively, <syn f orm> is being used here as a parameter to control which specific form should be considered the morphological form.",
        "Evaluable paths may themselves be global (as in our example) or local, and their evaluable components may also involve global or local reference.",
        "The entire analysis is somewhat larger than the original, but it encodes all the past and present tense forms as well as all three participial forms.",
        "More importantly, almost all the information is in the VERB node and is common to many verb lexemes.8 Indeed, the other nodes are as small as they reasonably could be: Love simply states that it is a verb with morphological root love, and Wordl simply states that it is a present participle instance of Love.",
        "Of course, Love is a completely regular verb; but DAT R's capacity for definition by default allows subregular and irregular lexemes to be concisely represented also.",
        "As an example, consider the class of verbs which take en as their past participle ending: hew, mow, saw, sew, etc.'",
        "We can represent this subregularity with a new verbal node that defaults to VERB, but overrides just the past participle morphology:",
        "Computational LinguisticsVolume 22, Number 2 <mor present tense sing one> == am <mor present tense sing three> == is <mor present tense plur> == are <mor past tense sing one> == <mor past tense sing three> <mor past tense sing three> == was <mor past tense plur> == were.",
        "In this section, we have moved from simple attribute/value listings to a compact, generalization-capturing representation for a fragment of English verbal morphology.",
        "In so doing, we have seen examples of most of the important ingredients of DATR: local and global descriptors, definition by default, and evaluable paths."
      ]
    },
    {
      "heading": "3. The DATR Language",
      "text": []
    },
    {
      "heading": "3.1 Syntax",
      "text": [
        "A DATR description consists of a sequence of sentences corresponding semantically to a set of statements.",
        "Sentences are built up out of a small set of basic expression types, which themselves are built up out of sequences of lexical tokens, which we take to be primitive.",
        "In the previous section, we referred to individual lines in DATR definitions as statements.",
        "Syntactically, however, a DATR description consists of a sequence of sentences, where each sentence starts with a node name and ends with a period, and contains one or more path equations relating to that node, each corresponding to a statement in DATR.",
        "This distinction between sentences and statements is primarily for notational convenience (it would be cumbersome to require repetition of the node name for each statement) and statements are the primary unit of specification in DATR.",
        "For the purposes of this section, where we need to be particularly clear about this distinction, we shall call a sentence containing just a single statement a simple sentence.",
        "3.1.1 Lexical Tokens.",
        "The syntax of DATR distinguishes four classes of lexical token: nodes, atoms, variables, and reserved symbols.",
        "The complete list of reserved symbols is as follows: < >==/ We have already seen the use of the first seven of these.",
        "Single quotes can be used to form atoms that would otherwise be ill-formed as such; % is used for end-of-line comments, following the Prolog convention; # is used to introduce declarations and other compiler directives.'",
        "The other classes, nodes, atoms, and variables, must be distinct, and distinct from the reserved symbols, but are otherwise arbitrary.13 For this discussion, we have already adopted the convention that both nodes and atoms are simple words, with nodes starting with uppercase letters.",
        "We extend this convention to variables, discussed more fully in Section 3.4 below, which we require to start with the character $.",
        "And we take white space (spaces, new lines, tabs, etc.)",
        "to delimit lexical tokens but otherwise to be insignificant.",
        "12 Aside from their use in Section 3.4, we will completely ignore such directives in this paper.",
        "13 Formally, we require them to be finite classes, but this is not of great significance here.",
        "A descriptor sequence is a (possibly empty) sequence of descriptors.",
        "The recursive definition of evaluable paths in terms of descriptor sequences allows arbitrarily complex expressions to be constructed, such as:15 \"Nodel:<\"<atoml>\" Node2:<atom2>>\" \"<\"<\"<Nodel:<atoml atom2> atom3>\" Node2 \"<atom4 atom5>\" <> >\">\" But the value sequences determined by such definitions are flat: they have no structure beyond the simple sequence and in particular do not reflect the structure of the descriptors that define them.",
        "We shall sometimes refer to descriptor sequences containing only atoms as simple values, and similarly, (unquoted) path expressions containing only atoms as simple paths.",
        "Computational LinguisticsVolume 22, Number 2 Simple extensional sentences take the form Node:Path = Ext .",
        "where Node is a node, Path is a simple path, and Ext is a simple value.",
        "Extensional sentences derivable from the examples given in Section 2 include: Do:<mor past participle> = done.",
        "Mow:<mor past tense sing one> = mow ed.",
        "Love:<mor present tense sing three> = love s. Simple definitional sentences take the form Node:Path == Def.",
        "where Node and Path are as above and Def is an arbitrary descriptor sequence.",
        "Definitional sentences already seen in Section 2 include:",
        "Extensional statements, and combinations of definitional and extensional statements, may be similarly abbreviated, and the examples used throughout this paper make extensive use of this convention.",
        "Such compound sentences correspond to a number of individual (and entirely independent) DATR statements.",
        "Finally, it is worth reiterating that DATR descriptions correspond to sets of statements: the order of sentences, or of definitions within a compound sentence, is immaterial to the relationships described."
      ]
    },
    {
      "heading": "3.2 Inheritance in DATR",
      "text": [
        "DATR descriptions associate values with node/path pairs.",
        "This is achieved in one of three ways: a value is explicitly stated, or it is explicitly inherited, or it is implicitly",
        "Evans and GazdarLexical Knowledge Representation specified (stated or inherited) via the default mechanism.",
        "We have already seen how values are explicitly stated; in this and the following subsections, we continue our exposition by providing an informal account of the semantics of specification via inheritance or by default.",
        "The present subsection is only concerned with explicit (i.e., nondefault) inheritance.",
        "Section 3.3 deals with implicit specification via DATR's default mechanism.",
        "Computational LinguisticsVolume 22, Number 2 can be read approximately as \"if the value for Node2:Path2 is defined, then the value of Node 1 : Pathl is defined and equal to it.\" There are several points to notice here.",
        "First, if Node2:Path2 is not defined, then Nodel:Pathl is unconstrained, so this is a weak directional equality constraint.",
        "However, in practice this has no useful consequences, due to interactions with the default mechanism (see Section 5.1 below).",
        "Second, \"defined\" here means \"defined by a definitional statement,\" that is, a \"==\" statement: local inheritance operates entirely with definitional statements, implicitly introducing new ones for Node1:Path1 on the basis of those defined for Node2:Path2.",
        "Finally, as we shall discuss more fully in the next subsection, \"value\" here technically covers both simple values and global inheritance descriptors.",
        "For example, when a global path is specified, it effectively returns control to the current global node (often the original query node) but with the newly given path.",
        "Thus in Section 2, above, we saw that the node VERB defines the default morphology of present forms using global inheritance from the path for the morphological root: VERB:<mor present> == \"<mor root>\".",
        "The node from which inheritance occurs is that stored in the global context: a query of Love: <mor present> will result in inheritance from Love : <mor root> (via VERB: <mor pre sent >), while a query of Do : <mor present> will inherit from Do : <mor root>.",
        "Similarly, a quoted node form accesses the globally stored path value, as in the following example:",
        "Evans and GazdarLexical Knowledge Representation",
        "Here, the value of Declension3 : <accusative> inherits from Declension2: <vocat ive> and then from De clens oni : <ac cus at ive>, using the global path (in this case the query path), rather than the local path (<vocat ive>) to fill out the specification.",
        "The resulting value is am and not a as it would have been if the descriptor in Declension2 had been local, rather than global.",
        "We observed above that when inheritance through a global descriptor occurs, the global context is altered to reflect the new node/path pair.",
        "Thus after Love : <mor present> has inherited through \"VERB: <mor root >\", the global path will be <mor root> rather than <mor present>.",
        "When we consider quoted node/path pairs, it turns out that this is the only property that makes them useful.",
        "Since a quoted node/path pair completely respecifies both node and path, its immediate inheritance characteristics are the same as the unquoted node/path pair.",
        "However, because it also alters the global context, its effect on any subsequent global descriptors (in the evaluation of the same query) will be different:",
        "In this example, the value of Declens ion3 : <accusative> inherits from Declension2 : <vocative> and then from Declensionl : <vocative> and then from Declension2: <nominative> (because the global node has changed from Declension3 to Declension2) giving a value of u and not as it would have been if the descriptor in Declension3 had been local, rather than global.",
        "There are a number of ways of understanding this global inheritance mechanism.",
        "The description we have given above amounts to a \"global memory\" model, in which a DATR query evaluator is a machine equipped with two memories: one containing the current local node and path, and another containing the current global node and path.",
        "Both are initialized to the query node and path, and the machine operates by repeatedly examining the definition associated with the current local settings.",
        "Local descriptors alter just the local memory, while global descriptors alter both the local and global settings.",
        "This model is the basis of at least one implementation of DATR but it is not, of course, declarative.",
        "Nevertheless, the notion of global inheritance does have a declarative reading, very similar to local inheritance but, as we have already suggested, layered on top of it.",
        "Recall that local inheritance establishes a network of weak equality relationships among node/path pairs, and these equalities are used to distribute values across this network.",
        "Formally speaking, the local inheritance network controls the distribution not only of simple values, but also of global descriptors, as we mentioned above.",
        "That is, to local inheritance, values and global descriptors are one and the same, and are inherited through the network.",
        "Indeed, this is the intuitive warrant for the use of the quote notation: the quotes turn an inheritance descriptor into a (kind",
        "Computational LinguisticsVolume 22, Number 2 of) value.",
        "Consequently, global descriptors are also distributed through the local inheritance network, and so are implicitly present at many node/path pairs in addition to those they are explicitly defined for.",
        "In fact, a global descriptor is implicitly present at every node/path pair that could ever occur as the global context for evaluation of the descriptor at its original, explicitly defined location.",
        "This means that once distributed in this way, the global descriptors form a network of weak equality relationships just as the local descriptors do, and distribute the simple values (alone) in the same way.",
        "To see this interpretation in action, we consider an alternative analysis of the past participle form of Come.",
        "The essential elements of the analysis are as follows: BARE_VERB: <mor past participle> == \"<mor root>\".",
        "Come: <mor root> == come <mor past participle> == BARE_VERB.",
        "Local inheritance from BARE_VERB to Come implicitly defines the following statement (in addition to the above): Come: <mor past participle> == \"<mor root>\".",
        "Because we have now brought the global inheritance descriptor to the node corresponding to the global context for its interpretation, global inheritance can now operate entirely locallythe required global node is the local node, Come, producing the desired result: Come: <mor past participle> = come.",
        "Notice that, in this last example, the final statement was extensional, not definitional.",
        "So far in this paper we have almost entirely ignored the distinction we established between definitional and extensional statements, but with this declarative reading of global inheritance we can do so no longer.",
        "Local inheritance uses definitional inheritance statements to distribute simple values and global descriptors.",
        "The simple valued definitional statements thereby defined map directly to extensional statements, and global inheritance uses the global inheritance statements (now distributed), to further distribute these extensional statements about simple values.",
        "The statements must be of a formally distinct type, to prevent local inheritance descriptors from distributing them still further.",
        "In practice, however, we need not be too concerned about the distinction: descriptions are written as definitional statements, queries are read off as extensional statements.\" The declarative interpretation of global inheritance suggests an alternative procedural characterization to the one already discussed, which we outline here.",
        "Starting from a query, local descriptors alone are used to determine either a value or a global descriptor associated with the queried node/path pair.",
        "If the result is a global descriptor, this is used to construct a new query, which is evaluated in the same way.",
        "The 17 However, in principle, there is nothing to stop an extensional statement from being specified as part of a DATR description directly.",
        "Such a statement would respect global inheritance but not local inheritance, and might be useful to achieve some exotic effect.",
        "Evans and GazdarLexical Knowledge Representation process repeats until a value is returned.",
        "The difference between this and the earlier model is one of perspective: When a global descriptor is encountered, one can either bring the global context to the current evaluation context (first model), or take the new descriptor back to the global context and continue from there (second model).",
        "The significance of the latter approach is that it reduces both kinds of inheritance to a single basic operation with a straightforward declarative interpretation.",
        "Thus we see that DAT R contains two instances of essentially the same declarative inheritance mechanism.",
        "The first, local inheritance, is always specified explicitly, while the second, global inheritance, is specified implicitly in terms of the first.",
        "Extending these inheritance mechanisms to the more complex DATR expressions is straightforward.",
        "Descriptors nested within definitional expressions are treated independentlyas though each was the entire value definition rather than just an item in a sequence.",
        "In particular, global descriptors that alter the global context in one nested definition have no effect on any others.",
        "Each descriptor in a definitional sequence or evaluable path is evaluated from the same global state.",
        "In the case of global evaluable paths, once the subexpressions have been evaluated, the expression containing the resultant path is also evaluated from the same global state."
      ]
    },
    {
      "heading": "3.3 Definition by Default",
      "text": [
        "The other major component of DAT R is definition by default.",
        "This mechanism allows a DAT R definitional statement to be applicable not only for the path specified in its left-hand side, but also for any rightward extension of that path for which no more specific definitional statement exists.",
        "In effect, this \"fills in the gaps\" between paths defined at a node, on the basis that an undefined path takes its definition from the path that best approximates it without being more specific.'",
        "Of course, to be effective, this \"filling in\" has to take place before the operation of the inheritance mechanisms described in the previous section.",
        "Consider for example, the definition of Do we gave above.",
        "Computational LinguisticsVolume 22, Number 2 been defined at all, since there would have been no leading subpath with a definition.",
        "Note how <mor> itself takes its definition from <>, since all the explicitly defined <mor ...> specifications have at least one further attribute.",
        "The definition for <mor past> overrides default definition from <> and in turn provides a definition for longer paths.",
        "However, <mor past participle> blocks default definition from <mor past>.",
        "Thus the following arise:19 Do:<mor past <mor past <mor past <mor past <mor pasttense> == did tense plur> == did tense sing three> == did participle plur> == done participle sing one> == done Similarly all the <mor present > forms inherit from VERB except for the explicitly cited <mor present tense sing three>.",
        "Definition by default introduces new DATR sentences, each of whose left-hand-side paths is an extension of the left-hand-side paths of some explicit sentence.",
        "This path extension carries over to any paths occurring on the right-hand side as well.",
        "For example, the sentence: VERB: <mor present tense> == \"<mor root>\" <mor form> == <mor \"<syn form>\">.",
        "gives rise to the following, inter alia: VERB: <mor <mor <mor <mor present tense present tense form present> form passive> sing> = plur> = == <mor == <mor \"<mor root sing>\" \"<mor root plur>\" \"<syn form present>\" present> \"<syn form passive>\" passive>.",
        "This extension occurs for all paths in the right-hand side, whether they are quoted or unquoted and/or nested in descriptor sequences or evaluable paths.",
        "The intent of this path extension is to allow descriptors to provide not simply a single definition for a path but a whole set of definitions for extensions to that path, without losing path information.",
        "In some cases this can lead to gratuitous extensions to pathspath attributes specifying detail beyond any of the specifications in the overall description.",
        "However, this does not generally cause problems since such gratuitously detailed paths, being unspecified, will always take their value from the most specific path that is specified; effectively, gratuitous detail is ignored.2 Indeed, DATR's approach to default information always implies an infinite number of unwritten DATR statements, with paths of arbitrary length."
      ]
    },
    {
      "heading": "Evans and GazdarLexical Knowledge Representation 3.4 Abbreviatory Variables",
      "text": [
        "The default mechanism of DATR provides for generalization across sets of atoms by means of path extension, and is the preferred mechanism to use in the majority of cases.",
        "However, to transduce atoms in the path domain to atoms in the value domain (see Section 4.3, below), it is extremely convenient to use abbreviatory variables over finite sets of atoms.",
        "This is achieved by declaring DATR variables whose use constitutes a kind of macro: they can always be eliminated by replacing the equations in which they occur with larger sets of equations that spell out each value of the variables.",
        "Conventionally, variable names begin with the $ character and are declared in one of the following three ways: #vars $Varl: Rangel Range2 #vars $Var2: Rangel Range2- RangeA RangeB.",
        "#vars $Var3.",
        "Here, the first case declares a variable $Varl that ranges over the values Rangel , Range2 ..., where each RangeN is either an atom or a variable name; the second case declares $Var2 to range over the same range, but excluding values in RangeA RangeB ...; and the third declares $Var3 to range over the full (finite) set of atoms in the language.21 For example: #vars netters: abcdef ghijklmnoP qrstuvwxy z.",
        "#vars $vowels: aeio u. vars $consonants: $letters - $vowels.",
        "#vars $not_z: $letters - z.",
        "#vars $odd: 1 3 5 7 9. vars $even: 0 2 6 4 8.",
        "#vars $digit: $odd $even.",
        "Caution has to be exercised in the use of DATR variables for two reasons.",
        "One is that their use makes it hard to spot multiple conflicting definitions: #vars $vowel: aeio u. DIPTHONG:",
        "Here, <e> appears on the left hand side of two conflicting definitions.",
        "Exactly what happens to such an improper description in practice depends on the implementation, and usages of this kind can be the source of hard-to-locate bugs (see also Section 5.1, below).",
        "The other reason is that one can fall into the trap of using variables to express generalizations that would be better expressed using the path extension mechanism.",
        "Here is a very blatant example: #vars $number: singular plural.",
        "This approach has the advantage that the attribute ordering used in the <mor > paths is handled internally: the leaf nodes need not know or care about it.'"
      ]
    },
    {
      "heading": "4.2 Boolean Logic",
      "text": [
        "We can, if we wish, use parameters in evaluable paths that resolve to true or false.",
        "We can then define standard truth tables over DATR paths:",
        "Computational LinguisticsVolume 22, Number 2 sg like> into the value ni ta ku penda (Swahili for I will like you):' Si:<subj 1 sg> <subj 2 sg> <subj 3 sg> <subj 1 pl> <subj 2 pl> <subj 3 pl>ni S2:<> u S2:<> a S2:<> tu S2:<>",
        "Although the example is trivial, the technique is both powerful and useful.",
        "Gibbon (1990), for example, has made notably effective use of it in his treatments of African tone systems.'",
        "Much of the computational phonology and morphology of the last decade and a half has depended on FSTs (Kaplan and Kay 1994).",
        "Potential lexical applications come readily to mindfor example, the orthographic spelling rules for English suffixation (such as sky/skies).",
        "We give below a small fragment of such an FST in which + is used as a morpheme boundary marker.",
        "Note the role of DATR variables in giving concise expression to the rules: # vars $abc:abcdefghijklmnopqrstuvwxyz.",
        "# vars $vow: ae io u.",
        "SPELL:",
        "These axioms then give rise to theorems such as these:",
        "Computational LinguisticsVolume 22, Number 2 <syn subcat rest first syn cat> = pp <syn subcat rest first syn pform> = to <syn subcat rest rest> = nil.",
        "Finally, notice that the equation that specifies passive morphology appears on the PASSIVE_VERB node.",
        "This ensures that passive morphology is undefined for verbs not syntactically passive.",
        "The techniques used in this rather simple treatment of passive can be readily adapted for use in encoding other lexical rules and for grammatical frameworks other than that implicit in the PAT Rish syntax we have adopted in our example.",
        "Thus, Evans, Gazdar, and Weir (1995) formulate various lexical rules for LTAG (see note 33).",
        "These techniques can also be readily adapted for use in the semantic domain and used, for example, to implement the distinction between fixed and projective inheritance of lexical semantic information proposed by Pustejovsky (1991, 433-437).",
        "It is advantageous to express lexical rules in the same formal language as is used to express the lexical hierarchy, since lexical rules themselves may well exhibit exactly the kinds of defaulty relations, one to another, that lexical classes do.'",
        "Thus a lexical rule for direct Wh-questions may be a variant of that for indirect Wh-questions: similar, sharing components, but not identical.",
        "With a suitable degree of abstraction, achieved by parameterization of the components, lexical rules can be reified in a language like DATR, allowing one to inherit from another."
      ]
    },
    {
      "heading": "4.6 Representing Ambiguity and Alternation",
      "text": [
        "Computational LinguisticsVolume 22, Number 2 of seven atoms.",
        "It is up to some component external to DATR that makes use of such complex values to interpret it as a two-member set of alternative forms.",
        "Likewise, if we have some good reason for wanting to put together the various senses of cherry into a value returned by a single path, then we can write something like this: Cherry: <sem glosses> == { <sem gloss 1> , <sem gloss 2> , <sem gloss 3> }.",
        "which will then provide this theorem: Cherry: <sem glosses> = { sweet red berry with pip tree bearing sweet red berry with pip wood from tree bearing sweet red berry with pip }.",
        "Also relevant here are the various techniques for reducing lexical disjunction discussed in Pulman (forthcoming)."
      ]
    },
    {
      "heading": "4.7 Encoding DAGs",
      "text": [
        "As a feature-based formalism with a syntax modeled on PATR, it would be reasonable to expect that DATR can be used to describe directed acyclic graphs (DAGs) in a PATR-like fashion.",
        "Consider an example such as the following: DAG1: <vp agr> == <v agr> <v agr per> == 3 <vp agr gen> == masc.",
        "This looks like simple re-entrancy, from which we would expect to be able to infer: DAG1 : <vp agr per> = 3.",
        "And, indeed, this turns out to be valid.",
        "But matters are not as simple as the example makes them appear: if DAG1 was really the DAG it purports to be, then we would also expect to be able to infer: DAG1: <v agr gen> = masc.",
        "This, however, is not valid; in fact, <v agr gen> is undefined.",
        "It might be tempting to conclude from this that the equality operator in DATR is very different from the corresponding operator in PATR, but this would be to misunderstand what has happened in this example.",
        "In fact, the semantics of the statement DAG1: <vp agr> == <v agr>.",
        "taken in isolation is very similar to the semantics of the corresponding PATR statement: both assert equality of values associated with the two paths.",
        "The DATR statement is",
        "Evans and GazdarLexical Knowledge Representation slightly weaker in that it allows the left-hand side to be defined when the right-hand side is undefined, but, even in DATR, if both sides are defined they must be the same, so in principle, the value of the left-hand side does semantically constrain the value of the right-hand side.",
        "However, in a DATR description, specifying explicit values for extensions of the left-hand side of such an equality constraint overrides its effect, and thus does not influence the values on its right-hand side.",
        "Another difference lies in the fact that DATR subpaths and superpaths can have values of their own: DAG2: <v agr> == sing <v agr per> == 3.",
        "From this little description we can derive the following statements, inter alia: DAG2: <v agr> = sing <v agr num> = sing <v agr per> = 3 <v agr per num> = 3.",
        "From the perspective of a standard untyped DAG-encoding language like PATR, this is strange.",
        "In PATR, if <v agr per> has value 3, then neither <v agr> nor <v agr per num> can have (atomic) values.",
        "As these examples clearly show, DATR descriptions do not map trivially into (sets of) standard DAGs (although neither are they entirely dissimilar); but that does not mean that DATR descriptions cannot describe standard DAGs.",
        "Indeed, there are a variety of ways in which this can be done.",
        "An especially simple approach is possible when the DAGs one is interested in are all built out of a set of paths whose identity is known in advance (Kilbury, Naerger, and Renz 1991).",
        "In this case, we can use DATR paths as DAG paths, more or less directly:",
        "We can also derive the following un-DAG-like consequences, of course: She2:",
        "<referent referent referent> = < NP referent >.",
        "But these nonsensical theorems will be of no concern to a DAT R-invoking NLP system that is able to specify in advance which paths are of interest for DAG-construction and to ignore all the rest.\" A more sophisticated approach uses DATR itself to construct a DAG description (in the notation of your choice) as a value:4'",
        "Evans and GazdarLexical Knowledge Representation"
      ]
    },
    {
      "heading": "5. Technical Issues",
      "text": [
        "In this section we briefly discuss a number of technical issues, relating both to DATR as a formal language, and also to practical aspects of DAT R in use."
      ]
    },
    {
      "heading": "5.1 Functionality",
      "text": [
        "Most DATR descriptions consist only of definitional statements, and include at most one statement for each node/path pair.",
        "In this section we examine the significance of this observation from a formal perspective.",
        "As noted in Section 2, DATR nodes can be thought of semantically as denoting partial functions from paths (sequences of atoms) to values (sequences of atoms).'",
        "Generalizing this view in the obvious way, whole DAT R descriptions can be thought of as denoting functions from nodes to (partial) functions from paths to values.",
        "This semantic notion induces a notion of consistency for DAT R descriptions: we say that a DATR description is consistent if and only if it has a coherent interpretation as a function; that is, if the extensional sentences defined (explicitly or implicitly) for each node constitute a (partial) function from paths to values.",
        "The syntax of DAT R does not itself prevent one from writing down inconsistent descriptions: VERB: <syn cat> == verb <syn cat> == noun.",
        "However, such descriptions are of no utility and it would be desirable to find a mechanical way of eliminating them.",
        "In pursuit of this, we can define a syntactic notion of functionality over DATR descriptions as follows: A DAT R description is functional if and only if (i) it contains only definitional statements and (ii) those statements constitute a (partial) function from node/path pairs to descriptor sequences.",
        "The significance of this syntactic notion arises from the following property:44 Every functional DATR description is consistent.",
        "To understand why this is, note first that the default extension process preserves functionality since it only adds definitional statements about new node/path pairs not already present in the original description.",
        "Local inheritance derives new statements associated with a node/path pair, but at most one of these defines a value or global inheritance descriptor (since local inheritance ceases at that point).",
        "Thus although the local inheritance makes the description become syntactically nonfunctional, the specification of values or global descriptors remains functional.",
        "The value specifications map directly to extensional statements, while the global inheritance descriptors operate just as the local ones, adding at most one further value statement for each global 43 We continue to oversimplify matters here.",
        "As Keller (1995) points out, the meaning of a node depends on the global context, and a node thus really denotes a function from global contexts to partial functions from paths to values.",
        "Though important, this point is tangential to the issue addressed here.",
        "44 For simplicity here, we consider only the case of descriptor sequences of length onethe general case involves complications not relevant to the main point.",
        "Computational LinguisticsVolume 22, Number 2 inheritance statement, so that ultimately the consistency of the set of (extensional) value statements is assured.",
        "This theorem cannot be strengthened to a biconditional, however, since consistent but nonfunctional DAT R descriptions exist, as in the following examples:",
        "In NONFUNC1, UNDEF is a node with no associated definitions, so the first statement imposes no constraint on the value of <a>; in NONFUNC2, two definitions for <a> are provided, which happen to define the same value; in NONFUNC3, we establish a mutual dependence between <a> and <b>, and then define a value for one (either) of them.",
        "However, we have not encountered any examples of nonfunctional but consistent descriptions that are not better expressed by a straightforward functional counterpart.'",
        "Indeed, we suspect (but have no proof) that every consistent DATR description is extensionally equivalent to (that is, defines the same extensional sentences as) a functional one.",
        "In the light of these considerations, we assume here, and elsewhere, that functionality is a reasonable restriction to place on DAT R descriptions.\" The advantage of this is that to check the functionality of a DATR description, and hence guarantee its consistency, is completely trivial.",
        "In other words, we can substitute a straightforward syntactic constraint on descriptions for the less tractable notion of semantic consistency, apparently without significant loss of expressive power.",
        "Among other things, this means that implementations of DAT R can either treat apparent violations of functionality as syntactic errors and require the user to eliminate them, or (more commonly in existing implementations) treat them as intentional corrections and silently erase earlier statements for the node and path for which a violation has been detected."
      ]
    },
    {
      "heading": "5.2 Multiple Inheritance",
      "text": [
        "Evans and GazdarLexical Knowledge Representation inheritance is an issue central to the design of any formalism for representing inheritance networks.",
        "For the formalism to be coherent, it must provide a way of avoiding or resolving any conflict that might arise.",
        "This might be by banning multiple inheritance altogether, restricting it so that conflicts are avoided, providing some mechanism for conflict resolution as part of the formalism itself, or providing the user of the formalism with the means to specify how the conflict should be resolved.",
        "Putting aside considerations of functionality for the moment, we see that, in DATR, both the second and third of these options are employed.",
        "The \"longest-defined-subpath-wins\" principle amounts to conflict resolution built into the formalism; however, it does not deal with every case.",
        "Definitions such as:",
        "may result in unresolvable conflicts.",
        "Such conflicts could, of course, just be ruled out by appealing to their inconsistency, which, following a logical tradition, is grounds for ruling the description to be \"improper.\" Touretzky (1986, 70ff) provides a formal description of a number of properties that an inheritance network may have, and discusses their significance with respect to the problem of multiple inheritance.",
        "Tree-structured networks, as their name suggests, allow any node to inherit from at most one other node, so multiple inheritance conflicts cannot arise.",
        "Orthogonal networks allow a node to inherit from more than one other node, but the properties it inherits from each must be disjoint, so that again, no conflict can possibly arise.",
        "The basic descriptive features of DATR allow the specification of simple orthogonal networks similar to Touretzky's.",
        "For example, if we write: A: <a> == true.",
        "<b> == false.",
        "B: C:<a> == A <b> == B. then we are specifying a network of three nodes (A B, and C), and two \"predicates\" (Boolean-valued attributes coded as DAT R paths <a> and <6>), with C inheriting a value for <a> from A, and for <b> from B.",
        "The network is orthogonal, since <a> and <b> represent distinct (sets of) predicates.",
        "Orthogonal multiple inheritance (OMI) is a desirable property of lexical representation systems.",
        "Consider an analysis in which we put the common properties of verbs at a VERB node and the (disjoint) common properties of words that take noun phrase complements at an NP_ARG node.",
        "A transitive verb (TR_VERB) is both a verb and a word that takes an NP complement, thus it should inherit from both VERB and NP_ARG in this analysis.",
        "In DATR, this might be expressed as follows:",
        "Here TR_VERB inherits from both VERB and NP_ARG but the path prefixes cat and arg ensure that the inheritance is orthogonal and that no conflict (e.g., in respect of < cat> values) can arise.",
        "More generally, OMI is invaluable for partitioning the various different, and largely independent, aspects of lexical description conventionally associated with such initial path prefixes as phn (phonology), mor (morphology), syn (syntax), and sem (semantics).",
        "In the English verbal system, for example, most morphological subregularities (such as having a past participle form in -en) operate entirely independently of most syntactic subregularities (such as having a ditransitive subcategorization frame).",
        "Within the semantic domain, Pustejovsky and Boguraev (1993, 214) introduce the expression typed inheritance for OMI and argue for its advantages in connection with the consistent assembly of the different facets of meaning associated with a lexical item.",
        "The above examples of OMI are in fact instances of a more general phenomenon in DATR.",
        "We have already noted that the combination of the longest-defined-subpathwins and logical consistency are the basis of DATR's support for coherent multiple inheritance.",
        "It turns out that functionality (which of course implies consistency) ensures orthogonality so that OMI falls out as the most normal, natural mode of definition using DAT R. Finally, we note that a number of recent lexical theories have invoked a form of inheritance in which multiple parents with overlapping domains are specified, and a priority ordering imposed to resolve potential inheritance conflicts (e.g., Flickinger 1987; Russell et al.",
        "1992).",
        "In this prioritized multiple inheritance (PMI), precedence is given to nodes that come earlier in the ordering, so that the inherited value for a property comes from the first parent node in the ordering that defines that property, regardless of whether other later nodes also define it (possibly differently).",
        "Surprisingly perhaps, DATR's version of OMI can be used to reconstruct PMI without making syntactic and semantic additions to the language.",
        "In fact, we have described elsewhere no fewer than three different techniques for capturing PMI in DATR (Evans, Gazdar, and Moser 1993).",
        "But DATR was primarily designed to facilitate OMI analyses of natural language lexicons and we do not believe that PMI treatments of the lexicon offer significant analytical or descriptive advantages."
      ]
    },
    {
      "heading": "5.3 Modes of Use",
      "text": [
        "Lexicons can either be developed by hand or, in principle at least, they can be induced from relevant data.",
        "Once created, lexicons are used for language understanding, language generation, or both.",
        "Lexicons that are in use also have to be maintained.",
        "At present, implementations of lexical representation systems are typically specialized to one or two of these tasks.",
        "A language for lexical knowledge representation is merely one component of a lexical representation system, of course, but its design may well have implications for the tasks noted above.",
        "A language that coded everything into bit strings might be fully adequate for, say, the induction and generation tasks, but would probably not facilitate manual lexicon maintenance.",
        "From a more formal point of view, Barg (1994) provides the useful tabular conceptualization shown in Table 2, below, of the inferential tasks that may be associated with a lexical representation language like DATR.",
        "Consider the English verbal morphology",
        "facts that provided our running example in Section 2, above.",
        "The conventional inference task presupposes that we have a description (such as that given in that section) and a query (such as Love: <mor past part ic iple>): the task is to infer the appropriate value for this query, namely love ed.",
        "This task is crucial to lexicon development and maintenance, since it provides lexicon developers with the means to check the empirical adequacy of their analyses.",
        "It is also a task that is likely to figure in the on-line use of the lexicon in a language-processing system, once the relevant lexical entry (i.e., the relevant DATR node) has been determined, to recover information associated with the entry, and it is the task that does the compilation in systems that use a partially or fully compiled-out off-line lexicon (as in Andry et al.",
        "1992).",
        "The reverse query task again presupposes that we have a description available to us, but instead of starting with a known query, we start instead with a known value love ed, say, and the task is to infer what queries would lead to that value (Love: <mor past participle>, Love: <mor past tense sing one>, etc.",
        ").47 The ability to perform this kind of inference may also be useful in lexicon development and maintenance.",
        "However, its most obvious application is to \"bootstrap\" lexical access in language-processing systems that make direct use of an on-line lexicon: given a surface form (in analysis) or a semantic form (in generation), we need to identify a lexical entry associated with that form by reverse query, and then access other lexical information associated with the entry by conventional inference.",
        "Langer (1994) gives an inference algorithm, based on the familiar chart data structure, for reverse querying DATR lexicons; and Gibbon (1993) describes EDQL (Extended DATR Query Language) which permits quantification into components of multisentence DATR queries.",
        "The final task is that of theory induction.",
        "Here one starts with a set of known query-value pairs (Love: <mor past participle> = love ed., Love: <mor pres tense sing three> = love s., etc.)",
        "and the task is to induce a description that has those pairs as theorems under the application of conventional inference.",
        "In a world in which all the relevant data was already clearly set out in descriptive linguistic work, an algorithm that efficiently achieved this kind of induction would be the philosopher's stone to the construction of computational lexicons.",
        "In the real world, such an algorithm would still be useful for domains like morphology (where the quality and clarity of extant descriptive linguistic work is very high), for bootstrapping lexical descriptions for subsequent manual development by humans, for updating lexicons in the light of newly encountered lexical information, and for converting one kind of lexicon into a completely different kind of lexicon by inducing the latter from the output of the former.",
        "The automatic induction of (symbolic) lexicons from data is a very new research area in computational linguistics: Kilbury (1993), Kilbury, Naerger, and Renz (1994), Light (1994), and Light, Reinhard, and Boyle-Hinrichs (1993) have proposed a variety of incremental algorithms that take a partial lexical hierarchy and 47 An alternative formulation is to start with a known value and path, and the task is to infer the appropriate nodes.",
        "Computational LinguisticsVolume 22, Number 2 elaborate it as necessary in the light of successively presented data sets, while Barg (1994) has presented a non-incremental algorithm that induces full DATR hierarchies from suitable data sets.",
        "Since DATR is no more than a language, it does not itself dictate how a DATR lexicon is to be used.",
        "As it turns out, different researchers have used it very differently.",
        "Andry et al.",
        "(1992), in the context of a speech recognition task involving the parsing of \"extremely large lattices of lexical hypotheses\" (p. 248), opted for off-line compilation of their 2,000 word DATR lexicons into pairs of on-line lexicons, one of which was encoded with bit-vectors for speed and compactness.",
        "At the other extreme, Duda and Gebhardi (1994) present an interface between a PATR-based parser and a DATR lexicon where the former is dynamically linked to the latter and able to query it freely, in both conventional and reverse modes, without restriction.",
        "Gibbon (1993) presents an implementation of a very flexible query language, EDQL, which allows quantification over any constituents of (possibly complex) DATR queries."
      ]
    },
    {
      "heading": "5.4 Implementations",
      "text": [
        "As already noted, the inferential core of DATR is extremely simple to implement.",
        "We know of the existence of approximately a dozen different implementations of the language but there may well be others that we do not know of.",
        "The best known, and most widely available are our own (Brighton/Sussex), which is written in Prolog and runs on most Unix platforms, Gibbon's (Bielefeld) DDATR Scheme and NODE Sicstus Prolog implementations, and Kilbury's (Duesseldorf) QDATR Prolog implementation, which runs (in compiled form) on PCs and on Sicstus Prolog under Unix.",
        "All of these are freely available on request, as is an extensive archive of over one hundred example fragments, some of which illustrate formal techniques and others of which are applications of DATR to the lexical phonology, morphology, syntax, or semantics of a wide variety of different languages.'",
        "Other interesting implementations that we are familiar with include the experimental reverse query implementation by Langer (Osnabrueck), Duda and Gebhardi's (Berlin) implementation that is dynamically linked to PATR, and Barg's (Duesseldorf) implementation of a system that induces DATR descriptions from extensional data sets."
      ]
    },
    {
      "heading": "6. Concluding Remarks",
      "text": [
        "Our title for this paper is to be taken literallyDATR is a language for lexical knowledge representation.",
        "It is a kind of programming language, not a theoretical framework for the lexicon (in the way that, say, H PSG is a theoretical framework for syntax).",
        "Clearly, the language is well suited to lexical frameworks that embrace, or are consistent with, nonmonotonicity and inheritance of properties through networks of nodes.",
        "But those two dispositions hardly constitute a restrictive notion of suitability in the context of contemporary NLP work, nor are they absolute requirements: it is, for example, entirely possible to write useful DATR fragments that never override inherited values (and so are monotonic) or that define isolated nodes with no inheritance.",
        "It is true, of course, that our examples, in this paper and elsewhere, reflect a particular set of assumptions about how NLP lexicons can be best organized.",
        "But, apart from the utility of inheritance and nonmonotonicity, we have been careful not 48 Anonymous FTP to ftp.cogs.sussex.ac.uk and directory /pub/nlp/DATR provides access to various DATR implementations, the example archive, and some relevant papers and documentation.",
        "Evans and GazdarLexical Knowledge Representation to build those assumptions into the DATR language itself.",
        "There is, for example, no built-in assumption that lexicons should be lexeme-based rather than, say, word or morpheme-based.",
        "Unlike some other NLP inheritance languages, DATR is not intended to provide the facilities of a particular syntactic formalism.",
        "Rather, it is intended to be a lexical formalism that can be used with any syntactic representation that can be encoded in terms of attributes and values.",
        "Thus, at the time of writing, we know of nontrivial DATR lexicons written for G PSG, LTAG, PATR, Unification Categorial Grammar, and Word Grammar.",
        "Equally, the use of DATR does not commit one, in advance, to adopting any particular set of theoretical assumptions with respect to phonology, morphology, or semantics.",
        "In phonology, for example, the language allows one to write transducers that map strings of atomic phonemes to strings of atomic phones.",
        "But it also allows one to encode full-blown feature and syllable-tree-based prosodic analyses.",
        "Unlike the formalisms typically proposed by linguists, DATR does not attempt to embody in its design any substantive and restrictive universal claims about the lexicons of natural language.",
        "That does not distinguish it from most NLP formalisms, of course.",
        "However, we have also sought to ensure that its design does not embody features that would restrict its use to a single language (English, say) or to a particular class of closely related languages (the Romance class, say).",
        "The available evidence suggests that we have succeeded in the latter aim since, at the time of writing, nontrivial DATR fragments of the lexicons of Arabic, Arapesh, Czech, English, French, German, Gikuyu, Italian, Latin, Polish, Portuguese, Russian, and Spanish have been developed.",
        "There are also smaller indicative fragments for Baoule, Dakota, Dan, Dutch, Japanese, Nyanja, Sanskrit, Serbo-Croat, Swahili, and Tem.",
        "Unlike most other languages proposed for lexical knowledge representation, DATR is not intended to be restricted in the levels of linguistic description to which it can sensibly be applied.",
        "It is designed to be equally applicable at phonological, orthographic, morphological, syntactic, and semantic levels of description; but it is not intended to replace existing approaches to those levels.",
        "Rather, we envisage descriptions of different levels according to different theoretical frameworks being implementable in DATR: thus an NLP group might decide, for example, to build a lexicon with DRT-style semantic representations, H PSG-style syntactic representations, \"item & arrangement\"- style morphological representations and a KIMMO-style orthographic component, implementing all of these, including the H PSG lexical rules, in DATR.",
        "DATR itself does not mandate any of the choices in this example, but equally, nor does it allow such choices to be avoided.'",
        "DATR cannot be (sensibly) used without a prior decision as to the theoretical frameworks in which the description is to be conducted: there is no \"default\" framework for describing morphological facts in DATR.",
        "Thus, for example, Gibbon (1992) and Langer and Gibbon (1992) use DATR to implement their ILEX theory of lexical organization, Corbett and Fraser (1993) and Fraser and Corbett (in press) use DATR to implement their Network Morphology framework, and Gazdar (1992) shows how Paradigm Function Morphology analyses (Stump 1992) can be mapped into DATR.",
        "Indeed, it would not be entirely misleading to think of DATR as a kind of assembly language for constructing (or reconstructing) higher-level theories of lexical representation.",
        "49 However, DATR's framework-agnosticism may make it a plausible candidate for the construction of polytheoretic lexicons.",
        "For example, one that would allow either categorial or HPSG-style subcategorization specifications to be derived, depending on the setting of a parameter.",
        "Evans and GazdarLexical Knowledge Representation Finally, Domenig and ten Hacken contend that lexical inheritance formalisms (and thus DATR) are unusable for the purpose for which they were designed because the humans who have to work with them for lexicon development cannot keep track of all the interactions.",
        "They provide no evidence for this assertion and the widespread adoption, development, and use of a variety of large inheritance lexicons in working NLP systems over the last few years make the assertion seem somewhat implausible.",
        "They conclude that their evaluation of DATR has been \"unfair\" (p. 29) because they failed to consider the language in its natural environment.",
        "We agree that their evaluation is unfair, but ascribe the cause to the ways in which they attempted to apply DATR to their chosen tasks.'",
        "Daelemans and van der Linden (1992) review a number of approaches to lexical knowledge representation, including DATR, with respect to their notational adequacy and expressivity.",
        "They argue that adequate approaches will allow (i) recursive path formation; (ii) multiple inheritance, preferably orthogonal multiple inheritance; (iii) nonmonotonic inheritance; and require (iv) that irregular items take precedence over regular ones without explicit coding (p. 61).",
        "Since, as we have seen, and as Langer and Gibbon (1992) note, DATR has all four of these properties, one might expect it to emerge from their review with at least a low alpha gradebut in fact they find fault with it on a number of grounds.",
        "The first of these is the use of double quotes to mark global inheritance in the concrete syntax of DATR.",
        "They claim that global inheritance is the normal kind of inheritance in DATR and should thus not be marked in any special way, while (unquoted) local inheritance is exceptional and should therefore have a special notation (like quotes) associated with it (p. 63).52 The small example they give lends some plausibility to their claim.",
        "However, the claim is nonetheless misleading.",
        "Quoted paths (the only instances of global inheritance to be found in their example fragment) are indeed ubiquitous at the highest nodes of existing DATR fragments, but unquoted nodes, unquoted paths, and unquoted node/path pairs all also occur very frequently in existing DATR fragments, while quoted nodes and quoted node/path pairs are hardly found at all.",
        "In some common applications of DATR, such as FSTs, no use at all may be made of global inheritance.",
        "Their second objection is to the way path extension in DATR permits the derivation of theorems that have no interpretation in the domain being modeled (p. 63).",
        "Thus, for example, a description that had (a) as a (sensible) theorem might also have (b) as one of an infinity of (silly) theorems: (a)Parrot : <mor plur> = parrot s. (b)Parrot:<mor plur past perfect> = parrot s. The issue here is that while DATR encourages abstraction away from the most specific level of detail wherever possible, it does not itself provide a built-in mechanism for stating what that most specific level is.",
        "Our position is that this is part of the lexical metatheory, rather than the lexical description itself.",
        "It needs to be known by anyone (or any system) wishing to access the lexicon properly, and it may be practically useful to constrain access by checking for the well-formedness of queries according to such a metatheorythis could be done quite straightforwardly in DATR as an adjunct to the main lexicon if desired.",
        "This notion, however, is external to, and independent of, 51 For another critical discussion of the same Domenig and ten Hacken material, see Russell (1993).",
        "52 One of our referees comments that \"the issue ... appears to be rather scholastic.\" We agree.",
        "Computational LinguisticsVolume 22, Number 2 the lexical description itself: the range of sensible queries only weakly constrains the manner in which their values are defined.",
        "Their third objection concerns multiple inheritance.",
        "They draw attention to the fact that DATR's normal mode of multiple inheritance is orthogonal and complain that prioritized multiple inheritance can only be expressed with additional DATR code (p. 63).",
        "However, we agree with their earlier comment \"that orthogonal multiple default inheritance is at this stage the best solution for conflicts\" (p. 61) and can see no computational linguistic motivation for equipping DATR with a further primitive inheritance mechanism.\" Their fourth objection consists of the claim that \"it is not possible in DATR to have complex structured objects as values\" (p. 64).",
        "In one sense this is true, since DATR values are simply sequences of atoms.",
        "But although true, it does not provide support for a sound objection.",
        "DATR can construct those sequences of atoms on the basis of a complex recursive description, and the atom sequences themselves can represent complex recursive objects so far as NLP system components outside the lexicon are concerned.",
        "The sequences of atoms that DATR provides as values constitute an interface for the lexicon that is entirely neutral with respect to the representational requirements of external components.",
        "For what is intended to be a general-purpose lexical knowledge representation language, not tied to any particular conceptions of linguistic structure or NLP formalism, this neutrality seems to us to be a feature, not a bug.",
        "In a fifth objection, they note correctly that the semantics of paths in DATR and PATR is different but then go on to claim that DATR paths \"could be better described as atomic attributes\" that \"do not correspond with a recursive structure\" and whose \"only function is to support prefix matching\" (p. 64).",
        "None of these latter claims are true.",
        "If DATR paths were atomic attributes then our Section 4.3, on finite-state transducers, could not have been written; DATR paths are the same as PATR paths as far as recursive structure is concerned; and, as we have seen throughout this paper, DATR paths have many functions in addition to prefix matching.",
        "In a final set of comments, they briefly raise various issues connected with the integration of DATR lexicons with unification-based grammar (p. 64).",
        "We have dealt with these issues in earlier parts of the present paper and will not rehearse them here.'",
        "Krieger and Nerbonne (1993) claim that \"the basic insight of DATR\" lies in its use in characterizing \"the inflectional variants of a lexeme as alternative (disjunctive) realisations\" (p. 135).",
        "This claim confuses the basic insight of a very traditional approach to inflectional morphology with the application of DATR in implementing that approach.",
        "Elsewhere they note that \"the fundamental idea in our characterisation is due to the work in DATR, in which paradigms are treated as alternative further specifications of abstract lexemes\" (p. 104).",
        "Unfortunately, their own implementation of this fundamental idea turns out to be significantly less satisfactory than that provided in the DATR analysis to which they refer.",
        "In order to reconstruct paradigms in their feature language, they invoke distributed disjunctions (fixed-length term expressions).\" The descriptive problem with this approach, as they admit, is that \"there is no way to note that a single form in a paradigm is exceptional without respecifying the entire paradigmthe disjunction must be respecified as a whole ... there is no way to",
        "Evans and GazdarLexical Knowledge Representation identify a particular alternation within the distributed disjunction\" (p. 107).",
        "Anyone familiar with the way inflection works in Romance languages will immediately see that this is a very serious weakness.",
        "In Latin, for example, there are many individual words and small subclasses of words that deviate from a major declension or conjugation in just one or two parts of the paradigm.",
        "Under Krieger and Nerbonne's approach every such case will require one to \"respecify the entire paradigmatic disjunction\" (p. 107).",
        "This is exactly the kind of redundancy that the introduction of defaults is meant to eliminate.56 At the root of Krieger and Nerbonne's (1993) critique of DAT R is a complaint that it fails to provide all the resources of a modern, fully equipped unification grammar formalism (p. 90-91).",
        "From our perspective, this is a bit like criticizing STANDARD ML on the grounds that it lacks the functionality provided in ADA.",
        "Thus, for example, they complain that disjunction is missing from DATR and that nobody seems to be trying to add it to the language (p. 110).",
        "They cite their own \"extensive employment of [distributed] disjunction\" (p. 110) as evidence for its utility in lexical description, apparently forgetting that their use of distributed disjunction to describe inflection was motivated by a desire to reconstruct a treatment of inflection that they had seen implemented in DAT R. They provide no motivation for adding distributed disjunction to DAT R's (rather small) list of available descriptive resources because that list of resources already allows better analyses of the phenomena they discuss than does their version of distributed disjunction, as noted above.",
        "They also object to the fact that use of a DATR lexicon will require an \"interface\" (p. 110) between the lexicon and a feature-based parser.",
        "But, as we have seen in Section 4.7, above, such an interface will normally be trivial and required in any case (since Krieger and Nerbonne's parser must be able to access and read files that contain text descriptions of feature structures).",
        "As it is, they seem happy to countenance an interface to a separate two-level morphophonemic processor (p. 103, n. 9) whereas, in DAT R, the morphophonemics can be done entirely in the lexicon if one wishes.",
        "From remarks they make on pages 109 and 111 of their paper, Krieger and Nerbonne appear to believe that it is impossible to implement a particular inflectional analysis of the passive in Latin in DAT R. They do not provide much of an argument, but what they do say suggests that the simple treatment of passive given in Section 4.5, above, is likewise impossible.",
        "This may be because they regard their own interpretation of lexical rules as \"novel\" (p. 113), although examples of that interpretation of lexical rules appear in earlier DATR work that they cite.",
        "Many of the points made in Nerbonne (1992) are repeated from the more accessible Krieger and Nerbonne (1993)57 and we have considered them in our discussion of the latter.",
        "Some of the points from the 1992 and 1993 papers resurface in Bouma and Nerbonne (1994).",
        "Nerbonne appears to misconstrue Evans, Gazdar, and Moser (1993) as an attempt to augment DAT R with re-entrancy and goes on to suggest that DAT R is somehow forced to maintain that \"all linguistic generalizations tend to follow the lines of morphological form\" (p. 47) when, in fact, the attribute ordering used in a DAT R treatment of morphology is entirely independent of the use and ordering of those same attributes elsewhere in the lexicon (see the discussion at the end of Section 4.1, above).",
        "Like Daelemans and van der Linden (1992), he makes some pessimistic comments",
        "<n from v root> = institute + tion <a from n from v root> = institute + tion + al <v from a from n from v root> = institute + tion + al + ize <n from v from a from n from v root> = institute + tion + al + ize + tion.",
        "Note the recursive reintroduction of the tion suffix in the last theorem shown.",
        "58 Sacks (1973) makes interesting reading in this connection."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "We are grateful to the four Computational Linguistics referees for their criticisms and suggestions; to Lynne Cahill, Dafydd Gibbon, Jim Kilbury and David Weir for their comments on an earlier draft of the paper; and to Walter Daelemans and John Nerbonne for their comments on the first draft of the appendix.",
        "We thank Petra Barg, Lynne Cahill, Norman Fraser, Dafydd Gibbon, Elizabeth Jenkins, Jim Kilbury, Lionel Moser, and Ingrid Renz for their role(s) in the development of the DATR language and the coding techniques discussed above; Fernando Pereira for early critical comments that led directly to the introduction of evaluable paths into the language; and Bill Keller and David Weir for much relevant recent interaction.",
        "This research was supported by various grants to the authors from ESRC (UK) and SERC/EPSRC (UK)."
      ]
    }
  ]
}
