{
  "info": {
    "authors": [
      "Noriko Tomuro"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P96-1058",
    "title": "Maximizing Top-Down Constraints for Unification-Based Systems",
    "url": "https://aclweb.org/anthology/P96-1058",
    "year": 1996
  },
  "references": [
    "acl-J89-4001",
    "acl-P85-1018",
    "acl-P94-1040"
  ],
  "sections": [
    {
      "text": [
        "Chicago, IL 60604 cphdnt Oted.",
        "cs.",
        "depaul.edu"
      ]
    },
    {
      "heading": "Abstract",
      "text": [
        "A left-corner parsing algorithm with top-down filtering has been reported to show very efficient performance for unification-based systems.",
        "However, due to the non-termination of parsing with left-recursive grammars, top-down constraints must be weakened.",
        "In this paper, a general method of maximizing top-down constraints is proposed.",
        "The method provides a procedure to dynamically compute *restrictor*, a minimum set of features involved in an infinite loop for every propagation path; thus top-down constraints are maximally propagated."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "A left-corner parsing algorithm with top-down filtering has been reported to show very efficient performance for unification-based systems (Carroll, 1994).",
        "In particular, top-down filtering seems to be very effective in increasing parse efficiency (Shann, 1991).",
        "Ideally all top-down expectation should be propagated down to the input word so that unsuccessful rule applications are pruned at the earliest time.",
        "However, in the context of unification-based parsing, left-recursive grammars have the formal power of a Turing machine, therefore detection of all infinite loops due to left-recursion is impossible (Shieber, 1992).",
        "So, top-down constraints must be weakened in order for parsing to be guaranteed to terminate.",
        "In order to solve the nontermination problem, Shieber (1985) proposes restrictor, a statically predefined set of features to consider in propagation, and restriction, a filtering function which removes the features not in restrictor from top-down expectation.",
        "However, not only does this approach fail to provide a method to automatically generate the restrictor set, it may weaken the predicative power of top-down expectation more than necessary: a globally defined restrictor can only specify the least common features for all propagation paths.",
        "In this paper, a general method of maximizing top-down constraints is proposed.",
        "The method provides a procedure to dynamically compute *restrictor*, a minimum set of features involved in an infinite loop, for every propagation path.",
        "Features in this set are selected by the detection function, and will be ignored in top-down propagation.",
        "Using *restrictor*, only the relevant features particular to the propagation path are ignored, thus top-down constraints are maximally propagated."
      ]
    },
    {
      "heading": "2 Notation",
      "text": [
        "We use notation from the PATR-II formalism (Shieber, 1986) and (Shieber, 1992).",
        "Directed acyclic graphs (dags) are adopted as the representation model.",
        "The symbol = is used to represent the equality relation in the unification equations, and the symbol • used in the form of pl • p2 represents the path concatenation of pl and p2.",
        "The subsumption relation is defined as \"Dag D subsumes dag D' if D is more general than D' .\"",
        "The unification of D and D' is notated by D U D' .",
        "The extraction function D/p1 extracts the subdag under path pl for a given D, and the embedding function D\\ pl injects D into the enclosing dag D' such that D'/pl = D. The filtering function p is similar to (Shieber, 1992): p(D) returns a copy of D in which some features may be removed.",
        "Note that in this paper *restrictor* specifies the features to be removed by p, whereas in (Shieber, 1985, 1992) restrictor specifies the features to be retained by restriction which is equivalent to p."
      ]
    },
    {
      "heading": "3 Top-down Propagation",
      "text": [
        "Top-down propagation can be precomputed to form a reachability table.",
        "Each entry in the table is a compiled dag which represents the relation between a non-terminal category and a rule used to rewrite the constituents in the reachability relation (i.e., reflexive, transitive closure of the left-corner path).",
        "For example, consider the following fragment of a grammar used in the syntax/semantics integrated system called LINK (Lytinen, 1992):",
        "The dag D(1) in Figure l' represents the initial application of rl to the category NP.",
        "Note that the subdag under the lc arc is the rule used to rewrite the constituent on the left-corner path, and the paths from the top node represent which top-down constraints are propagated to the lower level.",
        "Top-down propagation works as follows: given a dag D that represents a reachability relation and a rule dag R whose left-hand side category (i.e., root) is the same as D's left-corner category (i.e., under its (lc 1) path), the resulting dag is D1 = p(D') U (R\\ lc), where D' is a copy of D in which all the numbered arcs and lc arc are deleted and the subdag which used to be under the (lc 1) path is promoted to lie under the lc arc.",
        "Dags after the next two recursive applications of rl (D(2) and D(3) respectively2) are shown in Figure 1.",
        "Notice the filtering function p is applied only to D'.",
        "In the case when p(D1) = nil, the top node in D1 will have no connections to the rule dag under the lc arc.",
        "This means no top-down constraints are propagated to the lower level, therefore the parsing becomes pure bottom-up.",
        "In many unification-based systems, subsumption is used to avoid redundancy: a dag is recorded in the table if it is not subsumed by any other one.",
        "Therefore, if a newly created dag is incompatible or more general than existing dags, rule application continues.",
        "In the above example, D(2) is incompatible with D(1) and therefore gets entered into the table.",
        "The owner arc keeps extending in the subsequent recursive applications (as in D(3)), thus the propagation goes into an infinite loop."
      ]
    },
    {
      "heading": "3.1 Proposed Method",
      "text": [
        "Let A be a dag created by the first application of the rule R and B be a dag created by the second application during the top-down propagation.3 In the proposed method, A and B are first checked for subsumption.",
        "If B is subsumed by A, the propagation for this path terminates.",
        "Otherwise a possible loop is detected.",
        "The detection function (described in the next subsection) is called on A and B and selected features are added to the *restrictor* set.",
        "Then, using the updated *restrictor*, propagation is redone from A.",
        "When R is applied again yielding B', while B' is not subsumed by A, the following process is repeated: if B' is incompatible with A, the detection function is called on A and B' and propagation is redone from A.",
        "If B' is more general than A, then A is replaced by B' (thereby keeping the most general dag for the path) and propagation is redone from B'.",
        "Otherwise the process stops for this propagation path.",
        "Thus, the propagation will terminate when enough features are detected, or when *restrictor* includes all the (finite number of) features in the grammar.5 In the example, when the detection function is called on D(1) and D(2) after the first recursive application, the feature owner is selected and added to *restrictor*.",
        "After the propagation is redone from D(1), the resulting dag D(4) becomes more general than D(1).6 Then D(1) is replaced by D(4), and the propagation is redone once again.",
        "This time it results the same D(4), therefore the propagation",
        "terminates."
      ]
    },
    {
      "heading": "3.2 Detection Function",
      "text": [
        "The detection function compares two dags X and Y by checking every constraint (unification equation) x in X with any inconsistent or more general constraint y in Y.",
        "If such a constraint is found, the function selects a path in x or y and detects its last arc/feature as being involved in the possible loop.7 If x is the path constraint pl p2 where pl and p2 are paths of length > 1, features may be detected in the following cases:8",
        "• (case 1) If both pl and p2 exist in Y, and there exists a more general constraint y in Y in the form pl p3 p2 •p3 (length of p3 is also > 1), the path p3 is selected; • (case 2) If both pl and p2 exist in Y, but the subdag under pl and the subdag under p2 do not unify, or if neither pl nor p2 exists in Y, whichever of pl or p2 does not contain the lc arc, or either if they both contain the lc arc, is selected; and • (case 3) If either pl or p2 does not exist in Y, the one which does not exist in Y is selected.",
        "If x is the constant constraint pl c (where c is some constant), features may be detected in the following cases: • (case 4) If there exists an incompatible constraint y of the form pl d where d c in Y, or if there is no path pl in Y, pl is selected; and • (case 5) If there exists an incompatible constraint y of the form pl • p2 c, then p2 is selected."
      ]
    },
    {
      "heading": "4 Related Work",
      "text": [
        "A similar solution to the nontermination problem with unification grammars in Prolog is proposed in (Samuelsson, 1993).",
        "In this method, an operation called anti-unification (often referred to as generalization as the counterpart of unification) is applied to the root and leaf terms of a cyclic propagation, and the resulting term is stored in the reachablity table as the result of applying restriction on both terms.",
        "Another approach taken in (Haas, 1989) eliminates the cyclic propagation by replacing the features in the root and leaf terms with new variables.",
        "The method proposed in this paper is more general than the above approaches: if the selection ordering is imposed in the detection function, features in *restrictor* can be collected incrementally as the cyclic propagations are repeated.",
        "Thus, this method 'This scheme may be rather conservative.",
        "'Note the cases in this section do not represent all possible situations.",
        "is able to create a less restrictive *restrictor* than these other approaches."
      ]
    },
    {
      "heading": "5 Discussion and Future Work",
      "text": [
        "The proposed method has an obvious difficulty: the complexity caused by the repeated propagations could become overwhelming for some grammars.",
        "However, in the experiment on LINK system using a fairly broad grammar (over 130 rules), precompilation terminated with only a marginally longer processing time.",
        "In the experiment, all features (around 40 syntactic/semantic features) except for one in the example in this paper were able to be used in propagation.",
        "In the preliminary analysis, the number of edges entered into the chart has decreased by 30% compared to when only the category feature (i.e., context-free backbone) was used in propagation.",
        "For future work, we intend to apply the proposed method to other grammars.",
        "By doing the empirical analysis of precompilation and parse efficiency for different grammars, we will be able to conclude the practical applicability of the proposed method.",
        "We also indend to do more exhaustive case analysis and investigate the selection ordering of the detection function.",
        "Although the current definition covers most cases, it is by no means complete."
      ]
    }
  ]
}
