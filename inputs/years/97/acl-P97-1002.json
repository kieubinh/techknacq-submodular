{
  "info": {
    "authors": [
      "Lillian Lee"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P97-1002",
    "title": "Fast Context-Free Parsing Requires Fast Boolean Matrix Multiplication",
    "url": "https://aclweb.org/anthology/P97-1002",
    "year": 1997
  },
  "references": [
    "acl-J94-2002"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Valiant showed that Boolean matrix multiplication (BMM) can be used for CFG parsing.",
        "We prove a dual result: CFG parsers running in time 0(IGI Iw13-6) on a grammar G and a string w can be used to multiply m x m Boolean matrices in time 0(m3-0).",
        "In the process we also provide a formal definition of parsing motivated by an informal notion due to Lang.",
        "Our result establishes one of the first limitations on general CFG parsing: a fast, practical CFG parser would yield a fast, practical BMM algorithm, which is not believed to exist."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The context-free grammar (CFG) formalism was developed during the birth of the field of computational linguistics.",
        "The standard methods for CFG parsing are the CKY algorithm (Kasami, 1965; Younger, 1967) and Earley's algorithm (Earley, 1970), both of which have a worst-case running time of 0(gN3) for a CFG (in Chomsky normal form) of size g and a string of length N. Graham et al.",
        "(1980) give a variant of Earley's algorithm which runs in time 0(g N3/ log N).",
        "Valiant's parsing method is the asymptotically fastest known (Valiant, 1975).",
        "It uses Boolean matrix multiplication (BMM) to speed up the dynamic programming in the CKY algorithm: its worst-case running time is 0(gM(N)), where M(m) is the time it takes to multiply two m x m Boolean matrices together.",
        "The standard method for multiplying matrices takes time 0(m3).",
        "There exist matrix multiplication algorithms with time complexity 0(m3-5); for instance, Strassen's has a worst-case running time of 0(m281) (Strassen, 1969), and the fastest currently known has a worst-case running time of 0(m2376) (Coppersmith and Winograd, 1990).",
        "Unfortunately, the constants involved are so large that these fast algorithms (with the possible exception of Strassen's) cannot be used in practice.",
        "As matrix multiplication is a very well-studied problem (see Strassen's historical account (Strassen, 1990, section 10)), it is highly unlikely that simple, practical fast matrix multiplication algorithms exist.",
        "Since the best BMM algorithms all rely on general matrix multiplication', it is widely believed that there are no practical 0(m3-6) BMM algorithms One might therefore hope to find a way to speed up CFG parsing without relying on matrix multiplication.",
        "However, we show in this paper that fast CFG parsing requires fast Boolean matrix multiplication in a precise sense: any parser running in time 0(g N3') that represents parse data in a retrieval-efficient way can be converted with little computational overhead into a 0(m3-€/3) BMM algorithm.",
        "Since it is very improbable that practical fast matrix multiplication algorithms exist, we thus establish one of the first nontrivial limitations on practical CFG parsing.",
        "The \"four Russians\" algorithm (Arlazarov et al., 1970), the fastest BMM algorithm that does not simply use ordinary matrix multiplication, has worst-case running time 0(m3/ log m).",
        "Our technique, adapted from that used by Satta (1994) for tree-adjoining grammar (TAG) parsing, is to show that BMM can be efficiently reduced to CFG parsing.",
        "Satta's result does not apply to CFG parsing, since it explicitly relies on the properties of TAGs that allow them to generate non-context-free languages."
      ]
    },
    {
      "heading": "2 Definitions",
      "text": [
        "A Boolean matrix is a matrix with entries from the set {0, 1}.",
        "A Boolean matrix multiplication algorithm takes as input two in x in Boolean matrices A and B and returns their Boolean product A x B, which is the m x m Boolean matrix C whose entries C23 are defined by",
        "That is, cjj = 1 if and only if there exists a number k, 1 < k < m, such that aik = bki = 1.",
        "We use the usual definition of a context-free grammar (CFG) as a 4-tuple G = (E, V, R, S), where E is the set of terminals, V is the set of nonterminals, R is the set of productions, and S E V is the start symbol.",
        "Given a string w = w1w2 • • wAr over E*, where each wi is an element of E, we use the notation w.1 to denote the substring wiwi+i • • wi-itvj• We will be concerned with the notion of c-derivations, which are substring derivations that are consistent with a derivation of an entire string.",
        "Intuitively, A w3i is a c-derivation if it is consistent with at least one parse of w.",
        "• A , and • S wt-1",
        "We would like our results to apply to all \"practical\" parsers, but what does it mean for a parser to be practical?",
        "First, we would like to be able to retrieve constituent information for all possible parses of a string (after all, the recovery of structural information is what distinguishes parsing algorithms from recognition algorithms); such information is very useful for applications like natural language understanding, where multiple interpretations for a sentence may result from different constituent structures.",
        "Therefore, practical parsers should keep track of c-derivations.",
        "Secondly, a parser should create an output structure from which information about constituents can be retrieved in an efficient way – Satta (1994) points out an observation of Lang to the effect that one can consider the input string itself to be a retrieval-inefficient representation of parse information.",
        "In short, we require practical parsers to output a representation of the parse forest for a string that allows efficient retrieval of parse information.",
        "Lang in fact argues that parsing means exactly the production of a shared forest structure \"from which any specific parse can be extracted in time linear with the size of the extracted parse tree\" (Lang, 1994, pg.",
        "487), and Satta (1994) makes this assumption as well.",
        "These notions lead us to equate practical parsers with the class of c-parsers, which keep track of c-derivations and may also calculate general substring derivations as well.",
        ".FG,111 acts as an oracle about parse information, as follows:",
        "• If A c-derives w, then YG,w(A,i, = \"yes\".",
        "• If A 0* w (which implies that A does not c-derive wO, then .FG,w(A,i, j) = \"no\".",
        "• YG,to answers queries in constant time.",
        "Note that the answer .FG,ID gives can be arbitrary if A w-1 but A does not c-derive w. The constant-time constraint encodes the notion that information extraction is efficient; observe that this is a stronger condition than that called for by Lang.",
        "We define c-parsers in this way to make the class of c-parsers as broad as possible.",
        "If we had changed the first condition to \"If A derives ...\", then Earley parsers would be excluded, since they do not keep track of all substring derivations.",
        "If we had written the second condition as \"If A does not c-derive w, then ... \", then CKY parsers would not be c-parsers, since they keep track of all substring derivations, not just c-derivations.",
        "So as it stands, the class of c-parsers includes tabular parsers (e.g. CKY), where ..FG,w is the table of substring derivations, and Earley-type parsers, where .FG,„, is the chart.",
        "Indeed, it includes all of the parsing algorithms mentioned in the introduction, and can be thought of as a formalization of Lang's informal definition of parsing."
      ]
    },
    {
      "heading": "3 The reduction",
      "text": [
        "We will reduce BMM to c-parsing, thus proving that any c-parsing algorithm can be used as a Boolean matrix multiplication algorithm.",
        "Our method, adapted from that of Satta (1994) (who considered the problem of parsing with tree-adjoining grammars), is to encode information about Boolean matrices into a CFG.",
        "Thus, given two Boolean matrices, we need to produce a string and a grammar such that parsing the string with respect to the grammar yields output from which information about the product of the two matrices can be easily retrieved.",
        "We can sketch the behavior of the grammar as follows.",
        "Suppose entries aik in A and bk3 in B are both 1.",
        "Assume we have some way to break up array indices into two parts so that i can be reconstructed from i1 and i2, j can be reconstructed from j1 and j2, and k can be reconstructed from k1 and k2.",
        "(We will describe a way to do this later.)",
        "Then, we will have the following derivation (for a quantity 8 to be defined later) The key thing to observe is that C,11 generates two nonterminals whose \"inner\" indices match, and that these two nonterminals generate substrings that lie exactly next to each other.",
        "The \"inner\" indices constitute a check on kl, and the substring adjacency constitutes a check on k2.",
        "Let A and B be two Boolean matrices, each of size m x m, and let C be their Boolean matrix product, C = A x B.",
        "In the rest of this section, we consider A, B, C, and m to be fixed.",
        "Set n = [m1/31, and set 6 = n + 2.",
        "We will be constructing a string of length 38; we choose 5 slightly larger than n in order to avoid having epsilon-productions in our grammar.",
        "Recall that aij is non-zero if and only if we can find a non-zero aik and a non-zero such that k = i.",
        "In essence, we need simply check for the equality of indices k and T. We will break matrix indices into two parts: our grammar will check whether the first parts of k and Tc are equal, and our string will check whether the second parts are also equal, as we sketched above.",
        "Encoding the indices ensures that the grammar is of as small a size as possible, which will be important for our time bound results.",
        "Our index encoding function is as follows.",
        "Let i be a matrix index, 1 < i < m. Then we define the function f (i) = f2(i)) by = Li/n] (0 < f1(i) < n2), and 12(i) = (i mod n) + 2 (2 f2(i) n + 1).",
        "Since Ii and 12 are essentially the quotient and remainder of integer division of i by n, we can retrieve i from (MO, 12(i)).",
        "We will use the notational shorthand of using subscripts instead of the functions fi and f2, that is, we write and i2 for f1(i) and f2(i).",
        "It is now our job to create a CFG G = (E, V, R, S) and a string w that encode information about A and B and express constraints about their product C. Our plan is to include a set of nonterminals {Cp,q : 1 < p, q < n2} in V so that cij = 1 if and only if Ci, c-derives wi22+25.",
        "In section 3.1, we describe a version of G and prove it has this c-derivation property.",
        "Then, in section 3.2 we explain that G can easily be converted to Chomsky normal form in such a way as to preserve c-derivations.",
        "We choose the set of terminals to be E = {wt : 1 < t < 3n + 6}, and choose the string to be parsed to be w = wiw2 • • • W3n+6.",
        "We consider w to be made up of three parts, x, y, and z, each of size 6: w =",
        "Observe that for any i, 1 < i < m, wi, lies within x, wi2+6 lies within y, and Wi2+26 lies within z, since"
      ]
    },
    {
      "heading": "3.1 The grammar",
      "text": [
        "Now we begin building the grammar G = (E, V, R, S).",
        "We start with the nonterminals V = {S} and the production set R = 0.",
        "We add nonterminal W to V for generating arbitrary non-empty substrings of w; thus we need the productions",
        "Next we encode the entries of the input matrices A and B in our grammar.",
        "We include sets of",
        "For every non-zero entry b13 in B, we add the production (B-rules) Wi2±1±6WW32+26.",
        "We need to represent entries of C, so we create nonterminals {Cpa : 1 < p, q < n2} and productions (C-rules)Cp,qAp,rBr,q, 1 < p, q,r < n2.",
        "Finally, we complete the construction with productions for the start symbol S:",
        "We now prove the following result about the grammar and string we have just described.",
        "-P-jir22o±of2 Fix i and j.",
        "Let us prove the \"only if\" direction first.",
        "Thus, suppose cii = 1.",
        "Then there exists a k such that aik = bk3 = 1.",
        "Figure 1 sketches how",
        "The production -->Ai1,k1Bk1,1 is one of the C-rules in our grammar Since aik = 1, A1 ,k1 – + wi,Wwk2+6 is one of our A-rules, and since bki = 1, Bkiji wk2+1+6WWj2+26 is one of our B-rules.",
        "Finally, since i2 + 1 < (k2 + 6) - 1 and (k2 + 1 + 6) +1 < (j2 + 25) - 1, we have W wik22++15-1 and W wic22++225±-61, since both substrings are of length at least one.",
        "Therefore,",
        "and Claim 1 follows.",
        "Claim 2 S w2C1,j1w4+1.",
        "This claim is essentially trivial, since by the definition of the S-rules, we know that S .WC„,j,W .",
        "We need only show that neither 4-1 nor W3n+6 is the empty string (and hence can be de3g2e6d+by W); since 1 < i2 - 1 and j2 + 26 + 1 < 3n + 6, the claim holds.",
        "Claims .1 and 2 together prove that C,1,31 c-derives w3,22+26, as required.2 Next we prove the \"if\" direction.",
        "Suppose Cil c-derives V.7102+26, which by definition means C21,31 * tV3222+25.",
        "Then there must be a derivation resulting from the application of a C-rule as follows:",
        "for some k'.",
        "It must be the case that for some t, Aii,k, '4.2 and B 74+2+125.",
        "But then we must have the productions Azi,ki wi,Wwe and Bic, ,31 wt+iWw32+26 with e k\" + 6 for some k\".",
        "But we can only have such productions if there exists a number k such that k1 = k', k2 = k\", aik = 1, and bki = 1; and this implies that cii = 1.",
        "• Examination of the proof reveals that we have also shown the following two corollaries.",
        "Corollary 1 For 1 .< i,j < in, c = 1 if and only if Ci1,31 w:+26 Corollary 2 S w if and only if C is not the all-zeroes matrix.",
        "Let us now calculate the size of G. V consists of 0((n2)2) = 0(m4/3) nonterminals.",
        "R contains 0(n) W-rules and 0((n2)2) = 0(m4/3) S-rules.",
        "There are at most m2 A-rules, since we have an A-rule for each non-zero entry in A; similarly, there are at most m2 B-rules.",
        "And lastly, there are (n2)3 = 0(m2) C-rules.",
        "Therefore, our grammar is of size 0(m2); since G encodes matrices A and B, it is of optimal size."
      ]
    },
    {
      "heading": "3.2 Chomsky normal form",
      "text": [
        "We would like our results to be true for the largest class of parsers possible.",
        "Since some parsers require the input grammar to be in Chomsky normal form (CNF), we therefore wish to construct a CNF version G' of G. However, in order to preserve time bounds, we desire that 0(G11) = 0(1G1), and we also require that Theorem 1 holds for G' as well as G. The standard algorithm for converting CFGs to CNF can yield a quadratic blow-up in the size of the grammar and thus is clearly unsatisfactory for our purposes.",
        "However, since G contains no epsilon-productions or unit productions, it is easy to see that we can convert G simply by introducing a small (0(n)) number of nonterminals without changing any c-derivations for the Cmq.",
        "Thus, from now on we will simply assume that G is in CNF."
      ]
    },
    {
      "heading": "3.3 Time bounds",
      "text": [
        "We are now in a position to prove our relation between time bounds for Boolean matrix multiplication and time bounds for CFG parsing.",
        "Theorem 2 Any c-parser P with running time 0(T(g)t(N)) on grammars of size g and strings of length N can be converted into a BMM algorithm Mp that runs in time 0 (max(m2 ,T (m2 )t(mi 3 ))).",
        "In particular, if P takes time 0(g N3-6), then Mp runs in time 0(m3-613).",
        "Proof.",
        "Mp acts as follows.",
        "Given two Boolean m x m matrices A and B, it constructs G and w as described above.",
        "It feeds G and w to P, which outputs FG,W.",
        "To compute the product matrix C, Mp queries for each i and j, 1 < i,j < m, whether C1,1 derives wii.r26 (we do not need to ask whether Ci,o, c-derives 4:1-25 because of corollary 1), setting cii appropriately.",
        "By definition of c-parsers, each such query takes constant time.",
        "Let us compute the running time of Mp.",
        "It takes 0(m2) time to read the input matrices.",
        "Since G is of size 0(m2) and w = 0(m113), it takes 0(m2) time to build the input to P, which then computes .7\"G,„, in time 0(T(m2)t(m1/3)).",
        "Retrieving C takes 0(m2).",
        "So the total time spent by Mp is 0(max(m2,T(m2)i(mi./3))), as was claimed.",
        "In the case where T(g) = g and t(N) = N3-6, Mp has a running time of 0(m2 (mil3)3-6) 0(m2-1-1-6/3) = 0(m3-e/3).",
        "• The case in which P takes time linear in the grammar size is of the most interest, since in natural language processing applications, the grammar tends to be far larger than the strings to be parsed.",
        "Observe that theorem 2 translates the running time of the standard CFG parsers, 0(gN3), into the running time of the standard BMM algorithm, 0(m3).",
        "Also, a c-parser with running time 0(gN2.43) would yield a matrix multiplication algorithm rivalling that of Strassen's, and a c-parser with running time better than 0(gN1.12) could be converted into a BMM method faster than Coppersmith and Winograd.",
        "As per the discussion above, even if such parsers exist, they would in all likelihood not be very practical.",
        "Finally, we note that if a lower bound on BMM of the form 1i(m3') were found, then we would have an immediate lower bound of 12(N3-3') on c-parsers running in time linear in g."
      ]
    },
    {
      "heading": "4 Related results and conclusion",
      "text": [
        "We have shown that fast practical CFG parsing algorithms yield fast practical BMM algorithms.",
        "Given that fast practical BMM algorithms are unlikely to exist, we have established a limitation on practical CFG parsing.",
        "Valiant (personal communication) notes that there is a reduction of m x m Boolean matrix multiplication checking to context-free recognition of strings of length m2; this reduction is alluded to in a footnote of a paper by Harrison and Havel (1974).",
        "However, this reduction converts a parser running in time 0(1w11.5) to a BMM checking algorithm running in time 0(m3) (the running time of the standard multiplication method), whereas our result says that sub-cubic practical parsers are quite unlikely; thus, our result is quite a bit stronger.",
        "Seiferas (1986) gives a simple proof of anC2(N2 ) lower bound (originally due to log N Gallaire (1969)) for the problem of on-line linear CFL recognition by multitape Turing machines.",
        "However, his results concern on-line recognition, which is a harder problem than parsing, and so do not apply to the general off-line parsing case.",
        "Finally, we recall Valiant's reduction of CFG parsing to boolean matrix multiplication (Valiant, 1975); it is rather pleasing to have the reduction cycle completed."
      ]
    },
    {
      "heading": "5 Acknowledgments",
      "text": [
        "I thank Joshua Goodman, Rebecca Hwa, Jon Kleinberg, and Stuart Shieber for many helpful comments and conversations.",
        "Thanks to Les Valiant for pointing out the \"folklore\" reduction.",
        "This material is based upon work supported in part by the National Science Foundation under Grant No.",
        "IRI-9350192.",
        "I also gratefully acknowledge partial support from an NSF Graduate Fellowship and an AT&T GRPW/ALFP grant.",
        "Finally, thanks to Giorgio Satta, who mailed me a preprint of his BMM/TAG paper several years ago."
      ]
    }
  ]
}
