{
  "info": {
    "authors": [
      "Peter Neuhaus",
      "Norbert Broker"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P97-1043",
    "title": "The Complexity of Recognition of Linguistically Adequate Dependency Grammars",
    "url": "https://aclweb.org/anthology/P97-1043",
    "year": 1997
  },
  "references": [
    "acl-C88-1049",
    "acl-C96-1085",
    "acl-C96-2122",
    "acl-E89-1014",
    "acl-J85-4001"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Results of computational complexity exist for a wide range of phrase structure-based grammar formalisms, while there is an apparent lack of such results for dependency-based formalisms.",
        "We here adapt a result on the complexity of ID/LP-grammars to the dependency framework.",
        "Contrary to previous studies on heavily restricted dependency grammars, we prove that recognition (and thus, parsing) of linguistically adequate dependency grammars is,ArP-complete."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The introduction of dependency grammar (DG) into modern linguistics is marked by Tesniere (1959).",
        "His conception addressed didactic goals and, thus, did not aim at formal precision, but rather at an intuitive understanding of semantically motivated dependency relations.",
        "An early formalization was given by Gaifman (1965), who showed the generative capacity of DG to be (weakly) equivalent to standard context-free grammars.",
        "Given this equivalence, interest in DG as a linguistic framework diminished considerably, although many dependency grammarians view Gaifman's conception as an unfortunate one (cf.",
        "Section 2).",
        "To our knowledge, there has been no other formal study of DG.This is reflected by a recent study (Lombardo & Lesmo, 1996), which applies the Earley parsing technique (Earley, 1970) to DG, and thereby achieves cubic time complexity for the analysis of DG.",
        "In their discussion, Lombardo & Lesmo express their hope that slight increases in generative capacity will correspond to equally slight increases in computational complexity.",
        "It is this claim that we challenge here.",
        "After motivating non-projective analyses for DG, we investigate various variants of DG and identify the separation of dominance and precedence as a major part of current DG theorizing.",
        "Thus, no current variant of DG (not even Tesniere's original formulation) is compatible with Gaifman s conception, which seems to be motivated by formal considerations only (viz., the proof of equivalence).",
        "Section 3 advances our proposal, which cleanly separates dominance and precedence relations.",
        "This is illustrated in the fourth section, where we give a simple encoding of an VP-complete problem in a discontinuous DG.",
        "Our proof of ArT'-completeness, however, does not rely on discontinuity, but only requires unordered trees.",
        "It is adapted from a similar proof for unordered context-free grammars (UCFGs) by Barton (1985)."
      ]
    },
    {
      "heading": "2 Versions of Dependency Grammar",
      "text": [
        "The growing interest in the dependency concept (which roughly corresponds to the 0-roles of GB, subcatego-rization in HPSG, and the so-called domain of locality of TAG) again raises the issue whether non-lexical categories are necessary for linguistic analysis.",
        "After reviewing several proposals in this section, we argue in the next section that word order – the description of which is the most prominent difference between PSGs and DGs – can adequately be described without reference to non-lexical categories.",
        "Standard PSG trees are projective, i.e., no branches cross when the terminal nodes are projected onto the input string.",
        "In contrast to PSG approaches, DG requires non-projective analyses.",
        "As DGs are restricted to lexical nodes, one cannot, e.g., describe the so-called unbounded dependencies without giving up projectiv-ity.",
        "First, the categorial approach employing partial constituents (Huck, 1988; Hepple, 1990) is not available, since there are no phrasal categories.",
        "Second, the coin-dexing (Haegeman, 1994) or structure-sharing (Pollard & Sag, 1994) approaches are not available, since there are no empty categories.",
        "Consider the extracted NP in \"Beans, I know John likes\" (cf. also to Fig.1 in Section 3).",
        "A projective tree would require \"Beans\" to be connected to either \"I\" or \"know\" – none of which is conceptually directly related to \"Beans\".",
        "It is \"likes\" that determines syntactic fea",
        "tures of \"Beans\" and which provides a semantic role for it.",
        "The only connection between \"know\" and \"Beans\" is that the finite verb allows the extraction of \"Beans\", thus defining order restrictions for the NP.",
        "This has led some DG variants to adopt a general graph structure with multiple heads instead of trees.",
        "We will refer to DGs allowing non-projective analyses as discontinuous DGs.",
        "Tesniere (1959) devised a bipartite grammar theory which consists of a dependency component and a translation component ('translation' used in a technical sense denoting a change of category and grammatical function).",
        "The dependency component defines four main categories and possible dependencies between them.",
        "What is of interest here is that there is no mentioning of order in Tesniere' s work.",
        "Some practitioneers of DG have allowed word order as a marker for translation, but they do not prohibit non-projective trees.",
        "Gaifman (1965) designed his DG entirely analogous to context-free phrase structure grammars.",
        "Each word is associated with a category, which functions like the non-terminals in CFG.",
        "He then defines the following rule format for dependency grammars:",
        "This rule states that a word of category X governs words of category Y1,... , Y occur in the given order.",
        "The head (the word of category X) must occur between the i-th and the (i + 1)-th modifier.",
        "The rule can be viewed as an ordered tree of depth one with node labels.",
        "Trees are combined through the identification of the root of one tree with a leaf of identical category of another tree.",
        "This formalization is restricted to projective trees with a completely specified order of sister nodes.",
        "As we have argued above, such a formulation cannot capture semantically motivated dependencies."
      ]
    },
    {
      "heading": "2.1 Current Dependency Grammars",
      "text": [
        "Today's DGs differ considerably from Gaifman' s conception, and we will very briefly sketch various order descriptions, showing that DGs generally dissociate dominance and precedence by some mechanism.",
        "All variants share, however, the rejection of phrasal nodes (although phrasal features are sometimes allowed) and the introduction of edge labels (to distinguish different dependency relations).",
        "Meaning-Text Theory (Mel' euk, 1988) assumes seven strata of representation.",
        "The rules mapping from the unordered dependency trees of surface-syntactic representations onto the annotated lexeme sequences of deep-morphological representations include global ordering rules which allow discontinuities.",
        "These rules have not yet been formally specified (Mel' euk & Pertsov, 1987, p.1870, but see the proposal by Rambow & Joshi (1994).",
        "Word Grammar (Hudson, 1990) is based on general graphs.",
        "The ordering of two linked words is specified together with their dependency relation, as in the proposition \"object of verb succeeds it\".",
        "Extraction is analyzed by establishing another dependency, visitor, between the verb and the extractee, which is required to precede the verb, as in \"visitor of verb precedes it\".",
        "Resulting inconsistencies, e.g. in case of an extracted object, are not resolved, however.",
        "Lexicase (Starosta, 1988; 1992) employs complex feature structures to represent lexical and syntactic entities.",
        "Its word order description is much like that of Word Grammar (at least at some level of abstraction), and shares the above inconsistency.",
        "Dependency Unification Grammar (Hellwig, 1988) defines a treelike data structure for the representation of syntactic analyses.",
        "Using morphosyntactic features with special interpretations, a word defines abstract positions into which modifiers are mapped.",
        "Partial orderings and even discontinuities can thus be described by allowing a modifier to occupy a position defined by some transitive head.",
        "The approach cannot restrict discontinuities properly, however.",
        "Slot Grammar (McCord, 1990) employs a number of rule types, some of which are exclusively concerned with precedence.",
        "So-called head/slot and slot/slot ordering rules describe the precedence in projective trees, referring to arbitrary predicates over head and modifiers.",
        "Extractions (i.e., discontinuities) are merely handled by a mechanism built into the parser.",
        "This brief overview of current DG flavors shows that various mechanisms (global rules, general graphs, procedural means) are generally employed to lift the limitation to projective trees.",
        "Our own approach presented below improves on these proposals because it allows the lexi-calized and declarative formulation of precedence constraints.",
        "The necessity of non-projective analyses in DG results from examples like \"Beans, I know John likes\" and the restriction to lexical nodes which prohibits gap-threading and other mechanisms tied to phrasal categories."
      ]
    },
    {
      "heading": "3 A Dependency Grammar with Word Order Domains",
      "text": [
        "We now sketch a minimal DG that incorporates only word classes and word order as descriptional dimensions.",
        "The separation of dominance and precedence presented here grew out of our work on German, and retains the local flavor of dependency specification, while at the same time covering arbitrary discontinuities.",
        "It is based on a (modal) logic with model-theoretic interpretation, which is presented in more detail in (Broker, 1997)."
      ]
    },
    {
      "heading": "3.1 Order Specification",
      "text": [
        "Our initial observation is that DG cannot use binary precedence constraints as PSG does.",
        "Since DG analyses are hierarchically flatter, binary precedence constraints result in inconsistencies, as the analyses of Word Grammar and Lexicase illustrate.",
        "In PSG, on the other hand, the phrasal hierarchy separates the scope of precedence restrictions.",
        "This effect is achieved in our approach by defining word order domains as sets of words, where precedence restrictions apply only to words within the same domain.",
        "Each word defines a sequence of order domains, into which the word and its modifiers are placed.",
        "Several restrictions are placed on domains.",
        "First, the domain sequence must mirror the precedence of the words included, i.e., words in a prior domain must precede all words in a subsequent domain.",
        "Second, the order domains must be hierarchically ordered by set inclusion, i.e., be projective.",
        "Third, a domain (e.g., di.",
        "in Fig.!)",
        "can be constrained to contain at most one partial dependency tree.' We will write singleton domains as \"_\", while other domains are represented by \"E\".",
        "The precedence of words within domains is described by binary precedence restrictions, which must be locally satisfied in the domain with which they are associated.",
        "Considering Fig.1 again, a precedence restriction for \"likes\" to precede its object has no effect, since the two are in different domains.",
        "The precedence constraints are formulated as a binary relation \"-.<\" over dependency labels, including the special symbol \"self\" denoting the head.",
        "Discontinuities can easily be characterized, since a word may be contained in any domain of (nearly) any of its transitive heads.",
        "If a domain of its direct head contains the modifier, a continuous dependency results.",
        "If, however, a modifier is placed in a domain of some transitive head (as \"Beans\" in Fig. 1), discontinuities occur.",
        "Bounding effects on discontinuities are described by specifying that certain dependencies may not be crossed.2 For the",
        "purpose of this paper, we need not formally introduce the bounding condition, though.",
        "A sample domain structure is given in Fig. 1, with two domains d1 and d2 associated with the governing verb \"know\" (solid) and one with the embedded verb \"likes\" (dashed).",
        "d1 may contain only one partial dependency tree, the extracted phrase.",
        "d2 contains the rest of the sentence.",
        "Both domains are described by (2), where the domain sequence is represented as \"<\".",
        "d2 contains two precedence restrictions which require that \"know\" (represented by self) must follow the subject (first precedence constraint) and precede the object (second precedence constraint).",
        "(2) { } ( (subject -‹ self), (self -‹ object)}"
      ]
    },
    {
      "heading": "3.2 Formal Description",
      "text": [
        "The following notation is used in the proof.",
        "A lexicon Lex maps words from an alphabet E to word classes, which in turn are associated with valencies and domain sequences.",
        "The set C of word classes is hierarchically ordered by a subclass relation",
        "(3) isac c CxC A word w of class c inherits the valencies (and domain sequence) from c, which are accessed by (4) w.valencies",
        "A valency (b, d, c) describes a possible dependency relation by specifying a flag b indicating whether the dependency may be discontinuous, the dependency name d (a symbol), and the word class c E C of the modifier.",
        "A word h may govern a word m in dependency d if h defines a valency (b, d, c) such that (m isac c) and m can consistently be inserted into a domain of h (for b = – ) or a domain of a transitive head of h (for b +).",
        "This condition is written as",
        "The language L(G) includes any sequence of words for which a dependency tree can be constructed such that for each word h governing a word m in dependency d, governs(h, d, m) holds.",
        "The modifier of h in dependency d is accessed by"
      ]
    },
    {
      "heading": "4 The complexity of DG Recognition",
      "text": [
        "Lombardo & Lesmo (1996, p.728) convey their hope that increasing the flexibility of their conception of DG will \" ... imply the restructuring of some parts of the recognizer, with a plausible increment of the complexity\".",
        "We will show that adding a little (linguistically required) flexibility might well render recognition .VP-complete.",
        "To prove this, we will encode the vertex cover problem, which is known to be ATP-complete, in a DG."
      ]
    },
    {
      "heading": "4.1 Encoding the Vertex Cover Problem in Discontinuous DG",
      "text": [
        "A vertex cover of a finite graph is a subset of its vertices such that (at least) one end point of every edge is a member of that set.",
        "The vertex cover problem is to decide whether for a given graph there exists a vertex cover with at most k elements.",
        "The problem is known to be .NP-complete (Garey & Johnson, 1983, pp53-56).",
        "Fig.",
        "2 gives a simple example where {c, d} is a vertex cover.",
        "A straightforward encoding of a solution in the DG formalism introduced in Section 3 defines a root word s of class S with k valencies for words of class 0.",
        "0 has 1V1 subclasses denoting the nodes of the graph.",
        "An edge is represented by two linked words (one for each end point) with the governing word corresponding to the node included in the vertex cover.",
        "The subordinated word is assigned the class R, while the governing word is assigned the subclass of 0 denoting the node it represents.",
        "The latter word classes define a valency for words of class R (for the other end point) and a possibly discontinuous valency for another word of the identical class (representing the end point of another edge which is included in the vertex cover).",
        "This encoding is summarized in Table 1.",
        "The input string contains an initial s and for each edge the words representing its end points, e.g. \"saccdadbdcb\" for our example.",
        "If the grammar allows the construction of a complete dependency tree (cf.",
        "Fig.",
        "3 for one solution), this encodes a solution of the vertex cover problem."
      ]
    },
    {
      "heading": "4.2 Formal Proof using Continuous DG",
      "text": [
        "The encoding outlined above uses non-projective trees, i.e., crossing dependencies.",
        "In anticipation of counter arguments such as that the presented dependency grammar was just too powerful, we will present the proof using only one feature supplied by most DG formalisms, namely the free order of modifiers with respect to their head.",
        "Thus, modifiers must be inserted into an order domain of their head (i.e., no + mark in valencies).",
        "This version of the proof uses a slightly more complicated encoding of the vertex cover problem and resembles the proof by Barton (1985).",
        "Definition 1 (Measure) Let 11 • 11 be a measure for the encoded input length of a computational problem.",
        "We require that if S is a set or string and k E N then 181 > k implies 11811 > 11k11 and that for any tuple 11(• • • x, • • • )11 > 11x11 holds."
      ]
    },
    {
      "heading": "Definition 2 (Vertex Cover Problem)",
      "text": [
        "A possible instance of the vertex cover problem is a triple (V, E, k) where (V, E) is a finite graph and 1V1 > k E N. The vertex cover problem is the set VC of all instances (V, E, k) for which there exists a subset V' C V and a function f : E – > V' such that IV' 1 < k and",
        "A possible instance of the DG recognition problem is a tuple (G, cr) where G = (Lex, C, isac , E) is a dependency grammar as defined in Section 3 and a E E+.",
        "The DG recognition problem DGR consists of all instances (G,(r) such that a E L(G).",
        "For an algorithm to decide the VC problem consider a data structure representing the vertices of the graph (e.g., a set).",
        "We separate the elements of this data structure",
        "into the (maximal) vertex cover set and its complement set.",
        "Hence, one end point of every edge is assigned to the vertex cover (i.e., it is marked).",
        "Since (at most) all 1E1 edges might share a common vertex, the data structure has to be a multiset which contains 1E1 copies of each vertex.",
        "Thus, marking the 1V1 – k complement vertices actually requires marking 1V1 – k times 1E1 identical vertices.",
        "This will leave (k – 1) * 1E1 unmarked vertices in the input structure.",
        "To achieve this algorithm through recognition of a dependency grammar, the marking process will be encoded as the filling of appropriate valencies of a word s by words representing the vertices.",
        "Before we prove that this encoding can be generated in polynomial time we show that:",
        "Let G = (Lex ,C, isac , E) and a E E. We give a nondetermitzistic algorithm for deciding whether a = (si • .90 is in L(G).",
        "Let H be an empty set initially:",
        "1.",
        "Repeat until 1H1 = lo-1 (a) i.",
        "For every s, E a choose a lexicon entry c, E Lex(si).",
        "ii.",
        "From the c, choose one word as the head ho.",
        "iii.",
        "Let H {h0} and M := fedi E P., lain \\H.",
        "(b) Repeat until M = 0: i.",
        "Choose a head h E H and a valency (b,d,c) E h.valencies and a modifier m E M. ii.",
        "If governs(h, d, m) holds then establish the dependency relation between h and the m, and add m to the set H. iii.",
        "Remove in from M.",
        "The algorithm obviously is (nondeterministically) polynomial in the length of the input.",
        "Given that (C, a) E DGR, a dependency tree covering the whole input exists and the algorithm will be able to guess the dependents of every head correctly.",
        "If, conversely, the algorithm halts for some input (G, a), then there necessarily must be a dependency tree rooted in ho completely covering a.",
        "Thus, (C, a) E DG R. • Lemma 2 Let (V, E, k) be a possible instance of the vertex cover problem.",
        "Then a grammar G(V, E, k) and an input o-(V, E, k) can be constructed in time polynomial in 11(V, E, k) such that (V, E,k) E VC <=> (G(V, E,k),a(V, E, k)) E DGR For the proof, we first define the encoding and show that it can be constructed in polynomial time.",
        "Then we proceed showing that the equivalence claim holds.",
        "The set of classes is C =def IS, R,U)U E [1,1E1]} U 1',1i E [1, 'VD.",
        "In the isac hierarchy the classes U, share the superclass U, the classes V, the superclass R. Valencies are defined for the classes according to Table 2.",
        "Furthermore, we define E =der {S} U {Vili E [1, 'VD.",
        "The lexicon Lex associates words with classes as given in Table 2.",
        "We set G(V, E, k) =def.",
        "(Lex , C, isac , E) and",
        "For an example, cf.",
        "Fig.",
        "4 which shows a dependency tree for the instance of the vertex cover problem from Fig. 2.",
        "The two dependencies u1 and u2 represent the complement of the vertex cover.",
        "It is easily seen3 that 11 (G (V, E , k), a (V, E , k))11 is polynomial in liVII,11Eil and k. From 1E1 > k and Definition 1 it follows that 11(17, E,k)ii > hEll > iikii > k • 3 The construction requires 2 *II/1+1E1 + 3 word classes, IV' + 1 terminals in at most 1E1 + 2 readings each.",
        "S defines IVI + k * lEl – k valencies, Ui defines 1E1 – 1 valencies.",
        "The length of a is IVI * 1E1 + 1.",
        "Hence, the construction of (G(V, E , k), a (V, E, k)) can be done in worst-case time polynomial in 11 (V, E , k)11.",
        "We next show the equivalence of the two problems.",
        "Assume (V, E, k) E VC: Then there exists a subset V' C V and a function f : E 4 V' such that 1V'I < k and V(v,n, vn) E E i((vin,v0) E {(v7„, v,i)}.",
        "A dependency tree for o-(V, E, k) is constructed by:",
        "1.",
        "For every ei E E, one word f (ei) is assigned class Hi and governed by s in valency hi.",
        "2.",
        "For each vi E V \\ VI, lEl – 1 words vi are assigned",
        "class R and governed by the remaining copy of vi in reading Ui through valencies r1 to ri Eli.",
        "3.",
        "The vi in reading Ui are governed by s through the valencies u (j E [1, 1V1 – k]).",
        "4.",
        "(k – 1) * lEl words remain in a.",
        "These receive reading R and are governed by s in valencies r, (j E [1, (k – 1)1E1]).",
        "The dependency tree rooted in s covers the whole input a(V, E, k).",
        "Since G(V,E,k) does not give any further restrictions this implies a(V,E,k) E L(G(V, E, k)) and, thus, (G(V, E,k),a(V,E,k)) E DG R. Conversely assume (G(V,E,k),a(V,E,k)) E DGR: Then a(V, E, k) E L(G(V, E, k)) holds, i.e., there exists a dependency tree that covers the whole input.",
        "Since s cannot be governed in any valency, it follows that s must be the root.",
        "The instance s of S has 1E1 valencies of class H, (k – 1) *1E1 valencies of class R, and 1V1 – k valencies of class U, whose instances in turn have 1E1-1 valencies of class R. This sums up to 1E1 * 1V1 potential dependents, which is the number of terminals in a besides s. Thus, all valencies are actually filled.",
        "We define a subset Vo C V by Vo =def E V13i E [1, 1V1 – k] s.mod(ui) = v}.",
        "I.e.,",
        "The dependents of s in valencies hi are from the set V\\ Vo.",
        "We define a function f : E 4 V \\ Vo by f(e) =def s.mod(hi) for all ei E E. By construction f (ei) is an end point of edge ei, i.e. (2) V(vm, vn) E E ((vm,vn)) E {vmovn} We define a subset V' C V by V' =clef If (e) E E}.",
        "Thus",
        "(3) Ve E E : f (e) E VI",
        "By construction of V' and by (1) it follows (4) IVI IVol = k From (2), (3), and (4) we induce (V, E, k) E VC.",
        "• Theorem 3 The DG recognition problem is in the complexity class JVPC.",
        "0 The .'VP-completeness of the DG recognition problem follows directly from lemmata 1 and 2.",
        "•"
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We have shown that current DG theorizing exhibits a feature not contained in previous formal studies of DG, namely the independent specification of dominance and precedence constraints.",
        "This feature leads to a MP-complete recognition problem.",
        "The necessity of this extension approved by most current DGs relates to the fact that DG must directly characterize dependencies which in PSG are captured by a projective structure and additional processes such as coindexing or structure sharing (most easily seen in treatments of so-called unbounded",
        "dependencies).",
        "The dissociation of tree structure and linear order, as we have done in Section 3, nevertheless seems to be a promising approach for PSG as well; see a very similar proposal for HPSG (Reape, 1989).",
        "The ./VP-completeness result also holds for the discontinuous DG presented in Section 3.",
        "This DG can characterize at least some context-sensitive languages such as an bn en , i.e., the increase in complexity corresponds to an increase of generative capacity.",
        "We conjecture that, provided a proper formalization of the other DG versions presented in Section 2, their ArP-completeness can be similarly shown.",
        "With respect to parser design, this result implies that the well known polynomial time complexity of chart or tabular-based parsing techniques cannot be achieved for these DG formalisms in general.",
        "This is the reason why the PARSETALK text understanding system (Neuhaus & Hahn, 1996) utilizes special heuristics in a heterogeneous chart and backtracking-based parsing approach."
      ]
    }
  ]
}
