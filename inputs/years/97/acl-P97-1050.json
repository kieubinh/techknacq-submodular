{
  "info": {
    "authors": [
      "Jochen Dorre"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P97-1050",
    "title": "Efficient Construction of Underspecified Semantics Under Massive Ambiguity",
    "url": "https://aclweb.org/anthology/P97-1050",
    "year": 1997
  },
  "references": [
    "acl-C96-2153",
    "acl-J93-4001",
    "acl-P89-1018"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We investigate the problem of determining a compact underspecified semantical representation for sentences that may be highly ambiguous.",
        "Due to combinatorial explosion, the naive method of building semantics for the different syntactic readings independently is prohibitive.",
        "We present a method that takes as input a syntactic parse forest with associated constraint-based semantic construction rules and directly builds a packed semantic structure.",
        "The algorithm is fully implemented and runs in 0(n4log(n)) in sentence length, if the grammar meets some reasonable 'normality' restrictions."
      ]
    },
    {
      "heading": "1 Background",
      "text": [
        "One of the most central problems that any NL system must face is the ubiquitous phenomenon of ambiguity.",
        "In the last few years a whole new branch developed in semantics that investigates underspecified semantic representations in order to cope with this phenomenon.",
        "Such representations do not stand for the real or intended meaning of sentences, but rather for the possible options of interpretation.",
        "Quantifier scope ambiguities are a semantic variety of ambiguity that is handled especially well by this approach.",
        "Pioneering work in that direction has been (Alshawi 92) and (Reyle 93).",
        "More recently there has been growing interest in developing the underspecification approach to also cover syntactic ambiguities (cf. (Pinlcal 95; EggLe-beth 95; Schiehlen 96)).",
        "Schiehlen's approach is outstanding in that he fully takes into account syntactic *This research has been carried out while the author visited the Programming Systems Lab of Prof. Gert Smolka at the University of Saarland, Saarbriicken.",
        "Thanks to John Maxwell, Martin Muller, Joachim Niehren, Michael Schiehlen, and an anonymous reviewer for valuable feedback and to all at PS Lab for their helpful support with the OZ system.",
        "constraints.",
        "In (Schiehlen 96) he presents an algorithm which directly constructs a single underspecified semantic structure from the ideal \"underspecified\" syntactic structure, a parse forest.",
        "On the other hand, a method for producing \"packed semantic structures\", in that case \"packed quasi-logical forms\", has already been used in the Core Language Engine, informally described in (Al-shawl 92, Chap.",
        "7).",
        "However, this method only produces a structure that is virtually isomorphic to the parse forest, since it simply replaces parse forest nodes by their corresponding semantic operators.",
        "No attempt is made to actually apply semantic operators in the phase where those \"packed QLFs\" are constructed.",
        "Moreover, the packing of the QLFs seems to serve no purpose in the processing phases following semantic analysis.",
        "Already the immediately succeeding phase \"sortal filtering\" requires QLFs to be unpacked, i.e. enumerated.",
        "Contrary to the CLE method, Schiehlen's method actively packs semantic structures, even when they result from distinct syntactic structures, extracting common parts.",
        "His method, however, may take time exponential w.r.t.",
        "sentence length.",
        "Already the semantic representations it produces can be exponentially large, because they grow linear with the number of (syntactic) readings and that can be exponential, e.g., for sentences that exhibit the well-known attachment ambiguity of prepositional phrases.",
        "It is therefore an interesting question to ask, whether we can compute compact semantic representations from parse forests without falling prey to exponential explosion.",
        "The purpose of the present paper is to show that construction of compact semantic representations like in Schiehlen's approach from parse forests is not only possible, but also cheap, i.e., can be done in polynomial time.",
        "To illustrate our method we use a simple DCG grammar for PP-attachment ambiguities, adapted from (Schiehlen 96), that yields semantic representations (called UDRSs) according to the Underspecified Discourse Representation Theory (Reyle 93; KampReyle 93).",
        "The grammar is shown in Fig. 1.",
        "The UDRSs constructed by the grammar are flat lists of the UDRS-constraints 1 < (subordination (partial) ordering between labels; Prolog representation: lt (/ , /')), 1 : Cond (condition introduction in subUDRS labeled 1), 1 : X (referent introduction in 1), 1 : GenQuant(1',1\") (generalised quantifier) and an anchoring function.",
        "The meaning of a UDRS as a set of denoted DRSs can be explained as follows.1 All conditions with the same label form a subUDRS and labels occurring in subUDRSs denote locations (holes) where other subUDRSs can be plugged into.",
        "The whole UDRS denotes the set of well-formed DRSs that can be formed by some plugging of the subUDRSs that does not violate the ordering ‹.",
        "Scope of quantifiers can be underspecified in UDRSs, because subordination can be left partial.",
        "In our example grammar every nonterminal has three arguments.",
        "The 2nd and the 3rd argument represent a UDRS list as a difference list, i.e., the UDRS is \"threaded through\".",
        "The first argument is a list of objects occurring in the UDRS that play a specific role in syntactic combinations of the current node.2 An example of a UDRS, however a packed UDRS, is shown later on in §5.",
        "To avoid the dependence on a particular grammar formalism we present our method for a constraint-based grammar abstractly from the actual constraint 'Readers unfamiliar with DRT should think of these structures as some Prolog terms, representing semantics, built by unifications according to the semantic rules.",
        "It is only important to notice how we extract common parts of those structures, irrespective of the structures' meanings.",
        "2E.g., for an NP its referent, as well as the upper and lower label for the current clause and the top label.",
        "system employed.",
        "We only require that semantic rules relate the semantic 'objects' or structures that are associated with the nodes of a local tree by employing constraints.",
        "E.g., we can view the DCG rule s --+ np vp as a relation between three 'semantic construction terms' or variables SemS , SemNP, SemVP equivalent to the constraints",
        "Here is an overview of the paper.",
        "§2 gives the preliminaries and assumptions needed to precisely state the problem we want to solve.",
        "§3 presents the abstract algorithm.",
        "Complexity considerations follow in §4.",
        "Finally, we consider implementation issues, present results of an experiment in §5, and close with a discussion."
      ]
    },
    {
      "heading": "2 The Problem",
      "text": [
        "As mentioned already, we aim at calculating from given parse forests the same compact semantic structures that have been proposed by (Schiehlen 96), i.e. structures that make explicit the common parts of different syntactic readings, so that subsequent semantic processes can use this generalised information.",
        "As he does, we assume a constraint-based grammar, e.g. a DCG (PereiraWarren 80) or HPSG (PollardSag 94) , in which syntactic constraints and constraints that determine a resulting semantic representation can be seperated and parsing can be performed using the syntactic constraints only.",
        "Second, we assume that the set of syntax trees can be compactly represented as a parse forest (cf. (Earley 70; BillotLang 89; Tomita 86)).",
        "Parse forests are rooted labeled directed acyclic graphs with AND-nodes (standing for context-free branch",
        "ing) and OR-nodes (standing for alternative sub-trees), that can be characterised as follows (cf.",
        "Fig.",
        "2 for an example) .3",
        "1.",
        "The terminal yield as well as the label of two AND-nodes are identical, if and only if they both are children of one OR-node.",
        "2.",
        "Every tree reading is a valid parse tree.",
        "Tree readings of such graphs are obtained by replacing any OR-node by one of its children.",
        "Parse forests can represent an exponential number of phrase structure alternatives in o(n3) space, where n is the length of the sentence.",
        "The example uses the 3 OR-nodes (A, B, C) and the AND-nodes 1 through 32 to represent 5 complete parse trees, that would use 5 x 19 nodes.",
        "Third, we assume the rule-to-rule hypothesis, i.e., 3 The graphical representation of an OR-node is a box surrounding its children, i.e. the AND-OR-graph structure of that the grammar associates with each local tree a 'semantic rule' that specifies how to construct the mother node's semantics from those of its children.",
        "Hence, input to the algorithm is",
        "• a parse forest • an associated semantic rule for every local tree (AND-node together with its children) therein • and a semantic representation for each leaf (coming from a semantic lexicon).",
        "To be more precise, we assume a constraint language C over a denumerable set of variables X, that is a sublanguage of Predicate Logic with equality and is closed under conjunction, disjunction, and variable renaming.",
        "Small greek letters 0, will henceforth denote constraints (open formulae) and letters X, Y, Z (possibly with indeces) will denote variables.",
        "Writing 0(Xi, , Xk) shall indicate that X1,... , Xk are the free variables in the constraint p5 Frequently used examples for constraint languages are the language of equations over first-order terms",
        "for DCGs,4 PATR-style feature-path equations, or typed feature structure description languages (like the constraint languages of ALE (Carpenter 92) or CUF (DOrreDorna 93)) for HPSG-style grammars.",
        "Together with the constraint language we require a constraint solver, that checks constraints for satisfiability, usually by transforming them into a normal form (also called 'solved form').",
        "Constraint solving in the DCG case is simply unification of terms.",
        "The semantic representations mentioned before are actually not given directly, but rather as a constraint on some variable, thus allowing for partiality in the struct7.1ral description.",
        "To that end we assume that every node in the parse forest ii has associated with it a variable X, that is used for constraining the (partial) semantic structure of v. The semantics of a leaf node p is hence given as a constraint OA (Xj., called a leaf constraint.",
        "A final assumption that we adopt concerns the nature of the 'semantic rules'.",
        "The process of semantics construction shall be a completely monotonous process of gathering constraints that never leads to failure.",
        "We assume that any associated (instantiated) semantic rule r(v) of a local tree (AND-branching) uk) determines v's semantics E(v) as follows from those of its children:",
        "The constraint Or(v)(X,,, X„„ , X„k ) is called the rule constraint for v. It is required to only depend on the variables X,,, X„, , .",
        ".",
        ".",
        ", X.",
        "Note that if the same rule is to be applied at another node, we have a different rule constraint.",
        "Note that any E(v) depends only on X,, and can be thought of as a unary predicate.",
        "Now, let us consider semantics construction for a single parse tree for the moment.",
        "The leaf constraints together with the rules define a semantics constraint E(v) for every node v, and the semantics of the full sentence is described by the E-constraint of the root node, E(root).",
        "In the E-constraints, we actually can suppress the existential quantifiers by adopting the convention that any variable other than the one of the current node is implicitly existentially bound on the formula toplevel.",
        "Name conflicts, that would force variable renaming, cannot occur.",
        "Therefore E(root) is (equivalent to) just a big conjunction of all rule constraints for the inner nodes and all leaf constraints.",
        "Moving to parse forests, the semantics of an OR-node v(vi, , uk) is to be defined as",
        "4DCG shall refer in this paper to a logically pure version, Definite Clause Grammars based on pure PROLOG, involving no nonlogical devices like Cut, var/l, etc.",
        "specifying that the set of possible (partial) semantic representations for v is the union of those of v's children.",
        "However, we can simplify this formula once and for all by assuming that for every OR-node there is only one variable X, that is associated with it and all of its children.",
        "Using the same variable for vi vk is unproblematic, because no two of these nodes can ever occur in a tree reading.",
        "Hence, the definition we get is",
        "Now, in the same way as in the single-tree case, we can directly \"read off\" the E-constraint for the whole parse forest representing the semantics of all readings.",
        "Although this constraint is only half the way to the packed semantic representation we are aiming at, it is nevertheless worthwhile to consider its structure a little more closely.",
        "Fig.",
        "3 shows the structure of the E-constraint for the OR-node B in the example parse forest.",
        "In a way the structure of this constraint directly mirrors the structure of the parse forest.",
        "However, by writing out the constraint, we loose the sharings present in the forest.",
        "A subformula coming from a shared subtree (as E(18) in Fig. 3) has to be stated as many times as the subtree appears in an unfolding of the forest graph.",
        "In our PP-attachment example the blowup caused by this is in fact exponential.",
        "On the other hand, looking at a E-constraint as a piece of syntax, we can represent this piece of syntax in the same manner in which trees are represented in the parse forest, i.e. we can have a representation of E(root) with a structure isomorphic to the forest's graph structure.5 In practice this difference becomes a question of whether we have full control over the representations the constraint solver employs (or any other process that receives this constraint as input).",
        "If not, we cannot contend ourselves with the possibility of compact representation of constraints, but rather need a means to enforce this compactness on the constraint level.",
        "This means that we have to introduce some form of functional abstraction into the constraint language (or anything equivalent that allows giving names to complex constraints and referencing to them via their names).",
        "Therefore we enhance the constraint language as follows.",
        "We allow to our disposition a second set of variables, called names, and two special forms of constraints",
        "1. def (<name>, <constraint>) name definition 2.",
        "<name> name use",
        "with the requirements, that a name may only be used, if it is defined and that its definition is unique.",
        "Thus, the constraint E(B) above can be written as",
        "The packed semantic representation as constructed by the method described so far still calls for an obvious improvement.",
        "Very often the different branches of disjunctions contain constraints that have large parts in common.",
        "However, although these overlaps are efficiently handled on the representational level, they are invisible at the logical level.",
        "Hence, what we need is an algorithm that fac-tores out common parts of the constraints on the logical level, pushing disjunctions down.' There are two routes that we can take to do this efficiently.",
        "In the first we consider only the structure of the parse forest, however ignore the content of (rule or leaf) constraints.",
        "I.e. we explore the fact that the parts of the E-constraints in a disjunction that stem from nodes shared by all disjuncts must be identical, and hence can be factored out.' More precisely, we can compute for every node v the set must-occur(v) of nodes (transitively) dominated by v that must occur in a tree of the forest, whenever v occurs.",
        "We can then use this information, when building the disjunction E(v) to factor out the constraints introduced by nodes in must-occur(v), i.e., we build the factor A,,,Emust-oc cur( v) E (vi) and a 'remainder' constraint E(vi)VI, for each disjunct.",
        "The other route goes one step further and takes into account the content of rule and leaf constraints.",
        "For it we need an operation generalise that can be characterised informally as follows.",
        "For two satisfiable constraints 0 and 0, genera1ise(0, 7,G) yields the triple such that e contains the common part' of 0 and f and 0' represents the 'remainder' 0\\e and likewise 14,1 represents 0\\e.",
        "'Actually, in the E(B) example such a factoring makes the use of the name N superfluous.",
        "In general, however, use of names is actually necessary to avoid exponentially large constraints.",
        "Subtrees may be shared by quite different parts of the structure, not only by disjuncts of the same disjunction.",
        "In the PP-attachment example, a compression of the E-constraint to polynomial size cannot be achieved with factoring alone.",
        "7(Maxwell IIIKaplan 93) exploit the same idea for efficiently solving the functional constraints that an LFG grammar associates with a parse forest.",
        "The exact definition of what the 'common part' or the 'remainder' shall be, naturally depends on the actual constraint system chosen.",
        "For our purpose it is sufficient to require the following properties: If genera1ise(0.",
        "0) (e, , V), then cb 1 e and th I-e and m eAo, and :p e A 0'.",
        "We shall call such a generalisation operation simplifying if the normal form of e is not larger than any of the input constraints' normal form.",
        "Example: An example for such a generalisation operation for PROLOG's constraint system (equations over first-order terms) is the so-called anti-unify operation, the dual of unification, that some PROLOG implementations provide as a library predicate.' Two terms Ti and T2 'anti-unify' to T, if T is the (unique) most specific term that subsumes both Ti and T2.",
        "The 'remainder constraints' in this case are the residual substitutions cri and o-2 that transform T into Ti or T2, respectively.",
        "Let us now state the method informally.",
        "We use generalise to factor out the common parts of disjunctions.",
        "This is, however, not as trivial as it might appear at first sight.",
        "Generalise should operate on solved forms, but when we try to eliminate the names introduced for subtree constraints in order to solve the corresponding constraints, we end up with constraints that are exponential in size.",
        "In the following section we describe an algorithm that circumvents this problem."
      ]
    },
    {
      "heading": "3 The Algorithm",
      "text": [
        "Input: • parse forest, leaf and rule constraints as described above",
        "• array of variables X,, indexed by node s.t.",
        "if v is a child of OR-node v', then X, = Data structures: • an array SEM of constraints and an array D of names, both indexed by node • a stack ENV of def constraints",
        "Output: a constraint representing a packed semantic representation",
        "solved forms.",
        "However, at least the simplifications true A (/) and A true should be assumed.",
        "The Packed Semantics Construction Algorithm is given in Fig. 4.",
        "It enforces the following invariants, which can easily be shown by induction.",
        "1.",
        "Every name used has a unique definition.",
        "2.",
        "For any node v we have the equivalence E(v) E-_--SEM[v] A [D[u]J, where ID[v]]] shall denote the constraint obtained from D[v] when recursively replacing names by the constraints they are bound to in ENV.",
        "3.",
        "For any node v the constraint SEM[v] is never larger than the E-constraint of any single tree in the forest originating in v.",
        "Hence, the returned constraint correctly represents the semantic representation for all readings."
      ]
    },
    {
      "heading": "4 Complexity",
      "text": [
        "The complexity of this abstract algorithm depends primarily on the actual constraint system and generalisation operation employed.",
        "But note also that the influence of the actual semantic operations prescribed by the grammar can be vast, even for the simplest constraint systems.",
        "E.g., we can write a DCGs that produce abnormal large \"semantic struc-tures\" of sizes growing exponentially with sentence length (for a single reading).",
        "For meaningful grammars we expect this size function to be linear.",
        "Therefore, let us abstract away this size by employing a function fG(n) that bounds the size of semantic structures (respectively the size of its describing constraint system in normal form) that grammar G assigns to sentences of length n. Finally, we want to assume that generalisation is simplifying and can be performed within a bound of g(m) steps, where m is the total size of the input constraint systems.",
        "With these assumptions in place, the time complexity for the algorithm can be estimated to be (n = sentence length, N = number of forest nodes)",
        "since every program step other than the generalisation operation can be done in constant time per node.",
        "Observe that because of Invariant 3. the input constraints to generalise are bounded by fG as any constraint in SEM.",
        "In the case of a DCG the generalisation operation is anti_unif y, which can be performed in o(n • log(n)) time and space (for acyclic structures).",
        "Hence, together with the assumption that the semantic structures the DCG computes can be bounded linearly in sentence length (and are acyclic), we obtain a 0(n • log(n)• N) < 0(n4log(n)) total time complexity."
      ]
    },
    {
      "heading": "5 Implementation and Experimental Results",
      "text": [
        "The algorithm has been implemented for the PROLOG (or DCG) constraint system, i.e., constraints are equations over first-order terms.",
        "Two implementations have been done.",
        "One in the concurrent constraint language OZ (SmolkaTreinen 96) and one in Sicstus Prolog.' The following results relate to the Prolog implementation.' Fig. 5 shows the resulting packed UDRS for the example forest in Fig. 2.",
        "Fig.",
        "6 displays the SEM part as a graph.",
        "The disjunctive binding environment only encodes what the variable referents B and D (in conjunction with the corresponding labels A and C) may be bound to to: one of el, x2, or x3 (and likewise the corresponding label).",
        "Executing the goal dEnv (509 , 1 , [B , A ,D ,C] ) yields the five solutions: A = 11, B = el, C = 11, D = el ?",
        "A = 12, B = x2, C = 11, D = el ?",
        "A = 11, B = el, C = 14, D = x3 ?",
        "A = 12, B = x2, C = 12, D = x2 ?",
        "A = 12, B = x2, C = 14, D = x3 ?",
        "no"
      ]
    },
    {
      "heading": "I ?-",
      "text": [
        "Table 1 gives execution times used for semantics construction of sentences of the form I saw a man (on a hill) for different n. The machine used for 9 The OZ implementation has the advantage that feature structure constraint solving is built-in.",
        "Our implementation actually represents the DCG terms as a feature structures.",
        "Unfortunately it is an order of magnitude slower than the Prolog version.",
        "The reason for this presumably lies in the fact that meta-logical operations the algorithm needs, like generalise and copy_term have been modeled in OZ and not on the logical level were they properly belong, namely the constraint solver.",
        "'9 This implementation is available from http://www.ims.uni-stuttgart.derjochen/CBSem.",
        "hop anchor(xl,'Speaker')",
        "the experiment was a Sun Ultra-2 (168MHz), running Sicstus 3.0#3.",
        "In a further experiment an nary ant i_unif y operation was implemented, which improved execution times for the larger sentences, e.g., the 16 PP sentence took 750 msec.",
        "These results approximately fit the expectations from the theoretical complexity bound."
      ]
    },
    {
      "heading": "6 Discussion",
      "text": [
        "Our algorithm and its implementation show that it is not only possible in theory, but also feasible in practice to construct packed semantical representations directly from parse forests for sentence that exhibit massive syntactic ambiguity.",
        "The algorithm is both in asymptotic complexity and in real numbers dramatically faster than an earlier approach, that also tries to provide an underspecified semantics for syntactic ambiguities.",
        "The algorithm has been presented abstractly from the actual constraint system and can be :-,dapted to any constraint-based grammar formalism.",
        "A critical assumption for the method has been that semantic rules never fail, i.e., no search is involved in semantics construction.",
        "This is required to guarantee that the resulting constraint is a kind of 'solved form' actually representing so-to-speak the free combination of choices it contains.",
        "Nevertheless, our method (modulo small changes to handle failure) may still prove useful, when this restriction is not fulfilled, since it focuses on computing the common information of disjunctive branches.",
        "The conjunctive part of the output constraint of the algorithm can then be seen as an approximation of the actual result, if the output constraint is satisfiable.",
        "Moreover, the disjunctive parts are reduced, so that a subsequent full-fledged search will have considerably less work than when directly trying to solve the original constraint system."
      ]
    }
  ]
}
