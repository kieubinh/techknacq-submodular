{
  "info": {
    "authors": [
      "Giorgio Satta",
      "John C. Henderson"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P97-1057",
    "title": "String Transformation Learning",
    "url": "https://aclweb.org/anthology/P97-1057",
    "year": 1997
  },
  "references": [
    "acl-J94-3001",
    "acl-J95-4004"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "String transformation systems have been introduced in (Brill, 1995) and have several applications in natural language processing.",
        "In this work we consider the computational problem of automatically learning from a given corpus the set of transformations presenting the best evidence.",
        "We introduce an original data structure and efficient algorithms that learn some families of transformations that are relevant for part-of-speech tagging and phonological rule systems.",
        "We also show that the same learning problem becomes NP-hard in cases of an unbounded use of don't care symbols in a transformation."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Ordered sequences of rewriting rules are used in several applications in natural language processing, including phonological and morphological systems (Kaplan and Kay, 1994), morphological disambiguation, part-of-speech tagging and shallow syntactic parsing (Brill, 1995), (Karlsson et al., 1995).",
        "In (Brill, 1995) a learning paradigm, called error-driven learning, has been introduced for automatic induction of a specific kind of rewriting rules called transformations, and it has been shown that the achieved accuracy of the resulting transformation systems is competitive with that of existing systems.",
        "In this work we further elaborate on the error-driven learning paradigm.",
        "Our main contribution is summarized in what follows.",
        "We consider some families of transformations and design efficient algorithms for the associated learning problem that improve existing methods.",
        "Our results are achieved by exploiting a data structure originally introduced in this work.",
        "This allows us to simultaneously represent and test the search space of all possible transformations.",
        "The transformations we investigate make use of classes of symbols, in order to generalize regularities in rule applications.",
        "We also show that when an unbounded number of these symbol classes are allowed within a transformation, then the associated learning problem becomes NP-hard.",
        "The notation we use in the remainder of the paper is briefly introduced here.",
        "E denotes a fixed, finite alphabet and c the null string.",
        "E* and E+ are the set of all strings and all non-null strings over E, respectively.",
        "Let w E E*.",
        "We denote by lw I the length of w. Let w = uxv; u is a prefix and v is a suffix of w; when x is non-null, it is called a factor of w. The suffix of w of length i is denoted suffi(w), for 0 < i < I wl.",
        "Assume that x is non-null, and w = uixsuffi(w) for yo > 0 different values of i but not for so + 1, or x is not a factor of w and so = 0.",
        "Then we say that so is the statistic of factor x in w."
      ]
    },
    {
      "heading": "2 The learning paradigm",
      "text": [
        "The learning paradigm we adopt is called error-driven learning and has been originally proposed in (Brill, 1995) for part of speech tagging applications.",
        "We briefly introduce here the basic assumptions of the approach.",
        "A string transformation is a rewriting rule denoted as u v, where u and v are strings such that Iu = Iv .",
        "This means that if u appears as a factor of some string w, then u should be replaced by v in w. The application of the transformation might be conditioned by the requirement that some additionally specified pattern matches some part of the string w to be rewritten.",
        "We now describe how transformations can be automatically learned.",
        "A pair of strings (w, w') is an aligned pair if I w I = WI.",
        "When w = uxsuffi(w), WI = u'x'suffi(0) and Ix' = x', we say that factors x and x' occur at aligned positions within (w, w').",
        "A multi-set of aligned pairs is called an aligned corpus.",
        "Let (w, w') be an aligned pair and let r be some transformation of the form u v. The positive evidence of r (w.r.t.",
        "(w, w')) is the number of different positions at which factors it and v are aligned within (w, w').",
        "The negative evidence of 7 (w.r.t.",
        "w, w') is the number of different positions at which factors it and u are aligned within",
        "(w, w').",
        "Intuitively speaking, positive (negative) evidence is a count of how many times we will do well (badly, respectively) when using 7 on w in trying to get w'.",
        "The score associated with T is the difference between the positive evidence and the negative evidence of r. This extends to an aligned corpus in the obvious way.",
        "We are interested in the set of transformations that are associated with the highest score in a given aligned corpus, and will develop algorithms to find such a set in the next sections."
      ]
    },
    {
      "heading": "3 Data Structures",
      "text": [
        "This section introduces two data structures that are basic to the development of the algorithms presented in this paper."
      ]
    },
    {
      "heading": "3.1 Suffix trees",
      "text": [
        "We briefly present here a data structure that is well known in the text processing literature; the reader is referred to (Crochemore and Rytter, 1994) and (Apostolic°, 1985) for definitions and further references.",
        "Let w be some non-null string.",
        "Throughout the paper we assume that the rightmost symbol of w is an end-marker not found at any other position in the string.",
        "The suffix tree associated with w is a \"compressed\" trie of all strings suffi(w), 1 < i < I w I. Edges are labeled by factors of w which are encoded by means of two natural numbers denoting endpoints in the string.",
        "An example is reported in Figure 1.",
        "An implicit node is a node not explicitly represented in the suffix tree, that splits the label of some edge at a given position.",
        "(Each implicit node corresponds to some node in the original trie having only one child.)",
        "We denote by parent(p) the parent node of (implicit) node p and by label(p, q) the label of the edge spanning (implicit) nodes p and q.",
        "Throughout the paper, we take the dominance relation between nodes to be reflexive, unless we write proper dominance.",
        "We also say that implicit node q immediately dominates node p if q splits the arc between parent(p) and p. Of main interest here are the following properties of suffix trees:",
        "• if node p has children pl, , pd, then d > 2 and strings label(p, pi) differ one from the other at the leftmost symbol; • all and only the factors of w are represented by paths from the root to some (implicit) node; • the statistic of factor u of w is the number of leaves dominated by the (implicit) node ending the path representing u.",
        "In the remainder of the paper, we sometimes identify an (implicit) node of a suffix tree with the factor represented by the path from the root to that node.",
        "The suffix tree and the statistics of all factors of w can be constructed/computed in time ()(Iwl), as reported in (Weiner, 1973) and (McCreight, 1976).",
        "McCreight algorithm uses two basic functions to scan paths in the suffix tree under construction.",
        "These functions are briefly introduced here and will be exploited in the next subsection.",
        "Below, p is a node in a tree and u is a non-null string.",
        "function Slow_scan(p, u): Starting at p, scan u symbol by symbol.",
        "Return the (implicit) node corresponding to the last matching symbol.",
        "The next function runs faster than Slow_scan, and can be used whenever we already know that u is an (implicit) node in the tree (u completely matches some path in the tree).",
        "function Fast_scan(p, u): Starting at p, scan u by iteratively (i) finding the edge between the current node and one of its children, that has the same first symbol as the suffix of u yet to be scanned, and (ii) skipping a prefix of u equal to the length of the selected edge label.",
        "Return the (implicit) node u.",
        "From each node an in the suffix tree, an some factor, McCreight's algorithm creates a pointer, called an slink, to node u which necessarily exists in the suffix tree.",
        "We write q s-link(p) if there is an slink from p to q."
      ]
    },
    {
      "heading": "3.2 Suffix tree alignment",
      "text": [
        "In the next section each transformation will be associated with several strings.",
        "Given an input text, we will compute transformation scores by computing statistics of these strings.",
        "This can easily be done using suffix trees, and by pairing statistics corresponding to the same transformation.",
        "The latter task can be done using the data structure originally introduced here.",
        "A total function h : E E', E and E' two alphabets, is called a (restricted) homomorphism.",
        "We extend h to a string function in the usual way by posing h(E) = E and h(au) = h(a)h(tt), a E E and u E E*.",
        "Given w, w' E E+, we need to pair each factor u of w with factor h(u) possibly occurring in w', To solve this problem, we construct the suffix trees T, T' for w, w', respectively.",
        "Then we establish an a-link (a pointer) from each node u of T, u some factor, to the (implicit) node h(u) of T', if h(u) exists.",
        "Furthermore, if factor ua with a E E is an (implicit) node of T such that h(u) but not h(ua) are (implicit) nodes of T', we create node u in T (if u was an implicit node) and establish an a-link from u to (implicit) node h(u) of T'.",
        "Note that the total number of a-links is 0( lw I).",
        "The resulting data structure is called here suffix tree alignment.",
        "An example is reported in Figure 2.",
        "We now specify a method to compute suffix tree alignments.",
        "In what follows p, p' are tree nodes and u is a non-null string.",
        "Crucially, we assume we can access the slinks of T and T'.",
        "Paths u and v in T and T', respectively, are aligned if v = h(u).",
        "The next two functions are used to move a-links up and down two aligned paths.",
        "function Move_link_down(p,p' , u): Starting at p and VI, simultaneously scan u and h(u), respectively, using function Slow_scan.",
        "Stop as soon as a symbol is not matched.",
        "At each encountered node of T and at the (implicit) node of T corresponding to the last successful match, create an a-link to the paired (implicit) node of T'.",
        "Return the pair of nodes in the lastly created a-link along with the length of the successfully matched prefix of u.",
        "In the next function, we use function Fastscan introduced in Section 3.1, but we run it upward the tree (with the obvious modifications).",
        "function Move_link_up(p,p'): Starting at p and p1, simultaneously scan the paths to the roots of T and T', respectively, using function Fastscan.",
        "Stop as soon as a node of T is encountered that already has an a-link.",
        "At each encountered node of T create an a-link to the paired (implicit) node of T' We also need a function that \"shifts\" a-links to a new pair of aligned paths.",
        "This is done using slinks.",
        "The next auxiliary function takes care of those (implicit) nodes for which the slink is missing.",
        "(This is the case for implicit nodes of T' and for some nodes of T that have been newly created.)",
        "We rest on the property that the parent node of any such (implicit) node always has an s-link, when it differs from the root.",
        "function Up_link_down(p): If s-link(p) is defined then return s-link(p).",
        "Else, let 1,1 parent(p).",
        "If Pm is not the root node, let p2 = s-link(pi) and return (implicit) node Fastscan(p2, label(pi,p)).",
        "If p1 is the root node, return (implicit) node",
        "We can now present the algorithm for the construction of suffix tree alignments.",
        "Algorithm 1 Let T and T' be the suffix trees for strings w and w', respectively:",
        "root of T' , suffm(w))",
        "In Figure 3 a sample run of Algorithm 1 is schematically represented.",
        "In the next section we use the following properties of Algorithm 1:",
        "• after T and T' have been processed, for every node p of T representing factor u of w, (implicit) node a-link(p) of T' is defined if and only if a-Iink(p) represents factor h(u) of w'; • the algorithm can be executed in time",
        "0(iwi + The first property above can be proved as follows.",
        "For 1 < i < Iwi, bi in Algorithm 1 is (the node representing) the longest prefix of suffi(w) such that h(b2) is an (implicit) node of T' (is a factor of w').",
        "This can be proved by induction on 1w1 – i, using the definition of Move_link_down and of slink.",
        "We then observe that, if u is a node of T, then factor u is a prefix of some suffi(w) and either u dominates bi or bi properly dominates u in T. If u dominates bi, then",
        "• h(u) must be an (implicit) node of T'.",
        "In this case an a-link is established from u to h(u) by Move_link_up or Move_link_down, depending on whether u dominates or is dominated by sbi in T. If bi properly dominates u, h(u) does not occur in w'.",
        "In this case, node u is never reached by the algorithm and no a-link is established for this node.",
        "The proof of the linear time result is rather long, we only give an outline here.",
        "The interesting case is the function Shift_link, which is executed itul – 1 times by the algorithm.",
        "When executed once on nodes p and p', Shift_link uses time 0(1) if s-link(p) and s-link(p') are both defined.",
        "In all other cases, it uses an amount of time proportional to the number of (implicit) nodes visited by function Fast_scan, which is called through function Up_link_down.",
        "We use an amortization technique and charge a constant amount of time to the symbols in w and w', for each node visited in this way.",
        "Consider the execution of Shift_link(bi+1,b41) for some i, 1< i < lwl – 1.",
        "Assume that, correspondingly, Fast_scan visits nodes ud of T in this order, with d > 1 and each u • some factor of w. Then we have that each u • is a (proper) prefix of uj+i, and ud = sbi.",
        "For each uj, 1 <j <d – 1, we charge a constant amount of time to the symbol in w \"corresponding\" to the last symbol of uj.",
        "The visit to ud, on the other hand, is charged to the ith symbol of w. (Note that charging the visit to ud to the symbol in w \"corresponding\" to the last symbol of ud does not work, since in the case of sbi = bi the same symbol would be charged again at the next iteration of the for-cycle.)",
        "It is not difficult to see that, in this way, each symbol of w is charged at most once.",
        "A similar argument works for visits to nodes of T' by Fast_scan, which are charged to symbols of w'.",
        "This shows that the time used by all executions of Shift_link is Oawl+ iwiD• Suffix trees and suffix tree alignments can be generalized to finite multi-sets of strings, each string ending with the same end-marker not found at any other position.",
        "In this case each leaf holds a record, called count, of the number of times the corresponding suffix appears in the entire multi-set, which will be propagated appropriately when computing factor statistic.",
        "Most important here, all of the above results still hold for these generalizations.",
        "In the next section, we will deal with the multi-set case."
      ]
    },
    {
      "heading": "4 Transformation learning",
      "text": [
        "This section deals with the computational problem of learning string transformations from an aligned corpus.",
        "We show that some families of transformations can be efficiently learned exploiting the data structures of Section 3.",
        "We also consider more general kinds of transformations and show that for this class the learning problem is NP-hard."
      ]
    },
    {
      "heading": "4.1 Data representation",
      "text": [
        "We introduce a representation of aligned corpora that reduces the problem of computing the positive/negative evidence of transformations to the problem of computing factor statistics.",
        "Let (w, w') be an aligned pair, w = al • • • an and w' = • • a,, with ai E E for 1 < i < n, and n > 1.",
        "We define",
        "where w x w' appears in Lx as many times as (w, w') appears in L."
      ]
    },
    {
      "heading": "4.2 Learning algorithms",
      "text": [
        "Let L be an aligned corpus with N aligned pairs over a fixed alphabet E, and let n be the length of the longest string in a pair in L. We start by considering plain transformations of the form",
        "where u, v E E+, rui = 14 We want to find all instances of strings u, v E E* such that, in L, u v has score greater or equal than the score of any other transformation.",
        "Existing methods for this problem are data-driven.",
        "They consider all pairs of factors (with lengths bounded by n) occurring at aligned positions within some pair in L, and update the positive and the negative evidence of the associated transformations.",
        "They thus consider 0(Nn2) factor pairs, where each pair takes time 0(n) to be read/stored.",
        "We conclude that these methods use an amount of time 0(Nn3).",
        "We can improve on this by using suffix tree alignments.",
        "Let Lx be defined as in (2) and let h1 : (E x E) (E x E) be the homomorphism specified as:",
        "Recall that each suffix of a multi-set of strings is represented by a leaf in the associated suffix-tree, because of the use of the end-marker, and that each leaf stores the count of the occurrences of the corresponding suffix in the source multi-set.",
        "We schematically specify our first learning algorithm below.",
        "Algorithm 2 Step 1: construct two copies Tx and 7; of the suffix tree associated with Lx and align them using h1; Step 2: visit trees Tx and T;< in post-order, and annotate each node p with the number e(p) computed as the sum of the counts at leaves that p dominates; Step 3: annotate each node p of Tx with the score e(p) – e(p1), where p' = a-link(p) if a-link(p) is an actual node, p' is the node immediately dominated by a-link(p) if a-link(p) is an implicit node, and e(p') = 0 if a-link(p) is undefined; make a list of the nodes with the highest annotated score.",
        "Let p be a node of Tx associated with factor u x v. Integer e(p) computed at Step 2 is the number of times a suffix having u x v as a prefix appears in strings in Lx.",
        "Thus e(p) is the number of different positions at which factors u and v are aligned within Lx and hence the positive evidence of transformation u v w.r.t.",
        "L, as defined in Section 2.",
        "Similarly, e(p1) is the statistic of factor u x u and hence the negative evidence of u v (as well as the negative evidence of all transformations having u as left-hand side).",
        "It follows that Algorithm 2 records, at Step 3, the transformations having the highest score in L among all transformations represented by nodes of T. It is not difficult to see that the remaining transformations, denoted by implicit nodes of T, do not have score greater than the one above.",
        "The latter transformations with highest score, if any, can be easily recovered by visiting the implicit nodes that immediately dominate the nodes of Tx recorded at Step 3.",
        "A complexity analysis of Algorithm 2 is straightforward.",
        "Step 1 can be executed in time 0(Nn), as discussed in Section 3.",
        "Since the size of Tx and T;( is 0(Nn); all other steps can be easily executed in linear time.",
        "Hence Algorithm 2 runs in time 0(Nn).",
        "We now turn to a more general kind of transformations.",
        "In several natural language processing applications it is useful to generalize over some transformations of the form in (3), by using classes of symbols in E. Let t > 1 and let CI., Ct be a partition of E (each Ci 0).",
        "Consider = .",
        "• • , as an alphabet.",
        "We say that string al • • ad E E+ matches string G1 • • Cid E rs+ if ak E Ci,, for 1 < k < d. We define transformations'",
        "ing interpretation.",
        "An occurrence of string u must be rewritten to v in a text whenever u is followed by a substring matching 7.",
        "String 7 is called the right context of the transformation.",
        "The positive evidence for such transformation is the number of positions at which factors ux and vx' are aligned within the corpus, for all possible x, x1 E E+ with x matching -y.",
        "(We do not require x = x', since later transformations can change the right context.)",
        "The negative evidence for the transformation is the number of positions at which factors ux and ux' are aligned within the corpus, x, x' as above.",
        "We are not aware of any learning method for transformations of the form in (4).",
        "A naive method for this task would consider all factor pairs appearing at aligned positions in some pair in L. The left component of each factor must then be split into a string in E+ and a string in r+, to represent a transformation in the desired form.",
        "Overall, there are 0(Nn3) possible transformations, and we need time 0(n) to read/store each transformation.",
        "Then the method uses an amount of time 0(Nn4).",
        "Again, we can improve on this.",
        "We need a representation for right context strings.",
        "Define homomorphism",
        "'In generative phonology (4) is usually written as u – › v / _ 7.",
        "Our notation can more easily be generalized, as it is needed in some transformation systems.",
        "(h2 is well defined since F is a partition of E.) Let also have an a-link to a leaf of Tr dominated by p; otherwise, e' = 0; Step 4: find all pairs (p, q), p a node of Tr and (q, e, e') E r(p), such that e – e' is greater than or equal to any other el – el, (qi, el, el) in some r(pi)•",
        "where h2(w x w') appears in Lr as many times as w x w' appears in L..",
        "is inserted in r(p) if the relations depicted above are realized, where dashed arrows denote a-links, black circles denote nodes, and white circles denote nodes that might be implicit.",
        "Integer e > 0 is a count of the paths from node q downward, having the form y x y' with a prefix of y matching 7.",
        "Similarly, e' is a count of the paths from node q' downward satisfying the same matching condition with 7.",
        "The matching condition is enforced by the fact that the above paths have their ending leaf nodes a-linked to a leaf node of Ti-' dominated by node p. Below we link a suffix-tree to more than one suffix-tree.",
        "In the notation of a-links we then use a subscript indicating the suffix tree of the target node, in order to distinguish among different linkings.",
        "We now schematically specify the learning algorithm; additional computational details will be provided later in the discussion of the complexity."
      ]
    },
    {
      "heading": "Algorithm 3",
      "text": [
        "Step 1: construct two copies Tx and r< of the suffix tree associated with L. and construct the suffix tree Tr associated with Li'; Step 2: align Tx with r, using h1 and align the resulting suffix trees Tx and with Tr using h2; Step 3: for each node p of Ti-', store a set r(p) including all triples (q, e, e') such that (see Figure 4):",
        "• q is a node of Tx such that a-linkTr(q) properly dominates p • e > 0 is the sum of the counts at leaves of Tx dominated by q that have an a-link to a leaf of Tr dominated by p • if q' = a-link T (q) is defined, e' is the sum of the counts at leaves of r< dominated by q' that",
        "We next show that if pair (p, q) is found at Step 4, then q represents a factor u x v, p represents a factor h2(u x v)7, and transformation u-y v – has the highest score among all transformations represented by nodes of Tx and Tr.",
        "Similarly to the case of Algorithm 2, this is the highest score achieved in L, and other transformations with the same score can be obtained from some of the implicit nodes immediately dominating p and q.",
        "Let p add q be defined as in Step 3 above.",
        "Assume that q represents a factor u x v of some string in L. and p represents a factor 67 E F* of some string in Li', where 161 = 1u1.",
        "Since a-linkTr(q) dominates p, we must have h2(u x v) = b.",
        "Consider a suffix (u x v)(x x x')(y x y') appearing in so > 0 strings in L x , such that h2(x x x') = 7.",
        "(This means that x matches 7, and there are at least so positions at which u v has been applied with a right-context of 7.)",
        "We have that string h2 ((u x v)(x x s')(y x y')) = 67h2(y x y') must be a suffix of some strings in Li'.",
        "It follows that (u x v)(x x x')(y x y') is a leaf of Tx with a count of so, 67h2(y x y') is a leaf of Ti', and there is an a-link between these two nodes.",
        "Leaf (u x v)(x x x')(y x y') is dominated by q, and leaf 67h2(y x y') is dominated by p. Then, at Step 3, integer so is added to e. Since no condition has been imposed above on string x' and on suffix (y x y'), we conclude that the final value of e must be the positive evidence of transformation u-y – > v – .",
        "A similar argument shows that the negative evidence of this transformation is stored in e'.",
        "It then follows that, at Step 4, Algorithm 3 finds the transformations with the highest score among those represented by nodes of Tx and Ti'.",
        "Algorithm 3 can be executed in time 0(N n2).",
        "We only outline a proof of this property here, by focusing on Step 3.",
        "To execute this step we visit Ti-' in post order.",
        "At leaf node p, we consider the set F(p) of all leaves q of T. such that p = a-linkTx(q), and the set F1(p) of all leaves q' of r, such that p = a-linkTx (q').",
        "For each (implicit) node of r< that dominates some node in F' (p) and that is the target of some a-link (from some source node of Tx ), we record the sum of the counts of the dominated nodes in F' (p).",
        "This can be done in time 0 (IF' (p)I n).",
        "For each node q of Tx dominating some node in F(p), we store in r(p) the triple (q, e, e'), since a-link Tr(q) necessarily dominates p. We let e > 0 be the sum of the counts of the dominated nodes in F(p), and let e' be the value retrieved from the a-link to r<, if any.",
        "This takes time 0 (IF (p)i n).",
        "When p ranges over the leaves of",
        "Tr, we have E, IF(p)1= Ep }r(p)1 = 0(Nn).",
        "We then conclude that sets 7(p) for all leaves p of Tr can be computed in time 0(Nn2).",
        "At internal node p with children pi, 1 < i < d, d > 1, we assume that sets r(pi)'s have already been computed.",
        "Assume that for some i we have (q, ei , E r(pi) and a-linkTr(q) does not immediately dominate pi.",
        "If (q, e, e') E 7(p), we add ei, e to e, e', respectively; otherwise, we insert (q,ei,e) in r(p).",
        "We can then compute sets r(p) for all internal nodes p of Tr using an amount of time E 1r(p)1 = 0(Nn2)."
      ]
    },
    {
      "heading": "4.3 General transformations",
      "text": [
        "We have mentioned that the introduction of classes of alphabet symbols allows abstraction over plain transformations that is of interest to natural language applications.",
        "We generalize here transformations in (4) by letting 7 be a string over E U F. More precisely, we assume 7 has the form:",
        "where uo, ud E E*, ui E E+ and aj E r+ for 1 < i < d 1 and 1 <j < d, and d> 1.",
        "The notion of matching previously defined is now extended in such a way that, for a, b E E, a matches b if a = b.",
        "Then the interpretation of the resulting transformation is the usual one.",
        "The parameter d in (5) is called the number of alternations of the transformation.",
        "We have established the following results:",
        "• transformations with a bounded number of alternations can be learned in polynomial time; • learning transformations with an unbounded number of alternations is NP-hard.",
        "Again, we only give an outline of the proof below.",
        "The first result is easy to show, by observing that in an aligned corpus there are polynomially many occurrences of transformations with a bounded number of alternations.",
        "The second result holds even if we restrict ourselves to 1E1 = 2 and in 1, that is if we use a don't care symbol.",
        "Here we introduce a decision problem associated with the optimization problem of learning the transformations with the highest score, and outline an NP-completeness proof."
      ]
    },
    {
      "heading": "TRANSFORMATION SCORING (TS)",
      "text": [
        "Instance: (L, K), with L an aligned corpus, K a positive integer.",
        "Question: Is there a transformation that has score greater than or equal to K w.r.t.",
        "L?",
        "Membership in NP is easy to establish for TS.",
        "To show NP-hardness, we consider the CLIQUE decision problem for undirected, simple, connected graphs and transform such a problem to the TS problem.",
        "(The NP-completeness for the used restriction of the CLIQUE problem (Garey and Johnson, 1979) is easy to establish.)",
        "Let (G, K') be an instance of the CLIQUE problem as above, G = (V, E) and K'> 0.",
        "Without loss of generality, we assume that V = {1,2, , q}.",
        "Let E = {a, b}; we construct an instance of the TS problem (L, K) over E as follows.",
        "For each {i, j} E V with i < j let",
        "We add to the aligned corpus L:",
        "1. one instance of pair pi,j = btvi,j) for each i < j, {i,j} E E; 2. q2 instances of pair pi = (awi,j , awi,j) for each j E V with i <j and {i, j} E; 3. q2 instances of pair pa = (aaq,baq).",
        "Also, we set K = q2 + (K2).",
        "The above instance of TS can easily be constructed in polynomial deterministic time with respect to the length of (G, K') .",
        "It is easy to show that when (G, K') is a positive instance of the source problem, then the corresponding instance of TS is satisfied by at least one transformation.",
        "Assume now that there exists a transformation r having score greater equal than K > 0, w.r.t.",
        "L. Since the replacement of a with b is the only rewriting that appears in pairs of L, 7 must have the form a7 b If 7 includes some occurrence of b, then 7 cannot match pa and the positive evidence of 7 will not exceed 1E1 < < K, contrary to our assumption.",
        "We then conclude that 7 has the form (?",
        "denotes the don't care symbol): a21-l?a32-21-i?...",
        "?aq'-ja, where V\" =,id} C V, d > 0 and q' < q.",
        "If there exists i, j E V\" such that {i, j} E, then 7 would match some pair pi E L and it would have negative evidence smaller or equal than q2.",
        "Since the positive evidence of 7 cannot exceed q2 7 would have a score not exceeding 1E1 < (?))",
        "< K, contrary to our assumption.",
        "Then 7 matches no pair E L and, for each i, j E V\", we have j} E E. Since K - q2 = (K2'), at least (K2') pairs pi,j E L are matched by r. We therefore conclude that d > K' and that V\" is a clique in G of size greater equal than K'.",
        "This concludes our outline of the proof."
      ]
    },
    {
      "heading": "5 Concluding remarks",
      "text": [
        "With some minor technical changes to function Up_link_down, we can align a suffix tree with itself (w.r.t.",
        "a given homomorphism).",
        "In this way we improve space performance of Algorithms 2 and 3, avoiding the construction of two copies of the same suffix tree.",
        "Algorithm 3 can trivially be adapted to learn transformations in (4) where a left context is specified in place of a right context.",
        "The algorithm can also be used to learn traditional phonological rules of the form a b I where a, b are single phonemes and 7 is a sequence over {C, V}, the classes of consonants and vowels.",
        "In this case the",
        "algorithm runs in time 0(Nn) (for fixed alphabet).",
        "We leave it as an open problem whether rules of the form in (4) can be learned in linear time.",
        "We have been concerned with learning the best transformations that should be applied at a given step.",
        "An ordered sequence of transformations can be learned by iteratively learning a single transformation and by processing the aligned corpus with the transformation just learned (Brill, 1995).",
        "Dynamic techniques for processing the aligned corpus were first proposed in (Ramshaw and Marcus, 1996) to re-edit the corpus only where needed.",
        "Those authors report that this is not space efficient if transformation learning is done by independently testing all possible transformations in the search space (as in (Brill, 1995)).",
        "The suffix tree alignment data structure allows simultaneous scoring for all transformations.",
        "We can now take advantage of this and design dynamical algorithms that re-edit a suffix tree alignment only where needed, on the line of a similar method for suffix trees in (McCreight, 1976).",
        "An alternative data structure to suffix trees for the representations of string factors, called DAWG, has been presented in (Blumer et al., 1985).",
        "We point out here that, because a DAWG is an acyclic graph rather than a tree, straightforward ways of defining alignment between two DAWGs results in a quadratic number of a-links, making DAWGs much less attractive than suffix trees for factor alignment.",
        "We believe that suffix tree alignments are a very flexible data structure, and that other transformations could be efficiently learned using these structures.",
        "We do not regard the result in Section 4.3 as a negative one, since general transformations specified as in (5) seem too powerful for the proposed applications in natural language processing, and learning might result in corpus overtraining.",
        "Other than transformation based systems the methods presented in this paper can be used for learning rules of constraint grammars (Karlsson et al., 1995), phonological rule systems as in (Kaplan and Kay, 1994), and in general those grammatical systems using constraints represented by means of rewriting rules.",
        "This is the case whenever we can encode the alphabet of the corpus in such a way that alignment is possible."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "Part of the present research was done while the first author was visiting the Center for Language and Speech Processing, Johns Hopkins University, Baltimore, MD.",
        "The second author is a member of the Center for Language and Speech Processing.",
        "This work was funded in part by NSF grant IRI-9502312.",
        "The authors are indebted to Eric Brill for technical discussions on topics related to this paper."
      ]
    }
  ]
}
