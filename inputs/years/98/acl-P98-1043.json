{
  "info": {
    "authors": [
      "Michael A. Covington"
    ],
    "book": "COLING-ACL",
    "id": "acl-P98-1043",
    "title": "Alignment of Multiple Languages for Historical Comparison",
    "url": "https://aclweb.org/anthology/P98-1043",
    "year": 1998
  },
  "references": [
    "acl-J94-3004",
    "acl-J96-4002"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "An essential step in comparative reconstruction is to align corresponding phonological segments in the words being compared.",
        "To do this, one must search among huge numbers of potential alignments to find those that give a good phonetic fit.",
        "This is a hard computational problem, and it becomes exponentially more difficult when more than two strings are being aligned.",
        "In this paper I extend the guided-search alignment algorithm of Covington (Computational Linguistics, 1996) to handle more than two strings.",
        "The resulting algorithm has been implemented in Prolog and gives reasonable results when tested on data from several languages."
      ]
    },
    {
      "heading": "1 Background",
      "text": [
        "The Comparative Method for reconstructing languages consists of at least the following steps:",
        "1.",
        "Choose sets of words in the daughter languages that appear to be cognate; 2.",
        "Align the phonological segments that appear to correspond (e.g., skip the [1(] when aligning German Pali] with English [niy] 'knee') ;1 3.",
        "Find regular correspondence sets (proto-allophones, Hoenigswald 1950); 4.",
        "Classify the proto-allophones into proto-phonemes with phonological rules (sound laws).",
        "The results of each step can be used to refine guesses made at previous steps.",
        "For example, 'These phonetic transcriptions may nor may not be phonemic.",
        "Because of the way the Comparative Method works, synchronic allophony is, in general, factored out along with diachronic allophony as the reconstruction proceeds.",
        "a regular correspondence, once discovered, can be used to refine one's choice of alignments and even putative cognates.",
        "Parts of the Comparative Method have been computerized by Frantz (1970), Hewson (1974), Wimbish (1989), and Lowe and Mazaudon (1994), but none of them have tackled the alignment step.",
        "Covington (1996) presents a workable alignment algorithm for comparing two languages.",
        "In this paper I extend that algorithm to handle more than two languages at once."
      ]
    },
    {
      "heading": "2 Multiple-string alignment",
      "text": [
        "The alignment step is hard to automate because there are too many possible alignments to choose from.",
        "For example, French le [la] and Spanish el [el] can be lined up at least three ways: Of these, the second is etymologically correct, and the third would merit consideration if one did not know the etymology.",
        "The number of alignments rises exponentially with the length of the strings and the number of strings being aligned.",
        "Two ten-letter strings have anywhere from 26,797 to 8,079,453 different alignments depending on exactly what alignments are considered distinct (Covington 1996, Covington and Canfield 1996).",
        "As for multiple strings, if two strings have A alignments then n strings have roughly An-1 alignments, assuming the alignments are generated by aligning the first two strings, then aligning the third string against the second, and so forth.",
        "In fact, the search space isn't quite that large because some combinations are equivalent to others, but it is clearly too large to search exhaustively.",
        "el lo el - - la -el la",
        "Fortunately the comparative linguist is not looking for all possible alignments, only the ones that are likely to manifest regular sound correspondences – that is, those with a reasonable degree of phonetic similarity.",
        "Thus, phonetic similarity can be used to constrain the search."
      ]
    },
    {
      "heading": "3 Applying an evaluation metric",
      "text": [
        "The phonetic similarity criterion used by Covington (1996) is shown in Table 1.",
        "It is obviously just a stand-in for a more sophistiCated, perhaps feature-based, system of phonology.",
        "The algorithm computes a \"badness\" or \"penalty\" for each step (column) in the alignment, summing the values to judge the badness of the whole alignment, thus:",
        "The alignment with the lowest total badness is the one with the greatest phonetic similarity.",
        "Note that two separate skips count exactly the same as one complete mismatch; thus the alignments",
        "are equally valued.",
        "In fact, a \"no-alternatingskips rule\" prevents the second one from being generated; deciding whether [e] and [1] correspond is left for another, unstated, part of the comparison process.",
        "I will explain below why this is not satisfactory.",
        "Naturally, the alignment with the best overall phonetic similarity is not always the etymologically correct one, although it is usually close; we are looking for a good phonetic fit, not necessarily the best one."
      ]
    },
    {
      "heading": "4 Generalizing to three or more languages",
      "text": [
        "When a guided search is involved, aligning strings from three or more languages is not simply a matter of finding the best alignment of the first two, then adding a third, and then a fourth, and so on.",
        "Thus, an algorithm to align two strings cannot be used iteratively to align more than two.",
        "The reason is that the best overall alignment of three or more strings is not necessarily the best alignment of any given pair in the set.",
        "Fox (1995:68) gives a striking example, originally from Haas (1969).",
        "The best alignment of the Choctaw and Cree words for 'squirrel' appears to be: Choctaw f an i Cree -ilu Here the correspondence [a]:[i] is problematic.",
        "Add the Koasati word, though, and it becomes clear that the correct alignment is actually: Choctaw Koasati Cree Any algorithm that started by finding the best alignment of Choctaw against Cree would miss this solution.",
        "A much better strategy is to evaluate each column of the alignment (I'll call it a \"step\") before generating the next column.",
        "That is, evaluate the first step, and then the second step,",
        "and so on.",
        "At each step, the total badness is computed by comparing each segment to all of the other segments.",
        "Thus the total badness of a",
        "That way, no string gets aligned against another without considering the rest of the strings in the set.",
        "Another detail has to do with skips.",
        "Empirically, I found that the badness of comes out too high if computed as",
        "that is, the algorithm is too reluctant to take skips.",
        "The reason, intuitively, is that in this alignment step, there is really only one skip, not two separate skips (one skipping VI and one skipping [pp.",
        "This becomes even more apparent when more than three strings are being aligned.",
        "Accordingly, when computing badness I count each skip only once (assessing it 50 points), then ignore skips when comparing the segments against each other.",
        "I have not implemented the rule from Covington (1996) that gives a reduced penalty for adjacent skips in the same string to reflect the fact that affixes tend to be contiguous."
      ]
    },
    {
      "heading": "5 Searching the set of alignments",
      "text": [
        "The standard way to find the best alignment of two strings is a matrix-based technique known as dynamic programming (Ukkonen 1985, Waterman 1995).",
        "However, dynamic programming cannot accommodate rules that look ahead along the string to recognize assimilation or metathesis, a possibility that needs to be left open when implementing comparative reconstruction.",
        "Additionally, generalization of dynamic programming to multiple strings does not entirely appear to be a solved problem (cf. Ke-cecioglu 1993).",
        "Accordingly, I follow Covington (1996) in recasting the problem as a tree search.",
        "Consider the problem of aligning Eel] with Rai.",
        "Covington (1996) treats this as a process that steps through both strings and, at each step, performs either a \"match\" (accepting a character from both strings), a \"skip-1\" (skipping a character in the first string), or a \"skip-2\" (skipping a character in the second string).",
        "That results in the search tree shown in Fig. 1 (ignoring Cov-ington's \"no-alternating-skips rule\").",
        "The search tree can be generalized to multiple strings by breaking up each step into a series of operations, one on each string, as shown in Fig. 2.",
        "Instead of three choices, match, skip-1, and skip-2, there are really 2 x 2: accept or skip on string 1 and then accept or skip on string 2.",
        "One of the four combinations is disallowed – you can't have a step in which no characters are accepted from any string.",
        "Similarly, if there were three strings, there would be three two-way decisions, leading to eight (= 23) states, one of which would be disallowed.",
        "Using search trees of this type, the decisions necessary to align any number of strings can be strung together in a satisfactory way."
      ]
    },
    {
      "heading": "6 Alternating skips",
      "text": [
        "Covington (1996) considers the alignments e 1 1 - equivalent and generates only the first of them, leaving it to some later step in the comparison process to decide whether [e] and [1] really correspond.",
        "The rule is:",
        "NO-ALTERNATING-SKIPS RULE: If there is",
        "a skip in one string, there cannot be a skip in the other string at the next step.",
        "Although this tactic narrows the search space, I do not think this is linguistically satisfactory; after all, aligning [e] with [1] and skipping them in tandem are quite different linguistic claims.",
        "Consider for example the final segment of Spanish [dos] and Italian [due] `two'; it is correct to skip the [s] and the [e] in tandem because they come from different Latin endings.",
        "It is not historically correct to pair [s] with [e] in a correspondence set.",
        "string 1 string 2 string 1 string 2 string 1..."
      ]
    },
    {
      "heading": "II",
      "text": [
        "Step 1 Step 2 Step 3...",
        "Also, the no-alternating-skips rule does not generalize easily to multiple strings.",
        "I therefore replace it with a different restriction:",
        "- - - a b c de f - -",
        "-a-b-c a b c - - English three,2 the algorithm finds its \"best\" d-e-f- - -def alignment, or numerous other equivalent combinations of skips."
      ]
    },
    {
      "heading": "7 Pruning the search",
      "text": [
        "The goal of the algorithm is, of course, to generate not the whole search tree, but only the parts of it likely to contain the best alignments, thereby narrowing the intractably large search space into something manageable.",
        "Following Covington (1996), I implemented a very simple pruning strategy.",
        "The program keeps track of the badness of the best complete alignment found so far.",
        "Every branch in the search tree is abandoned as soon as its total badness exceeds that value.",
        "Thus, bad alignments are abandoned when they have only partly been generated.",
        "A second part of the strategy is that the computer always tries matches before it tries skips.",
        "As a result, if not much material needs to be skipped, a good alignment is found very quickly.",
        "For example, three four-character strings have 10,536 alignments (generated my way), but when comparing Spanish tres, French trois, and tr-es t r w a - Or iy after completing only ten other alignments, although it also pursues several hundred branches of the tree part of the way.",
        "(Here the match of [s] with [y1 is problematic, but the computer can't know that; it also finds a number of alternative alignments.)"
      ]
    },
    {
      "heading": "8 Results and evaluation",
      "text": [
        "The algorithm has been prototyped in LPA Pro-log, and Table 2 shows some of the alignments it found.",
        "None of these took more than five seconds on a 133-MHz Pentium, and the Prolog program was written for versatility, not speed.",
        "As comparative linguists know, the alignment that gives the best phonetic fit (by any criterion) is not always the etymologically correct one.",
        "This is evident with my algorithm.",
        "For",
        "instance, comparing the Sanskrit, Greek, and Latin words for 'field,' the algorithm finds the correct alignment, age r - - ag- r os aj-ras (badness = 365) but then discards it in favor of a seemingly better alignment: age r - - ag- r os a jras (badness = 345) It doesn't know, of course, that [gl:[j] is a phonetically probable correspondence.",
        "Worse, occasionally the present algorithm doesn't consider the etymologically correct alignment at all because something that looks better has already been found.",
        "For example, taking the Avestan, Greek, and Latin words for '100', the algorithm settles on - sat am hekat on ken tum (badness 610) without ever considering the etymologically correct alignment: --sa- tam heka- ton - -kent um (badness 690) The penalties for skips may still be too high here, but the real problem is, of course, that the algorithm is looking for the one best alignment, and that's not what comparative reconstruction needs.",
        "Instead, the computer should prune the search tree less eagerly, pursuing any alignment whose badness is, say, no more than 120% of the lowest found so far, and delivering all solutions that are reasonably close to the best one found during the entire procedure.",
        "Indeed, the availability of multiple potential alignments is the keystone of Kay's (1964) proposal to implement the Comparative Method, which could not be implemented at the time Kay proposed it because of the lack of an efficient search algorithm.",
        "The requisite modification is easily made and I plan to pursue it in subsequent work."
      ]
    }
  ]
}
