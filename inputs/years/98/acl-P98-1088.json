{
  "info": {
    "authors": [
      "Mark Hepple"
    ],
    "book": "COLING-ACL",
    "id": "acl-P98-1088",
    "title": "Memoisation for Glue Language Deduction and Categorial Parsing",
    "url": "https://aclweb.org/anthology/P98-1088",
    "year": 1998
  },
  "references": [
    "acl-C92-1024",
    "acl-C96-1091",
    "acl-E93-1013",
    "acl-E95-1018",
    "acl-E95-1019",
    "acl-P97-1019"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "The multiplicative fragment of linear logic has found a number of applications in computational linguistics: in the \"glue language\" approach to LFG semantics, and in the formulation and parsing of various categorial grammars.",
        "These applications call for efficient deduction methods.",
        "Although a number of deduction methods for multiplicative linear logic are known, none of them are tabular methods, which bring a substantial efficiency gain by avoiding redundant computation (c.f.",
        "chart methods in CFG parsing): this paper presents such a method, and discusses its use in relation to the above applications."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The multiplicative fragment of linear logic, which includes just the linear implication (0 – ) and multiplicative (0) operators, has found a number of applications within linguistics and computational linguistics.",
        "Firstly, it can be used in combination with some system of labelling (after the 'labelled deduction' methodology of (Gabbay, 1996)) as a general method for formulating various categorial grammar systems.",
        "Linear deduction methods provide a common basis for parsing categorial systems formulated in this way.",
        "Secondly, the multiplicative fragment forms the core of the system used in work by Dalrymple and colleagues for handling the semantics of LFG derivations, providing a 'glue language' for assembling the meanings of sentences from those of words and phrases.",
        "Although there are a number of deduction methods for multiplicative linear logic, there is a notable absence of tabular methods, which, like chart parsing for CFGs, avoid redundant computation.",
        "Hepple (1996) presents a compilation method which allows for tabular deduction for implicational linear logic (i.e. the fragment with only o – ).",
        "This paper develops that method to cover the fragment that includes the multiplicative.",
        "The use of this method for the applications mentioned above is discussed."
      ]
    },
    {
      "heading": "2 Multiplicative Linear Logic",
      "text": [
        "Linear logic is a 'resource-sensitive' logic: in any deduction, each assumption ('resource') is used precisely once.",
        "The formulae of the multiplicative fragment of (intuitionistic) linear logic are defined by .7\" ::------ A IFo – F I .F 0 ,T (A a nonempty set of atomic types).",
        "The following rules provide a natural deduction formulation:",
        "The elimination (E) and introduction (I) rules for o – correspond to steps of functional application and abstraction, respectively, as the term labelling reveals.",
        "The o – I rule discharges precisely one assumption (B) within the proof to which it applies.",
        "The 01 rule pairs together the premise terms, whereas 0E has a substitution like meaning.'",
        "Proofs that W0 – (X0 – Z), Xo – Y, Yo – Z W and that Xo – Yo – Z, YOZ X follow:",
        "The differential status of the assumptions and goal of a deduction (i.e. between r and A in F A) is addressed in terms of polarity: assumptions are deemed to have positive polarity, and goals negative polarity.",
        "Each Sub-formula also has a polarity, which is determined by the polarity of the immediately containing (sub)formula, according to the following schemata (where 25 is the opposite polarity to p):",
        "For example, the leftmost assumption of the first proof above has the polarity pattern ( W+ o – (X – 0 Z+ ) – ).",
        "The proofs illustrate the phenomenon of 'hypothetical reasoning', where additional assumptions (called 'hypotheticals') are used, which are later discharged.",
        "The need for hypothetical reasoning in a proof is driven by the types of the assumptions and goal: the hypotheticals correspond to positive polarity subformulae of the assumptions/goal that occur in the following subformula contexts: i) (X – o – Y+) – (giving hypothetical Y) ii) (X+ ®Y) (giving hypo's X and Y) The subformula (Xo – Z) of Wo – (Xo – Z) in the proof above is an instance of context (i), so a hypothetical Z results.",
        "Subformulae that are instances of patterns (i,ii) may nest within other such instances (e.g. in ((A0B)0C)o – D, both ((A0B)0C) and (AB) are instances of (ii)).",
        "In such cases, we can focus on the maximal pattern instances (i.e. not contained within any other), and then examine the hypotheticals produced for whether they in turn license hypothetical reasoning.",
        "This approach makes explicit the patterns of dependency amongst hypothetical elements."
      ]
    },
    {
      "heading": "3 First-order Compilation for Implicational Linear Logic",
      "text": [
        "Hepple (1996) shows how deductions in implicational linear logic can be recast as deductions involving only first-order formulae, using only a single inference rule (a variant of o – E).",
        "The method involves compiling the original formulae to indexed first-order formulae, where a higher-order2 initial formula yields multiple compiled formulae, e.g. (omitting indices) Xo – (Yo – Z) would yield Xo – Y and Z, i.e. with the subformula Z, relevant to hypothetical reasoning, being excised to be treated as a separate assumption, leaving a first-order residue.3 Indexing is used to ensure general linear use of resources, but also notably to ensure proper use of excised subformulae, i.e. so that Z, in our example, must be used in deriving the argument of Xo – Y, or otherwise invalid deductions would result).",
        "Simplifying X0 – (Yo – Z) to Xo – Y removes the need for an o – I inference, but the effect of such a step is not lost, since it is compiled into the semantics of the formula.",
        "The approach is best explained by example.",
        "In proving X0 – (Yo – Z), Yo – W, Wo – Z X, the premise formulae compile to the indexed formulae (1-4) shown in the proof below.",
        "Each of these formulae (1-4) is associated with a set containing a single index, which serves as a unique identifier for that assumption.",
        "1. : X0 – (Y:{j}) : Au.x(Az.u) 2.",
        "{j}:Z:z 2.",
        "{k} : Yo – (W: 0) : Au.yu 4.",
        "{/} : Wo – (Z: 0) : Au.wu 5.",
        "{j, /} :W :wz [2+4] 6.",
        "{j, k, l} :Y : y(wz) [3+5] 7.",
        "{i, j, k, : X : x (Az .y(wz)) [1+6]",
        "The formulae (5-7) arise under combination, allowed by the single rule below.",
        "The index sets of these formulae identify precisely the assumptions from which they are derived, with appropriate indexation being ensured by the condition 7r = q5ki-J7k of the rule (where-W- stands for disjoint union, which enforces linear usage).",
        ": Ao – (B:a): Av.a B: b ir=hb",
        "2 The key division here is between higher-order formulae, which are are functors that seek at least one argument that bears a a functional type (e.g. Wo – (Xo – Z)), and first-order formulae, which seek no such argument.",
        "3 This 'excision' step has parallels to the 'emit' step used in the chart-parsing approaches for the associative Lambek calculus of (Kiinig, 1994) and (Hepple, 1992), although the latters differs in that there is no removal of the relevant subformula, i.e. the 'emitting formula' is not simplified, remaining higher-order.",
        "Assumptions (1) and (4) both come from Xo – (Yo – Z): note how (1)'s argument is marked with (4)'s index (j).",
        "The condition a C tp of the rule ensures that (4) must contribute to the derivation of (1)'s argument.",
        "Finally, observe that the rule's semantics involves not simple application, but rather by direct substitution for the variable of a lambda expression, employing a special variant of substitution, notated _[_//.._], which specifically does not act to avoid accidental binding.",
        "Hence, in the final inference of the proof, the variable z falls within the scope of an abstraction over z, becoming bound.",
        "The abstraction over z corresponds to an o – I step that is compiled into the semantics, so that an explicit inference is no longer required.",
        "See (Hepple, 1996) for more details, including a precise statement of the compilation procedure."
      ]
    },
    {
      "heading": "4 First-order Compilation for Multiplicative Linear Logic",
      "text": [
        "In extending the above approach to the multiplicative, we will address the OI and OE rules as separate problems.",
        "The need for an OI use within a proof is driven by the type of either some assumption or the proof's overall goal, e.g. to build the argument of an assumption such as Ao – (BOC).",
        "For this specific example, we might try to avoid the need for an explicit 01 use by transforming the assumption to the form Ao – Bo – C (note that the two formulae are interderivable).",
        "This line of exploration, however, leads to incompleteness, since the manoeuvre results in proof structures that lack a node corresponding to the result of the OI inference (which is present in the natural deduction proof), and this node may be needed as the locus of some other inference.4 This problem can be overcome by the use of goal atoms, which are unique pseudo-type atoms, that are introduced into types by compilation (in the parlance of lisp, they are tensymmed' atoms).",
        "An assumption Ao – (BOC) would compile to Ac – g plus go-Bo-c, where g is the unique goal atom (gl, perhaps).",
        "A proof using these types does contain a node corresponding to (what would be) the result of the 0 inference in the natural 4Specifically, the node must be present to allow for steps corresponding to OE inferences.",
        "The expert reader should be able to convince themselves of this fact by considering an example such as Xo – ((YOU)o – (ZOU)), Yo – Z X. deduction proof, namely that bearing type g, the result of combining go-Bo-c with its arguments.",
        "This method can be used in combination with the existing compilation approach.",
        "For example, an initial assumption Ao – ((BOC)o – D) would yield a hypothetical D, leaving the residue A0 – (BOC), which would become Ao – g plus go – Bo – C, as just discussed.",
        "This method of uniquely-generated 'goal atoms' can also be used in dealing with deductions having complex types for their intended overall result (which may license hypotheticals, by virtue of realising the polarity contexts discussed in section 2).",
        "Thus, we can replace an initial deduction F A with go-A, r g, making the goal A part of the left hand side.",
        "The new premise go-A can be compiled just like any other.",
        "Since the new goal formula g is atomic, it requires no compilation.",
        "For example, a goal type Xo – Y would become an extra premise go-(xo-y), which would compile to formulae go-x plus Y.",
        "Turning next to OE, the rule involves hypothetical reasoning, so compilation of a maximal positive polarity subformula BOC will add hypotheticals B,C.",
        "No further compilation of BOC itself is then required: whatever is needed for hypothetical reasoning with respect to the internal structure of its subformulae will arise elsewhere by compilation of the hypotheticals B,C.",
        "Assume that these latter hypotheticals have identifying indices i, j and semantic variables x,y respectively.",
        "A rule for OE might combine BOC (with term t, say) with any other formula A (with term s, say) provided that the latter has a disjoint index set that includes i, j, to give a result that is also of type A, that is assigned semantics E2,y(t,․).",
        "To be able to construct this semantics, the rule would need to be able to access the identities of the variables x, y.",
        "The need to explicitly annotate this identity information might be avoided by 'raising' the semantics of the multiplicative formula at compilation time to be a function over the other term, e.g. t might be raised to Au.E2,y (t, u).",
        "A usable inference rule might then take the following form (where the identifying indices of the hypotheticals have been marked on the product type):",
        "Note that we can safely restrict the rule to require that the type A of the minor premise is atomic.",
        "This is possible since firstly, the first-order compilation context ensures that the arguments required by a functor to yield an atomic result are always present (with respect to completing a valid deduction), and secondly, the alternatives of combining a functor with a multiplicative under the rule either before or after supplying its arguments are equivalent.5 In fact, we do not need the rule above, as we can instead achieve the same effects using only the single (0--) inference rule that we already have, by allowing a very restricted use of type polymorphism.",
        "Thus, since the above rule's conclusion and minor premise are the same atomic type, we can in the compilation simply replace a formula X0Y, with an implication Ao – (A: {i, j}), where A is a variable over atomic types (and i, j the identifying indices of the two hypotheticals generated by compilation).",
        "The semantics provided for this functor is of the 'raised' kind discussed above.",
        "However, this approach to handling 0E inferences within the compiled system has an undesirable characteristic (which would also arise using the inference rule discussed above), which is that it will allow multiple derivations that assign equivalent proof terms for a given type combination.",
        "This is due to non-determinism for the stage at which a type such as Ao – (A: { j}) participates in the proof.",
        "A proof might contain several nodes bearing atomic types which contain the required hypotheticals, and Ao – (A: j}) might combine in at any of these nodes, giving equivalent results.",
        "The above ideas for handling the multiplicative are combined with the methods developed 'This follows from the proof term equivalence (ga)) = (EL(f,g) a) where x, y E freevars(g).",
        "The move of requiring the minor premise to be atomic effects a partial normalisation which involves not only the relative ordering of OE and o – E steps, but also that between interdependent OE steps (as might arise for an assumption such as ((A0B)0C)).",
        "It is straightforward to demonstrate that the restriction results in no loss of readings.",
        "See (Benton et ai., 1992) regarding term assignment and proof normalisation for linear logic.",
        "for the implicational fragment to give the compilation procedure (7), stated in Figure 1.",
        "This takes a sequent r A as input (case 7-1), where A is a type and each assumption in I' takes the form Type:Sem (Sem minimally just some unique variable), and it returns a structure (g, 0, A), where g is a goal atom, (/) the set of all identifying indices, and A a set of indexed first order formulae (with associated semantics).",
        "Let A* denote the result of closing A under the single inference rule.",
        "The sequent is proven if (0, g, t) E A* for some term t, which is a complete proof term for the implicit deduction.",
        "The statement of the compilation procedure here is somewhat different to that given in (Hepple, 1996), which is based on polar translation functions.",
        "In the version here, the formula related cases address only positive formulae.7 As an example, consider the deduction Xo – Y, YOZ X0Z.",
        "Compilation returns the goal atom gO, the full index set {g, h, j, k , 1} , plus the formulae show in (1-6) below.",
        "The formulae (7-13) arise under combination.",
        "Formulae (11) and (13) correspond to successful overall analyses (i.e. have type gO, and are labelled with the full index set).",
        "The proof illustrates the possibility of multiple derivations 7 Note that the complexity of the compilation is linear in the 'size' of the initial deduction, as measured by a count of type atoms.",
        "For applications where the formulae that may participate are preset (e.g. they are drawn from lexicon), formulae can be precompiled, although the results of precompilation would need to be parametised with respect to the variables/indices appearing, with a sufficient supply 'fresh' symbols being generated at time of lexical access, to ensure uniqueness.",
        "T(Xi: Xi, .",
        "• , Xn,: Xn X0) (g (1), A) where io, • • • in fresh indices; g a fresh goal atom; 0 = indices(A)",
        "where Y is atomic; x a fresh variable; 71(0, (sx))) = (07 X2, t) xo--((70--z): 0), s)) = ((0, X 0 (Y : 7), Ay.s(Az.y))) U r((i, Z, z)) where i a fresh index; y, z fresh variables; 7r=iU//) 7((cp, Xo-((Y 0 Z): 0), s)) = WI), X c (g: 7), s)) U r((i, go-Yo-Z, AzAy.",
        "(Y 0 z))) where i a fresh index; g a fresh goal atom; y, z fresh variables; it =i1.4 7((0, X 0 Y, s)) = (4), Ao- - (A: {i, j}), At.",
        "(EL(s, t))) U r((i, X, x)) U T((j, Y, y)) where i, j fresh indices; x, y, t fresh variables; A a fresh variable over atomic types assigning equivalent readings, i.e. (11) and (13) have identical proof terms, that arise by non-determinism for involvement of formula (4)."
      ]
    },
    {
      "heading": "5 Computing Exclusion Constraints",
      "text": [
        "The use of inclusion constraints (i.e. requirements that some formula must be used in deriving a given functor's argument) within the approach allows us to ensure that hypotheticals are appropriately used in any overall deduction and hence that deductions are valid.",
        "However, the approach allows that deduction can generate some intermediate results that cannot be part of an overall deduction.",
        "For example, compiling a formula Xo-(Yo-(Zo-W))0-(Vo-W) gives the first-order residue Xo-Yo-V, plus hypotheticals Zo-W and W. A partial deduction in which the hypothetical Zo-W is used in deriving the argument V of Xo-Yo-V cannot be extended to a successfull overall deduction, since its use again for the functor's second argument Y (as an inclusion constraint will require) would violate linear usage.",
        "For the same reason, a direct combination of the hypotheticals Zo-W and W is likewise a deductive dead end.",
        "This problem can be addressed via exclusion constraints, i.e. annotations to forbid stated formulae having been used in deriving a given funtor's argument, as proposed in (Hepple, 1998).",
        "Thus, a functor might have the form Xo-(Y:{i}:{j}) to indicate that i must appear in its argument's index set, and that j must not.",
        "Such exclusions can be straightforwardly computed over the set of compiled formulae that derive from each initial assumption, using simple (set-theoretic) patterns of reasoning.",
        "For example, for the case above, since W must be used in deriving the argument V of the main residue formula, it can be excluded from the argument Y of that formula (which follows from the disjointness condition on the single inference rule).",
        "Given that the argument Y must include Zo-W, but excludes W, we can infer that W cannot contribute to the argument of Zo-W, giving an exclusion constraint that (amongst other things) blocks the direct combination of Zo-W and W. See (Hepple, 1998) for more details (although a slightly different version of the first-order formalism is used there)."
      ]
    },
    {
      "heading": "6 Tabular Deduction",
      "text": [
        "A simple algorithm for use with the above approach, which avoids much redundant computation, is as follows.",
        "Given a possible theorem to prove, the results of compilation (i.e. indexed types plus semantics) are gathered on an agenda.",
        "Then, a loop is followed in which an item is taken from the agenda and added to the database (which is initially empty), and then the next triple is taken from the agenda and",
        "so on until the agenda is empty.",
        "Whenever an entry is added to the database, a check is made to see if it can combine with any that are already there, in which case new agenda items are generated.",
        "When the agenda is empty, a check is made for any successful overall analyses.",
        "Since the result of a combination always bears an index set larger than either parent, and since the maximal index set is fixed at compilation time, the above process must terminate.",
        "However, there is clearly more redundancy to be eliminated here.",
        "Where two items differ only in their semantics, their subsequent involvement in any further deductions will be precisely parallel, and so they can be collapsed together.",
        "For this purpose, the semantic component of database entries is replaced with a unique identifer, which serves as a 'hook' for semantic alternatives.",
        "Agenda items, on the other hand, instead record the way that the agenda item was produced, which is either 'presupplied' (by compilation) or `by combination', in which case the entries combined are recorded by their identifiers.",
        "When an agenda item is added to the database, a check is made for an entry with the same indexed type.",
        "If there is none, a new entry is created and a check made for possible combinations (giving rise to new agenda items).",
        "However, if an appropriate existing entry is found, a record is made for that entry of an additional way to produce it, but no check made for possible combinations.",
        "If at the end there is a successful overall analsysis, its unique identifier, plus the records of what combined to produce what, can be used to enumerate directly the proof terms for successful analyses."
      ]
    },
    {
      "heading": "7 Application #1: Categorial",
      "text": []
    },
    {
      "heading": "Parsing",
      "text": [
        "The associative Lambek calculus (Lambek, 1958) is perhaps the most familiar representative of the class of categorial formalisms that fall within the 'type-logical' tradition.",
        "Recent work has seen proposals for a range of such systems, differing in their resource sensitivity (and hence, implicitly, their underlying notion of 'linguistic structure'), in some cases combining differing resource sensitivities in one system.8 Many of 8See, for example, the formalisms developed in (Moortgat et al., 1994), (Morrill, 1994), (Hepple, 1995).",
        "these proposals employ a 'labelled deductive system' methodology (Gabbay, 1996), whereby types in proofs are associated with labels which record proof information for use in ensuring correct inferencing.",
        "A natural 'base logic' on which to construct such systems is the multiplicative fragment of linear logic, since (i) it stands above the various categorial systems in the hierarchy of substructural logics, and (ii) its operators correspond to precisely those appearing in any standard categorial logic.",
        "The key requirement for parsing categorial systems formulated in this way is some theorem proving method that is sufficient for the fragment of linear logic employed (although some additional work will be required for managing labels), and a number of different approaches have been used, e.g. proof nets (Moortgat, 1992), and SLD resolution (Morrill, 1995).",
        "Hepple (1996) introduces first-order compilation for implicational linear logic, and shows how that method can be used with labelling as a basis parsing implicational categorial systems.",
        "No further complications arise for combining the extended compilation approach described in this paper with labelling systems as a basis for efficient, non-redundant parsing of categorial formalisms in the core multiplicative fragment.",
        "See (Hepple, 1996) for a worked example."
      ]
    },
    {
      "heading": "8 Application #2: Glue Language Deduction",
      "text": [
        "In a line of research beginning with Dalrymple et al.",
        "(1993), a fragment of linear logic is used as a 'glue language' for assembling sentence meanings for LFG analyses in a 'deductive' fashion (enabling, for example, an direct treatment of quantifier scoping, without need of additional mechanisms).",
        "Some sample expressions:"
      ]
    },
    {
      "heading": "hates:",
      "text": [
        "The operator serves to pair together a 'role' with a meaning expression (whose semantic type is shown by a subscript), where a 'role' is essentially a node in a LFG f-structure.",
        "For our purposes roles can be treated as if they were just atomic symbols.",
        "For theorem proving purposes, the universal quantifiers above can be deleted: the uppercase variables can be treated",
        "as Prolog-like variables, which become instantiated under matching during proof construction; the lowercase variables can be replaced by arbitrary constants.",
        "Such deletion leaves a residue that can be treated as just expressions of multiplicative linear logic, with role/meaning pairs serving as `basic formulae'.9 An observation contrasting the categorial and glue language approaches is that in the categorial case, all that is required of a deduction is the proof term it returns, which (for 'linguistic derivations') provides a `semantic recipe' for combining the lexical meanings of initial formulae directly.",
        "However, for the glue language case, given the way that meanings are folded into the logical expressions, the lexical terms themselves must participate in a proof for the semantics of a LFG derivation to be produced.",
        "Here is one way that the first-order compilation approach might be used for glue language deduction (other ways are possible).",
        "Firstly, we can take each (quantifier-free) glue term, replace each role/meaning pair with just the role component, and associate the resulting formula with a unique semantic variable.",
        "The set of formulae so produced can then undergo the first-order compilation procedure.",
        "Crucially for compilation, although some of the role expressions in the formulae may be (Prolog-like') variables, they correspond to atomic formulae (so there is no `hidden structure' that compilation cannot address).",
        "A complication here is that occurrences of a single role variable may end up in different first-order formulae.",
        "In any overall deduction, the binding of these multiple variable instances must be consistent, but we cannot rely on a global binding context, since alternative proofs will typically induce distinct (but internally consistent) bindings.",
        "Hence, bindings must be handled locally (i.e. relative to each database formula) and combinations will involve merging of local binding contexts.",
        "Each proof term that tabular deduction returns corresponds to a natural deduction proof over the precompilation formulae.",
        "If we mechanically mirror this pattern of proof over the original glue terms (with meanings, but quantifier-free), a role/meaning",
        "pair that provides a reading of the original LFG derivation will result."
      ]
    }
  ]
}
