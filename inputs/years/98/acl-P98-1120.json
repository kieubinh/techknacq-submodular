{
  "info": {
    "authors": [
      "Yves Lepage"
    ],
    "book": "COLING-ACL",
    "id": "acl-P98-1120",
    "title": "Solving analogies on words: an algorithm",
    "url": "https://aclweb.org/anthology/P98-1120",
    "year": 1998
  },
  "references": [
    "acl-C90-3101",
    "acl-C94-1037",
    "acl-C96-1046",
    "acl-C96-2121",
    "acl-P97-1055"
  ],
  "sections": [
    {
      "heading": "Introduction",
      "text": [
        "To introduce the algorithm presented in this paper, we take a path that is inverse to the historical development of the idea of analogy (see (Hoffman 95)).",
        "This is necessary, because a certain incomprehension is faced when speaking about linguistic analogy, i.e., it is generally given a broader and more psychological definition.",
        "Also, with our proposal being computational, it is impossible to ignore works about analogy in computer science, which has come to mean artificial intelligence."
      ]
    },
    {
      "heading": "1 A Survey of Works on Analogy",
      "text": [
        "This paper is not intended to be an exhaustive study.",
        "For a more comprehensive study on the subject, see (Hoffman 95)."
      ]
    },
    {
      "heading": "1.1 Metaphors, or Implicit Analogies",
      "text": [
        "Beginning with works in psychology and artificial intelligence, (Gentner 83) is a milestone study of a possible modeling of analogies such as, \"an atom is like the solar system\" adequate for artificial intelligence.",
        "In these analogies, two domains are mapped, one onto the other, thus modeling of the domain becomes necessary.",
        "sun nucleus planet 4 electron In addition, properties (expressed by clauses, formulae, etc.)",
        "are transferred from one domain onto the other, and their number somehow determines the quality of the analogy.",
        "attracts (sun, 4 attracts (nucleus , planet) electron) moremassive(sun, L moremassive(nucleus, planet) electron) However, Gentner's explicit description of sentences as \"an A is like a B\" as analogies is subject to criticism.",
        "Others (e.g. (Steinhart 94)) prefer to call these sentences metaphors', the validity of which rests on sentences of the kind, \"A is to B as C is to D\", for which the name analogy2 is reserved.",
        "In other words, some metaphors are supported by analogies.",
        "For instance, the metaphor, \"an atom is like the solar system\", relies on the analogy, \"an electron is to the nucleus, as a planet is to the sun\" .3 The answer of the Al community is complex because they have headed directly to more complex problems.",
        "For them, in analogies or metaphors (Hall 89):",
        "• two different domains appear • for both domains, modeling of a knowledge-base is necessary • mapping of objects and transfer of properties are different operations • the quality of analogies has to be evaluated as a function of the strength (number, truth, etc.)",
        "of properties transferred.",
        "We must drastically simplify all this and enunciate a simpler problem (whose resolution may not necessarily be simple).",
        "This can be achieved by simplifying data types, and consequently the characteristics of the problem."
      ]
    },
    {
      "heading": "1.2 Multiplicity vs Unicity of Domains",
      "text": [
        "In the field of natural language processing, there have been plenty of works on pronunciation of English by analogy, some being very much concerned with reproducing human behavior (see (Damper & Eastmond 96)).",
        "Here is an illustration of the task from (Pirelli Sz Federici 94):",
        "Similarly to AT approaches, two domains appear (graphemic and phonemic).",
        "Consequently, the functions f, g and h are of different types because their domains and ranges are of different data types.",
        "Similarly to AT again, a common feature in such pronouncing systems is the use of data bases of written and phonetic forms.",
        "Regarding his own model, (Yvon 94) comments that: The [...] model crucially relies upon the existence of numerous paradigmatic relationships in lexical data bases.",
        "Paradigmatic relationships being relationships in which four words intervene, they are in fact morphological analogies: \"reaction is to reactor, as faction is to factor\".",
        "Contrasting sharply with Al approaches, morphological analogies apply in only one domain, that of words.",
        "As a consequence, the number of relationships between analogical terms decreases from three (f, g and h) to two (1 and g).",
        "Moreover, because all four terms intervening in the analogy are from the same domain, the domains and ranges of f and g are identical.",
        "Finally, morphological analogies can be regarded as simple equations independent of any knowledge about the language in which they are written.",
        "This standpoint eliminates the need for any knowledge base or dictionary."
      ]
    },
    {
      "heading": "1.3 Unicity vs Multiplicity of Changes",
      "text": [
        "Solving morphological analogies remains difficult because several simultaneous changes may be required to transform one word into a second (for instance, doer undo requires the deletion of the suffix er and the insertion of the prefix un-).",
        "This problem has yet to be solved satisfactorily.",
        "For example, in (Yvon 94), only one change at a time is allowed, and multiple changes are captured by successive applications of morphological analogies (cascade model).",
        "However, there are cases in the morphology of some languages where multiple changes at the same time are mandatory, for instance in semitic languages.",
        "\"One change at a time\", is also found in (Na-ga.o 84) for a translation method, called translation by analogy, where the translation of an input sentence is an adaptation of translations of similar sentences retrieved from a data base.",
        "The difficulty of handling multiple changes is remedied by feeding the system with new examples differing by only one word commutation at a time.",
        "(Sadler and Vendelmans 90) proposed a different solution with an algebra on.trees: differences on strings are reflected by adding or subtracting trees.",
        "Although this seems a more convincing answer, the use of data bases would resume, as would the multiplicity of domains.",
        "Our goal is a true analogy-solver, i.e., an algorithm which, on receiving three words as input, outputs a word, analogical to the input.",
        "For that, we thus have to answer the hard problem of: (1) performing multiple changes (2) using a unique data-type (words) (3) without dictionary nor any external knowledge."
      ]
    },
    {
      "heading": "1.4 Analogies on Words",
      "text": [
        "We have finished our review of the problem and ended up with what was the starting point of our work.",
        "In linguistic works, analogy is defined by Saussure, after Humboldt and Baudoin de Courtenay, as the operation by which, given two forms of a given word, and only one form of a second word, the missing form is coined', \"honor is to honOrem as Ordtor is to Oriite•renz\" noted eirdtOrem : Oreitor = honóreni : honor.",
        "This is the same definition as the one given by Aristotle himself, \"A is to B as C is to D\", postulating identity of types for A, B, C, and D.",
        "However, while analogy has been mentioned and used, algorithmic ways to solve analogies seem to have never been proposed, maybe because the operation, is so \"intuitive\".",
        "We (Lepage & Ando 96) recently gave a tentative computational explanation which was not always valid because false analogies were captured.",
        "It did not constitute an algorithm either.",
        "The only work on solving analogies on words seems to be Copycat ((Hofstadter et al.",
        "94) and (Hoffman 95)), 'which solves such puzzles as: abc : abbccc = zjk : x.",
        "Unfortunately it does not seem to use a truly dedicated algorithm, rather, following the AT approach, it uses a formalisation of the domain with such functions as, \"previous in alphabet\", \"rank in alphabet\", etc."
      ]
    },
    {
      "heading": "2 Foundations of the Algorithm 2.1 The First Term as an Axis",
      "text": [
        "(Itkonen and Haukioja 97) give a program in Prolog to solve analogies in sentences, as a refutation of Chomsky, according to whom analogy would not be operational in syntax, because it delivers non-grammatical sentences.",
        "That analogy would apply also to syntax, was advocated decades ago by Hermann Paul and Bloomfield.",
        "Chomsky's claim is unfair, because it supposes that analogy applies only on the symbol level.",
        "Itkonen and Haukioja show that analogy, when controlled by some structural level, does deliver perfectly grammatical sentences.",
        "What is of interest to us, is the essence of their method, which is the seed for our algorithm: Sentence D is formed by going through sentences B and C one element at a time and inspecting the relations of each element to the structure of sentence A (plus the part of sentence D that is ready).",
        "Hence, sentence A is the axis against which sentences B and C are compared, and by opposition to which output sentence D is built.",
        "The method will thus be: (a) look for those parts which are not common to A and B on one hand, and not common to A and C on the other and (b) put them together in the right order."
      ]
    },
    {
      "heading": "2.2 Common Subsequences",
      "text": [
        "Looking for common subsequences of A and B (resp.",
        "A and C) solves problem (a) by complementation.",
        "(Wagner Sz Fischer 74) is a method to find longest common subsequences by computing edit distance matrices, yielding the minimal number of edit operations (insertion, deletion, substitution) necessary to transform one string into another.",
        "For instance, the following matrices give the distance between like and unlike on one hand, and between like and known on the other hand, in their right bottom cells: dist(like, unlike) = 2 and dist(like, known) = 5"
      ]
    },
    {
      "heading": "2.3 Similitude between Words",
      "text": [
        "We call similitude between A and B the length of their longest common subsequence.",
        "It is also equal to the length of A, minus the number of its characters deleted or replaced to produce B.",
        "This number we call pdist(A,B), because it is a pseudo-distance, which can be computed exactly as the edit distances, except that insertions cost 0.",
        "Characters inserted into B or C may be left aside, precisely because they are those characters of B and C, absent from A, that we want to assemble into the solution, D. As A is the axis in the resolution of analogy, graphically we make it the vertical axis around which the computation of pseudo-distances takes place.",
        "For instance, for like : unlike ="
      ]
    },
    {
      "heading": "2.4 The Coverage Constraint",
      "text": [
        "It is easy to verify that there is no solution to an analogy if some characters of A appear neither in B nor in C. The contrapositive says that, for an analogy to hold, any character of A has to appear in either B or C. Hence, the sum of the similitudes of A with B and C must be greater than or equal to its length: sim(A, B)-1-sim(A, C) > A I, or, equivalently,",
        "When the length of A is greater than the sum of the pseudo-distances, some subsequences of A are common to all strings in the same order.",
        "Such subsequences have to be copied into the solution D. We call com(A,B,C , D) the sum of the length of such subsequences.",
        "The delicate point is that this sum depends precisely on the solution D being currently built by the algorithm.",
        "To summarise, for analogy A:B= C:D to hold, the following constraint must be verified:"
      ]
    },
    {
      "heading": "3 The Algorithm",
      "text": []
    },
    {
      "heading": "3.1 Computation of Matrices",
      "text": [
        "Our method relies on the computation of two pseudo-distance matrices between the three first terms of the analogy.",
        "A result by (Ukkonen 85) says that it is sufficient to compute a diagonal band plus two extra bands on each of its sides in the edit distance matrix, in order to get the exact distance, if the value of the overall distance is known to be less than some given threshold.",
        "This result applies to pseudo-distances, and is used to reduce the computation of the two pseudo-distance matrices.",
        "The width of the extra bands is obtained by trying to satisfy the coverage constraint with the value of the current pseudo-distance in the other matrix."
      ]
    },
    {
      "heading": "3.2 Main Component",
      "text": [
        "Once enough in the matrices has been computed, the principle of the algorithm is to follow the paths along which longest common subsequences are found, simultaneously in both matrices, copying characters into the solution accordingly.",
        "At each time, the positions in both matrices must be on the same horizontal line, i.e. at a same position in A, in order to ensure a right order while building the solution, D. Determining the paths is done by comparing the current cell in the matrix with its three previous ones (horizontal, vertical or diagonal), according to the technique in (Wagner & Fischer 74).",
        "As a consequence, paths are followed from the end of words down to their beginning.",
        "The nine possible combinations (three directions in two matrices) can be divided into two groups: either the directions are the same in both matrices, or they are different.",
        "The following sketches the gorithm.",
        "com(A, B, C, D) has been initialised to: I A I – (pdist(A,B) pdist(A,C)).",
        "and ic are the current positions in A, B and C. dir AB (resp.",
        "dirAc) is the direction of the path in matrix A x B (resp.",
        "A x C) from the current position.",
        "\"copy\" means to copy a character from a word at the beginning of D and to move to the previous character in that word.",
        "'In this case, we move in the three words at the same time.",
        "Also, the character arithinetics factors, in view of generalisations, different operations: if the three current characters in A, B and C are equal, copy this character, otherwise copy that character from B or C that is different from the one in A.",
        "If all current characters are different, this is a failure.",
        "bThe word with less similitude with A is chosen, so as to make up for its delay."
      ]
    },
    {
      "heading": "3.3 Early Termination in Case of Failure",
      "text": [
        "Complete computation of both matrices is not necessary to detect a failure.",
        "It is obvious when a letter in A does not appear in B or C. This may already be detected before any matrix computation.",
        "Also, checking the coverage constraint allows the algorithm to stop as soon as non-satisfying moves have been performed."
      ]
    },
    {
      "heading": "3.4 An Example",
      "text": [
        "We will show how the analogy like : unlike = known : x is solved by the algorithm.",
        "The algorithm first verifies that all letters of like are present either in unlike or known.",
        "Then, the minimum computation is done for the pseudo-distances matrices, i.e. only the minimal diagonal band is computed.",
        "As the coverage constraint is verified, the main component is called.",
        "It follows the paths noted by values in circles in the matrices.",
        "The succession of moves triggers the following copies into the solution: dirAB dirAc copy diagonal diagonal n diagonal diagonal w diagonal diagonal o diagonal diagonal n horizontal horizontal k horizontal diagonal n horizontal diagonal u At each step, the coverage constraint being verified, finally, the solution x = unknown is ouptut."
      ]
    },
    {
      "heading": "4 Properties and Coverage",
      "text": []
    },
    {
      "heading": "4.1 Trivial Cases, Mirroring",
      "text": [
        "Trivial cases of analogies are, of course, solved by the algorithm, like: A:A= A:x x= A or A:A= C:x x = C. Also, by construction, A:B= C: x and A: C= B: x deliver the same solution.",
        "With this construction, mirroring poses no problem.",
        "If we note A the mirror of word A, then A:B=C:D A:B=C:D."
      ]
    },
    {
      "heading": "4.2 Prefixing, Suffixing, Parallel Infixing",
      "text": [
        "Appendix A lists a number of examples, actually solved by the algorithm, from simple to complex, which illustrate the algorithm's performance."
      ]
    },
    {
      "heading": "4.3 Reduplication and Permutation",
      "text": [
        "The previous form of the algorithm does not produce reduplication.",
        "This would be necessary if we wanted to obtain, for example, plu",
        "case, our algorithm delivers, x = orang-burung, because preference is given to leave prefixes unchanged.",
        "However, the algorithm may be easily modified so that it applies repeatedly so as to obtain the desired solutionG.",
        "Permutation is not captured by the algorithm.",
        "An example (q with a and u) in Protosemitic is: yagtilu : yugtilu = qatal : qutal."
      ]
    },
    {
      "heading": "4.4 Language-independence/Codedependence",
      "text": [
        "Because the present algorithm performs computation only on a symbol level, it may be applied to any language.",
        "It is thus language independent.",
        "This is fortunate, as analogy in linguistics certainly derives from a more general psychological operation ((Gentner 83), (Itkonen 94)), which seems to be universal among human beings.",
        "Examples in Section A illustrate the language independence of the algorithm.",
        "Conversely, the symbols determine the granularity of the analogies computed.",
        "Consequently, a commutation not reflected in the coding system will not be captured.",
        "This may be illustrated by a Japanese example in three different",
        "codings: the native writing system, the Hep-burn transcription and the official, strict recommendation (kunrei).",
        "Kanji/Kana: of-4-D : 'f it = ft < :x",
        "x hatarakimasu The algorithm does not solve the first two analogies (solutions: t, hatarakimasu) because it does not solve the elementary analogies, o:= < : and tsu : chi = ku: ki, which are beyond the symbol level'.",
        "More generally speaking, the interaction of analogy with coding seems the basis of a frequent reasoning principle:",
        "Only the first analogy holds on the symbol level and, as is, is solved by our algorithm.",
        "f is an encoding function for which an inverse exists.",
        "A striking application of this principle is the resolution of some Copycat puzzles, like: abc: abd ijk : x x Using a binary ASCII representation, which reflects sequence in the alphabet, our algorithm produces:",
        "In other words, coding is the key to many analogies.",
        "More generally we follow (Itkonen and Haukioja 97) when they claim that analogy is an operation against which formal representations should also be assessed.",
        "But for that, of course, we needed an automatic analogy-solver."
      ]
    },
    {
      "heading": "Conclusion",
      "text": [
        "We have proposed an algorithm which solves analogies on words, i.e. when possible it coins a fourth word when given three words.",
        "It relies on the computation of pseudo-distances between strings.",
        "The verification of a constraint, relevant for analogy, limits the computation of matrix cells, and permits early termination in case of failure.",
        "This algorithm has been proved to handle many different cases in many different languages.",
        "In particular, it handles parallel infix-ing, a property necessary for the morphological description of semitic languages.",
        "Reduplication is an easy extension.",
        "This algorithm is independent of any language, but not coding-independent: it constitutes a trial at inspecting how much can be achieved using only pure computation on symbols, without any external knowledge.",
        "We are inclined to advocate that much in the matter of usual analogies, is a question of symbolic representation, i.e. a question of encoding into a form solvable by a purely symbolic algorithm like the one we proposed.",
        "Set in this way, even analogies of geometrical type can be solved under a convenient representation.",
        "An adequate description (or coding), with no reduplication, is:",
        "This is actually solved by our algorithm:",
        "70ne could imagine extending the algorithm by para.metrising it with such predefined analogical relations."
      ]
    },
    {
      "heading": "A Examples",
      "text": [
        "The following examples show actual resolution of analogies by the algorithm.",
        "They illustrate what the algorithm achieves on real linguistic examples."
      ]
    },
    {
      "heading": "A.1 Insertion or deletion of prefixes or suffixes",
      "text": [
        "Latin: oratorenz: orator honorenz: x"
      ]
    }
  ]
}
