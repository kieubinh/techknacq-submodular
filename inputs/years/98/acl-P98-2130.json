{
  "info": {
    "authors": [
      "Vincenzo Lombardo",
      "Leonardo Lesmo"
    ],
    "book": "COLING-ACL",
    "id": "acl-P98-2130",
    "title": "Formal Aspects and Parsing Issues of Dependency Theory",
    "url": "https://aclweb.org/anthology/P98-2130",
    "year": 1998
  },
  "references": [
    "acl-C96-1058",
    "acl-C96-1085",
    "acl-C96-2122",
    "acl-J90-4003",
    "acl-J92-2001",
    "acl-J93-4002",
    "acl-P97-1043"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "The paper investigates the problem of providing a formal device for the dependency approach to syntax, and to link it with a parsing model.",
        "After reviewing the basic tenets of the paradigm and the few existing mathematical results, we describe a dependency formalism which is able to deal with long-distance dependencies.",
        "Finally, we present an Earley-style parser for the formalism and discuss the (polynomial) complexity results."
      ]
    },
    {
      "heading": "1. Introduction",
      "text": [
        "Many authors have developed dependency theories that cover cross-linguistically the most significant phenomena of natural language syntax: the approaches range from generative formalisms (Sgall et al.",
        "1986), to lexically-based descriptions (Mel'cuk 1988), to hierarchical organizations of linguistic knowledge (Hudson 1990) (Fraser, Hudson 1992), to constrained categorial grammars (Milward 1994).",
        "Also, a number of parsers have been developed for some dependency frameworks (Covington 1990) (Kwon, Yoon 1991) (Sleator, Temperley 1993) (Hahn et al.",
        "1994) (Lombardo, Lesmo 1996), including a stochastic treatment (Eisner 1996) and an object-oriented parallel parsing method (Neuhaus, Hahn 1996).",
        "However, dependency theories have never been explicitly linked to formal models.",
        "Parsers and applications usually refer to grammars built around a core of dependency concepts, but there is a great variety in the description of syntactic constraints, from rules that are very similar to CFG productions (Gaifrnan 1965) to individual binary relations on words or syntactic categories (Covington 1990) (Sleator, Temperley 1993).",
        "John likes beans\".",
        "The leftward or rightward orientation of the edges represents the order constraints: the dependents that precede (respectively, follow) the head stand on its left (resp.",
        "right).",
        "The basic idea of dependency is that the syntactic structure of a sentence is described in terms of binary relations (dependency relations) on pairs of words, a head (parent), and a dependent (daughter), respectively; these relations usually form a tree, the dependency tree (fig.",
        "1).",
        "The linguistic merits of dependency syntax have been widely debated (e.g. (Hudson 1990)).",
        "Dependency syntax is attractive because of the immediate mapping of dependency trees on the predicate-arguments structure and because of the treatment of free-word order constructs (Sgall et al.",
        "1986) (Mel'cuk 1988).",
        "Desirable properties of lexicalized formalisms (Schabes 1990), like finite ambiguity and decidability of string acceptance, intuitively hold for dependency syntax.",
        "On the contrary, the formal studies on dependency theories are rare in the literature.",
        "Gaifman (1965) showed that projective dependency grammars, expressed by dependency rules on syntactic categories, are weakly equivalent to context-free grammars.",
        "And, in fact, it is possible to devise 0(n3) parsers for this formalism (Lombardo, Lesmo 1996), or other projective variations (Milward 1994) (Eisner 1996).",
        "On the controlled relaxation of projective constraints, Nasr (1995) has introduced the condition of pseudo-projectivity, which provides some controlled looser constraints on arc crossing in a dependency tree, and has developed a polynomial parser based on a graph-structured stack.",
        "Neuhaus and Broker (1997) have recently showed that the general recognition problem for non-projective dependency grammars (what they call discontinuous DG) is NP-complete.",
        "They have devised a discontinuous DG with exclusively lexical categories (no traces, as most dependency theories do), and dealing with free word order constructs through a looser subtree ordering.",
        "This formalism, considered as the most straightforward extension to a projective formalism, permits the reduction of the vertex cover problem to the dependency recognition problem, thus yielding the NP-completeness result.",
        "However, even if banned from the dependency literature, the use of non lexical categories is only a notational variant of some graph structures already present in some formalisms (see, e.g., Word Grammar (Hudson 1990)).",
        "This paper introduces a lexicalized dependency formalism, which deals",
        "with long distance dependencies, and a polynomial parsing algorithm.",
        "The formalism is projective, and copes with long-distance dependency phenomena through the introduction of non lexical categories.",
        "The non lexical categories allow us to keep inalterate the condition of projectivity, encoded in the notion of derivation.",
        "The core of the grammar relies on predicate-argument structures associated with lexical items, where the head is a word and dependents are categories linked by edges labelled with dependency relations.",
        "Free word order constructs are dealt with by constraining displacements via a set data structure in the derivation relation.",
        "The introduction of non lexical categories also permits the resolution of the inconsistencies pointed out by Neuhaus and Broker in Word Grammar (1997).",
        "The parser is an Earley type parser with a polynomial complexity, that encodes the dependency trees associated with a sentence.",
        "The paper is organized as follows.",
        "The next section presents a formal dependency system that describes the linguistic knowledge.",
        "Section 3 presents an Earley-type parser: we illustrate the algorithm, trace an example, and discuss the complexity results.",
        "Section 4 concludes the paper."
      ]
    },
    {
      "heading": "2. A dependency formalism",
      "text": [
        "The basic idea of dependency is that the syntactic structure of a sentence is described in terms of binary relations (dependency relations) on pairs of words, a head (or parent), and a dependent (daughter), respectively; these relations form a tree, the dependency tree.",
        "In this section we introduce a formal dependency system.",
        "The formalism is expressed via dependency rules which describe one level of a dependency tree.",
        "Then, we introduce a notion of derivation that allows us to define the language generated by a dependency grammar of this form.",
        "The grammar and the lexicon coincide, since the rules are lexicalized: the head of the rule is a word of a certain category, i.e. the lexical anchor.",
        "From the linguistic point of view we can recognize two types of dependency rules: primitive dependency rules, which represent subcategorization frames, and non-primitive dependency rules, which result from the application of lexical metarules to primitive and non-primitive dependency rules.",
        "Lexical metaniles (not dealt with in this paper) obey general principles of linguistic theories.",
        "A dependency grammar is a six-tuple <W, C, S, D, I, H>, where W is a finite set of symbols (words of a natural language); C is a set of syntactic categories (among which the special category E); S is a non-empty set of root categories (C S); D is the set of dependency relations, e.g. SUBJ, OBJ, XCOMP, P-OBJ, PRED (among which the special relation VISITOR'); I is a finite set of symbols (among which the special symbol 0), called u-indices; H is a set of dependency rules of the form",
        "• .. <1* mY mu m'c m>) 1) xEW , is the head of the rule; 2) Xe C, is its syntactic category;",
        "3) an element <rj Yj uj tj> is a d-quadruple (which describes a dependent); the sequence of d-quads, including the symbol # (representing the linear position of the head, # is a special symbol), is called the d-quad sequence.",
        "We have that",
        "Finally, it holds that: I) For each UE I that appears in a u-triple <u, r, Y>€ U, there exists exactly one d-quad <riYiuiti> in the same rule such that u=ui, i j. II) For each u=ui of a d-quad <riyjuiti>, there exists exactly one u-triple <u, r, Y>E t, i*j, in the same rule.",
        "Intuitively, a dependency rule constrains one node (head) and its dependents in a dependency tree: the d-quad sequence states the order of elements, both the head (# position) and the dependents (d-quads).",
        "The grammar is lexicalized, because each dependency rule has a lexical anchor in its head (x:X).",
        "A d-quad <rjYjujtj> identifies a dependent of category Yi, connected with the head via a dependency refation rj.",
        "Each element of the d-quad sequence is possibly associated with a u-index (uj) and a set of u-triples (rj).",
        "Both uj and Tican be null elements, i.e. 0 and 0, respectively.",
        "A u-triple component of the d-quad) <u, R, Y> bounds the area of the dependency tree where the trace can be located.",
        "Given the constraints I and II, there is a one-to-one correspondence between the u-indices and the u-triples of the d-quads.",
        "Given that a dependency rule constrains one head and its direct dependents in the dependency tree, we have that the dependent indexed by uk is coindexed with a",
        "trace node in the subtree rooted by the dependent containing the u-triple <uk, R, Y>.",
        "Now we introduce a notion of derivation for this formalism.",
        "As one dependency rule can be used more than once in a derivation process, it is necessary to replace the u-indices with unique symbols (progressive integers) before the actual use.",
        "The replacement must be consistent in the u and the t components.",
        "When all the indices in the rule are replaced, we say that the dependency rule (as well as the u-triple) is instantiated.",
        "A triple consisting of a word w (E W) or the trace symbol c( W) and two integers g and v is a word object of the grammar.",
        "Given a grammar G, the set of word objects of G is",
        "A pair consisting of a category X (E C) and a string of instantiated u-triples y is a category object of the grammar (X(y)).",
        "A 4-tuple consisting of a dependency relation r (ED), a category object X(y1), an integer k, a set of instantiated u-triples y2 is a derivation object of the grammar.",
        "Given a grammar G, the set of derivation objects of G is",
        "Yi 9'112 are strings of instantiated u-triples).",
        "Let c43vE Wx(G)* and 11/E (Wx (G) Cx(G) )*.",
        "The derivation relation holds as follows:",
        "dependency rule, and pi pm=yp u yx.",
        "<r,X( <j,r,X>),u,0> a uei We define as the reflexive, transitive closure of Given a grammar G, L(G) is the language of sequences of word objects: L'(G)= { a E Wx (G)* / <TOP, Q(0), 0,0> a and QE S(G)} where TOP is a dummy dependency relation.",
        "The language generated by the grammar G, L(G), is defined through the function t: L(G)= { WE Wx (G)* w=t(a) and aE L'(G) where t is defined recursively as",
        "where - is the empty sequence.",
        "As an example, consider the grammar",
        "where T(G1) includes the following dependency rules:",
        "1.",
        "I: N (#); 2.",
        "John: N (#); 3. beans: N (#); 4. likes: V (<SUBJ, N, 0, 0># <OBJ, N, 0, )>); 5. know: V+EX (<VISITOR, N, ul, 0>",
        "<SUBJ, N. 0, 0> <SCOMP, V, 0, (<ul,OBJ,N>)>).",
        "A derivation for the sentence \"Beans I know John likes\" is the following:",
        "ibeans I know John likes £1 The dependency tree corresponding to this derivation is in fig. 2."
      ]
    },
    {
      "heading": "3. Parsing issues",
      "text": [
        "In this section we describe an Earley-style parser for the formalism in section 2.",
        "The parser is an off-line algorithm: the first step scans the input sentence to select the appropriate dependency rules",
        "from the grammar.",
        "The selection is carried out by matching the head of the rules with the words of the sentence.",
        "The second step follows Earley's phases on the dependency rules, together with the treatment of u-indices and u-triples.",
        "This off-line technique is not uncommon in lexicalized grammars, since each Earley's prediction would waste much computation time (a grammar factor) in the body of the algorithm, because dependency rules do not abstract over categories (cf. (Schabes 1990)).",
        "In order to recognize a sentence of n words, n+1 sets Si of items are built.",
        "An item represents a subtree of the total dependency tree associated with the sentence.",
        "An item is a 5-tuple <Dotted-rule, Position, It-index, v-index, T-stack>.",
        "Dotted-rule is a dependency rule with a dot between two d-quads of the d-quad sequence.",
        "Position is the input position where the parsing of the subtree represented by this item began (the leftmost position on the spanned string).",
        "ii-index and v-index are two integers that correspond to the indices of a word object in a derivation.",
        "T-stack is a stack of sets of u-triples to be satisfied yet: the sets of u-triples (including empty sets, when applicable) provided by the various items are stacked in order to verify the consumption of one u-triple in the appropriate subtree (cf. the notion of derivation above).",
        "Each time the parser predicts a dependent, the set of u-triples associated with it is pushed onto the stack.",
        "In order for an item to enter the completer phase, the top of T-stack must be the empty set, that means that all the u-triples associated with that item have been satisfied.",
        "The sets of u-triples in T-stack are always inserted at the top, after having checked that each u-triple is not already present in T-stack (the check neglects the u-index).",
        "In case a u-triple is present, the deeper u-triple is deleted, and the T-stack will only contain the u-triple in the top set (see the derivation relation above).",
        "When satisfying a u-triple, the T-stack is treated as a set data structure, since the formalism does not pose any constraint on the order of consumption of the u-triples.",
        "Following Earley's style, the general idea is to move the dot rightward, while predicting the dependents of the head of the rule.",
        "The dot can advance across a d-quadruple <rjYjujti> or across the special symbol #.",
        "The d-quad immediately following the dot can be indexed ui.",
        "This is acknowledged by predicting an item (representing the subtree rooted by that dependent), and inserting a new progressive integer in the fourth component of the item (v -index).",
        "ti is pushed onto T-stack: the substructure rooted by a node of category Yi must contain the trace nodes of the type licensed by the u-triples.",
        "The prediction of a trace occurs as in the case 2) of the derivation process.",
        "When an item P contains a dotted rule with the dot at its end and a T-stack with the empty set 0 as the top symbol, the parser looks for the items that can advance the dot, given the completion of the dotted dependency rule in P. Here is the algorithm.",
        "<x: Q(at .",
        "), 0, L, v, []> E Sn, where Qe S(G) then accept else reject endif.",
        "At the beginning (initialization), the parser initializes the set So, by inserting all the dotted rules (x:Q(5)€ H(G)) that have a head of a root category (QE S(G)).",
        "The dot precedes the whole d-quad sequence (5).",
        "Each u-index of the rule is replaced by a progressive integer, in both the u and",
        "the components of the d-quads.",
        "Both 11 and v-indices are null (0), and T-stack is empty (W. The body consists of an external loop on the sets Si (0 i 5 n) and an inner loop on the single items of the set Si.",
        "Let",
        "be a generic item.",
        "Following Earley's schema, the parser invokes three phases on the item P: completer, predictor and scanner.",
        "Because of the derivation of traces (e) from the u-triples in T - stack, we need to add some code (the so-called pseudo-phases) that deals with completion, prediction and scanning of these entities.",
        "Completer: When 5 is an empty sequence (all the d-quad sequence has been traversed) and the top of T-stack is the empty set 0 (all the triples concerning this item have been satisfied), the dotted rule has been completely analyzed.",
        "The completer looks for the items in Sj which were waiting for completion (return items; j is the return Position of the item P).",
        "The return items must contain a dotted rule where the dot immediately precedes a d-quad <R,Y,ox,tx>, where Y is the head category of the dotted rule in the item P. Their generic form is <x: X(2.",
        "• <R,Y,ux,tx> C), j', v', T-stack'>.",
        "These items from Sj are inserted into Si after having advanced the dot to the right of <R,Y,u,,T,>.",
        "Before inserting the items, we need updating the T-stack component, because some u-triples could have been satisfied (and, then, deleted from the T-stack).",
        "The new T-stack\" is the T-stack of the completed item after popping the top element 0.",
        "Predictor: If the dotted rule of P has a d-quad <R8,4,u5,ts> immediately after the dot, then the parser is expecting a subute headed by a word of category Zs.",
        "This expectation is encoded by inserting a new item (predicted item) in the set, for each rule associated with Zs (of the form z:Z8(0)).",
        "Again, each u-index of the new item (d - quad sequence 0) is replaced by a progressive integer.",
        "The v index component of the predicted item is set to us.",
        "Finally, the parser prepares the new T-stack', by pushing the new u-triples introduced by 28, that are to be satisfied by the items predicted after the current item.",
        "This operation is accomplished by the primitive PUSH-UNION, which also accounts for the non repetition of u-triples in T-stack.",
        "As stated in the derivation relation through the UNION operation, there cannot be two u-triples with the same relation and syntactic category in T-stack.",
        "In case of a repetition of a u-triple, PUSH deletes the old u-triple and inserts the new one (with the same u-index) in the topmost set.",
        "Finally, INSERT joins the new item to the set Si.",
        "The pseudopredictor accounts for the safisfaction of the the u-triples when the appropriate conditions hold.",
        "The current d-quad in P, <128,13,us,ts>, can be the dependent which satisfies the u-triple <u,R8,Z6> in T-stack (the UNION operation gathers all the u-triples scattered through the T-stack): in addition to updating T-stack (PUSH( 0 ,T-stack)) and inserting the u-index us in the v component as usual, the parser also inserts the u-index u in the 1.1. component to coindex the appropriate distant element.",
        "Then it inserts an item (trace item) with a fictitious dotted dependency rule for the trace.",
        "Scanner: When the dot precedes the symbol #, the parser can scan the current input word wi (if y, the head of the item P, is equal to it), or pseudoscan a trace item, respectively.",
        "The result is the insertion of a new item in the subsequent set (S i+1) or the same set (Si), respectively.",
        "At the end of the external loop (termination), the sentence is accepted if an item of a root category Q with a dotted rule completely recognized, spanning the whole sentence (Position=0), an empty T-stack must be in the set S."
      ]
    },
    {
      "heading": "3.1. An example",
      "text": [
        "In this section, we trace the parsing of the sentence \"Beans I know John likes\".",
        "In this example we neglect the problem of subject-verb agreement: it can be coded by inserting the AGR features in the category label (in a similar way to the +EX feature in the grammar GO; the comments on the right help to follow the events; the separator symbol I helps to keep trace of the sets in the stack; finally, we have left in plain text the d-quad sequence of the dotted rules; the other components of the items appear in boldface.",
        "So",
        "<SCOMP, V. 0, <1, OBJ, N» • ), 0, 0, 0, 0>"
      ]
    },
    {
      "heading": "3.2. Complexity results",
      "text": [
        "The parser has a polynomial complexity.",
        "The space complexity of the parser.",
        "i.e. the number of items, is 0(n3 IDIICN. )",
        "Each item is a 5-tuple <Dotted-rule, Position, 1.t-index, v-index, T-stack>: Dotted rules are in a number which is a constant of the grammar, but in off-line parsing this number is bounded by 0(n).",
        "Position is bounded by 0(n).",
        "11.- index and v index are two integers that keep trace of u-triple satisfaction, and do not add an own contribution to the complexity count.",
        "T-stack has a number of elements which depends on the maximum length of the chain of predictions.",
        "Since the number of rules is 0(n), the size of the stack is 0(n).",
        "The elements of T-stack contain all the u-triples introduced up to an item and which are to be satisfied (deleted) yet.",
        "A u-triple is of the form <u,R,Y>: u is an integer that is ininfluent, RE D, Ye C. Because of the PUSH-UNION operation on T-stack, the number of possible u-triples scattered throughout the elements of T-stack is IDIICI.",
        "The number of different stacks is given by the dispositions of IDIICI u-triples on 0(n) elements; so, 0(n Then, the number of items in a set of items is bounded by 0(n2+ IDIICI • ) and there are n sets of items (0(n3+ IDI The time complexity of the parser is 0(n7+3 ICI).",
        "Each of the three phases executes an INSERT of an item in a set.",
        "The cost of the INSERT operation depends on the implementation of the set data structure; we assume it to be linear (0(01- IDIICI )) to make easy calculations.",
        "The phase completer executes at most 0(n2 Imo)) actions per each pair of items (two for-loops).",
        "The pairs of items are 0(n62 DI ICI ‘. )",
        "But to execute the action of the completer, one of the sets must have the index equal to one of the positions, so 0(n5 21D1 IC1).",
        "Thus, the completer costs 0(n73 IN ICI).",
        "The",
        "phase predictor, executes 0(n) actions for each item to introduce the predictions (\"for each rule\" loop); then, the loop of the pseudopredictor is 0(ID110) (UNION+DELETE), a grammar factor.",
        "Finally it inserts the new item in the set (0(n2+"
      ]
    },
    {
      "heading": "IDIICI",
      "text": [
        "The total number of items is 0(0+ID IC) and, so, the cost of the predictor 0(n6 + 21D1 ICI), The phase scanner executes the INSERT operation per item, and the items are at most 0(n3+ IDI ICI).",
        "Thus, the scanner costs 0(n5+2 ID!",
        "ICI).",
        "The total complexity of the algorithm is 0(n71-3 'Ma).",
        "We are conscious that the (grammar dependent) exponent can be very high, but the treatment of the set data structure for the u-triples requires expensive operations (cf. a stack).",
        "Actually this formalism is able to deal a high degree of free word order (for a comparable result, see (Becker, Rambow 1995)).",
        "Also, the complexity factor due to the cardinalities of the sets D and C is greatly reduced if we consider that linguistic constraints restrict the displacement of several categories and relations.",
        "A better estimation of complexity can only be done when we consider empirically the impact of the linguistic constraints in writing a wide coverage grammar."
      ]
    },
    {
      "heading": "4. Conclusions",
      "text": [
        "The paper has described a dependency formalism and an Earley-type parser with a polynomial complexity.",
        "The introduction of non lexical categories in a dependency formalism allows the treatment of long distance dependencies and of free word order, and to aovid the NP-completeness.",
        "The grammar factor at the exponent can be reduced if we furtherly restrict the long distance dependencies through the introduction of a more restrictive data structure than the set, as it happens in some constrained phrase structure formalisms (Vijay-Schanker, Weir 1994).",
        "A compilation step in the parser can produce parse tables that account for left-corner information (this optimization of the Earley algorithm has already been proven fruitful in (Lombardo, Lesmo 1996))."
      ]
    }
  ]
}
