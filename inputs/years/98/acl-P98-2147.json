{
  "info": {
    "authors": [
      "Mehryar Mohri",
      "Fernando Pereira"
    ],
    "book": "COLING-ACL",
    "id": "acl-P98-2147",
    "title": "Dynamic Compilation of Weighted Context-Free Grammars",
    "url": "https://aclweb.org/anthology/P98-2147",
    "year": 1998
  },
  "references": [
    "acl-J97-2003",
    "acl-P83-1014",
    "acl-P96-1031"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Weighted context-free grammars are a convenient formalism for representing grammatical constructions and their likelihoods in a variety of language-processing applications.",
        "In particular, speech understanding applications require appropriate grammars both to constrain speech recognition and to help extract the meaning of utterances.",
        "In many of those applications, the actual languages described are regular, but context-free representations are much more concise and easier to create.",
        "We describe an efficient algorithm for compiling into weighted finite automata an interesting class of weighted context-free grammars that represent regular languages.",
        "The resulting automata can then be combined with other speech recognition components.",
        "Our method allows the recognizer to dynamically activate or deactivate grammar rules and substitute a new regular language for some terminal symbols, depending on previously recognized inputs, all without recompilation.",
        "We also report experimental results showing the practicality of the approach."
      ]
    },
    {
      "heading": "1. Motivation",
      "text": [
        "Context-free grammars (CFGs) are widely used in language processing systems.",
        "In many applications, in particular in speech recognition, in addition to recognizing grammatical sequences it is necessary to provide some measure of the probability of those sequences.",
        "It is then natural to use weighted CFGs, in which each rule is given a weight from an appropriate weight algebra (Salomaa and Soittola, 1978).",
        "Weights can encode probabilities, for instance by setting a rule's weight to the negative logarithm of the probability of the rule.",
        "Rule probabilities can be estimated in a variety of ways, which we will not discuss further in this paper.",
        "Since speech recognizers cannot be fully certain about the correct transcription of a spoken utterance, they instead generate a range of alternative hypotheses with associated probabilities.",
        "An essential function of the grammar is then to rank those hypotheses according to the probability that they would be actually uttered.",
        "The grammar is thus used together with other information sources – pronunciation dictionary, phonemic context-dependency model, acoustic model (Bahl et al., 1983; Rabiner and Juang, 1993) – to generate an overall set of transcription hypotheses with corresponding probabilities.",
        "General CFGs are computationally too demanding for real-time speech recognition systems, since the amount of work required to expand a recognition hypothesis in the way just described would in general be unbounded for an unrestricted grammar.",
        "Therefore, CFGs used in spoken-dialogue applications often rem resent regular languages (Church, 1983; Brown and Buntschuh, 1994), either by construction or as a result of a finite-state approximation of a more general CFG (Pereira and Wright, 1997).'",
        "Assuming that the grammar can be efficiently converted into a finite automaton, appropriate techniques can then be used to combine it with other finite-state recognition models for use in real-time recognition (Mohri et al., 1998b).",
        "There is no general algorithm that would map an arbitrary CFG generating a regular language into a corresponding finite-state automaton (U1-lian, 1967).",
        "However, we will describe a useful class of grammars that can be so transformed, and a transformation algorithm that avoids some of the potential for combinatorial",
        "explosion in the process.",
        "Spoken dialogue systems require grammars or language models to change as the dialogue proceeds, because previous interactions set the context for interpreting new utterances.",
        "For instance, a previous request for a date might activate the date grammar and lexicon and inactivate the location grammar and lexicon in an automated reservations task.",
        "Without such dynamic grammars, efficiency and accuracy would be compromised because many irrelevant words and constructions would be available when evaluating recognition hypotheses.",
        "We consider two dynamic grammar mechanisms: activation and deactivation of grammar rules, and the substitution of a new regular language for a terminal symbol when recognizing the next utterance.",
        "We describe a new algorithm for compiling weighted CFCs, based on representing the grammar as a weighted transducer.",
        "This representation provides opportunities for optimization, including optimizations involving weights, which are not possible for general CFGs.",
        "The algorithm also supports dynamic grammar changes without recompilation.",
        "Furthermore, the algorithm can be executed on demand: states and transitions of the automaton are expanded only as needed for the recognition of the actual input utterances.",
        "Moreover, our lazy compilation algorithm is optimal in the sense that the construction requires work linear in the size of the input grammar, which is the best one can expect given that any algorithm needs to inspect the whole input grammar.",
        "It is however possible to speed-up grammar compilation further by applying pre-compilation optimizations to the grammar, as we will see later.",
        "The class of grammars to which our algorithm applies includes right-linear grammars, left-linear grammars and certain combinations thereof.",
        "The algorithm has been fully implemented and evaluated experimentally, demonstrating its effectiveness."
      ]
    },
    {
      "heading": "2. Algorithm",
      "text": [
        "We will start by giving a precise definition of dynamic grammars.",
        "We will then explain each stage of grammar compilation.",
        "Grammar compilation takes as input a weighted CFG represented as a weighted transducer (Salomaa and Soittola, 1978), which may have been optimized prior to compilation (preoptimized).",
        "The weighted transducer is analyzed by the compilation algorithm, and the analysis, if successful, outputs a collection of weighted automata that are combined at runtime according to the current dynamic grammar configuration and the strings being recognized.",
        "Since not all CFGs can be compiled into weighted automata, the compilation algorithm may reject an input grammar.",
        "The class of allowed grammars will be defined later."
      ]
    },
    {
      "heading": "2.1. Dynamic grammars",
      "text": [
        "The following notation will be used in the rest of the paper.",
        "A weighted CFG G = (V, P) over the alphabet E, with real-number weights consists of a finite alphabet V of variables or nonterminals disjoint from E, and a finite set PC VxR x (V U E)* of productions or derivation rules (Autebert et al., 1997).",
        "Given strings U, v E (V U E)*, and real numbers c and c', we write (u, c) 4 (v, c') when there is a derivation from u with weight c to v with weight c'.",
        "We denote by LG(X) the weighted language generated by a nonterminal X: LG(X)= {(w,C) E E* x R : (X, 0) 4 (w, c)} We can now define the two grammar-changing operations that we use.",
        "Dynamic activation or deactivation of rules 2 We augment the grammar with a set of active nonterminals, which are those available as start symbols for derivations.",
        "More precisely, let A C V be the set of active nonterminals.",
        "The language generated by G is then LG UXEA LG(X).",
        "Note that inactive nonterminals, and the rules involving them, are available for use in derivations; they are just not available as start symbols.",
        "Dynamic rule activation or deactivation is just the dynamic redefinition of the set A in successive uses of the grammar.",
        "Dynamic substitution Let a be a weighted rational transduction of E* to A* x R, E C A, that is a regular weighted substitution (Berstel, 1979).",
        "a is a monoid morphism verifying: 2 This is the terminology used in this area, though a more appropriate expression would be dynamic activation or deactivation of nonterminal symbols.",
        "Vs E E, a(x) C Reg(er x R) where Reg(* x R) denotes the set of weighted regular languages over the alphabet A.",
        "Thus a simply substitutes for each symbol a E Ea weighted regular expression a(a).",
        "A dynamic substitution consists of the application of the substitution a to E, during the process of recognition of a word sequence.",
        "Thus, after substitution, the language generated by the new",
        "Our algorithm allows for both of those dynamic grammar changes without recompiling the grammar."
      ]
    },
    {
      "heading": "2.2. Preprocessing",
      "text": [
        "Our compilation algorithm operates on a weighted transducer r(G) encoding a factored representation of the weighted CFG G, which is generated from G by a separate preprocessor.",
        "This preprocessor is not strictly needed, since we could use a version of the main algorithm that works directly on G. However, preprocessing can improve dramatically the time and space needed for the main compilation step, since the preprocessor uses determinization and minimization algorithms for weighted transducers (Mohri, 1997) to increase the sharing – factorirzg – among grammar rules that start or end the same way.",
        "The preprocessing step builds a weighted transducer in which each path corresponds to a grammar rule.",
        "Rule X a ...Yn has a corresponding path that maps X to the sequence Y1 ...Yr, with weight a.",
        "For example, the small CFG in Figure 1 is preprocessed into the compacted transducer shown in Figure 2."
      ]
    },
    {
      "heading": "2.3. Compilation",
      "text": [
        "The compilation of weighted left-linear or right-linear grammars into weighted automata is straightforward (Aho and Ullman, 1973).",
        "In the right-linear case, for instance, the states of the automaton are the grammar nonterminals together with a new final state F. There is a",
        "transition labeled with a E E and weight a E R from X E V to Y E V if the grammar contains the rule X a aY.",
        "There is a transition from X to F labeled with a and weight a if X a – > a is a rule of the grammar.",
        "The initial states are the states corresponding to the active nonterminals.",
        "For example, Figure 3 shows the weighted automaton for grammar G2 consisting of the last three rules of G1 with start symbol X.",
        "However, the standard methods for left and right-linear grammars cannot be used for grammars such as G1 that generate regular sets but have rules that are neither left nor right-linear.",
        "But we can use the methods for left and right-linear grammars as subroutines if the grammar can be decomposed into left-linear and right-linear components that do not call each other recursively (Pereira and Wright, 1997).",
        "More precisely, define a dependency graph DG for G's nonterminals and examine the set of its strongly-connected components (SCCs).4 The nodes of DG are G's nonterminals, and there is a directed edge from X to Y if Y appears in the right-hand side of a rule with left-hand side X, that is, if the definition of X depends on Y.",
        "Each SCCS of DG has a corresponding subgrammar of G consisting of those rules with",
        "left-hand nonterminals in S, with nonterminals not in S treated as terminal symbols.",
        "If each of these subgrammars is either left-linear or right-linear, we shall see that compilation into a single finite automaton is possible.",
        "The dependency graph DG can be obtained easily from the transducer r(G).",
        "For example, Figure 4 shows the dependency graph for our example grammar GI, with SCCs {Z} and {X, Y}.",
        "It is clear that G1 satisfies our condition, and Figure 5 shows the result of compiling G1 with A = {Z}.",
        "• The SCCs of DG can be obtained in time linear in the size of G (Aho et al., 1974).",
        "Before starting the compilation, we check that each subgrammar is left-linear or right-linear (as noted above, nonterminals not in the SCC of a subgrammar are treated as terminals).",
        "For example, if {Xi, X2} is an SCC, then the subgrammar",
        "with X1, X27 Y1) Y2 E V and a, b E E is right-linear, since expressions such as aY1bY2 can be treated as elements of the terminal alphabet of the subgrammar.",
        "When the compilation condition holds, for each SCCS we can build a weighted automaton K(S) representing the language of S's subgrammar using the standard methods.",
        "Since some nonterminals of G are treated as terminal symbols within a subgrammar, the transitions of an automaton K(S) may be labeled with nonterminals not in 5•5 The nonterminals not in S can then be replaced by their corresponding automata.",
        "The replacement operation is lazy, that is, the states and transitions of the replacing automata are only expanded when needed for a given input string.",
        "Another interesting characteristic of our algorithm is that the weighted automata K(S) can be made smaller by determinization and minimization, leading to improvements in runtime performance.",
        "The automaton M(X) that represents the language generated by nonterminal symbol X can be defined using K(S), where S is the strongly connected component containing X, X E S. For instance, when the subgrammar of S is right-linear, M(X) is the automaton that has the same states, transitions, and final states as K(S) and has the state corresponding to X as initial state.",
        "For example, Figure 6 shows K({X,Y}) for G1.",
        "M(X) is then obtained from K({X,Y}) by taking X as initial state.",
        "The left-linear case can be treated in a similar way.",
        "Thus, M(X) can always be defined in constant time and space by editing the automaton K(S).",
        "We use a lazy implementation of this editing operation for the definition",
        "of the automata M(X): the states and transitions of M(X) are determined using K (S) only when necessary for the given input string.",
        "This allows us to save both space and time by avoiding a copy of K(S) for each X E S. Once the automaton representing the language generated by each nonterminal is created, we can define the language generated by G by building an automaton MG with one initial state and one final state, and transitions labeled with active nonterminals from the initial to the final state.",
        "Figure 7 illustrates this in the case where A = {X, Y, Z}.",
        "Given this construction, the dynamic activation or deactivation of nonterminals can be done by modifying the automaton MG.",
        "This operation does not require any recompilation, since it does not affect the automaton M(X) built for each nonterminal X.",
        "All the steps in building the automata M(X) – construction of DG, finding the SCCs, and computing for K (S) for each SCCS – require linear time and space with respect to the size of G. In fact, since we first convert G into a compact weighted transducer r(G), the total work required is linear in the size of r(G).6 This leads to significant gains as shown by our experiments.",
        "In summary, the compilation algorithm has the following steps:",
        "1.",
        "Build the dependency graph DG of the grammar G. 2.",
        "Compute the SCCs of DG.7 3.",
        "For each SCC 5, construct the automaton K(S).",
        "For each X E S, build M(X) from",
        "4.",
        "Create a simple automaton MG accepting exactly the set of active nonterminals A.",
        "5.",
        "The automaton is then expanded on-the-fly for each input string using lazy replacement and editing.",
        "The dynamic substitution of a terminal symbol a by a weighted automaton9 ca is done by replacing the symbol a by the automaton cra, using the replacement operation discussed earlier.",
        "This replacement is also done on demand, with only the necessary part of Ca being expanded for a given input string.",
        "In practice, the automaton Ca can be large, a list of city or person names for example.",
        "Thus a lazy implementation is crucial for dynamic substitutions."
      ]
    },
    {
      "heading": "3. Optimizations, Experiments and Results",
      "text": [
        "We have a full implementation of the compilation algorithm presented in the previous section, including the lazy representations that are crucial in reducing the space requirements of speech recognition applications.",
        "Our implementation of the compilation algorithm is part of a general set of grammar tools, the GRM Library (Mohri, 1998b), currently used in speech processing projects at AT&T Labs.",
        "The GRM Library also includes an efficient compilation tool for weighted context-dependent rewrite rules (Mohri and Sproat, 1996) that is used in text-to-speech projects at Lucent Bell Laboratories.",
        "Since the GRM library is compatible with the FSM general-purpose finite-state machine library (Mohri et al., 1998a), we were able to use the tools provided in FSM library to optimize the input weighted transducers r(G) and the weighted automata in the compilation output.",
        "We did several experiments that show the efficiency of our compilation method.",
        "A key feature of our grammar compilation method is the representation of the grammar by a weighted transducer that can then be preoptimized using weighted transducer determinization and minimization (Mohri, 1997; Mohri, 1998a).",
        "To show",
        "the benefits of this representation, we compared the compilation time and the size of the resulting lazy automata with and without preoptimization.",
        "The advantage of preoptimization would be even greater if the compilation output were fully expanded rather than on-demand.",
        "We did experiments with full bigram models with various vocabulary sizes, and with two unweighted grammars derived by feature instantiation from hand-built feature-based grammars (Pereira and Wright, 1997).",
        "Figure 8 shows the compilation times of full bigram models with and without preoptimization, demonstrating the importance of the optimization allowed by using a transducer representation of the grammar.",
        "For a 250-word vocabulary model, the compilation time is about 50 times faster with the preoptimized representation.w Figure 8 also shows the sizes of the resulting lazy automata in the two cases.",
        "While in the preoptimized case time andspace grow linearly with vocabulary size (0(VIGI)), they grow quadratically in the unoptimized case (0(IGI)).",
        "The bigram examples also show the advantages of lazy replacement and editing over the full expansion used in previous work (Pereira and Wright, 1997).",
        "Indeed, the size of the fully-expanded automaton for the preoptimized 'For convenience, the compilation time for the unoptimized case in Figure 8 was divided by 10, and the size of the result by 25.",
        "case grows quadratically with the vocabulary size (0(IGI)), while it grows with the cube of the vocabulary size in the unoptimized case (0(IG1312)).",
        "For example, compilation is about 700 times faster in the optimized case for a fully expanded automaton even for a 40-word vocabulary model, and the result about 39 times smaller.",
        "Our experiments with a small and a medium-sized CFG obtained from feature-based grammars confirm these observations (Table 1).",
        "If dynamic grammars and lazy expansion are not needed, we can expand the result fully and then apply weighted determinization and minimization algorithms.",
        "Additional experiments show that this can yield dramatic reductions in automata size."
      ]
    },
    {
      "heading": "4. Conclusion",
      "text": [
        "A new weighted CFG compilation algorithm has been presented.",
        "It can be used to compile effi",
        "ciently an interesting class of grammars representing weighted regular languages and allows for dynamic modifications that are crucial in many speech recognition applications.",
        "While we focused here on CFGs with real number weights, which are especially relevant in speech recognition, weighted CFGs can be defined more generally over an arbitrary semiring (Salomaa and Soittola, 1978).",
        "Our compilation algorithm applies to general semirings without change.",
        "Both the grammar compilation algorithms (GRM library) and our automata optimization tools (FSM library) work in the most general case."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "We thank Bruce Buntschuh and Ted Roycraft for their help with defining the dynamic grammar features and for their comments on this work."
      ]
    }
  ]
}
