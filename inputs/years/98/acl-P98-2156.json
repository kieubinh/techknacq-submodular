{
  "info": {
    "authors": [
      "Mark-Jan Nederhof"
    ],
    "book": "COLING-ACL",
    "id": "acl-P98-2156",
    "title": "An Alternative LR Algorithm for TAGs",
    "url": "https://aclweb.org/anthology/P98-2156",
    "year": 1998
  },
  "references": [
    "acl-P90-1035"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We present a new LR algorithm for tree-adjoining grammars.",
        "It is an alternative to an existing algorithm that is shown to be incorrect.",
        "Furthermore, the new algorithm is much simpler, being very close to traditional LR parsing for context-free grammars.",
        "The construction of derived trees and the computation of features also become straightforward."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The efficiency of LR(k) parsing techniques (Sippu and Soisalon-Soininen, 1990) appears to be very attractive from the perspective of natural language processing.",
        "This has stimulated the computational linguistics community to develop extensions of these techniques to general context-free grammar parsing.",
        "The best-known example is generalized LR parsing (Tomita, 1986).",
        "A first attempt to adapt LR parsing to tree-adjoining grammars (TAGs) was made by Schabes and Vijay-Shanker (1990).",
        "The description was very complicated however, and not surprisingly, no implementation of the algorithm seems to have been made up to now.",
        "Apart from presentational difficulties, the algorithm as it was published is also incorrect.",
        "Brief indications of the nature of the incorrectness have been given before by Kinyon (1997).",
        "There seems to be no straightforward way to correct the algorithm.",
        "We therefore developed an alternative to the algorithm from Schabes and Vijay-Shanker (1990).",
        "This alternative is novel in presentational aspects, and is fundamentally different in that it incorporates reductions of subtrees.",
        "The new algorithm has the benefit that many theoretically and practically useful properties carry over from the context-free case.",
        "For example, by making a straightforward translation from TAGs to linear indexed grammars, one may identify computations of the parser with rightmost derivations in reverse.",
        "Also the extensions needed for construction of parse trees (or \"derived trees\" as they are often called for TAGs) and the computation of features are almost identical to the corresponding extensions for context-free LR parsing.",
        "Section 2 discusses our notation.",
        "The algorithm for constructing the LR table is given in Section 3, and the automaton that operates on these tables is given in Section 4.",
        "Section 5 first explains why the algorithm from Schabes and Vijay-Shanker (1990) is incorrect, and then provides an example of how our new algorithm works.",
        "Some extensions are discussed in Section 6, and the implementation in Section 7."
      ]
    },
    {
      "heading": "2 Notation",
      "text": [
        "For a good introduction to TAGs, the reader is referred to Joshi (1987).",
        "In this section we merely summarize our notation.",
        "A tree-adjoining grammar is a 4-tuple (Z, NT, I, A), where E is a finite set of terminals, I is a finite set of initial trees and A is a finite set of auxiliary trees.",
        "We refer to the trees in I U A as elementary trees.",
        "The set NT, a finite set of nonterminals, does not play any role in this paper.",
        "Each auxiliary tree has a distinguished leaf, call the foot.",
        "We refer to the foot of an auxiliary tree t as F. We refer to the root of an elementary tree t as R. The set of all nodes of an elementary tree t is denoted by .A( (t), and we define the set of all nodes in the grammar by = UtENA For each non-leaf node N we define children(N) as the list of children nodes.",
        "For other nodes, the function children is undefined.",
        "The dominance relation ‹* is the reflexive and",
        "transitive closure of the parent relation i defined by N i M if and only if children(N) = aM13, for some a, E Ar*.",
        "Each leaf N in an elementary tree, except when it is a foot, is labelled by either a terminal from Z or the empty string E. We identify such a node N labelled by a terminal with that terminal.",
        "Thus, we consider E to be a subset of N.1 For now, we will disallow labels to be E, since this causes a slight technical problem.",
        "We will return to this issue in Section 6.",
        "For each node N that is not a leaf or that is a foot, we define Adjunct(N) as the set of auxiliary trees that can be adjoined at N. This set may contain the element nil to indicate that adjunction at that node is not obligatory.",
        "An example of a TAG is given in Figure 1.",
        "There are two initial trees, ai and a2, and one auxiliary tree 0.",
        "For each node N, Adjunct(N) has been indicated to the right of that node, unless Adjunct(N) = {nil} , in which case that information is omitted from the picture.",
        "3 Construction of the LR table For technical reasons, we assume an additional node for each elementary tree t, which we denote by T. This node has only one child, viz. the actual root node R. We also assume an additional node for each auxiliary tree t, which we denote by I.",
        "This is the unique child of the actual foot node F. The domain of the function children is extended to include foot nodes, by defining children(Ft) = 1, for each t E A.",
        "For the algorithm, two kinds of tree need to be distinguished: elementary trees and subtrees of elementary trees.",
        "A subtree can be identified by a pair (t, N), where t is an elementary tree and N is a node in that tree; the pair indicates the subtree of t rooted at N. The set of all trees needed by our algorithm is given by:",
        "From here on, we will use the symbol t exclusively to range over I U A, and T to range over T in general.",
        "For each r E T, we may consider a part of the tree consisting of a node N in T and the list of its children nodes -y. Analogously to the notation for context-free parsing, we separate the list of children nodes into two lists, separated by a dot, and write N 4 a • [3, where al3 = 7, to indicate that the children nodes in a have already been matched against a part of the input string, and those in have as yet not been processed.",
        "The set of such objects for an elementary tree t is given by:",
        "Such objects are attached to the trees T E T to which they pertain, to form the set of items:",
        "A completed item is an item that indicates a completely recognized elementary tree or subtree.",
        "Formally, items are completed if they are of the form [t, T Rt •] or of the form Rt, N), N 4 a .1.",
        "The main concept needed for the construction of the LR table is that of LR states.",
        "These are particular elements from 2/tems to be defined shortly.",
        "First, we introduce the function closure from 2it' to 2items and the functions goto and gotow from 2/terns x AI to 2items• For any q C Items, closure(q) is the smallest set such that:",
        "1. q C closure (q); 2.",
        "[7-, N 4 a • M E closure(q), nil E Adjunct(M) and children (M) = 7 implies [T, M -* • 7] E closure(q); 3.",
        "[T, N a • M E closure(q) and t E Adjunct(M) implies [t, T • Rt] E closure (q); 4.",
        "[T, Ft 4 • 1] E closure(q), t E Adjunct(N), N E ./01) and children(N) = 7 implies [(t', N), N • 7] E closure(q); and 5.",
        "[7-, M -+ .1 E closure(q) and [r, N -+ aM • E Items implies [r, N 4 aM • E closure (q).",
        "The clauses 1 thru 4 are reminiscent of the clo",
        "sure function for traditional LR parsing.",
        "Note that in clause 4 we set out to recognize a subtree (t', N) of elementary tree t'.",
        "Clause 5 is unconventional: we traverse the tree T upwards when the dot indicates that all children nodes of M have been recognized.",
        "Next we define the function goto, for any q C Items, and any M E E or M E Ar such that Adjunct(M) includes at least one auxiliary tree.",
        "The function gotoj_ is similar in that it shifts the dot over a node, in this case the imaginary node 1 which is the unique child of an actual foot node F. However, it only does this if t is a tree which can be adjoined at the node that is given as the second argument.",
        "We construct the set Q of all LR states as the smallest collection of sets satisfying the conditions:",
        "1. qj E Q; 2. q E Q, M E .A./.",
        "and q' goto(q,M) 0 imply q' E Q; and 3. q E Q, M E Ar and q' = goto±(q,M) 0 0 imply q' E Q.",
        "An LR state is final if its closure includes a completed item corresponding to an initial tree: Qfin = {q E Q I closure(q)n {[t, T --+ Rt •1 I t E I} 0 0} Final LR states indicate recognition of the input.",
        "Other completed items give rise to a reduction, a type of stack manipulation by the LR automaton to be defined in the next section.",
        "As defined below, reductions are uniquely identified by either auxiliary trees t or by nodes N obtained from the corresponding completed items.",
        "For each node N in a tree, we consider the set CS(N) of strings that represent horizontal cross-sections through the subtree rooted at N. If we do not want to include the cross-section through N itself, we write CS(N)+.",
        "A cross-section can also be seen as the yield of the subtree after removal of a certain number of its subtrees.",
        "For convenience, each node of an auxiliary tree (or subtree thereof) that dominates a foot node is paired with a stack of nodes.",
        "The intuition behind such a stack of nodes [N1, , Arn] is that it indicates a path, the so called spine, through the derived tree in the direction of the foot nodes, where each N, with 1 < i < m, is a node at which adjunction has taken place.",
        "Such stacks correspond to the stacks of linear indexed grammars The set of all stacks of nodes is denoted by Ar*.",
        "The empty stack is denoted by [1, and stacks consisting of head H and tail T are denoted by [HIT].",
        "We define: A4 = U (Ar x N.* ) and we simultaneously define the functions CS and cs+ from Al to 2A4* as the least functions",
        "satisfying: • CS (N)+ C CS (N), for each N; • (N, L) E CS(N), for each N such that N .4* 1, and each L E .,V*; • N E CS (N), for each N such that --,(N •i* 1); and • for each N, children(N) = Mi • • • Mm and xi E CS(Mi), xm E CS(Mm) implies X1 • • • rni E CS+ (N)."
      ]
    },
    {
      "heading": "4 The recognizer",
      "text": [
        "Relying on the functions defined in the previous section, we now explore the steps of the LR automaton, which as usual reads input from left to right and manipulates a stack.",
        "We can divide the stack elements into two classes.",
        "One class contains the LR states from Q, the other contains elements of M. A stack consists of an alternation of elements from these two classes.",
        "More precisely, each stack is an element from the following set of strings, given by a regular expression:",
        "Note that the bottom element of the stack is always gin.",
        "We will use the symbol A to range over stacks and substrings of stacks, and the symbol X to range over elements from .M.",
        "A configuration (A, w) of the automaton consists of a stack A E S and a remaining input w. The steps of the automaton are given by the binary relation I on pairs of configurations.",
        "There are three kinds of step:",
        "got° N) 0, where L is determined by the following.",
        "If for some j (1 < j < m) Xi is of the form (M, L) then this provides the value of L, otherwise we set L = [1.2 reduce aux tree (AqoXiqiX2q2 • • • Xmq,•,,,,w) (AqoXq' , w), provided t E reductions(q,,,,), X1 • • • Xm E CS (R) and q' = goto(q0, N) 0, where we obtain node N from the (unique) Xi",
        "The shift step is identical to that for context-free LR parsing.",
        "There are two reduce steps that must be distinguished.",
        "The first takes place when a subtree of an elementary tree t has been recognized.",
        "We then remove the stack symbols corresponding to a cross-section through that subtree, together with the associated LR states.",
        "We replace these by 2 other symbols, the first of which corresponds to the foot of an auxiliary tree, and the second is the associated LR state.",
        "In the case that some node M of the cross-section dominates the foot of t, then we must copy the associated list L to the first of the new stack elements, after pushing N onto that list to reflect that the spine has grown one segment upwards.",
        "The second type of reduction deals with recognition of an auxiliary tree.",
        "Here, the head of the list [NIL], which indicates the node at which the auxiliary tree t has been adjoined according to previous bottom-up calculations, must match a node that occurs directly above the root node of the auxiliary tree; this is checked by the test q' = goto(q0, N) 0.",
        "Input v is recognized if (qi„, v) 1-* (q,„Aq, E) for some A and q E Qfin.",
        "Then A will be of the form XiqiX2q2 • • • qm_iX,„ where Xi • • E CS (Rt), for some t E I.",
        "Up to now, it has been tacitly assumed that the recognizer has some mechanism to its disposal to find the strings Xi • • •Xm E CS (Rt) and X1 • • Xn., E CS(N) in the stack.",
        "We will now explain how this is done.",
        "For each N, we construct a deterministic finite automaton that recognizes the strings from CS(N) from right to left.",
        "There is only one final state, which has no outgoing transitions.",
        "This is related to the fact that CS(N) is suffix-closed.",
        "A consequence is that, given any stack that may occur and any N, there is at most one string X1 • • Xn, E CS(N) that can be found from the top of the stack downwards, and this string is found in linear time.",
        "For each t E /U A we also construct a deterministic finite automaton for CS (R).",
        "The procedure for t E I is given in Figure 3, and an example of its application is given in Figure 4.",
        "The procedure for t E A is",
        "(K,N,T,s,{f}) that recognizes CS(R), given some t E I. K is the set of states, N acts as alphabet here, T is the set of transitions, s is the initial state and f is the (only) final state.",
        "similar except that it also has to introduce transitions labelled with pairs (N, L), where N dominates a foot and L is a stack in Al..; it is obvious that we should not actually construct different transitions for different L E Alt, but rather one single transition (N,_), with the placeholder \"2 representing all possible L E .A.I.*.",
        "The procedure for CS(N) can easily be expressed in terms of those for CS(R)."
      ]
    },
    {
      "heading": "5 Extended example",
      "text": [
        "For the TAG presented in Figure 1, the algorithm from Schabes and Vijay-Shanker (1990) does not work correctly.",
        "The language described by the grammar contains exactly the strings abc, a' b' c', adbec, and a' db' ec' .",
        "The algorithm from Schabes and Vijay-Shanker (1990) however also accepts adb' ec' and a' dbec.",
        "In the former string, it acts as if it were recognizing the (ill-formed) tree in Figure 2: it correctly matches the part to the \"south\" of the adjunction to the part to the \"north-east\".",
        "Then, after reading c', the information that would indicate",
        "whether a or a' was read is retrieved from the stack, but this information is merely popped without investigation.",
        "Thereby, the algorithm fails to perform the necessary matching of the elementary tree with regard to the part to the \"north-west\" of the adjunction.",
        "Our new algorithm recognizes exactly the strings in the language.",
        "For the running example, the set of LR states and some operations on them are shown in Figure 5.",
        "Arrows labelled with nodes N represent the goto function and those labelled with _L(N) represent the gotol function.",
        "The initial state is 0.",
        "The thin lines separate the items resulting from the goto and goto± functions from those induced by the closure function.",
        "(This corresponds with the distinction between kernel and nonkernel items as known from context-free LR parsing.)",
        "That correct input is recognized is illustrated by the following:",
        "Note that as soon as all the terminals in the auxiliary tree have been read, the \"south\" section of the initial tree is matched to the \"north-west\" section through the goto function.",
        "Through subsequent shifts this is then matched to the \"north-east\" section.",
        "This is in contrast to the situation when incorrect input, such as adb' ec' , is provided to the",
        "Here, the computation is stuck.",
        "In particular, a reduction with auxiliary tree f3 fails due to the fact that goto(1, N2) = 0."
      ]
    },
    {
      "heading": "6 Extensions",
      "text": [
        "The recognizer can be turned into a parser by attaching information to the stack elements from M. At reductions, such information is gathered and combined, and the resulting data is attached to the new element from M that is pushed onto the stack.",
        "This can be used for computation of derived trees or derivation trees, and for computation of features.",
        "Since this technique is almost identical to that for the context-free case, it suffices to refer to existing literature, e.g. Aho et al.",
        "(1986, Section 5.3).",
        "We have treated a classical type of TAG, which has adjunction as the only operation for composing trees.",
        "Many modern types of TAG also allow tree substitution next to adjunction.",
        "Our algorithm can be straightforwardly extended to handle tree substitution.",
        "The main changes that are required lie in the closure function, which needs an extra case (much like the corresponding operation in context-free LR parsing), in adding a third type of goto function, and in adding a fourth step, consisting of reduction of initial trees, which is almost identical to the reduction of auxiliary trees.",
        "The main difference is that all Xj are elements from N.; the X that is pushed can be a substitution node or a nonterminal (see also Section 7).",
        "Up to now we have assumed that the grammar does not assign the empty string as label to any of the leaves of the elementary trees.",
        "The problem introduced by allowing the empty string is that it does not leave any trace on the stack, and therefore CS (Rt) and CS(N) are no longer suffix-closed.",
        "We have solved this by extending items with a third component E, which is a set of nodes labelled with e that have been traversed by the closure function.",
        "Upon encountering a completed item [7-, N 4 a •, E], a reduction is performed according to the sets CS (R, E) or CS+ (N, E), which are subsets of CS (Re) and CS + (N), respectively, containing only those cross-sections in which the nodes la",
        "belled with E are exactly those in E. An automaton for such a set is deterministic and has one final state, without outgoing transitions."
      ]
    },
    {
      "heading": "7 Implementation",
      "text": [
        "We have implemented the parser generator, with the extensions from the previous section.",
        "We have assumed that each set Adjunct(N), if it is not {nil}, depends only on the nonterminal label of N. This allows more compact storage of the entries goto±(q, M): for a fixed state q and nonterminal B, several such entries where M has B as label can be collapsed into a single entry gotol(q, B).",
        "The goto function for tree substitution is represented similarly.",
        "We have constructed the LR table for the English grammar developed by the XTAG project at the University of Pennsylvania.",
        "This grammar contains 286 initial trees and 316 auxiliary trees, which together have 5950 nodes.",
        "There are 9 nonterminals that allow adjunction, and 10 that allow substitution.",
        "There are 21 symbols that function as terminals.",
        "Our findings are that for a grammar of this size, the size of the LR table is prohibitively large.",
        "The table represented as a collection of unit clauses in Prolog takes over 46 MB for storage.",
        "The majority of this is needed to represent the three goto functions, which together require over 2.5 million entries, almost 99% of which is consumed by goto, and the remainder by goto± and the goto function for tree substitution.",
        "The reduction functions require almost 80 thousand entries.",
        "There are 5610 LR states.",
        "The size of the automata for recognizing the sets CS (R, E) and CS + (N, E) is negligible: together they contain just over 15 thousand transitions.",
        "The time requirements for generation of the table were acceptable: approximately 25 minutes were needed on a standard main frame with moderate load.",
        "Another obstacle to practical use is the equivalent of hidden left recursion known from traditional LR parsing (Nederhof and Sarbo, 1996), which we have shown to be present in the grammar for English.",
        "This phenomenon precludes realization of nondeterminism by means of backtracking.",
        "Tabular realization was investigated by Nederhof (1998) and will be the subject of further research."
      ]
    },
    {
      "heading": "Acknowledgments",
      "text": [
        "Anoop Sarkar provided generous help with making the XTAG available for testing purposes.",
        "Parts of this research were carried out within the framework of the Priority Programme Language and Speech Technology (TST), while the author was employed at the University of Groningen.",
        "The TST-Programme is sponsored by NWO (Dutch Organization for Scientific Research).",
        "This work was further funded by the German Federal Ministry of Education, Science, Research and Technology (BMBF) in the framework of the VERBMOBIL Project under Grant 01 IV 701 VO."
      ]
    }
  ]
}
