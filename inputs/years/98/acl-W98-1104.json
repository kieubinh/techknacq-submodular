{
  "info": {
    "authors": [
      "Mikio Yamamoto",
      "Kenneth Ward Church"
    ],
    "book": "Workshop on Very Large Corpora",
    "id": "acl-W98-1104",
    "title": "Using Suffix Arrays to Compute Term Frequency and Document Frequency for All Substrings in a Corpus",
    "url": "https://aclweb.org/anthology/W98-1104",
    "year": 1998
  },
  "references": [
    "acl-C94-1101",
    "acl-J90-1003"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Mutual Information (MI) and similar measures are often used in corpus-based linguistics to find interesting ngrams.",
        "MI looks for bigrams whose term frequency (y) is larger than chance.",
        "Residual Inverse Document Frequency (RIDF) is similar, but it looks for ngrams whose document frequency (di) is larger than chance.",
        "Previous studies have tended to focus on relatively short ngrams, typically bigrams and trigrams.",
        "In this paper, we will show that this approach can be extended to arbitrarily long ngrams.",
        "Using suffix arrays, we were able to compute tf, df and RIDF for all ngrams in two large corpora, an English corpus of 50 million words of Wall Street Journal news articles and a Japanese corpus of 216 million characters of Mainichi Shimbun news articles."
      ]
    },
    {
      "heading": "1 MI and RIDF",
      "text": [
        "Mutual Information (MI), 1(x;y), compares the probability of observing word x and word y together (the joint probability) with the probabilities of observing x and y independently (chance).",
        "MI has been used to identify a variety of interesting linguistic phenomena, ranging from semantic relations of the doctor/nurse type to lexico-syntactic co-occurrence preferences of the save/from type (Church and Hanks, 1990).",
        "Church and Gale (1995) proposed Residual Inverse Document Frequency (RIDF), the difference between the observed IDF and what would be expected under a Poisson model for a random word or phrase with comparable frequency.",
        "RIDF is a variant of IDF, a standard method for weighting keywords in Information Retrieval (IR).",
        "Let D be the number of documents, Y' be the term frequency (what we call \"frequency\" in our field) and df be the document frequency (the number of documents which contain the word or phrase at least once).",
        "RIDF is defined as: Residual 1DF a observed IDF - predicted IDF = -log(df/D) +log(1-exp(- 0)) = -log(df/D) +log(1-exp(-tf/D)).",
        "RIDF is, in certain sense, like MI; both are the log of the ratio between an empirical observation and a chance-based estimate.",
        "Words or phrases with high RIDF or MI have distributions that cannot be attributed to chance.",
        "However, the two measures look for different kinds of deviations from chance.",
        "MI tends to pick out general vocabulary, the kind of words one would expect to find in a dictionary, whereas RIDF tends to pick out good keywords, the kind of words one would not expect to find in a dictionary.",
        "This distinction is not surprising given the history of the two measures; MI, as it is currently used in our field, came from lexicography whereas RIDF came from Information Retrieval.",
        "In addition, it is natural to compute RIDF for all substrings.",
        "This is generally not done for MI, though there are many ways that MI could be generalized to apply to longer ngrams.",
        "In the next section, we will show an algorithm based on suffix",
        "arrays for computing tf, df and RIDF for all substrings in a corpus in 0(NlogN) time.",
        "In section 3, we will compute RIDFs for all substrings in a corpus and compare and contrast MI and RIDF experimentally for phrases in a English corpus and words/phrases in a Japanese corpus.",
        "We won't try to argue that one measure is better than the other; rather we prefer to view the two measures as mutually complementary."
      ]
    },
    {
      "heading": "2 Computing tf and df for all substrings 2.1 Suffix arrays",
      "text": [
        "A suffix array is a data structure designed to make it convenient to compute term frequencies for all substrings in a corpus.",
        "Figure 1 shows an example of a suffix array for a corpus of N=6 words.",
        "A suffix array, s, is an array of all N suffixes, pointers to substrings that start at position i and continue to the end of the corpus, sorted alphabetically.",
        "The following very simple C function, suffix_array, takes a corpus as input and returns a suffix array.",
        "int suffix_compare(char **a, char **b){ return strcmp(*a.",
        "*b); /* The input is a string, terminated with a null */ char **suffix_array(char*corpus){ int i, N = strlen(corpus); char **result=(char **)malloc(N*sizeof(char *)); /* initialize result[i] with the ith suffix */ for(i=0; i < N; i++) result(i) = corpus + i; gsort(result, N, sizeof(char *), suffix_compare); return result; Nagao and Mori (1994) describe this procedure, and report that it works well on their corpus, and that it requires 0(NlogN) time, assuming that the sort step requires 0(NlogIV) comparisons, and that each comparison requires 0(1) time.",
        "We tried this procedure on our two corpora, and it worked well for the Japanese one, but unfortunately, it can go quadratic for a corpus with long repeated substrings, where strcmp takes 0(N) time rather than 0(1) time.",
        "For our English corpus, after 50 hours of cpu time, we gave up and turned to Doug McIlroy's implementation (http://cm.bell-labs.com/cm/cs/ who/doug/ssort.c) of Manber and Myers' (1993) algorithm, which took only 2 hours.",
        "For a corpus that would otherwise go quadratic, the Manber and Myers' algorithm is well worth the effort, but otherwise, the procedure described above is simpler, and often a bit faster.",
        "As mentioned above, suffix arrays were designed to make it easy to compute term frequencies (tf).",
        "If you want the term frequency of \"to be,\" you can do a binary search to find the first and last position in the suffix array that start with this phrase, i and j, and then tf(\"to be\") =j-i+1.",
        "In this case, i=5 and j=6, and consequently, tyto be\")=6-5+1=2.",
        "Similarly, tf(\"be\").",
        "2-1+1 = 2, and (\"to\")=6-5+1=2.",
        "This straightforward method of computing tf requires 0(logN) string comparisons, though as before, each string comparison could take 0(N) time.",
        "There are more sophisticated algorithms that take 0(logN) time, even for corpora with long repeated substrings.",
        "A closely related concept is lcp (longest common prefix).",
        "Lcp is a vector of length N, where Icp[i] indicates the length of the common prefix between the ith suffix and the i+/st suffix in the suffix array.",
        "Manber and Myers (1993) showed how to compute the lcp vector in 0(NlogN) time, even for corpora with long repeated substrings, though for many corpora, the complications required to avoid quadratic behavior are unnecessary.",
        "Lep's are denoted by bold vertical lines as well as the Icp table."
      ]
    },
    {
      "heading": "2.2 Classes of substrings",
      "text": [
        "Thus far we have seen how to compute tf for a single ngram, but how do we compute tf and df for all ngrams?",
        "There are N(N-1-1)12 substrings in a text of size N. If every substring has a different tf and df, the counting algorithm would require at least quadratic time and space.",
        "Fortunately many substrings have the same tf and the same df We",
        "will cluster the N(N1-1)/2 substrings into at most 2N-1 classes and compute tf and df over the classes.",
        "There will be at most N distinct values of RIDF.",
        "Let <i,j> be an interval on the suffix array: sUll.",
        "We call the interval LCP-delimited if the lcp's are larger inside the interval than at its boundary:",
        "In Figure 1, for example, the interval <5,6> is LCP-delimited, and as a result, tf(\"to\") = (\"to be\") = 2, and df(\"to\")=dft\"to be\").",
        "The interval <5,6> is associated with a class of substrings: \"to\" and \"to be.\" Classes will turn out to be important because all of the substrings in a class have the same tf (property I) and the same df (property 2).",
        "In addition, we will show that classes partition the set of substrings (property 3) so that we can compute tf and df on the classes, rather than substrings.",
        "Doing so is much more efficient because there many fewer classes than substrings (property 4).",
        "Classes of substrings are defined to be the (not necessarily least) common prefixes in an interval.",
        "In Figure 1, for example, both \"to\" and \"to be\" are common prefixes throughout the interval <5,6>.",
        "That is, every suffix in the interval <5,6> starts with \"to,\" and every suffix also starts with \"to be\".",
        "More formally, we define class(<ij>) as: fs[i]„,1 LBL<Irt5..SIL), where s[i]n is a substring (the first m characters of s[ip, LBL(Iongest boundary lcp) is the right hand of (1) and SIL (shortest interior lcp) is the left hand side\" of (1).",
        "In Figure 1, for example, S I L(<5 ,6>) = min(lcp[5]) = 2, LBL(<5,6>) = max0cp[4], Icp[6]) =0, and class(<5,6>) = {s[5]ni I 0<m.2} = (\"to\", \"to be\").",
        "Figure 2 shows six LCP-delimited intervals and the LB L and SIL of <2,4>.",
        "For <2,4>, the bounding lcp's are Icp[l = 2 and lc p[4]=3 (LBL=3), and the interior lcp's are Icp[2]=4 and",
        "LCP-delimited because SIL is infinite and LBL=6.",
        "The interval <2,3> is not LCP-delimited because SIL is 4 and LBL is 6 (LBL>SIL).",
        "By construction, the suffixes within the interval <i,j> all start with the substrings in class(<i,j>), and no suffixes outside this interval start with these substrings.",
        "As a result, if stand s2 are two substrings in class(<ij>) then",
        "The calculation of df is more complicated than tf, and will be discussed in section 2.4.",
        "It is not uncommon for an LCP-delimited interval to be nested within another.",
        "In Figure 2, for example, the interval <3,4> is nested within <2,4>.",
        "The computation of df in section 2.4 will take advantage of a very convenient nesting property.",
        "Given two LCP-delimited intervals, either one is nested within the other (e.g., <2,4> and <3,4>), or one precedes the other (e.g., <2,2> and <3,4>), but they cannot overlap.",
        "Thus, for example, the intervals <1,3> and <2,4> cannot both be LCP-delimited because they overlap.",
        "Because of this nesting property, it is possible to express the df of an interval recursively in terms of its constituents or subintervals.",
        "As mentioned above, we will use the following partitioning property so that we can",
        "compute tf and df on the classes rather than on the substrings.",
        "There are two parts to this argument: every substring belongs to at most one class (property 3a), and every substring belongs to at least one class (property 3b).",
        "Demonstration of property 3a (proof by contradiction): Suppose there is a substring, s, that is a member of two classes: class(<ij>) and class(<u,v>).",
        "There are three possibilities: one interval precedes the other, they are property nested or they overlap.",
        "The only interesting case is the nesting case.",
        "Suppose without loss of generality that <u,v> is nested within <ij> as in Figure 3.",
        "Because <u,v> is LCP-delimited, there must be a bounding lcp of <u,v> that is smaller than any lcp within <u,v>.",
        "This bounding Icp must be within <ij>, and as a result, class(<ij>) and class(<u,v>) must be disjoint.",
        "Therefore, s cannot be in both classes.",
        "Demonstration of property 3b (constructive argument): Let s be an arbitrary substring in the corpus.",
        "There will be at least one suffix in the suffix array that starts with s. Let i be the first such suffix and let j be the last such suffix.",
        "By construction, the interval <ij> is LCP-delimited (LBL(<itj>) < Psi and SIL(<ij>) ?_ Psi), and s is an element of class(<ij>).",
        "Finally, as mentioned above, computing over classes is much more efficient than computing over the substrings themselves because there are many fewer classes (at most 2N-1) than substrings (N(N+1)/2).",
        "The first clause is relatively straightforward.",
        "There are N intervals <i,i>.",
        "These are all and only the intervals with tfr--1.",
        "By construction, these intervals are LCP-delimited.",
        "To argue the second clause, we will make use of a uniqueness property: an LCP-delimited interval <ij> can be uniquely determined by its SIL and a representative element k (i 5_k<j).",
        "Suppose there were two distinct intervals, <ij> and <u,v>, with the same S I L, SIL(<u,v>), and the same representative, i.5./c<j and iik<v. Since they share a common representative, k, the two intervals must overlap.",
        "But since they are distinct, there must be a distinguishing element, d, that is in one but not the other.",
        "One of these distinguishing elements, d, would have to be a bounding lcp in one and an interior lcp in the other.",
        "But then the two intervals couldn't both be LCP-delimited.",
        "Given this uniqueness property, we can determine the N-1 upper bound on the number of LCP-delimited intervals by considering the N-1 elements in the lcp vector.",
        "Each of these elements, Icp[k], has the opportunity to become the SIL of an LCP-delimited interval <ij> with a representative k. Thus there could be as many as N-1 LCP-delimited intervals (though there could be fewer if some of the opportunities don't work out).",
        "Moreover, there couldn't be any more intervals with tf>l, because if there were one, its SIL should have been in the lcp vector.",
        "(Note that this lcp counting argument excludes intervals with tf=1 discussed above, because their SILs need not be in the lcp vector.)",
        "From property 4, it follows that there are at most N distinct values of RIDF.",
        "The N intervals <i,i> have just one RIDF value since tf=dfr--1 for these intervals.",
        "The other N-1 intervals could have another N-1 RIDF values.",
        "In summary, the four properties taken collectively make it practical to compute tf, df and RIDF over a relatively small number of classes; it would have been prohibitively expensive to compute these quantities directly over the N(N+1)/2 substrings."
      ]
    },
    {
      "heading": "2,3 Calculating classes using Suffix Array",
      "text": [
        "This section will describe a single pass procedure for computing classes.",
        "Since LCP-delimited intervals obey a convenient nesting property, the procedure is based on a push-down stack.",
        "The procedure outputs 4-tuples, <s[i],LBL,SIL,tf>, one for each LCP-delimited interval.",
        "The stack elements are pairs (x,y), where x is an index, typically the left edge of a candidate LCP-delimited interval, and y is the S I L of this candidate interval.",
        "Typically, y=lcp[x], though not always, as we will see in Figure 5.",
        "The algorithm sweeps over the suffixes in suffix array s[1..N] and their Icp[I..N] (Icp[IV]=0) successively.",
        "While Icp's of suffixes are monotonically increasing, indexes and lcp's of the suffixes are pushed into a stack.",
        "When it finds the i-th suffix whose Icp[i] is less than the lcp on the top of the stack, the index and lcp on the top are popped off the stack.",
        "Popping is repeated until the lcp on the top becomes less than the Icp[i].",
        "A stack element popped out generates a class.",
        "Suppose that a stack element composed of an index i and Icp[i] is popped out by Icp[f].",
        "Lcp[i] is used as the SIL.",
        "The LBL is the lop on the next top element in the stack or Icp[j].",
        "If the next top lop will be popped out by Icp[j], then the algorithm uses the next top lcp as the LB L, else it uses the Icp[j].",
        "Tf is the offset between the indexes i and j, that is, j-i+/.",
        "computing all classes with tf > 1.",
        "If classes with y.",
        "= 1 are needed, we can easily add the line to output those into the algorithm.",
        "The expressions, push(x,y) and pop(x,y), operate on the stack in the obvious way, but note that x and y are inputs for push and outputs for pop.",
        "The expression, top(x,y), is equivalent to pop(x,y) followed by push(x,y); it reads the top of the stack without changing the stack pointer.",
        "As mentioned above, the stack elements are typically pairs (z,y) where y=lcp[x], but not always.",
        "Pairs are typically pushed onto the stack by line 6, push(i, Icp[i]), and consequently, y=lcp[x], in many cases, but some pairs are pushed on by line 15.",
        "Figure 5 (a) shows the typical case with the suffix array in Figure 2.",
        "At this point, i=3 and the stack contains 4 pairs, a dummy element (-1, -1), followed by three pairs generated by line 6: (1, Icp[1]), (2, Icp[2]), (3, Icp[3]).",
        "In contrast, Figure 5 (b) shows an atypical case.",
        "In between snapshot (a) and snapshot (b), two LCP-delimited intervals were generated, <s[3], 4, 6, 2> and ‹s[2], 3, 4, 3>, and then the pair (2, 3) was pushed onto the stack by line 15, push(indexl, Icp[i]), to capture the fact that there is a candidate LCP-delimited interval starting at index 1=2, spanning past the representative element i=4, with an SIL of lcp[i=41."
      ]
    },
    {
      "heading": "2.4 Computing df for all classes",
      "text": [
        "This section will extend the algorithm in Figure 4 to include the calculation of df.",
        "Straightforwardly computing df independently for each class would require at least quadratic time, because the program must check document id's for all substrings (N at most) in all classes (N-1 at most).",
        "Instead of this, we will take advantage of the nesting property of intervals.",
        "The df for one",
        "interval can be computed recursively in terms of its constituents (nested subintervals), avoiding unnecessary recomputation.",
        "The stack elements in Figure 5 is augmented with two additional counters: (1) a df counter for summing the dfs over the nested subintervals and (2) a duplication counter for adjusting for overcounting documents that are referenced in multiple subintervals.",
        "The df for an interval is simply the difference of these two counters, that is, the sum of the dfs of the subintervals, minus the duplication.",
        "A C code implementation can be found at http://www.milab.is.tsukuba.ac.jp/-myama/OMdfc.",
        "The df counters are relatively straightforward to implement.",
        "The crux of the problem is the adjustment for duplication.",
        "The adjustment makes use of a document link table, as illustrated in Figure 6.",
        "The left two columns indicate that suffixes s[101], s[104] and s[107] are",
        "all in document 382, and that several other suffixes are also in the same documents.",
        "The third column links together suffixes that are in the same document.",
        "Note, for example, that there is a pointer from suffix 104 to 101, indicating that 4104] and s[101] are in the same document.",
        "The suffixes in one of these linked lists are kept sorted by their order in the suffix array.",
        "When the algorithm is processing s[t], the algorithm searches the stack to find the suffix, s[k], with the largest k such and s[i] and s[k] are in the same document.",
        "This search can be performed in 0(logN) time.",
        "Figure 7 shows the LCP-delimited intervals in a suffix array and four suffixes included in the same document.",
        "II has four immediate constituents of intervals.",
        "S[j] is included in the same document of s[iJ.",
        "Count for the document of s[j] will be duplicated at computing df of D. At the point of processing s[j], the algorithm will increment duplication-counter of II to cancel df count of s[j].",
        "As the same way, df count of s[k] has to canceled at computing dfof Figure 8 shows a snapshot of the stack after processing s[4] in Figure 2.",
        "Each stack element is a 4-tuple of the index of suffix array, lcp, df-counter and duplication-counter, (i, lcp, df, dc).",
        "Figure 2 shows s[1] and s[4] are in the same document.",
        "Looking up the document link table, the algorithm knows s[1] is the nearest suffix which is in the same document of *4].",
        "The duplication-counter of the element of s[1] is incremented.",
        "The duplication of counting s[I] and s[4] for the class generated by s[I] will be avoided using this duplication-counter.",
        "At some processing point, the algorithm uses only a part of the document link table.",
        "It",
        "needs only the nearest index on the link, but not the whole of the link.",
        "So we can compress the link table to dynamic one in which an entry of each document holds the nearest index.",
        "Figure 9 shows the nearest index table of document after processing s[4].",
        "The final algorithm to calculate all classes with if and df takes 0(NlogIV) time and 0(N) space in the worst case."
      ]
    },
    {
      "heading": "3 Experimental results",
      "text": []
    },
    {
      "heading": "3.1 RIDF and MI for English and Japanese",
      "text": [
        "We computed all RIDFs for all substrings of two corpora, Wall Street Journal of ACL/DCI in English (about 50M words and 113k articles) and Mainichi News Paper 1991-1995 (CD-Mainichi Shimbun 91-95) in Japanese (about 216M characters and 436k articles) , using the algorithm in the previous section.",
        "In English, we tokenized the text into words, delimited by white .space, whereas in Japanese we tokenized the text into characters (usually 2-bytes) because Japanese text has no word delimiter such as white space.",
        "It took a few hours to compute all RIDFs using the suffix array.",
        "It takes much longer to compute the suffix array than to compute if and df.",
        "We ignored substrings with tf < 10 to avoid noise, resulting in about 1.6M English phrases (#classes = 1.4M) and about 15M substrings of Japanese words/phrases (#classes = 10M).",
        "MI of the longest substring of each class was also computed by the following formula."
      ]
    },
    {
      "heading": "3.2 Little correlation between RIDF and MI",
      "text": [
        "We are interested in comparing and contrasting RIDF and MI.",
        "Figure 10 (a) plots RIDF vs MI for phrases in WSJ (length > 1), showing little, if any, correlation between RIDF and MI.",
        "Figure 10 (b) also plots RIDF vs MI but this time the corpus is in Japanese and the words were manually selected by the newspaper to be keywords.",
        "Both Figures 10 (a) and 10 (b) suggest that RIDF and MI are largely independent.",
        "There are many substrings with a large RIDF value and a small MI, and vice versa.",
        "MI is very different from RIDF.",
        "Both pick out interesting phrases, but phrases with large MI are interesting in different ways from phrases with large RIDF.",
        "Consider the phrases in Table 1, which all contain the word \"having.\" These phrases have large MI values and small RIDF values.",
        "A lexicographer such as Patrick Hanks, who works on dictionaries for learners, might be interested in these phrases because these kinds of collocations tend to be difficult for non-native speakers of the language.",
        "On the other hand, these kinds of collocations are not very good keywords.",
        "Table 2 is a random sample of phrases containing the substring /Mr/, sorted by RIDF.",
        "The ones at the top of the list tend to be better keywords than the ones further down.",
        "Table 3.A and 3.B show a few phrases starting with /the/, sorted by MI (Table 3.A) and sorted by RIDF (Table 3.B).",
        "Most of the phrases are interesting in one way or another, but those at the top of Table 3.A tend to be somewhat",
        "Where xyz is a phrase or string, x and z are a word or a character and y is a sub-phrase or substring.",
        "The first cot.",
        "is the token id and the last col. is",
        "2229521: line in the drafting of the Basic 2229902: s policy as expressed in the Basic 9746758: he U.S. Constitution and the Basic 11824764: any changes must follow the Basic 33007637: sts a tentative draft of the Basic 33007720: the relationship between the Basic 33007729: onstitution .",
        "Originally the Basic 33007945: wer of interpretation of the Basic 33007975: tation of a provision of the Basic 33008031: interpret provisions of the Basic 33008045: tation of a provision of the Basic 33008115: etation of an article of the Basic 33008205: nland representatives of the Basic 33008398: e : Mainland drafters of the Basic 33008488: pret all the articles of the Basic 33008506: y and power to interpret the Basic 33008521: pret those provisions of the Basic 33008545: r the tentative draft of the Basic 33008690: d of being guaranteed by the Basic 33008712: uncilor , is a member of the Basic 39020313: sts a tentative draft of the Basic 39020396: the relationship between the Basic 39020405: onstitution .",
        "Originally the Basic 39020621: wer of interpretation of the Basic 39020651: tation of a provision of the Basic 39020707: interpret provisions of the Basic 39020721: tation of a provision of the Basic",
        "of the phrase \"the Basic Law\" the doc id (position of the start word in the corpus) Law that will determine how Hon 2228648 Law -- as Gov.",
        "Wilson's debut s 2228648 Law of the Federal Republic of 9746014 Law , Hong Kong's miniconstitut 11824269 Law , and although this may be 33007425 Law and the Chinese Constitutio 33007425 Law was to deal with this topic 33007425 Law shall be vested in the NPC 33007425 Law , the courts of the HKSAR ( 33007425 Law .",
        "If a case involves the in 33007425 Law concerning defense , foreig 33007425 Law regarding \" defense , forei 33007425 Law Drafting Committee fear tha 33007425 Law simply do not appreciate th 33007425 Law .",
        "While recognizing that th 33007425 Law , it should irrevocably del 33007425 Law within the scope of Hong Ko 33007425 Law , I cannot help but conclud 33007425 Law , are being redefined out o 33007425 Law Drafting Committee .",
        "<BOA> 33007425 Law , and although this may be 39020101 Law and the Chinese Constitutio 39020101 Law was to deal with this topic 39020101 Law shall be vested in the NPC 39020101 Law , the courts of the HKSAR ( 39020101 Law .",
        "If a case involves the in 39020101 Law concerning defense , foreig 39020101 Law regarding \" defense , forei 39020101 Law Drafting Committee fear tha 39020101 Law simply do not appreciate th 39020101 Law .",
        "While recognizing that th 39020101 Law , it should irrevocably del 39020101 Law within the scope of Hong Ko 39020101 Law , I cannot help but conclud 39020101 Law , are being redefined out o 39020101 Law Drafting Committee .",
        "<BOA> 39020101",
        "idiomatic (in the WSJ domain) whereas those at the top of Table 3.B tend to pick out specific stories or events in the news.",
        "For example, the phrase, \"the Basic Law,\" selects for stories about the British handover of Hong Kong to China, as illustrated in Table 3.C.",
        "Table 4 shows a number of phrases with high MI containing common prepositions.",
        "The high MI indicates an interesting association, but again most of them are not good keywords, though there are a few exceptions such as \"Just for Men,\" a well-known brand name.",
        "RIDF and MI for Japanese substrings tend to be similar.",
        "Substrings with both high RIDF and MI tend to be good keywords such as fa* (merger), i* 0 (stock certificate), n (dictionary), (wireless) and so on.",
        "Substrings with both low RIDF and MI tend to be poor keywords such as ='-`7 (current regular-season game) and meaningless fragments such as ??).",
        "Table 5 shows examples where MI and RIDF point in opposite directions (rectangles in Figure 10 (b)).",
        "Words with low RIDF and high MI tend to be general vocabulary (often written in Kanji characters).",
        "In contrast, words with high RIDF and low MI tend • to be domain specific words such as loan words (often written in Katakana characters).",
        "MI is high for words in general vocabulary (words found in dictionary) and RIDF is high for good keywords for IR."
      ]
    },
    {
      "heading": "3.3 Word extraction",
      "text": [
        "Sproat and Shih (1990) found MI to be useful for word extraction in Chinese.",
        "We performed the following experiment to see if both MI and RIDF are useful for word extraction in Japanese.",
        "We extracted four random samples of 100 substrings each.",
        "The four samples cover all four combinations of high and low RIDF and high and low MI, where high is defined to be in the top decile and low is defined to be in the bottom decile.",
        "Then we manually scored each sample substring using our own judgment as a good (the substring is a word) or bad the substring is not a word) or gray (the judge is not sure).",
        "The results are presented in Table 6, which shows that",
        "Each cell is computed over a sample of 100 examples.",
        "The smaller values are counts of 'good' words and the larger values, 'not bad' words ('good' and 'gray' words).",
        "Good or 'not bad' word ratio of pairs of characters with high MI is 51-76%.",
        "substrings with high scores in both dimensions are more likely to be words than substrings that score high in just one dimension.",
        "Conversely, substrings with low scores in both dimensions are very unlikely to be words."
      ]
    },
    {
      "heading": "3.4 Case study: Names",
      "text": [
        "We also compared RIDF and MI for people's names.",
        "We made a list of people's names from corpora using simple heuristics.",
        "A phrase or substring is accepted as a person's name if English phrase starts with the title 'Mr.'",
        "'Ms.'",
        "or 'Dr.'",
        "and is followed by a series of capitalized words.",
        "For Japanese, we selected phrases in the keyword list ending with (-shi), which is roughly the equivalent of the English titles 'Mr.'",
        "and 'Ms.'",
        "Figure 11 plots RIDF and MI for names in English (a) and Japanese (b) with tf ?..",
        "10, respectively.",
        "Figure 11(a) shows that MI has a more limited range than RIDF, suggesting that RIDF may be more effective with names than MI.",
        "The English name 'Mr.",
        "From' is a particularly",
        "interesting case, since both 'Mr.'",
        "and 'From' is a stop word.",
        "In this case, the RIDF was large and the MI was not.",
        "The Japanese names in Figure 1 I (b) split naturally at RIDF = 0.5.",
        "Japanese names with RIDF below 0.5 are different from names after 0.5.",
        "The group whose RIDF is under 0.5 included first name and full name (first and last name) at rate of 90% and another group whose RIDF is up to 0.5 included only last name at rate of 90%.",
        "The reason of this separation is that full name (and first name as a substring of full name) appears once in the beginning of the document, but last name is repeated as a reference in the article.",
        "Recall that RIDF tends to give higher value to substrings which appear many times in a few documents.",
        "In summary, RIDF can discriminate difference of some words which cannot be done by MI."
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We showed that RIDF is efficiently and naturally scalable to long phrases or substrings.",
        "RIDF for all substrings in a corpus can be computed using the algorithm which computes tfs and dfs for all substrings based on Suffix Array.",
        "It remains an open question how to do this for MI.",
        "We found that RIDF is useful for finding good keywords, word extraction and so on.",
        "The combination of MI and RIDF is better than either by itself.",
        "RIDE is like MI, but different."
      ]
    }
  ]
}
