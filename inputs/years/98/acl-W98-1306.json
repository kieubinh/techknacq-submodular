{
  "info": {
    "authors": [
      "Gertjan van Noord"
    ],
    "book": "Workshop on Finite State Methods in Natural Language Processing",
    "id": "acl-W98-1306",
    "title": "Treatment of E-Moves in Subset Construction",
    "url": "https://aclweb.org/anthology/W98-1306",
    "year": 1998
  },
  "references": [
    "acl-J97-2003",
    "acl-P97-1058"
  ],
  "sections": [
    {
      "text": [
        "vannoordelet .",
        "rug .n1 Abstract The paper discusses the problem of determinising finite-state automata containing large numbers of e-moves.",
        "Experiments with finite-state approximations of natural language grammars often give rise to very large automata with a very large number of &-moves.",
        "The paper identifies three subset construction algorithms which treat &moves.",
        "A number of experiments has been performed which indicate that the algorithms differ considerably in practice.",
        "Furthermore, the experiments suggest that the average number of e-moves per state can be used to predict which algorithm is likely to perform best for a given input automaton."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "In experimenting with finite-state approximation techniques for context-free and more powerful grammatical formalisms (such as the techniques presented in Pereira and Wright (1997), Nederhof (1997), Evans (1997)) we have found that the resulting automata often are extremely large.",
        "Moreover, the automata contain many &cloves (jumps).",
        "And finally, if such automata are determinised then the resulting automata are often smaller.",
        "It turns out that a straightforward implementation of the subset construction detenninisation algorithm performs badly for such inputs.",
        "As a motivating example, consider the definite-clause grammar that has been developed for the OVIS2 Spoken Dialogue System.",
        "This grammar is described in detail in van Noord et al.",
        "(1997).",
        "After removing the feature constraints of this grammar, and after the removal of the sub-grammar for temporal expressions, this context-free skeleton grammar was input to an implementation of the technique described in Nederhof (1997).",
        "The resulting non-deterministic automaton (labelled zovis2 below) contains 89832 states, 80935 &moves, and 80400 transitions.",
        "The determinised automaton contains only 6541 states, and 60781 transitions.",
        "Finally, the minimal automaton contains only 78 states and 526 transitions!",
        "Other grammars give rise to similar numbers.",
        "Thus, the approximation techniques yield particularly 'verbose' automata for relatively simple languages.",
        "The experiments were performed using the FSA Utilities toolkit (van Noord, 1997).",
        "At the time, an old version of the toolkit was used, which ran into memory problems for some of these automata.",
        "For this reason, the subset construction algorithm has been re-implemented, paying special attention to the treatment of &moves.",
        "Three variants of the subset construction algorithm are identified which differ in the way &moves are treated: per graph The most obvious and straightforward approach is sequential in the following sense.",
        "Firstly, an equivalent automaton without c-moves is constructed for the input.",
        "In or",
        "der to do this, the transitive closure of the graph consisting of all e-moves is computed.",
        "Secondly, the resulting automaton is then treated by a subset construction algorithm for e-free automata.",
        "• per state For each state which occurs in a subset produced during subset construction, compute the states which are reachable using e-moves.",
        "The results of this computation can be memorised, or computed for each state in a preprocessing step.",
        "This is the approach mentioned briefly in Johson and Wood (1997).2 per subset For each subset Q of states which arises during subset construction, compute Q' Q which extends Q with all states which are reachable from any member of Q using e-moves.",
        "Such an algorithm is described in Aho, Sethi, and Ullman (1986).",
        "We extend this algorithm by memorising the e-closure computation.",
        "The motivation for this paper is the experience that the first approach turns out to be impractical for automata with very large numbers of e-moves.",
        "An integration of the subset construction algorithm with the computation of e-reachable states performs much better in practice.",
        "The per subset algorithm almost always performs better than the per state approach.",
        "However, for automata with a low number of jumps, the per graph algorithm outperforms the others.",
        "In constructing an e-free automaton the number of transitions increases.",
        "Given the fact that the input automaton already is extremely large (compared to the simplicity of the language it defines), this is an undesirable situation.",
        "An equivalent e-free automaton for the example given above results in an automaton with 2353781 transitions.",
        "The implementation of per subset is the only variant which succeeds in determinising the input automaton of this example.",
        "In the following section some background information concerning the FSA Utilities toolbox is provided.",
        "Section 3 then presents a short statement of the problem (determinise a given finite-state automaton), and a subset construction algorithm which solves this problem in the absence of e-moves.",
        "Section 4 identifies three variants of the subset construction algorithm which take &moves into account.",
        "Finally, section 5 discusses some experiments in order to compare the three variants both on randomly generated automata and on automata generated by approximation algorithms."
      ]
    },
    {
      "heading": "2 FSA Utilities",
      "text": [
        "The FSA Utilities toolbox is a collection of tools to manipulate regular expressions, finite-state automata and finite-state transducers (both string-to-string and string-to-weight transducers).",
        "Manipulations include determinisation (both for finite-state acceptors and finite-state transducers), minimisation, composition, complementation, intersection, Kleene closure, etc.",
        "Various visualisation tools are available to browse finite-state automata.",
        "The toolbox is implemented in SICStus Prolog.",
        "The motivation for the FSA Utilities toolbox has been the rapidly growing interest for finite-state techniques in computational linguistics.",
        "The FSA Utilities toolbox has been developed to experiment with these techniques.",
        "The toolbox is available free of charge under Gnu General Public License.",
        "The following provides an overview of the functionality of the toolbox.",
        "- Construction of finite automata on the basis of regular expressions.",
        "Regular expression operators include concatenation, Kleene dosure, union and option (the standard regular expression operators).",
        "Furthermore the extended regular expression operators are provided: complement, difference and intersection.",
        "Symbols can be intervals of symbols, or the 'Any'variable which matches any symbol.",
        "Regular expression operators are provided for operations on the underlying automaton, induding minimisation and determinisation.",
        "Finally, we support user-defined regular expression operators.",
        "- We also provide operators for transductions such as composition, cross-product, same-length-cross-product, domain, range, identity and inversion.",
        "- Determinisation and Minimisation.",
        "Three different minimisation algorithms are supported: Hoperoft's algorithm (Hoperoft, 1971), Hoperoft and Ullmart's algorithm (Hoperoft and Ullman, 1979), and Brzozowski's algorithm (Brzozowski, 1962).",
        "- Determinisation and minimisation of string-to-string and string-to-weight transducers (Mohri, 1996; Mohri, 1997).",
        "- Visualisation.",
        "Support includes built-in visualisation (Td/Tk, TeX+PicTeX, TeX+PsTricks, Postscript) and interfaces to third party graph visualisation software (Graphviz (dot), VCG, daVmci).",
        "- Random generation of finite automata (an extension of the algorithm in Leslie (1995) to allow the generation of finite automata containing &moves)."
      ]
    },
    {
      "heading": "3 Subset Construction",
      "text": []
    },
    {
      "heading": "3.1 Problem statement",
      "text": [
        "Let a finite-state machine M be specified by a tuple (Q,E,6,S,F) where Q is a finite set of states, E is a finite alphabet, 6 is a function from Q x (EU {e}) --■ 2.",
        "Furthermore, S C Q is a set of start states.' and F C Q is a set of final states.",
        "Let &move be the relation {(qi, qi)jqj E 6(qi, e)}.",
        "c-reachable is the reflexive and transitive closure of &move.",
        "Let &CLOSURE: 2Q 2Q be a function which is defined as: c-CLOSURE(Q1) = {qlq' E Q', (q' ,q) E c-reachable} For any given finite-state automaton M = (Q,E,6,S,F) there is an equivalent deterministic automaton M' = (2Q, E , 6', {Qo), F').",
        "F' is the set of all states in 2Q containing a final state of M, i.e., the set of subsets {Qi E 2Q lq E Q q E F).",
        "M' has a single start state Qo which is the epsilon closure of the start states of M, i.e., Qo = c-CLOSURE(S).",
        "Finally,",
        "An algorithm which computes M' for a given M will only need to take into account states in 2' which are reachable from the start state Qo.",
        "This is the reason that for many input automata the algorithm does not need to treat all subsets of states (but note that there are automata for which all subsets are relevant, and hence exponential behaviour cannot be avoided in general).",
        "Consider the subset construction algorithm in figure 1.",
        "The algorithm maintains a set of subsets States.",
        "Each subset can be either marked or unmarked (to indicate whether the subset has been treated by the algorithm); the set of unmarked subsets is sometimes referred to",
        "as the agenda.",
        "The algorithm takes such an unmarked subset T and computes all transitions leaving T. This computation is performed by the function instructions and is called instruction computation by Johson and Wood (1997).",
        "The function index_transitions constructs the function transitions : Q --+ x 2Q.",
        "This function returns for a given state p the set of pairs (a, T) representing the transitions leaving p. Furthermore, the function merge takes such a set of pairs and merges all pairs with the same first element (by taking the union of the corresponding second elements).",
        "For example: mergeffia, {1,2,4)), (b, {2, 4)), (a, {3, 4)), (b, {5, 61)}) = {(a, {1, 2,3,4}), (b, {2, 4, 5, 6})} The procedure add is responsible for 'reachable-state-set maintenance', by ensuring that target subsets are added to the set of subsets if these subsets were not encountered before.",
        "Moreover, if such a new subset contains a final state, then this subset is added to the set of final states."
      ]
    },
    {
      "heading": "4 Three Variants for e-Moves",
      "text": [
        "The algorithm presented in the previous section does not treat &moves.",
        "In this section three possible extensions of the algorithm are identified to treat &moves."
      ]
    },
    {
      "heading": "4.1 Per graph",
      "text": [
        "This variant can be seen as a straightforward implementation of the constructive proof that for any given automaton with &moves there is an equivalent one without &moves (Hoperoft and Ullman, 1979)[page 26-27].",
        "For a given M = (Q, 1, 6, 5, F) this variant first computes M' = (Q, , 5', S', F), where S' = &CLOSURE(S), and 8' (q, a) = &CLOSURE(O(q, a)).",
        "The function &CLOSURE is computed by using a standard transitive closure algorithm for directed graphs: this algorithm is applied to the directed graph consisting of all &moves of M. Such an algorithm can be found in several textbooks (see, for instance, Cormen, Leiserson, and Rivest (1990)).",
        "The advantage of this approach is that the subset construction algorithm does not need to be modified at all.",
        "Moreover, the transitive closure algorithm is fired only once (for the full graph), whereas the following two variants call a specialised transitive closure algorithm possibly many times."
      ]
    },
    {
      "heading": "4.2 Per subset and per state",
      "text": [
        "The pet subset and the per state algorithm use a variant of the transitive closure algorithm for graphs.",
        "Instead of computing the transitive closure of a given graph, this algorithm only computes the closure for a given set of states.",
        "Such an algorithm is given in figure2.",
        "funct closure(T)"
      ]
    },
    {
      "heading": "D =:",
      "text": [
        "foreac.h t E T do add t unmarked to D od while there is an unmarked state t D do",
        "In either of the two integrated approaches, the subset construction algorithm is initialised with an agenda containing a single subset which is the &CLOSURE of the set of start-states of the input; furthermore, the way in which new transitions are computed also takes the effect of &moves into account.",
        "Both differences are accounted for by an alternative definition of the epsilon_closure function.",
        "The approach in which the transitive dosure is computed for one state at a time is defined by the following definition of the epsilon_closure function.",
        "Note that we make sure that the transitive closure computation is only performed once for each input state, by memorising the closure function.",
        "In the case of the per subset approach the closure algorithm is applied to each subset.",
        "We also memorise the closure function, in order to ensure that the closure computation is performed only once for each subset.",
        "This can be useful since the same subset can be generated many times during subset construction.",
        "The definition simply is:",
        "The motivation for per state approach may be the insight that in this case the closure algorithm is called at most IQ' times.",
        "In contrast, in the per subset approach the transitive closure algorithm may need to be called 21Q1 times.",
        "On the other hand, in the per state approach some overhead must be accepted for computing the union of the results for each state.",
        "Moreover, in practice the number of subsets is often much smaller than 2.",
        "In some cases, the number of reachable subsets is smaller than the number of states encountered in those subsets."
      ]
    },
    {
      "heading": "5 Experiments",
      "text": [
        "Two sets of experiments have been performed.",
        "In the first set of experiments a number of random automata is generated according to a number of criteria (based on Leslie (1995)) .",
        "In the second set of experiments, results are provided for a number of (much larger) automata that surfaced during actual development work on finite-state approximation techniques.",
        "Random automata.",
        "Firstly, consider a number of experiments for randomly generated automata.",
        "Following Leslie (1995), the absolute transition density of an automaton is defined as the number of transitions divided by the square of the number of states times the number of symbols (i.e. the number of transitions divided by the number of possible transitions).",
        "Deterministic transition density is the number of transitions divided by the number of states times the number of symbols (i.e. the ratio of the number of transitions and the number of possible transitions in a deterministic machine).",
        "Leslie (1995) shows that deterministic transition density is a reliable measure for the difficulty of subset construction.",
        "Exponential blow-up can be expected for input automata with deterministic transition density of around 2.5 A number of automata were generated randomly, according to the number of states, symbols, and transition density The random generator makes sure that all states are reachable from the start state.",
        "For the first experiment, a number of automata was randomly generated, consisting of 15 symbols, and 15, 20, 25, 100 or 1000 states, using various densities (and no f-moves).",
        "The results are summarised in figure 3.",
        "Only a single result is given since each of the implementations works equally well in the absence of c-moves.6 A new concept called absolute jump density is introduced to specify the number of c-moves.",
        "It is defined as the number of c-moves divided by the square of the number of states (i.e., the probability that an c-move exists for a given pair of states).",
        "Furthermore, deterministic jump density is the number of e-moves divided by the number of states (i.e., the average number of c-moves which leave a given state).",
        "In order to measure the differences between the three implementations, a number of automata has been generated consisting of 15 states and 15 symbols, using various transition densities between 0.01 and 0.3 (for larger densities the automata tend to collapse to an automaton for E*).",
        "For each of these transition densities, jump densities were chosen in the range 0.01 to 0.24 (again, for larger values the automaton collapses).",
        "In figure 4 the outcomes of this experiment are summarised by listing the average amount of CPU-time required per deterministic jump density (for each of the three algorithms).",
        "Thus, every dot represents the average for determinising a number of different input automata with various absolute transition densities and the same deterministic jump density.",
        "The figures 5,6 and 7 summarise similar experiments using input automata with 20,25 and 100 states.",
        "The striking aspect of these experiments is that the per graph algorithm is more efficient for lower deterministic jump densities, whereas, if the deterministic jump density gets larger, the per subset algorithm is more efficient.",
        "The turning point is around a deterministic jump density between 1 and 1.5, where it seems that for larger automata the turning point occurs at a lower determinisic jump density.",
        "Interestingly, this generalisation is supported by the experiments on automata which were generated by approximation techniques (although the results for randomly generated automata are more consistent than the results for 'real' examples).",
        "Experithent: Automata generated by approximation algorithms The automata used in the previous experiments were randomly generated, according to a number of criteria.",
        "However, it may well be that in practice the automata that are to be treated by the algorithm have typical properties which were not reflected in this test data.",
        "For this reason results are presented for a number of automata that were generated using approximation techniques for context-free grammars (Pereira and Wright, 1997; Nederhof, 1997; Evans, 1997).",
        "In particular, a number of automata has been used generated by Mark-Jan Nederhof using the technique described in Nederhof (1997).",
        "In addition, a small number of automata have been used which were generated using the technique of Pereira and Wright (1997) (as implemented by Nederhof).",
        "The automata typically contain lots of jumps.",
        "Moreover, the number of states of the resulting automaton is often smaller than the number of states in the input automaton.",
        "Results are given in table 1.",
        "One of the most striking examples is the ygrim automaton consisting of 3382 states",
        "and 10571 jumps.",
        "For this example, the per graph implementation ran out of memory (after a long time), whereas the per subset algorithm produced the determinised automaton relatively quickly.",
        "The FSM implementation took much longer for this example (whereas for many of the other examples it performs better than our implementations).",
        "Note that this example has the highest number of jumps per number of states ratio."
      ]
    },
    {
      "heading": "6 Conclusion",
      "text": [
        "We have discussed three variants of the subset-construction algorithm for determinising finite automata.",
        "The experiments support the following conclusions: - the per graph variant works best for automata with a limited number of jumps - the per subset variant works best for automata with a large number of jumps - the per state variant almost never outperforms both of the two other variants - typically, if the deterministic jump density of the input is less than 1, then the per graph variant outperforms the per subset variant.",
        "If this value is larger than 1.5, then per subset outperforms per graph.",
        "- the per subset approach is especially useful for automata generated by finite-state approximation techniques, because those techniques often yield automata with very large number of c-moves."
      ]
    },
    {
      "heading": "Acknowledgements",
      "text": [
        "I am grateful to Mark-Jan Nederhof for support, and for providing me with lots of (often dreadful) automata generated by his finite-state approximation tools."
      ]
    }
  ]
}
