{
  "info": {
    "authors": [
      "Dale Gerdemann",
      "Gertjan van Noord"
    ],
    "book": "Conference of the European Association for Computational Linguistics",
    "id": "acl-E99-1017",
    "title": "Transducers from Rewrite Rules With Backreferences",
    "url": "https://aclweb.org/anthology/E99-1017",
    "year": 1999
  },
  "references": [
    "acl-J94-3001",
    "acl-J95-2004",
    "acl-P95-1003",
    "acl-P96-1015",
    "acl-P96-1031"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Context sensitive rewrite rules have been widely used in several areas of natural language processing, including syntax, morphology, phonology and speech processing.",
        "Kaplan and Kay, Karttunen, and Mohri & Sproat have given various algorithms to compile such rewrite rules into finite-state transducers.",
        "The present paper extends this work by allowing a limited form of backreferencing in such rules.",
        "The explicit use of backref-erencing leads to more elegant and general solutions."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "Context sensitive rewrite rules have been widely used in several areas of natural language processing.",
        "Johnson (1972) has shown that such rewrite rules are equivalent to finite state transducers in the special case that they are not allowed to rewrite their own output.",
        "An algorithm for compilation into transducers was provided by Kaplan and Kay (1994).",
        "Improvements and extensions to this algorithm have been provided by Karttunen (1995), Karttunen (1997), Karttunen (1996) and Mohri and Sproat (1996).",
        "In this paper, the algorithm will be extended to provide a limited form of back-referencing.",
        "Backreferencing has been implicit in previous research, such as in the \"batch rules\" of Kaplan and Kay (1994), bracketing transducers for finite-state parsing (Karttunen, 1996), and the \"LocalExtension\" operation of Roche and Schabes (1995).",
        "The explicit use of backreferencing leads to more elegant and general solutions.",
        "Backreferencing is widely used in editors, scripting languages and other tools employing regular expressions (Friedl, 1997).",
        "For example, Emacs uses the special brackets \\( and \\) to capture strings along with the notation \\n to recall the nth such string.",
        "The expression \\ (a* \\ )b \\ 1 matches strings of the form anban.",
        "Unrestricted use of backreferencing thus can introduce non-regular languages.",
        "For NLP finite state calculi (Karttunen et al., 1996; van Noord, 1997) this is unacceptable.",
        "The form of backreferences introduced in this paper will therefore be restricted.",
        "The central case of an allowable backreference is:",
        "This says that each string x preceded by A and followed by p is replaced by T(x), where A and p are arbitrary regular expressions, and T is a trans-ducer.'",
        "This contrasts sharply with the rewriting rules that follow the tradition of Kaplan & Kay:",
        "In this case, any string from the language 0 is replaced by any string independently chosen from the language 0.",
        "We also allow multiple (non-permuting) back-references of the form: 1 The syntax at this point is merely suggestive.",
        "As an example, suppose that Tacr transducer phrases into acronyms.",
        "Then T., (x)/(abbr)__(/abbr) would transduce <abbr>non-deterministic finite automaton</abbr> into <abbr>NDFA</abbr>.",
        "To compare this with a backreference in Perl, suppose that T., is a subroutine that converts phrases into acronyms and that R.„ is a regular expression matching phrases that can be converted into acronyms.",
        "Then (ignoring the left context) one can write something like: s/(Roc,•)(?=(/ABBR))/T„„($1)/ge;.",
        "The backreference variable, $1, will be set to whatever string matches.",
        "Since transducers are closed under concatenation, handling multiple backreferences reduces to the problem of handling a single backreference:",
        "A problem arises if we want capturing to follow the POSIX standard requiring a longest-capture strategy.",
        "Friedl (1997) (p. 117), for example, discusses matching the regular expression (toitop)(olpolo)?",
        "(gicallo?logical) against the word: topological.",
        "The desired result is that (once an overall match is established) the first set of parentheses should capture the longest string possible (top); the second set should then match the longest string possible from what's left (o), and so on.",
        "Such a leftmost longest match concatenation operation is described in §3.",
        "In the following section, we initially concentrate on the simple case in (1) and show how (1) may be compiled assuming left-to-right processing along with the overall longest match strategy described by Karttunen (1996).",
        "The major components of the algorithm are not new, but straightforward modifications of components presented in Karttunen (1996) and Mohri and Sproat (1996).",
        "We improve upon existing approaches because we solve a problem concerning the use of special marker symbols (§2.1.2).",
        "A further contribution is that all steps are implemented in a freely available system, the FSA Utilities of van Noord (1997) (§2.1.1)."
      ]
    },
    {
      "heading": "2 The Algorithm",
      "text": []
    },
    {
      "heading": "2.1 Preliminary Considerations",
      "text": [
        "Before presenting the algorithm proper, we will deal with a couple of meta issues.",
        "First, we introduce our version of the finite state calculus in §2.1.1.",
        "The treatment of special marker symbols is discussed in §2.1.2.",
        "Then in §2.1.3, we discuss various utilities that will be essential for the algorithm.",
        "The algorithm is implemented in the FSA Utilities (van Noord, 1997).",
        "We use the notation provided by the toolbox throughout this paper.",
        "Table 1 lists the relevant regular expression operators.",
        "FSA Utilities offers the possibility to define new regular expression operators.",
        "For example, consider the definition of the nullary operator vowel as the union of the five vowels:",
        "macro(vowel,{a,e,i,o,u}).",
        "In such macro definitions, Prolog variables can be used in order to define new nary regular expression operators in terms of existing operators.",
        "For instance, the lenient_composition operator (Karttunen, 1998) is defined by: macro (priority_union (Q ,R) , {Q, -domain(Q) o R}).",
        "macro ( lenient_compos it ion (R , C) , priority_union(R o C,R)) .",
        "Here, priority union of two regular expressions Q and R is defined as the union of Q and the composition of the complement of the domain of Q with R. Lenient composition of R and C is defined as the priority union of the composition of R and C (on the one hand) and R (on the other hand).",
        "Some operators, however, require something more than simple macro expansion for their definition.",
        "For example, suppose a user wanted to match n occurrences of some pattern.",
        "The FSA Utilities already has the '*' and '+' quantifiers, but any other operators like this need to be user defined.",
        "For this purpose, the FSA Utilities supplies simple Prolog hooks allowing this general quantifier to be defined as: macro (mat ch_n (N , X) ,Regex) : - match_n(N,X,Regex) match_n(0,_X, ) .",
        "Proceedings of EACL '99 For example: match_n(3 , a) is equivalent to the ordinary finite state calculus expression [a, a, a] .",
        "Finally, regular expression operators can be defined in terms of operations on the underlying automaton.",
        "In such cases, Prolog hooks for manipulating states and transitions may be used.",
        "This functionality has been used in van Noord and Gerdemann (1999) to provide an implementation of the algorithm in Mohri and Sproat (1996)."
      ]
    },
    {
      "heading": "2.1.2 Treatment of Markers",
      "text": [
        "Previous algorithms for compiling rewrite rules into transducers have followed Kaplan and Kay (1994) by introducing special marker symbols (markers) into strings in order to mark off candidate regions for replacement.",
        "The assumption is that these markers are outside the resulting transducer's alphabets.",
        "But previous algorithms have not ensured that the assumption holds.",
        "This problem was recognized by Karttunen (1996), whose algorithm starts with a filter transducer which filters out any string containing a marker.",
        "This is problematic for two reasons.",
        "First, when applied to a string that does happen to contain a marker, the algorithm will simply fail.",
        "Second, it leads to logical problems in the interpretation of complementation.",
        "Since the complement of a regular expression R is defined as E – R, one needs to know whether the marker symbols are in E or not.",
        "This has not been clearly addressed in previous literature.",
        "We have taken a different approach by providing a contextual way of distinguishing markers from non-markers.",
        "Every symbol used in the algorithm is replaced by a pair of symbols, where the second member of the pair is either a 0 or a 1 depending on whether the first member is a marker or not.2 As the first step in the algorithm, 0's are inserted after every symbol in the input string to indicate that initially every symbol is a non-marker.",
        "This is defined as: macro (non_markers [?",
        ", : 0] *) .",
        "Similarly, the following macro can be used to insert a 0 after every symbol in an arbitrary expression E. 2 This approach is similar to the idea of laying down tracks as in the compilation of monadic second-order logic into automata Klarlund (1997, p. 5).",
        "In fact, this technique could possibly be used for a more efficient implementation of our algorithm: instead of adding transitions over 0 and 1, one could represent the alphabet as bit sequences and then add a final 0 bit for any ordinary symbol and a final 1 bit for a marker symbol.",
        "macro (non_markers (E) , range (E o non_markers)) .",
        "Since E is a recognizer, it is first coerced to identity (E).",
        "This form of implicit conversion is standard in the finite state calculus.",
        "Note that 0 and 1 are perfectly ordinary alphabet symbols, which may also be used within a replacement.",
        "For example, the sequence [1,0] represents a non-marker use of the symbol 1."
      ]
    },
    {
      "heading": "2.1.3 Utilities",
      "text": [
        "Before describing the algorithm, it will be helpful to have at our disposal a few general tools, most of which were described already in Kaplan and Kay (1994).",
        "These tools, however, have been modified so that they work with our approach of distinguishing markers from ordinary symbols.",
        "So to begin with, we provide macros to describe the alphabet and the alphabet extended with marker symbols: macro (sig, [?,0]).",
        "macro (xsig, [?,{0,1}]) .",
        "The macro xsig is useful for defining a specialized version of complementation and containment: macro (not (X) , xsig* - X) .",
        "macro ($$ (X) , [xsig* , X , xsig*] ) .",
        "The algorithm uses four kinds of brackets, so it will be convenient to define macros for each of these brackets, and for a few disjunctions.",
        "macro (lbl, ['<1' ,1]).",
        "macro (1b2 , ['<2' ,1]).",
        "macro (rb2 , [' 2> ' ,1] ) .",
        "macro (rbl , [' 1> ' , 1] ) .",
        "macro(lb,{1b1,1b2}).",
        "macro(rb,{rbl,rb2}).",
        "macro(b1,{1b1,rb1}).",
        "macro(b2,{1b2,rb2}).",
        "macro(brack,{1b,rb}).",
        "As in Kaplan & Kay, we define an Intro(S) operator that produces a transducer that freely introduces instances of S into an input string.",
        "We extend this idea to create a family of Intro operators.",
        "It is often the case that we want to freely introduce marker symbols into a string at any position except the beginning or the end.",
        "%Y.",
        "Free introduction macro (intro (S) , -(xsig-S , x S}*).",
        "%% Introduction, except at begin macro (xintro (S) ,-( , [xsig-S, intro (S)]}) %% Introduction, except at end macro (introx(S) , [intro(S) ,xsig-S])-) .",
        "Proceedings of EACL '99 WI Introduction, except at begin & end macro (xintrox (S) , { , [xsig-S] , [xsig-S, intro (S) , xsig-S] .",
        "This family of Intro operators is useful for defining a family of Ignore operators: macro( ign( E1,S),range(E1 o intro( S))).",
        "macro(xign( E1,S),range(E1 o xintro( S))).",
        "macro( ignx(E1,S),range(E1 o introx(S))) macro(xignx(E1,S),range(E1 o xintrox(S))) In order to create filter transducers to ensure that markers are placed in the correct positions, Kaplan & Kay introduce the operator P-iff-S(L1,L2).",
        "A string is described by this expression iff each prefix in L1 is followed by a suffix in L2 and each suffix in L2 is preceded by a prefix in L1.",
        "In our approach, this is defined as: macro(if_p_then_s(L1,L2), notaL1,not(L2)])).",
        "macro(if_s_then_p(L1,L2), not([not(L1),L2])).",
        "macro(p_iff_s(L1,L2), if_p_then_s(L1,L2) if_s_then_p(L1,L2)).",
        "To make the use of p_if f _s more convenient, we introduce a new operator Lif f r (L ,R), which describes strings where every string position is preceded by a string in L just in case it is followed by a string in R: macro (1_ if f _r (L ,R) , p_iff_s( [xsig* , , [R,xsig*])) .",
        "Finally, we introduce a new operator if (Condition , Then ,Else) for conditionals.",
        "This operator is extremely useful, but in order for it to work within the finite state calculus, one needs a convention as to what counts as a boolean true or false for the condition argument.",
        "It is possible to define true as the universal language and false as the empty language: macro (true , ?",
        "*) .",
        "macro (f alse , {}) .",
        "With these definitions, we can use the complement operator as negation, the intersection operator as conjunction and the union operator as disjunction.",
        "Arbitrary expressions may be coerced to booleans using the following macro: macro (coerce_to_boolean(E) , range (E o (true x true))) .",
        "Here, E should describe a recognizer.",
        "E is composed with the universal transducer, which trans-duces from anything (?",
        "*) to anything (?*).",
        "Now with this background, we can define the conditional: macro(if(Cond,Then,Else),"
      ]
    },
    {
      "heading": "2.2 Implementation",
      "text": [
        "A rule of the form x -+ T(x)IA__p will be written as replace (T , Lambda , Rho ) .",
        "Rules of the more general form xi .",
        "Ti (xi) ) T„(x„)IA__p will be discussed in §3.",
        "The algorithm consists of nine steps composed as in figure 1.",
        "The names of these steps are mostly derived from Karttunen (1995) and Mohri and Sproat (1996) even though the transductions involved are not exactly the same.",
        "In particular, the steps derived from Mohri & Sproat (r, f, 11 and 12) will all be defined in terms of the finite state calculus as opposed to Mohri Sproat's approach of using low-level manipulation of states and transitions.",
        "The first step, non_markers, was already defined above.",
        "For the second step, we first consider a simple special case.",
        "If the empty string is in the language described by Right, then r (Right) should insert an rb2 in every string position.",
        "The definition of r (Right) is both simpler and more efficient if this is treated as a special case.",
        "To insert a bracket in every possible string position, we use: [[O x rb2, sig] * , x rb2] If the empty string is not in Right, then we must use intro (rb2) to introduce the marker rb2, followed by l_iff_r to ensure that such markers are immediately followed by a string in Right, or more precisely a string in Right where additional instances of rb2 are freely inserted in any position other than the beginning.",
        "This expression is written as:",
        "Putting these two pieces together with the conditional yields: macro (r (R) , if & R, % If : [] is in R:",
        "The third step, f (domain (T) ) is implemented as:",
        "The 1b2 is first introduced and then, using l_iff _r, it is constrained to occur immediately before every instance of (ignoring complexities) Phi followed by an rb2.",
        "Phi needs to be marked as normal text using non_markers and then xign_x is used to allow freely inserted 1b2 and rb2 anywhere except at the beginning and end.",
        "The following 1b2\" allows an optional 1b2, which occurs when the empty string is in Phi.",
        "The fourth step is a guessing component which (ignoring complexities) looks for sequences of the form 1b2 Phi rb2 and converts some of these into lbl Phi rbl, where the b1 marking indicates that the sequence is a candidate for replacement.",
        "The complication is that Phi, as always, must be converted to non_markers (Phi) and instances of b2 need to be ignored.",
        "Furthermore, between pairs of 1b1 and rbl, instances of 1b2 are deleted.",
        "These 1b2 markers have done their job and are no longer needed.",
        "Putting this all together, the definition is:",
        "The fifth step filters out non-longest matches produced in the previous step.",
        "For example (and simplifying a bit), if Phi is ab*, then a string of the form ... rbl a b lbl b ... should be ruled out since there is an instance of Phi (ignoring brackets except at the end) where there is an internal 1b1.",
        "This is implemented as:4",
        "The sixth step performs the transduction described by T. This step is straightforwardly implemented, where the main difficulty is getting T to apply to our specially marked string: macro(aux_replace(T), [lbl, inverse(non_markers) 4 The line with $$ (rbl) can be optimized a bit: Since we know that an rbl must be preceded by Phi, we can write: [ign_ (non_markers (Phi) , brack) , rb , xs ) .",
        "This may lead to a more constrained (hence smaller) transducer.",
        "Proceedings of EACL '99 o T o non_markers , rbl x 0 }*) The seventh step ensures that lbl is preceded by a string in Left:",
        "The eighth step ensures that 1b2 is not preceded by a string in Left.",
        "This is implemented similarly to the previous step: macro (12 (L) , if _s_then_p(",
        "Finally the ninth step, inverse (non_markers) , removes .the 0's so that the final result in not marked up in any special way."
      ]
    },
    {
      "heading": "3 Longest Match Capturing",
      "text": [
        "As discussed in §1 the POSIX standard requires that multiple captures follow a longest match strategy.",
        "For multiple captures as in (3), one establishes first a longest match for domain(Ti)",
        "• domain(Tn).",
        "Then we ensure that each of domain(T2) in turn is required to match as long",
        "as possible, with each one having priority over its rightward neighbors.",
        "To implement this, we define a macro lm_concat(Ts) and use it as: replace(lm_concat(Ts),Left,Right) Ensuring the longest overall match is delegated to the replace macro, so lm_concat(Ts) needs only ensure that each individual transducer within Ts gets its proper left-to-right longest matching priority.",
        "This problem is mostly solved by the same techniques used to ensure the longest match within the replace macro.",
        "The only complication here is that Ts can be of unbounded length.",
        "So it is not possible to have a single expression in the finite state calculus that applies to all possible lenghts.",
        "This means that we need something a little more powerful than mere macro expansion to construct the proper finite state calculus expression.",
        "The FSA Utilities provides a Prolog hook for this purpose.",
        "The resulting definition of 1m_concat is given in figure 2.",
        "Suppose (as in Friedl (1997)), we want to match the following list of recognizers against the string topological and insert a marker in each boundary position.",
        "This reduces to applying:",
        "This expression transduces the string topological only to the string top#o#logical.5"
      ]
    },
    {
      "heading": "4 Conclusions",
      "text": [
        "''An anonymous reviewer suggested that lm_concat could be implemented in the framework of Karttunen (1996) as:",
        "Indeed the resulting transducer from this expression would transduce topological into top#o#logical.",
        "But unfortunately this transducer would also transduce polotopogical into polottop#ottgical, since the notion of left-right ordering is lost in this expression.",
        "6 The bracketing operator of Karttunen (1996), on the other hand, does not provide for left and right contexts.",
        "The algorithm presented here has extended previous algorithms for rewrite rules by adding a limited version of backreferencing.",
        "This allows the output of rewriting to be dependent on the form of , the strings which are rewritten.",
        "This new feature brings techniques used in Perl-like languages into the finite state calculus.",
        "Such an integration is needed in practical applications where simple text processing needs to be combined with more sophisticated computational linguistics techniques.",
        "One particularly interesting example where backreferences are essential is cascaded deterministic (longest match) finite state parsing as described for example in Abney (Abney, 1996) and various papers in (Roche and Schabes, 1997a).",
        "Clearly, the standard rewrite rules do not apply in this domain.",
        "If NP is an NP recognizer, it would not do to .say NP [NP]1A__p.",
        "Nothing would force the string matched by the NP to the left of the arrow to be the same as the string matched by the NP to the right of the arrow.",
        "One advantage of using our algorithm for finite state parsing is that the left and right contexts may be used to bring in top-down filtering.6 An often cited advantage of finite state",
        "Proceedings of EACL '99 parsing is robustness.",
        "A constituent is found bottom up in an early level in the cascade even if that constituent does not ultimately contribute to an S in a later level of the cascade.",
        "While this is undoubtedly an advantage for certain applications, our approach would allow the introduction of some top-down filtering while maintaining the robustness of a bottom-up approach.",
        "A second advantage for robust finite state parsing is that bracketing could also include the notion of \"repair\" as in Abney (1990).",
        "One might, for example, want to say something like: xy [NP RepairDet(x) RepairN(y)ii A--p7 so that an NP could be parsed as a slightly malformed Det followed by a slightly malformed N. RepairDet and RepairN, in this example, could be doing a variety of things such as: contextualized spelling correction, reordering of function words, replacement of phrases by acronyms, or any other operation implemented as a transducer.",
        "Finally, we should mention the problem of complexity.",
        "A critical reader might see the nine steps in our algorithm and conclude that the algorithm is overly complex.",
        "This would be a false conclusion.",
        "To begin with, the problem itself is complex.",
        "It is easy to create examples where the resulting transducer created by any algorithm would become unmanageably large.",
        "But there exist strategies for keeping the transducers smaller.",
        "For example, it is not necessary for all nine steps to be composed.",
        "They can also be cascaded.",
        "In that case it will be possible to implement different steps by different strategies, e.g. by deterministic or non-deterministic transducers or bimachines (Roche and Schabes, 1997b).",
        "The range of possibilities leaves plenty of room for future research."
      ]
    }
  ]
}
