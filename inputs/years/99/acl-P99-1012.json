{
  "info": {
    "authors": [
      "William Schuler"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P99-1012",
    "title": "Preserving Semantic Dependencies in Synchronous Tree Adjoining Grammar",
    "url": "https://aclweb.org/anthology/P99-1012",
    "year": 1999
  },
  "references": [
    "acl-C90-3001",
    "acl-C90-3045",
    "acl-E93-1045",
    "acl-J94-1004",
    "acl-P95-1021",
    "acl-P96-1016"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "Rambow, Wier and Vijay-Shanker (Rambow et al., 1995) point out the differences between TAG derivation structures and semantic or predicate-argument dependencies, and Joshi and Vijay-Shanker (Joshi and Vijay-Shanker, 1999) describe a monotonic compositional semantics based on attachment order that represents the desired dependencies of a derivation without un-derspecifying predicate-argument relationships at any stage.",
        "In this paper, we apply the Joshi and Vijay-Shanker conception of compositional semantics to the problem of preserving semantic dependencies in Synchronous TAG translation (Shieber and Schabes, 1990; Abeille et al., 1990).",
        "In particular, we describe an algorithm to obtain the semantic dependencies on a TAG parse forest and construct a target derivation forest with isomorphic or locally non-isomorphic dependencies in 0(n7) time."
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "The primary goal of this paper is to solve the problem of preserving semantic dependencies in Isomorphic Synchronous Tree Adjoining Grammar (ISTAG) (Shieber, 1994; Shieber and Sch-abes, 1990), a variant of Tree Adjoining Grammar (Joshi, 1985) in which source and target elementary trees are assembled into isomorphic derivations.",
        "The problem, first described in Rambow, Wier and Vijay-Shanker (Rambow et al., 1995), stems from the fact that the TAG derivation structure – even using a flat adjunction of modifiers (Schabes and Shieber, 1994) – deviates from the appropriate dependency",
        "structure in certain cases.",
        "This can result in translation errors.",
        "For example, if we parse sentence (1),",
        "with the auxiliary is-supposed-to adjoining at the VP to predicate over be-able-to and the auxiliary be-able-to adjoining at the VP to predicate over fly.",
        "If we then try to assemble an isomorphic tree in a language such as Portuguese (which makes less use of raising verbs) using the ISTAG transfer rules in Figure 2, we will be forced into an ill-formed derivation:",
        "because the raising construction is-supposed-to translates to a bridge construction é- pressuposto-que and cannot adjoin anywhere in the tree for e-capaz-de (the translation of be-able-to) because there is no S-labeled adjunction site.",
        "The correct target derivation:",
        "(2) E pressuposto que X é capaz de voar.",
        "is not isomorphic to the source.",
        "Worse, this non-isomorphism is unbounded, because the bridge verb pressuposto may have to migrate across any number of intervening raising verbs to find an ancestor that contains an appropriate adjunction site:",
        "This sort of non-local non-isomorphic transfer cannot be handled in a synchronous TAG that has an isomorphism restriction on derivation trees.",
        "On the other hand, we do not wish to return to the original non-local formulation of synchronous TAG (Shieber and Schabes, 1990) because the non-local inheritance of links on the derived tree is difficult to implement, and because the non-local formulation can recognize languages beyond the generative power of TAG.",
        "Rambow, Wier and Vijay-Shanker themselves introduce D-Tree Grammar (Rambow et al., 1995) and Candito and Kahane introduce the DTG variant Graph Adjunction Grammar (Candito and Kahane, 1998b) in order to solve this problem using a derivation process that mirrors composition more directly, but both involve potentially significantly greater recognition complexity than TAG.",
        "for \"supposed to be able to fly\""
      ]
    },
    {
      "heading": "2 Overview",
      "text": [
        "Our solution is to retain ISTAG, but move the isomorphism restriction from the derivation structure to the predicate-argument attachment structure described in (Joshi and Vijay-Shanker, 1999).",
        "This structure represents the composition of semantic predicates for lexicalized elementary trees, each of which contains a 'predicate' variable associated with the situation or entity that the predicate introduces, and a set of 'argument' variables associated with the foot node and substitution sites in the original elementary tree.",
        "The predicates are composed by identifying the predicate variable in one predicate with an argument variable in another, so that the two variables refer to the same situation or entity.",
        "Composition proceeds from the bottom up on the derivation tree, with adjuncts traversed in order from the lowest to the highest adjunction site in each elementary tree, in much the same way that a parser produces a derivation.",
        "Whenever an initial tree is substituted, its predicate variable is identified in the composed structure with an argument variable of the tree it substitutes into.",
        "Whenever an auxiliary tree is adjoined, the predicate variable of the tree it adjoins into is identified in the composed structure with one of its own argument variables.",
        "In cases of adjunction, an auxiliary tree's semantics can also specify which variable will become the predicate variable of the composed structure for use in subsequent adjunctions at higher adjunction sites: a modifier auxiliary will return the host tree's original predicate variable, and a predicative auxiliary will return its own predicate variable.2 Since the traversal must",
        "proceed from the bottom up, the attachment of predicates to arguments is neither destructive nor underspecified at any stage in the interpretation.",
        "For example, assume the initial tree a:fly has a predicate variable 81, representing the situation of something flying, and an argument variable xl, representing the thing that is flying; and assume the predicative auxiliary tree th:beable-to has a predicate variable 82, representing the situation of something being possible, and an argument variable 83, representing the thing that is possible.",
        "If this now adjoined into a, the composed structure would have si identified with s3 (since the situation of flying is the thing that is possible), and s2 as an overall predicate variable, so if another tree later adjoins into this composed structure rooted on a, it will predicate over s2 (the situation that flying is possible) rather than over a's original predicate variable .si (the situation of flying by itself).",
        "Note that Joshi and Vijay-Shanker do not require the predicate and modifier distinctions, because they can explicitly specify the fates of any number of predicate variables in a tree's semantic representation.",
        "For simplicity, we will limit our discussion to only the two possibilities of predicative and modifier auxiliaries, using one predicate variable per tree.",
        "If we represent each such predicate-argument attachment as an arc in a directed graph, we can view the predicate-argument attachment structure of a derivation as a dependency graph, in much the same way as Candito and Kahane interpret the original derivation trees (Candito and Kahane, 1998a).",
        "More importantly, we can see that this definition predicts the predicate-argument dependencies for sentences (1) and (2) to be isomorphic:",
        "even though their derivation trees are not.",
        "This is because the predicative auxiliary for é-capaz-de returns its predicate variable to the host tree for subsequent adjunctions, so the auxiliary tree for é-pressuposto-que can attach it as one of its arguments, just as if it had adjoined directly to the auxiliary, as supposed-to does in English.",
        "It is also important to note that Joshi and Vijay-Shanker's definition of TAG compositional semantics differs from that of Shieber",
        "and Schabes (Shieber and Schabes, 1990) using Synchronous TAG, in that the former preserves the scope ordering of predicative adjunctions, which may be permuted in the latter, altering the meaning of the sentence.3 It is precisely this scope-preserving property we hope to exploit in our formulation of a dependency-based isomorphic synchronous TAG in the next two sections.",
        "However, as Josh i and Vijay-Shanker suggest, the proper treatment of synchronous translation to logical form may require a multicomponent Synchronous TAG analysis in order to handle quantifiers, which is beyond the scope of this paper.",
        "For this reason, we will focus on examples in machine translation."
      ]
    },
    {
      "heading": "3 Obtaining Source Dependencies",
      "text": [
        "If we assume that this attachment structure captures a sentence's semantic dependencies, then in order to preserve semantic dependencies in synchronous TAG translation, we will need to obtain this structure from a source derivation and then construct a target derivation with an isomorphic structure.",
        "The first algorithm we present obtains semantic dependencies for derivations by keeping track of an additional field in each chart item during parsing, corresponding to the predicate variable from Section 2.",
        "Other than the additional field, the algorithm remains essentially the same as the parsing algorithm described in (Schabes and Shieber, 1994), so it can be applied as a transducer during recognition, or as a post-process on a derivation forest (Vijay-Shanker and Weir, 1993).",
        "Once the desired dependencies are obtained, the forest may be filtered to select a single most-preferred tree using statistics or rule-based selectional restrictions on those dependencies.4 For calculating dependencies, we define a function arg(777) to return the argument position associated with a substitution site or foot node 77 in elementary tree 7.",
        "Let a dependency be defined as a labeled arc (0,1,q,b), from predicate 0 to predicate 0 with label 1.",
        "• For each tree selected by 0, set the predicate variable of each anchor item to 0.",
        "• For each substitution of initial tree Geo with predicate variable co into yo at node address 77, emit (0, arg(ry,71),w) • For each modifier adjunction of auxiliary tree )3,/, into tree 74, with predicate variable x, emit (0,arg(13, FOOT), x) and set the predicate variable of the composed item to x.",
        "• For each predicative adjunction of auxiliary tree Ap with predicate variable co into tree -y,/, with predicate variable x, emit (0, arg(0, FOOT), x) and set the predicate variable of the composed item to w. • For all other productions, propagate the predicate variable up along the path from the main anchor to the root.",
        "Since the number of possible values for the additional predicate variable field is bounded by n, where n is the number of lexical items in the input sentence, and none of the productions combine more than one predicate variable, the complexity of the dependency transducing algorithm is 0(n7).",
        "This algorithm can be applied to the example derivation tree in Section 1, a:fly /3i:be-able-to (VP) 02 As-supposed-to(VP) which resembles the stacked derivation tree for Candito and Kahane's example 5a, \"Paul claims Mary said Peter left.\"",
        "First, we adjoin 02 : i s - s up posed to at node VP of 0i:be-able-to, which produces the dependency (is-supposed-to, 0,be-able-to).",
        "Then we adjoin th:be-able-to at node VP of aliy, which produces the dependency (be-able-to, 0,fly).",
        "The resulting dependencies are represented graphically in the dependency structure below:",
        "This example is relatively straightforward, simply reversing the direction of adjunction dependencies as described in (Candito and Kahane, 1998a), but this algorithm can transduce",
        "the correct isomorphic dependency structure for the Portuguese derivation as well, similar to the distributed derivation tree in Candito and Ka-hane's example 5b, \"Paul claims Mary seems to adore hot dogs,\" (Rambow et al., 1995), where there is no edge corresponding to the dependency between the raising and bridge verbs:",
        "We begin by adjoining th:e-capaz-de at node VP of a:voar, which produces the dependency (é-capaz-de, 0,voar), just as before.",
        "Then we adjoin 02:é-pressuposto-que at node S of a:voar.",
        "This time, however, we must observe the predicate variable of the chart item for a:voar which was updated in the previous adjunction, and now references é-capaz-de instead of voar.",
        "Because the transduction rule for adjunction uses the predicate variable of the parent instead of just the predicate, the dependency produced by the adjunction of 02 is (é-pressuposto-que, 0,e-capaz-de), yielding the graph:",
        "The derivation examples above only address the preservation of dependencies through adjunction.",
        "Let us now attempt to preserve both substitution and adjunction dependencies in transducing a sentence based on Candito and Kahane's example 5c, \"That Paul has to stay surprised Mary,\" in order to demonstrate how they interact.5 We begin with the derivation tree:",
        "5We have replaced want to in the original example with have to in order to highlight the dependency structure and set aside any translation issues related to PRO control.",
        "As Candito and Kahane point out, this derivation tree does not match the dependency structure of the sentence as described in Meaning Text Theory (Mel'cuk, 1988), because there is no edge in the derivation corresponding to the dependency between surprise and have-to (the necessity of Paul's staying is what surprises Mary, not his staying in itself).",
        "Using the above algorithm, however, we can still produce the desired dependency structure:",
        "by adjoining 0:have-to at node VP of a2:stay to produce a composed item with have-to as its predicate variable, as well as the dependency (have-to, 0,stay).",
        "When a2:stay substitutes at node So of a1 :surprise, the resulting dependency also uses the predicate variable of the argument, yielding (surprise, 0,have-to)."
      ]
    },
    {
      "heading": "4 Obtaining Target Derivations",
      "text": [
        "Once a source derivation is selected from the parse forest, the predicate-argument dependencies can be read off from the items in the forest that constitute the selected derivation.",
        "The resulting dependency graph can then be mapped to a forest of target derivations, where each predicate node in the source dependency graph is linked to a set of possible elementary trees in the target grammar, each of which is instantiated with substitution or adjunction edges leading to other linked sets in the forest.",
        "The elementary trees in the target forest are determined by the predicate pairs in the transfer lexicon, and by the elementary trees that can realize the translated targets.",
        "The substitution and adjunction edges in the target forest are determined by the argument links in the transfer lexicon, and by the substitution and adjunction configurations that can realize the translated targets' dependencies.",
        "Mapping dependencies into substitutions is relatively straightforward, but we have seen in Section 2 that different adjunction configurations (such as the raising and bridge verb ad",
        "junctions in sentences (I) and (2)) can correspond to the same dependency graph, so we should expect that some dependencies in our target graph may correspond to more than one adjunction configuration in the target derivation tree.",
        "Since a dependency may be realized by adjunctions at up to n different sites, an unconstrained algorithm would require exponential time to find a target derivation in the worst case.",
        "In order to reduce this complexity, we present a dynamic programming algorithm for constructing a target derivation forest in time proportional to 0(n4) which relies on a restriction that the target derivations must preserve the relative scope ordering of the predicates in the source dependency graph.",
        "This restriction carries the linguistic implication that the scope ordering of adjuncts is part of the meaning of a sentence and should not be rearranged in translation.",
        "Since we exploit a notion of locality similar to that of Isomorphic Synchronous TAG, we should not expect the generative power of our definition to exceed the generative power of TAG, as well.",
        "First, we define an ordering of predicates on the source dependency graph corresponding to a depth-first traversal of the graph, originating at the predicate variable of the root of the source derivation, and visiting arguments and modifiers in order from lowest to highest scope.",
        "In other words, arguments and modifiers will be ordered from the bottom up on the elementary tree structure of the parent, such that the foot node argument of an elementary tree has the lowest scope among the arguments, and the first adjunct on the main (trunk) anchor has the lowest scope among the modifiers.",
        "Arguments, which can safely be permuted in translation because their number is finitely bounded, are traversed entirely before the parent; and modifiers, which should not be permuted because they may be arbitrarily numerous, are traversed entirely after the parent.",
        "This enumeration will roughly correspond to the scoping order for the adjuncts in the source derivation, while preventing substituted trees from interrupting possible scoping configurations.",
        "We can now identify all the descendants of any elementary tree in a derivation because they will form a consecutive series in the enumeration described above.",
        "It therefore provides a convenient way to generate a target derivation forest that preserves the scoping information in the source, by 'parsing' the scope-ordered string of elementary trees, using indices on this enumeration instead of on a string yield.",
        "It is important to note that in defining this algorithm, we assume that all trees associated with a particular predicate will use the same argument structure as that predicate.6 We also assume that the set of trees associated with a particular predicate may be filtered by transferring information such as mood and voice from source to target predicates.",
        "Apart from the different use of indices, the algorithm we describe is exactly the reverse of the transducer described in Section 3, taking a dependency graph D and producing a TAG derivation forest containing exactly the set of derivation trees for which those dependencies hold.",
        "Here, as in a parsing algorithm, we define forest items as tuples of (70, j, x) where a, )3, and 7 are elementary trees with node 77, 0 and '0 are predicates, x and w be predicate variables, and T and 1 are delimiters for opening and closing adjunction, but now let i, j, and k refer to the indices on the scoping enumeration described above, instead of on an input string.",
        "In order to reconcile scoping ranges for substitution, we must also define a function first(q) to return the leftmost (lowest) edge of the O's range in the scope enumeration, and last(0) to return the rightmost (highest) edge of the 0's range in the scope enumeration.",
        "• For each tree y mapped from predicate 0 at scope i, introduce (-y fir st(0),i +1, 0).",
        "• If (0, ar g(ry , 77), w) ED, try substitution of a into",
        "6 Although this does not hold for certain relative clause elementary trees with wh-extractions as substitutions sites (since the wh-site is an argument of the main verb of the clause instead of the foot node), Candito and Kahane (Candito and Kahane, 1998b) suggest an alternative analysis which can be extended to TAG by adjoining the relative clause into its wh-word as a predicative adjunct, and adjoining the wh-word into the parent noun phrase as a modifier, so the noun phrase is treated as an argument of the wh-word rather than of the relative clause.",
        "• If (11) , arg(0 , FOOT), x) ED, try modifier adjunction of /3 into -y:",
        "• If (11) , arg(i 3, FOOT), x) ED, try predicative adjunction of 3 into -y:",
        "• Apply productions for nonterminal projection as in the transducer algorithm, propagating index ranges and predicative variables up along the path from the main anchor to the root.",
        "Since none of the productions combine more than three indices and one predicate variable, and since the indices and predicate variable may have no more than n distinct values, the algorithm runs in 0(n4) time.",
        "Note that one of the indices may be redundant with the predicate variable, so a more efficient implementation might be possible in 0(n3).",
        "We can demonstrate this algorithm by translating the English dependency graph from Section 1 into a derivation tree for Portuguese.",
        "First, we enumerate the predicates with their relative scoping positions: [3] o:is-supposed-to [2] 01:be-able-to [1] 02:fly Then we construct a derivation forest based on the translated elementary trees a :voar, /31 :é- capaz-de, and 02 : é-pressuposto-que.",
        "Beginning at the bottom, we assign to these constituents the relative scoping ranges of 1-2, 2-3, and 3-$, respectively, where $ is a terminal symbol.",
        "Since there is a dependency from be-able-to to fly, we can adjoin [31:6-capaz-de to a:voar such that it covers the range of scopes from 1 to 3 (from voar to e-capaz-de), so we add this possibility to the forest.",
        "(avoar , 1, 2, • •) (13capaz, 2,3, -•) (Opress, 3,$, ..) (avow., 1, 3, capaz) There is also a dependency from is-supposed-to to be-able-to allowing us to adjoin 02: 6 pressuposto-que to /31:6-capaz-de to make it cover the range from 2 to $7 but there would be no S node to host its adjunction, so this possibility can not be added to the forest.",
        "We can, however, adjoin 132 : é-pressuposto-que to the instance of a :voar extending to i3 :é-capaz-de that covers the range from 1 to 3, resulting in a complete analysis of the entire scope from 1 to $, (from a :voar to 132 :pressuposto) rooted on voar:",
        "which matches the distributed derivation tree where both auxiliary trees adjoin to voar.",
        "[1-$]a:voar [2-31,31:6-capaz-de(VP) [3-$]/32:6-pressup.-que(S) Let us compare this to a translation using the same dependency structure, but different words: [3] 00 :is-going-to [2] 1:be-able-to [1] 2:fly Once again we select trees in the target language, and enumerate them with scoping ranges in a pre-order traversal, but this time the construction at scope position 3 must be translated as a raising verb (vai) instead of as a bridge construction ( 6-pressuposto-que): (avoar '1,2, .•) (Ocapaz, 2,3, ••) (Ovai, 3,$, -•) Although we can still adjoin th:ser-capaz-de at the VP node of a :voar, we will have nowhere to adjoin 132:vai, since the VP node of a:voar is now occupied, and only one predicative tree may adjoin at any node.7",
        "Fortunately, we can also realize the dependency between vai and ser-capaz-de by adjoining f32:vai at the VP.",
        "The new instance spanning from 2 to $ (from 01.:capaz to 02 :vai) can then be adjoined at the VP node of voar, to complete the derivation.",
        "This corresponds to the stacked derivation, with 132:vai adjoined to 131:ser-capaz-de and 01:ser-capaz-de adjoined to a:voar:"
      ]
    },
    {
      "heading": "5 Conclusion",
      "text": [
        "We have presented two algorithms – one for interpreting a derivation forest as a semantic dependency graph, and the other for realizing a semantic dependency graph as a derivation forest – that make use of semantic dependencies as adapted from the notion of predicate-argument attachment in (Joshi and Vijay-Shanker, 1999), and we have described how these algorithms can be run together in a synchronous TAG translation system, in 0(n7) time, using transfer rules predicated on isomorphic or locally non-isomorphic dependency graphs rather than isomorphic or locally non-isomorphic derivation trees.",
        "We have also demonstrated how such a system would be necessary in translating a real-world example that is isomorphic on dependency graphs but globally non-isomorphic on derivation trees.",
        "This system is currently being implemented as part of the Xtag project at the University of Pennsylvania, and as natural language interface in the Human Modeling and Simulation project, also at Penn."
      ]
    }
  ]
}
