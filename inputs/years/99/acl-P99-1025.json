{
  "info": {
    "authors": [
      "Alicia Abella",
      "Allen L. Gorin"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P99-1025",
    "title": "Construct Algebra: Analytical Dialog Management",
    "url": "https://aclweb.org/anthology/P99-1025",
    "year": 1999
  },
  "references": [
    "acl-W98-1122"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "In this paper we describe a systematic approach for creating a dialog management system based on a Construct Algebra, a collection of relations and operations on a task representation.",
        "These relations and operations are analytical components for building higher level abstractions called dialog motivators.",
        "The dialog manager, consisting of a collection of dialog motivators, is entirely built using the Construct Algebra."
      ]
    },
    {
      "heading": "1 INTRODUCTION",
      "text": [
        "The dialog manager described in this paper implements a novel approach to the problem of dialog management.",
        "There are three major contributions: the task knowledge representation, a Construct Algebra and a collection of dialog motivators.",
        "The task knowledge representation exploits object-oriented paradigms.",
        "The dialog motivators provide the dialog manager with the dialog strategies that govern its behavior.",
        "The Construct Algebra provides the building blocks needed to create new dialog motivators and analyze them.",
        "The first main component of this dialog manager is the task knowledge representation.",
        "The task knowledge is encoded in objects.",
        "These objects form an inheritance hierarchy that defines the relationships that exists among these objects.",
        "The dialog manager exploits this inheritance hierarchy in determining what queries to pose to the user.",
        "No explicit states and transitions need to be defined using this framework (Bennacef et al., 1996; Meng and et.",
        "al., 1996; Sadek et al., 1996).",
        "A change to the dialog does not require a change to the dialog manager, but more simply, a change to the inheritance hierarchy.",
        "The second main component of this dialog manager is the collection of dialog motivators.",
        "The dialog motivators determine what actions need to be taken (e.g. ask a confirmation question).",
        "The dialog motivators are founded on a theoretical framework called a Construct Algebra.",
        "The Construct Algebra allows a designer to add new motivators in a principled way.",
        "Creating a new application requires defining the inheritance hierarchy and perhaps additional dialog motivators not encompassed in the existing collection.",
        "This dialog manager has been used for two applications.",
        "The first is a spoken dialog system that enables a user to respond to the open-ended prompt How may I help you?",
        "(HMIHY) (Gorin et al., 1997).",
        "The system recognizes the words the customer has said (Riccardi and Bangalore, 1998) and extracts the meaning of these words (Wright et al., 1998) to determine what service they want, conducting a dialog (Abella and Gorin, 1997; AbeIla et al., 1996) to effectively engage the customer in a conversation that will result in providing the service they requested.",
        "The second application is to Voice Post Query (VPQ) (Buntschuh et al., 1998) which provides spoken access to the information in large personnel database (> 120,000 entries).",
        "A user can ask for employee information such as phone number, fax number, work location, or ask to call an employee.",
        "These applications are signifi",
        "cantly different but they both use the same dialog manager."
      ]
    },
    {
      "heading": "2 Task Representation",
      "text": [
        "Information about the task is defined using an object inheritance hierarchy.",
        "The inheritance hierarchy defines the relationships that exist amongst the task knowledge.",
        "Objects are defined to encode the hierarchy.",
        "This representation adheres to the principles of object-oriented design as described in (Booch, 1994).",
        "Each of the objects has three partitions.",
        "The first partition contains the name of the object, the second contains a list of variables with associated values that are specific to the object, and the third partition contains any methods associated with the object.",
        "For simplicity of illustration we will not include any of the methods.",
        "Each of the objects inherits its methods from a higher level object called the Construct.",
        "The Construct's methods are the relations and operations that will be described in section 4.",
        "The result of the speech recognizer is sent to the spoken language understanding (SLU) module.",
        "The SLU module extracts the meaning of the user's utterance and produces a list of possible objects with associated confidence scores that is interpreted by the dialog manager.",
        "The dialog manager then uses the inheritance hierarchy and an algorithm' fully described in (Abella and Gorin, 1997) to produce a set of semantically consistent inputs to be used by the dialog manager.",
        "The input is represented as a boolean expression of constructs extracted from the utterance.",
        "This input is then manipulated by the dialog motivators to produce an appropriate action, which most often consists of playing a prompt to the user or generating a query to a database."
      ]
    },
    {
      "heading": "3 The Construct",
      "text": [
        "A construct is the dialog manager's general knowledge representation vehicle.",
        "The task An understanding of this algorithm is not necessary for the understanding of the work described in this paper.",
        "knowledge is encoded as a hierarchy of constructs.",
        "The construct itself is represented as a tree structure which allows for the building of a containment hierarchy.",
        "It consists of two parts, a head and a body.",
        "Figure 1 illustrates a construct example for HMIHY.",
        "The DIAL_FOR_ME construct is the head and it has two constructs for its body, FOR-WARD_NUMBER and BILLING.",
        "These two constructs represent the two pieces of information necessary to complete a call.",
        "If a user calls requesting to place a call it is the DIAL_FOR_ME construct that is created with the generic BILLING construct and the FORWARD_NUMBER construct with its value set to empty.",
        "The dialog manager will then ask for the forward number and for the type of billing method.",
        "In figure 1 the dialog manager has received a response to the forward number request."
      ]
    },
    {
      "heading": "4 Construct Algebra",
      "text": [
        "The construct algebra defines a collection of elementary relations and operations on a set of constructs.",
        "These relations and operations are then used to build the larger processing units that we call the dialog motivators.",
        "The set of dialog motivators defines the application.",
        "In this section we formally define these relations and operations."
      ]
    },
    {
      "heading": "4.1 The Construct",
      "text": [
        "Definition 1 Head A head is an ordered pair <narne,value>, where name belongs to some set of prede",
        "fined names, N, and value belongs to some set of predefined values, V. A value may be NULL (not assigned a value)."
      ]
    },
    {
      "heading": "Definition 2 Construct",
      "text": [
        "A construct is defined recursively as an ordered pair <head,body> where body is a (possibly empty) set of constructs."
      ]
    },
    {
      "heading": "4.2 Relations",
      "text": [
        "The Construct Algebra defines six relations in the set of constructs.",
        "In each of the definitions, c1 and c2 are constructs.",
        "Note that the symbols C and c, introduced here, should not be understood in their usual \"subset\" and \"proper subset\" interpretation but will be described in definitions 4 and 5.",
        "Definition 3 requires that the heads of c1 and c2 be equal.",
        "Recall that the head of a construct is an ordered pair <name,value> which means that their names and values must be equal.",
        "A value may be empty (NULL) and by definition be equal to any other value.",
        "The equality of bodies means that a bijective mapping exists from the body of c1 into the body of c2 such that elements associated with this mapping are equal."
      ]
    },
    {
      "heading": "Definition 4 Restriction",
      "text": [
        "c1 is a restriction of c2, denoted c1 C c2, when",
        "Intuitively, c1 can be obtained by \"pruning\" elements of c2.",
        "The second part of the definition, (3f : ...) is what differentiates C from =.",
        "It is required that a mapping f between the bodies of c1 and c2 exist with the following properties:",
        "• f is 1 to 1.",
        "In other words, different elements of the body of cl, call them b1, are associated with different elements of the body of c2, call them b2 • The elements of the body of c1 are restrictions of the elements of the body of c2.",
        "In other words, b1 C b2, where b1 are elements from the body of c1 and b2 are elements from the body of c2.",
        "Definition 5 Containment c1 is contained in c2, denoted c1 C c2, when Cl C c2 or (3b2 E body(c2))(ci C b2) We assume that c1 C c2 either if c1 is a restriction of c2 or if c1 is contained in any element of the body of c2.",
        "Figure 3 gives an example.",
        "The AMBIGUITY construct represents the fact that the system is not sure whether the user has requested a COLLECT call or a CALLING_CARD call.",
        "This would trigger a clarifying question from the dialog manager.",
        "The generalization of heads means that the name of c2 is on the inheritance path of c1 and their values are equal.",
        "Intuitively, c2 is an ancestor of c1 or in object-oriented terms \"c1 is-a c2\".",
        "Note the similarity of this relation to C. Figure 4 illustrates an example.",
        "BILLING is a generalization of CALLING_CARD, or in other words CALL-ING_CARD is-a BILLING.",
        "This definition simply removes the directionality of In other words, either \"c1 is-a c2\"",
        "b2 is contained in c2 and ci is a symmetric generalization of b2.",
        "An example is illustrated in figure 5.",
        "BILLING is contained in DIAL_FOR_ME and is a symmetric generalization of CALLING_CARD."
      ]
    },
    {
      "heading": "4.3 Operations",
      "text": [
        "The Construct Algebra consists of two operations union, U and projection, \\ Definition 9 Union (U) We will define this operation in several steps.",
        "Each step is a progression towards a more general definition."
      ]
    },
    {
      "heading": "9.1 Union of values (vi U v2)",
      "text": [
        "We define head(ci) U head(c2) only in the case c1c-÷c2, which is all that is needed for a definition of U.",
        "In this definition the head of the resulting construct is the union of the heads of the operands.",
        "The body of the resulting construct consists of two parts.",
        "The first part is a set of unions (denoted (b2) U b2 in the definition above) where b2 spans the body of the second operand c2 and f is a mapping from Definition 6.",
        "Recall that the mapping f associates elements of the body (ci) with elements of the body (c2) such that f(b2),-4b2 for b2 E body (c2) so the union f(b2) U b2 is (recursively) defined in Definition 9.3.",
        "The second part of the body of the resulting construct consists of those elements b1 of the body (ci) that no element from the body (c2) maps into through the mapping f. In other words, the second part of the body consists of those elements \"left",
        "behind\" in the body (ci) after the mapping f. Figure 6 illustrates an example.",
        "The union operations results in a construct with the head CALLING_CARD and a body that contains both CARD_NUMBER and EXPIRATION.",
        "The CARD_NUMBER construct from c1 and c2 can be combined because the value of CARD_NUMBER from c1 is NULL.",
        "The construct EXPIRATION is added because it does not exist on the body of c2.",
        "of the resulting construct is the head of c2 which is DIAL_FOR_ME.",
        "The resulting construct no longer has BILLING but",
        "rather CALLING_CARD since BILLING is a generalization of CALLING_CARD.",
        "In addition the resulting construct contains the construct FORWARD NUMBER because it remains from DIAL_FOR_ME.",
        "Definition 9.6 c1 U C2 In the general case,",
        "In this definition REP is a construct used to represent the union of those constructs that do not satisfy any of the aforementioned conditions.",
        "By definition REP has a value of NULL and the body consists of the constructs c1 and c2.",
        "Figure 8 illustrates an example of an ambiguous construct and the result of the projection operation.",
        "The construct is AMBIGUITY because all the elements of its body have the value of 6151 for DEPT.",
        "In this example, c2 contains the construct LAST_NAME with the value of Smith.",
        "There are 2 constructs on the body of c1 that are in the relation b2 C ci, in other words have value for LAST_NAME of Smith.",
        "Therefore the result is an AMBIGUITY construct with two elements on its body, both with the LAST_NAME value of Smith."
      ]
    },
    {
      "heading": "5 Dialog Motivators",
      "text": [
        "A dialog motivator determines what action the dialog manager needs to take in conducting its dialog with a user.",
        "The dialog manager for HMIHY currently consists of 5 dialog motivators.",
        "They are disambiguation , confirmation, error handling (recovery from misrecognition or misunderstanding and silence), missing information and context switching.",
        "VPQ uses two additional motivators, they are continuation and",
        "database querying.",
        "The disambiguation motivator determines when there is ambiguous semantic information, like conflicting billing methods.",
        "Confirmation is used when the SLU returns a result with low confidence.",
        "Error handling takes on three forms.",
        "There is error recovery when the speech recognizer has likely misrec-ognized what the user has said (low confidence scores associated with the recognition results), when the user falls silent, and when the user says something the SLU does not expect or does not handle.",
        "Missing information determines what information to ask about in order to complete a transaction.",
        "Context switching is the ability of the system to realize when the user has changed his/her mind or realizes that it has misunderstood and allows the user to correct it.",
        "The continuation motivator determines when it is valid to offer the user the choice to query the system for additional information.",
        "Database querying decides when the system has acquired enough information to query a database for the requested information."
      ]
    },
    {
      "heading": "5.1 Disambiguation Motivator",
      "text": [
        "Figure 9 illustrate how the disambiguation motivator is created using the Construct Algebra.",
        "The disambiguation motivator is called with the current construct c and a set of constructs called cmic that represents information that the user does not know (IDK - \"I Don't Know\"), in other words, the user explicitly responds to a prompt with the phrase \"I don't know\" or its equivalent2.",
        "Input: A sequence of semantic input from the SLU module in response to a prompt Output: Complete construct c (no need for further dialog)"
      ]
    },
    {
      "heading": "Repeat",
      "text": [
        "For all dialog motivators DM; if DM; applies to c",
        "The motivator runs through several checks on the construct c. The first is to check to see if in fact the motivator applies, or in other words if c is a restriction of AMBIGUITY.",
        "If it is not then the motivator simply return C without changing it.",
        "The second step is to check to see if the ERROR construct is a generalization of CA where CA represents the user's response.",
        "The ERROR construct represents an error condition like silence or misrecognition.",
        "If it is, then it goes on to next motivator because this motivator does not apply to error conditions.",
        "If CA equals the IDK construct then this means that the user did not know the answer to our query and we add the construct used for disambiguation, ccj to the set of constructs c/DK.",
        "If however, CA is in the containment generalization relation with c then the projection operation is applied and the result is returned.",
        "If CA is not in this relation then this indicates a context switch on the part of the user and the disambiguation motivator returns CA as the result.",
        "All other motivators are constructed in a similar fashion.",
        "An application can use these motivators or create new ones that are application specific using the operations and relations of the Construct Algebra."
      ]
    },
    {
      "heading": "6 Dialog Manager",
      "text": [
        "The input to the dialog manager is a collection of semantic input generated by the SLU.",
        "Figure 10 illustrates the algorithm used by the dialog manager.",
        "The output is the complete construct c which no longer requires further dialog.",
        "The algorithm loops through all the dialog motivators determining which one needs to be applied to c. If it finds a motivator that applies then it will perform the necessary action (e.g. play a prompt or do a database lookup).",
        "The algorithm repeats itself to obtain CA (the construct answer).",
        "In other words, the construct that results from the action is subject to the dialog motivators starting from the beginning.",
        "Once CA has been found to be complete it is combined with c using Construct Algebra to produce a new construct.",
        "This new construct c also goes through the loop of dialog motivators and the procedure continues until no motivator applies and the algorithm returns the final construct c."
      ]
    },
    {
      "heading": "6.1 Example",
      "text": [
        "To illustrate how the dialog manager functions we will use an example from VPQ.",
        "Figure 11 illustrates a sample dialog with the system.",
        "The sequence of motivators for VPQ is error handling, confirmation, missing information, database querying and disambiguation.",
        "The construct that is created as a result of the user's initial utterance is shown in figure 12.",
        "All the information needed to do a database lookup is found in the user's utterance, namely the piece of information the user is seeking and the name of the person.",
        "Therefore the first motivator that applies is database querying.",
        "This motivator creates the database query and based on the result creates the construct CA.",
        "The construct CA is then searched by each of the motivators beginning again with error handling.",
        "The motivator that applies to CA is the disambiguation motivator because there are more than 20 people in the database whose last name is pronounced Klein, including Klein, Cline and Kline.",
        "The disambiguation motivator searches through CA to determine, based on preset parameters, which piece of information is most useful for the disambiguation process as well as which piece of information the user is likely to know, which is selected when the inheritance hierarchy is designed.",
        "For VPQ this includes asking about the first name and work location.",
        "In this example the dialog manager searches the database entries and determines that the most discriminating piece of information is the first name.",
        "Once the user responds with the first name there are still 2 possible candidates and it asks for the next piece of information which is work location.",
        "Had the user not known the work location the system would have read out the phone number of both people since the total number of matches is less than 3.",
        "If the number of entries after disambiguation remains greater than 3 the system refers the user to a live operator during work hours."
      ]
    },
    {
      "heading": "7 Conclusion",
      "text": [
        "In this paper we have described a novel approach to dialog management.",
        "The task knowledge representation defined intuitively and without the need to define call flows in the traditional finite-state approach.",
        "The Construct Algebra serves as the building blocks from which the dialog motivators that drive the dialog system are comprised.",
        "Building a new application will only require the designer to define the objects (e.g. COL"
      ]
    },
    {
      "heading": "FIND INFORMATION PERSON PHONE FIRST NAME LAST NAME NULL KLEIN NULL",
      "text": [
        "LECT, CREDIT etc.)",
        "and the inheritance hierarchy.",
        "The Construct Algebra serves as an analytical tool that allows the dialog motivators to be formally defined and analyzed and provides an abstraction hierarchy that hides the low-level details of the implementation and pieces together the dialog motivators.",
        "This same dialog manager is currently being used by two very different applications (HMIHY and VPQ)."
      ]
    }
  ]
}
