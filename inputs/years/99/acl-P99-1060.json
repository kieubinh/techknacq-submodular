{
  "info": {
    "authors": [
      "Mark Hepple"
    ],
    "book": "Annual Meeting of the Association for Computational Linguistics",
    "id": "acl-P99-1060",
    "title": "An Earley-Style Predictive Chart Parsing Method for Lambek Grammars",
    "url": "https://aclweb.org/anthology/P99-1060",
    "year": 1999
  },
  "references": [
    "acl-C90-2041",
    "acl-C92-1024",
    "acl-C96-1091",
    "acl-E95-1019",
    "acl-P88-1033",
    "acl-P94-1036",
    "acl-P95-1021"
  ],
  "sections": [
    {
      "heading": "Abstract",
      "text": [
        "We present a new chart parsing method for Lambek grammars, inspired by a method for D-Tree grammar parsing.",
        "The formulae of a Lambek sequent are firstly converted into rules of an indexed grammar formalism, which are used in an Earley-style predictive chart algorithm.",
        "The method is non-polynomial, but performs well for practical purposes – much better than previous chart methods for Lambek grammars"
      ]
    },
    {
      "heading": "1 Introduction",
      "text": [
        "We present a new chart parsing method for Lambek grammars The starting point for this work is the observation, in (Hepple, 1998), of certain similarities between categorial grammars and the D-Tree grammar (DTG) formalism of Rambow et al.",
        "(1995a).",
        "On this basis, we have explored adapting the DTG parsing approach of Rambow et al.",
        "(1995b) for use with the Lambek calculus.",
        "The resulting method is one in which the formulae of a Lambek sequent that is to be proven are first converted to produce rules of a formalism which combines ideas from the multiset-valued linear indexed grammar formalism of Rambow (1994), with the Lambek calculus span labelling scheme of Mor-rill (1995), and with the first-order compilation method for categorial parsing of Hepple (1996).",
        "The resulting 'grammar' is then parsed using an Earley-style predictive chart algorithm which is adapted from Rambow et al.",
        "(1995b)."
      ]
    },
    {
      "heading": "2 The Lambek Calculus",
      "text": [
        "We are concerned with the implicational (or 'product-free') fragment of the associative Lambek calculus (Lambek, 1958).",
        "A natural deduction formulation is provided by the following rules of elimination and introduction, which correspond to steps of functional application and abstraction, respectively (as the term labelling reveals).",
        "The rules are sensitive to the order of assumptions.",
        "In the (resp.",
        "[\\I]) rule, [B] indicates a discharged or withdrawn assumption, which is required to be the rightmost (resp.",
        "leftmost) of the proof.",
        "The above proof illustrates 'hypothetical reasoning', i.e. the presence of additional assumptions ('hypotheticals') in proofs that are subsequently discharged.",
        "It is because of this phenomenon that standard chart methods are inadequate for the Lambek calculus – hypo-theticals don't belong at any position on the single ordering over lexical categories by which standard charts are organised.",
        "The previous chart methods for the Lambek calculus deal with this problem in different ways.",
        "The method of Kiinig (1990, 1994) places hypothet-icals on separate `minicharts' which can attach into other (mini)charts where combinations are 'In effect, hypotheticals belong on additional subor-derings, which can connect into the main ordering of the chart at various positions, generating a branching, multidimensional ordering scheme.",
        "possible.",
        "The method requires rather complicated bookkeeping.",
        "The method of Hepple (1992) avoids this complicated book-keeping, and also rules out some useless subderivations allowed by KOnig's method, but does so at the cost of computing a representation of all the possible category sequences that might be tested in an exhaustive sequent proof search.",
        "Neither of these methods exhibits performance that would be satisfactory for practical use.2"
      ]
    },
    {
      "heading": "3 Some Preliminaries",
      "text": []
    },
    {
      "heading": "3.1 First-order Compilation for Categorial Parsing",
      "text": [
        "Hepple (1996) introduces a method of first-order compilation for implicational linear logic, to provide a basis for efficient theorem proving of various categorial formalisms Implicational linear logic is similar to the Lambek calculus, except having only a single non-directional implication – o.",
        "The idea of first-order compilation is to eliminate the need for hypothetical reasoning by simplifying higher-order formulae (whose presence requires hypothetical reasoning) to first-order formulae.",
        "This involves excising the subformulae that correspond to hypotheticals, leaving a first-order residue.",
        "The excised subformulae are added as additional assumptions.",
        "For example, a higher-order formula (Z – 0Y) – 0 X simplifies to Z+ (Y – 0 X), allowing proof (a) to be replaced by (b):",
        "The method faces two key problems: avoiding invalid deduction and getting an appropriate se",
        "mantics for the combination.",
        "To avoid invalid deduction, an indexing scheme is used to ensure that a hypothetical must be used to derive the argument of the residue functor from which was excised (e.g. Z must be used to derive the argument Y of Y – o X, a condition satisfied in proof (b).",
        "To get the same semantics with compilation as without, the semantic effects of the introduction rule are compiled into the terms of the formulae produced, e.g. (Z – 0 Y) – 0 X : w gives Z: z plus Y – 0 X : Au.w(Az.u).",
        "Terms are combined, not using standard application//3-reduction, but rather an operation Ax.g + h g[hIl x] where a variant of substitution is used that allows 'accidental' variable capture.",
        "Thus when Y – 0 X combines with its argument, whose derivation includes Z, the latter's variable becomes bound, e.g. Au.w(Az.u) + x(yz) w(Az.x(yz))"
      ]
    },
    {
      "heading": "3.2 Multiset-valued Linear Indexed Grammar",
      "text": [
        "Rambow (1994) introduces the multiset-valued linear indexed grammar formalism ({}-LIG).",
        "Indices are stored in an unordered multiset representation (c.f.",
        "the stack of conventional linear indexed grammar) The contents of the multiset at any mother node in a tree is distributed amongst its daughter nodes in a linear fashion, i.e each index is passed to precisely one daughter.",
        "Rules take the form Ao[mo] 4 Ai [mi] ... [m,].",
        "The multiset of indices mo are required to be present in, and are removed from, the multiset context of the mother node in a tree.",
        "For each daughter Az, the indices mi are added into whatever other indices are inherited to that daughter.",
        "Thus, a rule AH B[1] CH (where H indicates an empty multiset) can license the use of a rule D[1] 4 a within the derivation of its daughter B[1], and so the indexing system allows the encoding of dominance relations."
      ]
    },
    {
      "heading": "4 A New Chart Parsing Method for Lambek Grammars",
      "text": []
    },
    {
      "heading": "4.1 Lambek to SLMG Conversion",
      "text": [
        "The first task of the parsing approach is to convert the antecedent formulae of the sequent to be proved into a collection of rules of a formalism I call Span Labelled Multiset Grammar (SLMG).",
        "For digestibility, I will present the conversion process in three stages.",
        "(I will assume",
        "that in any sequent A to be proved, the succedent A is atomic.",
        "Any sequent not in this form is easily converted to one, of equivalent theoremhood, which is.)",
        "Firstly, directional types are labelled with span information using the labelling scheme of Morrill (1995) (which is justified in relation to relational algebraic models for the Lambek calculus (van Benthem, 1991)).",
        "An antecedent Xi in Xi ... Xn X0 has basic span (h – i) where h = (i – 1).",
        "The labelled formula is computed from (Xi: (h – 0)-1- using the polar translation functions shown in Figure 1 (where 15 denotes the complementary polarity to p).3 As an example, Figure 1 also shows the results of converting the antededents of Xl(YIZ),W,(W\\Y)IZ X (where k is a constant and i, j variables).4 The second stage of the conversion is adapted from the first-order compilation method of Hepple (1996), discussed earlier, modified to handle directional formulae and using a modified indexation scheme to record dependencies 3 The constants produced in the translation correspond to 'new' string positions, which make up the additional suborderings on which hypotheticals are located.",
        "The variables produced in the translation become instantiated to some string constant during an analysis, fixing the position at which an additional subordering becomes 'attached to' another (sub)ordering.",
        "4 The idea of implementing categorial grammar as a non-directional logic, but associating atomic types with string position pairs (i.e. spans) to handle word order, is used in Pareschi (1988), although in that approach all string positions instantiate to values on a single ordering (i.e. integers 0 – n for a string of length n), which is not sufficient for Lambek calculus deductions.",
        "between residue formulae and excised hypotheticals (one where both the residue and hypothetical record the dependency).",
        "For this procedure, the 'atomic type plus span label' units that result from the previous stage are treated as atomic units.",
        "The procedure r is defined by the cases shown in Figure 2 (although the method is perhaps best understood from the example also shown there).",
        "Its input is a pair (T, t), T a span labelled formula, t its associated term.5 This procedure simplifies higher-order formulae to first-order ones in the manner already discussed, and records dependencies between hypothetical and residue formulae using the indexing scheme.",
        "Assuming the antecedents of our example Xl(YIZ),W,(W\\Y)1Z X, to have terms Si, s2, s3 respectively, compilation yields results as in the example in Figure 2.",
        "The higher-order X/(Y/Z) yields two output formulae: the main residue XIY and the hypothetical Z, with the dependency between the two indicated by the common index 1 in the argument index set of the former and the principal index set of the latter.",
        "The empty sets elsewhere indicate the absence of such dependencies.",
        "The final stage of the conversion process converts the results of the second phrase into SLMG productions.",
        "The method will be explained by example.",
        "For a functor such as B\\(((A\\X)I D)IC), we can easily project the sequence of arguments it requires:",
        "Method:",
        "where w, v fresh variables, i a fresh multiset index, m2 = i U mi T((m, X/(Y:m2), Aw.t(Av.w))) A + r, T((i, Z, v)) B + A",
        "A,B,BW(A\\X)1D)1C),C,D X.",
        "If the functor was the lexical category of a word w, it might be viewed as fulfilling a role akin to a PS rule such asX--*ABwCD.",
        "For the present approach, with explicit span labelling, there is no need to include a rhs element to mark the position of the functor (or word) itself, so the corresponding production would be more akin toX. – =1.BCD.",
        "For an atomic formula, the corresponding production will have an empty rhs, e.g. A 4 ().6 The left and right hand side units of SLMG productions all take the form A[mj(i – j), where A is an atomic type, m is a set of indices (if m is empty, the unit may be written A[](i – j)), 6 Note that () is used rather than 6 to avoid the suggestion of the empty string, which it is not – matters to do with the 'string' are handled solely within the span labelling.",
        "This point is reinforced by observing that the 'string language' generated by a collection SLMG productions will consist only of (nonempty) sequences of ()'s.",
        "The real import of a SLMG derivation is not its terminal yield, but rather the instantiation of span labels that it induces (for string matters), and its structure (for semantic matters).",
        "and (i – j) a span label.",
        "For a formula (m,T,t) resulting after first-order compilation, the rhs elements of the corresponding production correspond to the arguments (if any) of T, whereas its lhs combines the result type (plus span) of T with the multiset m. For our running example Xl(Y1Z),W,(W\\Y)1Z X, the formulae resulting from the second phase (by first-order compilation) give rise to productions as shown in Figure 3.",
        "The associated semantic term for each rule is intended to be applied to the semantics if its daughters in their left-to-right order (which may require some reordering of the outermost lambdas c.f.",
        "the terms of the first-order formulae, e.g. as for the last rule).",
        "A sequent X1 ... Xn, X0 is proven if we can build a SLMG tree with root X0[](0 – n) in which the SLMG rules derived from the antecedents are each used precisely once, and which induces a consistent binding over span variables.",
        "For our running example, the required derivation, shown below, yields the correct interpretation si(Az.s3 z 82).",
        "Note that 'linear resource use', i.e. that each rule must be used precisely",
        "once, is enforced by the span labelling scheme and does not need to be separately stipulated.",
        "Thus, the span (0 – n) is marked on the root of the derivation.",
        "To bridge this span, the main residues of the antecedent formulae must all participate (since each 'consumes' a basic sub-span of the main span) and they in turn require participation of their hypotheticals via the indexing scheme."
      ]
    },
    {
      "heading": "4.2 The Earley-style Parsing Method",
      "text": [
        "The chart parsing method to be presented is derived from the Earley-style DTG parsing method of Rambow et al.",
        "(1995), and in some sense both simplifies and complicates their method.",
        "In effect, we abstract from their method a simpler one for Earley-style parsing of {}-LIG (which is a simpler formalism than the Linear Prioritized Multiset Grammar (LPMG) into which they compile DTG), and then extend this method to handle the span labelling of SLMG.",
        "A key differences of the new approach as compared to standard chart methods is that the usual external notion of span is dispensed with, and the combination of edges is instead regimented in terms of the explicit span labelling of categories in rules.",
        "The unification of span labels requires edges to carry explicit binding information for span variables.",
        "We use R to denote the set of rules derived from the sequent, and E the set of edges in the chart.",
        "The general form of edges is: ((mi , m2), 0, r, (A F • A)) where (A – > r, A) E R, U is a substitution over span variables, r is a restrictor set identifying span variables whose values are required non-locally (explained below), and ml, m2 are multisets.",
        "In a {}-LIG or SLMG tree, there is no restriction on how the multiset indices associated with any non-terminal node can be distributed amongst its daughters.",
        "Rather than cashing out the possible distributions as alternative edges in the predictor step, we can instead, in effect, 'thread' the multiset through the daughters, i.e. passing the entire multiset down to the first daughter, and passing any that are not used there on to the next daughter, and so on.",
        "For an edge ((mi, m2), 0, r, (A r • A)), mi corresponds to the multiset context at the time the ancestor edge with dotted rule (A – > .FA) was introduced, and m2 is the current multiset for passing onto the daughters in A.",
        "We call m1 the initial multiset and m2 the current multiset.",
        "The chart method employs the rules shown in Figure 4.",
        "We shall consider each in turn."
      ]
    },
    {
      "heading": "Initialisation:",
      "text": [
        "The rule recorded on the edge in this chart rule is not a real one (i.e. ct R), but serves to drive the parsing process via the prediction of edges for rules that can derive X0[1(1 – n).",
        "A successful proof of the sequent is shown if the completed chart contains an inactive edge for the special goal category, i.e. there is some edge ((0, 0), 0, 0, (GOAL[](4, – *) A.))",
        "E E"
      ]
    },
    {
      "heading": "Prediction:",
      "text": [
        "The current multiset of the predicting edge is passed onto the new edge as its initial multiset.",
        "The latter's current multiset (m6) may differ from its initial one due either to the removal of an index to license the new rule's use (i.e. if",
        "m5 is non-empty), or to the addition of indices from the predicting edge's next rhs unit (i.e. if m4 is non-empty).",
        "(Note the 'sloppy' use of set, rather than explicitly multiset, notation.",
        "The present approach is such that the same index should never appear in both of two unioned sets, so there is in practice little difference.)",
        "The line 0 01+ MG CI ((g – h), (i – j)) checks that the corresponding span labels unify, and that the resulting MGU can consistently augment the binding context of the predicting edge.",
        "This augmented binding is used to instantiate span variables in the new edge where possible.",
        "It is a characteristic of this parsing method, with top-down left-to-right traversal and associated propagation of span information, that the left span index of the next daughter sought by any active edge is guarenteed to be instantiated, i.e. g above is a constant.",
        "Commonly the variables appearing in SLMG rules have only local significance and so their substitutions do not need to be carried around with edges.",
        "For example, an active edge might require two daughters Bll(g – h) CH(h – i).",
        "A substitution for h that comes from combining with an inactive edge for BH(g – h) can be immediately applied to the next daughter C[1(h – i), and so does not need to be carried explicitly in the binding of the resulting edge.",
        "However, a situation where two occurrences of a variable appear in different rules may arise as a result of first-order compilation, which will sometimes (but not always) separate a variable occurrence in the hypothetical from another in the residue.",
        "For the rule set of our running example, we find an occurrence of h in both the first and second rule (corresponding to the main residue and hypothetical of the initial higher-order functor).",
        "The link between the two rules is also indicated by the indexing system.",
        "It turns out that for each index there is at most one variable that may appear in the two rules linked by the index.",
        "The identity of the 'non-local variables' that associate with each index can be straightforwardly computed off the SLMG grammar (or during the conversion process).",
        "The function nlv returns the set of non-local variables that associate with a multiset of indices.",
        "The line r2 = nlv(m2 U m4) computes the set of variables whose values may need to",
        "be passed non-locally, i.e. from the predicting edge down to the predicted edge, or from an inactive edge that results from combination of this predicted edge up to the active edge that consumes it.",
        "This `restrictor set' is used in reducing the substitution 0 to cover only those variables whose values need to be stored with the edge.",
        "The only case where a substitution needs to be retained for variable that is not in the restrictor set arises regarding the next daughter it seeks.",
        "For example, an active edge might require two daughters .13[](g – h) C[1](k – i), where the second's index links it to a hypothetical with span (k – h).",
        "Here, a substitution for h from a combination for the first daughter cannot be immediately applied and so should be retained until a combination is made for the second daughter.",
        "The function call dauglnlv(A) returns the set of non-local variables associated with the multiset indices of the next daughter in A (or the empty set if A is empty).",
        "There may be at most one variable in this set that appears in the substitution 0.",
        "The line 2 = 61/(r2 U dauglnlv(A)) reduces the substitution to cover only the variables whose values need to be stored.",
        "Failing to restrict the substitution in this way undermines the compaction of derivations by the chart, i.e. so that we find edges in the chart corresponding to the same subderivation, but which are not recognised as such during parsing due to them recording incompatible substitutions.",
        "Completer: Recall from the prediction step that the predicted edge's current multiset may differ from its initial multiset due to the addition of indices from the predicting edge's next rhs unit (i.e. m4 in the prediction rule).",
        "Any such added indices must be 'used up' within the subderivation of that rhs element which is realised by the combinations of the predicted edge.",
        "This requirement is checked by the condition m5 C m2.",
        "The treatment of substitutions here is very much as for the prediction rule, except that both input edges contribute their own substitution.",
        "Note that for the inactive edge (as for all inactive edges), both components of the span (i – j) will be instantiated, so we need only unify the right index of the two spans – the left indices can simply be checked for atomic identity.",
        "This observation is important to efficient implement-at ion of the algorithm, for which most effort is in practice expended on the completer step.",
        "Active edges should be indexed (i.e. hashed) with respect to the (atomic) type and left span index of the next rhs element sought.",
        "For inactive edges, the type and left span index of the lhs element should be used.",
        "For the completer step when an active edge is added, we need only access inactive edges that are hashed on the same type/left span index to consider for combination, all others can be ignored, and vice versa for the addition of an inactive edge.",
        "It is notable that the algorithm has no scanning rule, which is due to the fact that the positions of 'lexical items' or antecedent categories are encoded in the span labels of rules, and need no further attention.",
        "In the (Rambow et al., 1995) algorithm, the scanning component also deals with epsilon productions.",
        "Here, rules with an empty rhs are dealt with by prediction, by allowing an edge added for a rule with an empty rhs to be treated as an inactive edge (i.e. we equate \"( ) s\" and \"s If the completed chart indicates a successful analysis, it is straightforward to compute the proof terms of the corresponding natural deduction proofs, given a record of which edges were produced by combination of which other edges, or by prediction from which rule.",
        "Thus, the term for a predicted edge is simply that of the rule in R, whereas a term for an edge produced by a completer step is arrived at by combining a term of the active edge with one for the inactive edge (using the special substitution operation that allows 'accidental binding' of variables, as discussed earlier).",
        "Of course, a single edge may compact multiple alternative subproofs, and so return multiple terms.",
        "Note that the approach has no problem in handling multiple lexical assignments, they simply result in multiple rules generated off the same basic span of the chart."
      ]
    },
    {
      "heading": "5 Efficiency and Complexity",
      "text": [
        "The method is shown to be non-polynomial by considering a simple class of examples of the form X1,.",
        ".",
        ".",
        "Xn_1, a a, where each X is a/(a/(a\\ a)).",
        "Each such Xi gives a hypothetical whose dependency is encoded by a multiset index.",
        "Examination of the chart reveals spans for which there are multiple edges, differing in their 'initial' multiset (and other ways), there being",
        "one for edge for each subset of the indices deriving from the antecedents X1,.",
        ".",
        ".",
        "Xn-2, i.e. giving 2(n-2) distinct edges.",
        "This non-polynomial number of edge results in non-polynomial time for the completer step, and in turn for the algorithm as a whole.",
        "Hence, this approach does not resolve the open question of the polynomial time parsability of the Lambek calculus.",
        "Informally, however, these observations are suggestive of a possible locus of difficulty in achieving such a result.",
        "Thus, the hope for polynomial time parsability of the Lambek calculus comes from it being an ordered 'list-like' system, rather than an unordered 'bag-like' system, but in the example just discussed, we observe 'bag-like' behaviour in a compact encoding (the multiset) of the dependencies of hypothetical reasoning.",
        "We should note that the DTG parsing method of (Rambow et al., 1995), from which the current approach is derived, is polynomial time.",
        "This follows from the fact that their compilation applies to a preset DTG, giving rise to a fixed maximal set of distinct indices in the LPMG that the compilation generates.",
        "This fixed set of indices gives rise to a very large, but polynomial, worst-case upper limit on the number of edges in a chart, which in turn yields a polynomial time result.",
        "A key difference for the present approach is that our task is to parse arbitrary initial sequents, and hence we do not have the fixed initial grammar that is the basis of the Rambow et al.",
        "complexity result.",
        "For practical comparison to the previous Lambek chart methods, consider the highly ambiguous artificial example shown in Figure 5, (which has six readings).",
        "KOnig (1994) reports that a Prolog implementation of her method, running on a major workstation produces 300 edges in 50 seconds.",
        "A Prolog implementation of the current method, on a current major work station, produces 75 edges in less than a tenth of a second.",
        "Of course, the increase in computing power over the years makes the times not strictly comparable, but still a substantial speed up is indicated.",
        "The difference in the number of edges suggests that the KOnig method is suboptimal in its compaction of alternative derivations."
      ]
    }
  ]
}
